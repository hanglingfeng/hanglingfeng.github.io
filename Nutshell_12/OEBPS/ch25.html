<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Regular Expressions</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Regular Expressions" data-pdf-bookmark="Chapter 25. Regular Expressions" data-type="chapter" epub:type="chapter"><div class="chapter" id="regular_expressions-id00102">
<h1><span class="label">Chapter 25. </span>Regular Expressions</h1>

<p><a contenteditable="false" data-primary="regular expressions (Regex)" data-type="indexterm" id="ch25.html0"/>The regular expressions language identifies character patterns. The .NET types supporting regular expressions are based on Perl 5 regular expressions and support both search and search/replace functionality.</p>

<p>Regular expressions are used for tasks such as:</p>

<ul>
	<li>
	<p>Validating text input such as passwords and phone numbers</p>
	</li>
	<li>
	<p>Parsing textual data into more structured forms (e.g., a NuGet version string)</p>
	</li>
	<li>
	<p>Replacing patterns of text in a document (e.g., whole words only)</p>
	</li>
</ul>

<p>This chapter is split into both conceptual sections teaching the basics of regular expressions in .NET, and reference sections describing the regular expressions <span class="keep-together">language</span>.</p>

<p><a contenteditable="false" data-primary="System..." data-secondary="System.Text.RegularExpressions" data-type="indexterm" id="id4656"/>All regular expression types are defined in <code>System.Text.RegularExpressions</code>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The samples in this chapter are all preloaded into LINQPad, which also includes an interactive RegEx tool (press Ctrl+Shift+F1). An online tool is available at <a href="http://regexstorm.net/tester"><em class="hyperlink">http://regexstorm.net/tester</em></a>.</p>
</div>

<section data-pdf-bookmark="Regular Expression Basics" data-type="sect1"><div class="sect1" id="regular_expression_basics">
<h1>Regular Expression Basics</h1>

<p><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="basics" data-type="indexterm" id="ch25.html1"/>One of the most <a contenteditable="false" data-primary="? (question mark)" data-secondary="in regular expressions" data-type="indexterm" id="id4657"/><a contenteditable="false" data-primary="quantifiers" data-secondary="regular expressions" data-type="indexterm" id="id4658"/><a contenteditable="false" data-primary="question mark (?)" data-secondary="in regular expressions" data-type="indexterm" id="id4659"/>common regular expression operators is a <em>quantifier</em>. <code>?</code> is a quantifier that matches the preceding item 0 or 1 time. In other words, <code>?</code> means <em>optional</em>. An item is either a single character or a complex structure of characters in square brackets. For example, the regular expression <code>"colou?r"</code> matches <code>color</code> and <span class="keep-together"><code>colour</code></span>, but not <code>colouur</code>:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("color",   @"<strong>colou?r</strong>").Success);  // True
Console.WriteLine (Regex.Match ("colour",  @"<strong>colou?r</strong>").Success);  // True
Console.WriteLine (Regex.Match ("colouur", @"<strong>colou?r</strong>").Success);  // False</pre>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="Regex.Match" data-type="indexterm" id="id4660"/><code>Regex.Match</code> searches within a larger string. The object that it returns has properties for the <code>Index</code> and <code>Length</code> of the match as well as the actual <code>Value</code> matched:</p>

<pre data-type="programlisting">
Match m = Regex.Match ("any colour you like", @"<strong>colou?r</strong>");

Console.WriteLine (m.Success);     // True
Console.WriteLine (m.Index);       // 4
Console.WriteLine (m.Length);      // 6
Console.WriteLine (m.Value);       // colour
Console.WriteLine (m.ToString());  // colour</pre>

<p>You can think of <code>Regex.Match</code> as a more powerful version of the <code>string</code>’s <code>IndexOf</code> method. The difference is that it searches for a <em>pattern</em> rather than a literal string.</p>

<p>The <code>IsMatch</code> method is a shortcut for calling <code>Match</code> and then testing the <code>Success</code> property.</p>

<p>The regular expressions engine works from left to right by default, so only the leftmost match is returned. You can use the <code>NextMatch</code> method to return more matches:</p>

<pre data-type="programlisting">
Match m1 = Regex.Match ("One color? There are two colours in my head!",
                        @"<strong>colou?rs?</strong>");
Match m2 = m1.NextMatch();
Console.WriteLine (m1);         // color
Console.WriteLine (m2);         // colours</pre>

<p>The <code>Matches</code> method returns all matches in an array. We can rewrite the preceding example, as follows:</p>

<pre data-type="programlisting">
foreach (Match m in Regex.Matches
          ("One color? There are two colours in my head!", @"<strong>colou?rs?</strong>"))
  Console.WriteLine (m);</pre>

<p><a contenteditable="false" data-primary="| (vertical bar)" data-secondary="in regular expressions" data-type="indexterm" id="id4661"/><a contenteditable="false" data-primary="alternator (|)" data-type="indexterm" id="id4662"/><a contenteditable="false" data-primary="vertical bar (|)" data-secondary="in regular expressions" data-type="indexterm" id="id4663"/>Another common regular expressions operator is the <em>alternator</em>, expressed with a vertical bar, <code>|</code>. An alternator expresses alternatives. The following matches “Jen”, “Jenny”, and “Jennifer”:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.IsMatch ("Jenny", "<strong>Jen(ny|nifer)?</strong>"));  // True</pre>

<p>The brackets around an alternator separate the alternatives from the rest of the expression.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can specify a timeout when matching regular expressions. <a contenteditable="false" data-primary="Regex..." data-secondary="RegexMatchTimeoutException" data-type="indexterm" id="id4664"/>If a match operation takes longer than the specified <code>TimeSpan</code>, a <code>RegexMatchTimeoutException</code> is thrown. This can be useful if your program processes user-supplied regular expressions because it prevents malformed regular expressions from infinitely spinning.</p>
</div>

<section class="pagebreak-before" data-pdf-bookmark="Compiled Regular Expressions" data-type="sect2"><div class="sect2" id="compiled_regular_expressions">
<h2 class="less_space">Compiled Regular Expressions</h2>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="Regex object" data-type="indexterm" id="id4665"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="compiled regular expressions" data-type="indexterm" id="id4666"/>In some of the preceding examples, we called a static <code>RegEx</code> method repeatedly with the same pattern. An alternative approach in these cases is to instantiate a <code>Regex</code> object with the pattern and <code>RegexOptions.Compiled</code> and then call instance <span class="keep-together">methods</span>:</p>

<pre data-type="programlisting">
Regex r = new Regex (@"<strong>sausages?</strong>", RegexOptions.Compiled);
Console.WriteLine (r.Match ("sausage"));   // sausage
Console.WriteLine (r.Match ("sausages"));  // sausages</pre>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="RegexOptions.Compiled" data-type="indexterm" id="id4667"/><code>RegexOptions.Compiled</code> instructs the <code>RegEx</code> instance to use lightweight code generation (<code>DynamicMethod</code> in <code>Reflection.Emit</code>) to dynamically build and compile code tailored to that particular regular expression. This results in faster matching, at the expense of an initial compilation cost.</p>

<p>You can also instantiate a <code>Regex</code> object without using <code>RegexOptions.Compiled</code>. A <code>Regex</code> instance is immutable.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The regular expressions engine is fast. Even without compilation, a simple match typically takes less than a microsecond.</p>
</div>
</div></section>

<section data-pdf-bookmark="RegexOptions" data-type="sect2"><div class="sect2" id="regexoptions">
<h2>RegexOptions</h2>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="RegexOptions" data-type="indexterm" id="id4668"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="RegexOptions" data-type="indexterm" id="id4669"/>The <code>RegexOptions</code> flags enum lets you tweak matching behavior. A common use for <code>RegexOptions</code> is to perform a case-insensitive search:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("a", "<strong>A</strong>", RegexOptions.IgnoreCase)); // a</pre>

<p>This applies the current culture’s rules for case equivalence. The <code>CultureInvariant</code> flag lets you request the invariant culture instead:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("a", "<strong>A</strong>", RegexOptions.IgnoreCase
                                        | <strong>RegexOptions.CultureInvariant</strong>));</pre>

<p>You can activate most of the <code>RegexOptions</code> flags within a regular expression itself, using a single-letter code, as follows:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("a", @"<strong>(?i)A</strong>"));                     // a</pre>

<p>You can turn options on and off throughout an expression:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("AAAa", @"<strong>(?i)a(?-i)a</strong>"));            // Aa</pre>

<p><a contenteditable="false" data-primary="(?x) IgnorePatternWhitespace" data-type="indexterm" id="id4670"/><a contenteditable="false" data-primary="IgnorePatternWhitespace (?x)" data-type="indexterm" id="id4671"/>Another useful option is <code>IgnorePatternWhitespace</code> or <code>(?x)</code>. This allows you to insert whitespace to make a regular expression more readable—without the whitespace being taken literally.</p>

<p>The <code>NonBacktracking</code> option (from .NET 7) instructs the regex engine to use a forwards-only matching algorithm. This usually results in slower performance and disables some advanced features such as lookahead or lookbehind. However, it also prevents malformed or maliciously constructed expressions from taking near-infinite time, mitigating a potential denial-of-service attack when processing user-supplied regular expressions (a <em>ReDOS</em> attack). Specifying a timeout is also useful in this scenario.</p>

<p><a data-type="xref" href="#regular_expression_options-id00102">Table 25-1</a> lists all <code>RegExOptions</code> values along with their single-letter codes.</p>

<table class="border" id="regular_expression_options-id00102">
	<caption><span class="label">Table 25-1. </span>Regular expression options</caption>
	<thead>
		<tr>
			<th>Enum value</th>
			<th>Regular expressions code</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>None</code></td>
			<td> </td>
			<td> </td>
		</tr>
		<tr>
			<td><code>IgnoreCase</code></td>
			<td><code>i</code></td>
			<td>Ignores case (by default, regular expressions are case sensitive)</td>
		</tr>
		<tr>
			<td><code>Multiline</code></td>
			<td><code>m</code></td>
			<td>Changes <code>^</code> and <code>$</code> so that they match the start/end of a line instead of start/end of the string</td>
		</tr>
		<tr>
			<td><code>ExplicitCapture</code></td>
			<td><code>n</code></td>
			<td>Captures only explicitly named or explicitly numbered groups (see <a data-type="xref" href="#groups">“Groups”</a>)</td>
		</tr>
		<tr>
			<td><code>Compiled</code></td>
			<td> </td>
			<td>Forces compilation to IL (see <a data-type="xref" href="#compiled_regular_expressions">“Compiled Regular Expressions”</a>)</td>
		</tr>
		<tr>
			<td><code>Singleline</code></td>
			<td><code>s</code></td>
			<td>Makes <code>.</code> match every character (instead of matching every character except <code>\n</code>)</td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>IgnorePatternWhitespace</code></span></td>
			<td><code>x</code></td>
			<td>Eliminates unescaped whitespace from the pattern</td>
		</tr>
		<tr>
			<td><code>RightToLeft</code></td>
			<td><code>r</code></td>
			<td>Searches from right to left; can’t be specified midstream</td>
		</tr>
		<tr>
			<td><code>ECMAScript</code></td>
			<td> </td>
			<td>Forces ECMA compliance (by default, the implementation is not ECMA compliant)</td>
		</tr>
		<tr>
			<td><code>CultureInvariant</code></td>
			<td> </td>
			<td>Turns off culture-specific behavior for string comparisons</td>
		</tr>
			<tr>
			<td><code>NonBacktracking</code></td>
			<td> </td>
			<td>Disables backtracking to ensure predictable (albeit slower) performance</td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-pdf-bookmark="Character Escapes" data-type="sect2"><div class="sect2" id="character_escapes-id00601">
<h2>Character Escapes</h2>

<p><a contenteditable="false" data-primary="escape sequences" data-type="indexterm" id="id4672"/><a contenteditable="false" data-primary="metacharacters" data-type="indexterm" id="id4673"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="character escapes" data-type="indexterm" id="id4674"/>Regular expressions have the following metacharacters, which have a special rather than literal meaning:</p>

<blockquote>
<p>\ * + ? | { [ () ^ $ . #</p>
</blockquote>

<p><a contenteditable="false" data-primary="\ (backslash)" data-secondary="in regular expressions" data-type="indexterm" id="id4675"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="in regular expressions" data-type="indexterm" id="id4676"/>To use a metacharacter literally, you must prefix, or <em>escape</em>, the character with a backslash. In the following example, we escape the <code>?</code> character to match the string <code>"what?"</code>:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("what?", @"<strong>what\?</strong>")); // what? (correct)
Console.WriteLine (Regex.Match ("what?", @"<strong>what?</strong>"));  // what  (incorrect)</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="in regular expressions" data-type="indexterm" id="id4677"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="in regular expressions" data-type="indexterm" id="id4678"/>If the character is inside a <em>set</em> (square brackets), this rule does not apply, and the metacharacters are interpreted literally. We discuss sets in the following section.</p>
</div>

<p>The <code>Regex</code>’s <code>Escape</code> and <code>Unescape</code> methods convert a string containing regular expression metacharacters by replacing them with escaped equivalents, and vice versa:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Escape   (@"?"));     // <strong>\?</strong>
Console.WriteLine (Regex.Unescape (@"<strong>\?</strong>"));    // ?&gt;</pre>

<p>All the regular expression strings in this chapter are expressed with the C# <code>@</code> literal. This is to bypass C#’s escape mechanism, which also uses the backslash. Without the <code>@</code>, a literal backslash would require four backslashes:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("\\", "<strong>\\\\</strong>"));    // \</pre>

<p>Unless you include the <code>(?x)</code> option, spaces are treated literally in regular <span class="keep-together">expressions</span>:</p>

<pre data-type="programlisting">
Console.Write (Regex.IsMatch ("hello world", @"<strong>hello world</strong>"));  // True</pre>
</div></section>

<section data-pdf-bookmark="Character Sets" data-type="sect2"><div class="sect2" id="character_sets-id00602">
<h2>Character Sets</h2>

<p><a contenteditable="false" data-primary="character sets" data-type="indexterm" id="id4679"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="character sets" data-type="indexterm" id="id4680"/><a contenteditable="false" data-primary="wildcards (character sets)" data-type="indexterm" id="id4681"/>Character sets act as wildcards for a particular set of characters.</p>

<table class="border">
	<thead>
		<tr>
			<th>Expression</th>
			<th>Meaning</th>
			<th>Inverse (“not”)</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>[abcdef]</code></td>
			<td>Matches a single character in the list.</td>
			<td><span class="keep-together"><code>[^abcdef]</code></span></td>
		</tr>
		<tr>
			<td><code>[a-f]</code></td>
			<td>Matches a single character in a <em>range.</em></td>
			<td><code>[^a-f]</code></td>
		</tr>
		<tr>
			<td><code>\d</code></td>
			<td>Matches anything in the Unicode <em>digits</em> category. In ECMAScript mode, <code>[0-9]</code>.</td>
			<td><code>\D</code></td>
		</tr>
		<tr>
			<td><code>\w</code></td>
			<td>Matches a <em>word</em> character (by default, varies according to <span class="keep-together"><code>CultureInfo.CurrentCulture</code></span>; for example, in English, same as <span class="keep-together"><code>[a-zA-Z_0-9]</code></span>).</td>
			<td><code>\W</code></td>
		</tr>
		<tr>
			<td><code>\s</code></td>
			<td>Matches a whitespace character; that is, anything for which <span class="keep-together"><code>char.IsWhiteSpace</code></span> returns true (including Unicode spaces). In ECMAScript mode, <code>[\n\r\t\f\v ]</code>.</td>
			<td><code>\S</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>\p{</code><em>category</em><code>}</code></span></td>
			<td>Matches a character in a specified <em>category</em>.</td>
			<td><code>\P</code></td>
		</tr>
		<tr>
			<td><code>.</code></td>
			<td>(Default mode) Matches any character except <code>\n</code>.</td>
			<td><code>\n</code></td>
		</tr>
		<tr>
			<td><code>.</code></td>
			<td>(<code>SingleLine</code> mode) Matches any character.</td>
			<td><code>\n</code></td>
		</tr>
	</tbody>
</table>

<p>To match exactly one of a set of characters, put the character set in square brackets:</p>

<pre data-type="programlisting">
Console.Write (Regex.Matches ("That is that.", "<strong>[Tt]hat</strong>").Count);   // 2</pre>

<p>To match any character <em>except</em> those in a set, put the set in square brackets with a <code>^</code> symbol before the first character:</p>

<pre data-type="programlisting">
Console.Write (Regex.Match ("quiz qwerty", "<strong>q[^aeiou]</strong>").Index);    // 5</pre>

<p><a contenteditable="false" data-primary="- (hyphen)" data-type="indexterm" id="id4682"/><a contenteditable="false" data-primary="hyphen (-)" data-type="indexterm" id="id4683"/>You can specify a range of characters by using a hyphen. The following regular expression matches a chess move:</p>

<pre data-type="programlisting">
Console.Write (Regex.Match ("b1-c4", @"<strong>[a-h]\d-[a-h]\d</strong>").Success);  // True</pre>

<p><code>\d</code> indicates a digit character, so <code>\d</code> will match any digit. <code>\D</code> matches any nondigit character.</p>

<p><code>\w</code> indicates a word character, which includes letters, numbers, and the underscore. <code>\W</code> matches any nonword character. These work as expected for non-English letters, too, such as Cyrillic.</p>

<p><code>.</code> matches any character except <code>\n</code> (but allows <code>\r</code>).</p>

<p><code>\p</code> matches a character in a specified category, such as <code>{Lu}</code> for uppercase letter or <code>{P}</code> for punctuation (we list the categories in the reference section later in the <span class="keep-together">chapter</span>):</p>

<pre data-type="programlisting">
Console.Write (Regex.IsMatch ("Yes, please", @"<strong>\p{P}</strong>"));   // True</pre>

<p>We will find more uses for <code>\d</code>, <code>\w</code>, and <code>.</code> when we combine them with <em>quantifiers</em>.<a contenteditable="false" data-primary="" data-startref="ch25.html1" data-type="indexterm" id="id4684"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Quantifiers" data-type="sect1"><div class="sect1" id="quantifiers-id00083">
<h1>Quantifiers</h1>

<p><a contenteditable="false" data-primary="quantifiers" data-secondary="regular expressions" data-type="indexterm" id="id4685"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="quantifiers" data-type="indexterm" id="id4686"/>Quantifiers match an item a specified number of times.</p>

<table class="border">
	<thead>
		<tr>
			<th>Quantifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>*</code></td>
			<td>Zero or more matches</td>
		</tr>
		<tr>
			<td><code>+</code></td>
			<td>One or more matches</td>
		</tr>
		<tr>
			<td><code>?</code></td>
			<td>Zero or one match</td>
		</tr>
		<tr>
			<td><code>{<em>n</em>}</code></td>
			<td>Exactly <code><em>n</em></code> matches</td>
		</tr>
		<tr>
			<td><code>{<em>n</em>,}</code></td>
			<td>At least <code><em>n</em></code> matches</td>
		</tr>
		<tr>
			<td><code>{<em>n</em>,<em>m</em>}</code></td>
			<td>Between <code><em>n</em></code> and <code><em>m</em></code> matches</td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="* (asterisk)" data-secondary="in regular expressions" data-type="indexterm" id="id4687"/><a contenteditable="false" data-primary="asterisk (*)" data-secondary="in regular expressions" data-type="indexterm" id="id4688"/>The <code>*</code> quantifier matches the preceding character or group zero or more times. The following matches <em>cv.docx</em>, along with any numbered versions of the same file (e.g., <em>cv2.docx</em>, <em>cv15.docx</em>):</p>

<pre data-type="programlisting">
Console.Write (Regex.Match ("cv15.docx", @"<strong>cv\d*\.docx</strong>").Success);  // True</pre>

<p>Notice that we must escape the period in the file extension using a backslash.</p>

<p>The following allows anything between <em>cv</em> and <em>.docx</em> and is equivalent to <span class="keep-together"><code>dir cv*.docx</code></span>:</p>

<pre data-type="programlisting">
Console.Write (Regex.Match ("cvjoint.docx", @"<strong>cv.*\.docx</strong>").Success); // True</pre>

<p><a contenteditable="false" data-primary="+ (plus sign)" data-secondary="in regular expressions" data-type="indexterm" id="id4689"/><a contenteditable="false" data-primary="plus sign (+)" data-secondary="in regular expressions" data-type="indexterm" id="id4690"/>The <code>+</code> quantifier matches the preceding character or group one or more times. For example:</p>

<pre data-type="programlisting">
Console.Write (Regex.Matches ("slow! yeah slooow!", "<strong>slo+w</strong>").Count);  // 2</pre>

<p class="pagebreak-before"><a contenteditable="false" data-primary="{} (braces)" data-secondary="in regular expressions" data-type="indexterm" id="id4691"/><a contenteditable="false" data-primary="braces ({})" data-secondary="in regular expressions" data-type="indexterm" id="id4692"/>The <code>{}</code> quantifier matches a specified number (or range) of repetitions. The following matches a blood pressure reading:</p>

<pre data-type="programlisting">
Regex bp = new Regex (@"<strong>\d{2,3}/\d{2,3}</strong>");
Console.WriteLine (bp.Match ("It used to be 160/110"));  // 160/110
Console.WriteLine (bp.Match ("Now it's only 115/75"));   // 115/75</pre>

<section data-pdf-bookmark="Greedy Versus Lazy Quantifiers" data-type="sect2"><div class="sect2" id="greedy_versus_lazy_quantifiers">
<h2>Greedy Versus Lazy Quantifiers</h2>

<p><a contenteditable="false" data-primary="greedy quantifiers" data-type="indexterm" id="id4693"/><a contenteditable="false" data-primary="lazy quantifiers" data-type="indexterm" id="id4694"/><a contenteditable="false" data-primary="quantifiers" data-secondary="greedy versus lazy" data-type="indexterm" id="id4695"/>By default, quantifiers are <em>greedy</em>, as opposed to <em>lazy</em>. A greedy quantifier repeats as <em>many</em> times as it can before advancing. A lazy quantifier repeats as <em>few</em> times as it can before advancing. <a contenteditable="false" data-primary="? (question mark)" data-secondary="in regular expressions" data-type="indexterm" id="id4696"/><a contenteditable="false" data-primary="question mark (?)" data-secondary="in regular expressions" data-type="indexterm" id="id4697"/>You can make any quantifier lazy by suffixing it with the <code>?</code> symbol. To illustrate the difference, consider the following HTML fragment:</p>

<pre data-type="programlisting">
string html = "&lt;i&gt;By default&lt;/i&gt; quantifiers are &lt;i&gt;greedy&lt;/i&gt; creatures";</pre>

<p>Suppose that we want to extract the two phrases in italics. If we execute the <span class="keep-together">following</span></p>

<pre data-type="programlisting">
foreach (Match m in Regex.Matches (html, @"<strong>&lt;i&gt;.*&lt;/i&gt;</strong>"))
  Console.WriteLine (m);</pre>

<p>the result is not two matches, but a <em>single</em> match:</p>

<pre data-type="programlisting">
&lt;i&gt;By default&lt;/i&gt; quantifiers are &lt;i&gt;greedy&lt;/i&gt;</pre>

<p>The problem is that our <code>*</code> quantifier greedily repeats as many times as it can before matching <code>&lt;/i&gt;</code>. So, it passes right by the first <code>&lt;/i&gt;</code>, stopping only at the final <code>&lt;/i&gt;</code> (the <em>last point</em> at which the rest of the expression can still match).</p>

<p>If we make the quantifier lazy, the <code>*</code> bails out at the <em>first</em> point at which the rest of the expression can match:</p>

<pre data-type="programlisting">
foreach (Match m in Regex.Matches (html, @"<strong>&lt;i&gt;.*?&lt;/i&gt;</strong>"))
  Console.WriteLine (m);</pre>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;i&gt;By default&lt;/i&gt;
&lt;i&gt;greedy&lt;/i&gt;</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Zero-Width Assertions" data-type="sect1"><div class="sect1" id="zero_width_assertion">
<h1>Zero-Width Assertions</h1>

<p><a contenteditable="false" data-primary="zero-width assertions" data-secondary="defined" data-type="indexterm" id="id4698"/>The <a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="zero-width assertions" data-type="indexterm" id="ch25.html2"/><a contenteditable="false" data-primary="zero-width assertions" data-type="indexterm" id="ch25.html3"/>regular expressions language lets you place conditions on what should occur <em>before</em> or <em>after</em> a match, through <em>lookbehind</em>, <em>lookahead</em>, <em>anchors</em>, and <em>word boundaries</em>. These are called <em>zero-width</em> assertions because they don’t increase the width (or length) of the match itself.</p>

<section data-pdf-bookmark="Lookahead and Lookbehind" data-type="sect2"><div class="sect2" id="lookahead_and_lookbehind">
<h2>Lookahead and Lookbehind</h2>

<p><a contenteditable="false" data-primary="zero-width assertions" data-secondary="lookahead and lookbehind" data-type="indexterm" id="id4699"/>The <code>(?=<em>expr</em>)</code> construct checks whether the text that follows matches <code><em>expr</em></code>, without including <code>expr</code> in the result. <a contenteditable="false" data-primary="positive lookahead" data-type="indexterm" id="id4700"/>This is called <em>positive lookahead</em>. In the following example, we look for a number followed by the word “miles”:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("say 25 miles more", @"<strong>\d+\s(?=miles)</strong>"));

<em>OUTPUT: 25</em></pre>

<p>Notice that the word “miles” was not returned in the result, even though it was required to <em>satisfy</em> the match.</p>

<p>After a successful <em>lookahead</em>, matching continues as though the sneak preview never took place. So, if we append <code>.*</code> to our expression like this:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("say 25 miles more", @"<strong>\d+\s(?=miles).*</strong>"));</pre>

<p>the result is <code>25 miles more</code>.</p>

<p>Lookahead can be useful in enforcing rules for a strong password. Suppose that a password must be at least six characters and contain at least one digit. With a lookup, we could achieve this, as follows:</p>

<pre data-type="programlisting">
string password = "...";
bool ok = Regex.IsMatch (password, @"<strong>(?=.*\d).{6,}</strong>");</pre>

<p>This first performs a <em>lookahead</em> to ensure that a digit occurs somewhere in the string. If satisfied, it returns to its position before the sneak preview began and matches six or more characters. (In <a data-type="xref" href="#cookbook_regular_expressions">“Cookbook Regular Expressions”</a>, we include a more substantial password validation example.)</p>

<p><a contenteditable="false" data-primary="negative lookahead" data-type="indexterm" id="id4701"/>The opposite is the <em>negative lookahead</em> construct, <code>(?!<em>expr</em>)</code>. This requires that the match <em>not</em> be followed by <code><em>expr</em></code>. The following expression matches “good”—unless “however” or “but” appears later in the string:</p>

<pre data-type="programlisting">
string regex = "<strong>(?i)good(?!.*(however|but))";</strong>
Console.WriteLine (Regex.IsMatch ("Good work! But...",  regex));  // False
Console.WriteLine (Regex.IsMatch ("Good work! Thanks!", regex));  // True</pre>

<p><a contenteditable="false" data-primary="positive lookbehind" data-type="indexterm" id="id4702"/>The <code>(?&lt;=<em>expr</em>)</code> construct denotes <em>positive lookbehind</em> and requires that a match be <em>preceded</em> by a specified expression. <a contenteditable="false" data-primary="negative lookbehind" data-type="indexterm" id="id4703"/>The opposite construct, <code>(?&lt;!<em>expr</em>)</code>, denotes <em>negative lookbehind</em> and requires that a match <em>not be preceded</em> by a specified expression. For example, the following matches “good”—unless “however” appears <em>earlier</em> in the string:</p>

<pre data-type="programlisting">
string regex = "<strong>(?i)(?&lt;!however.*)good"</strong>;
Console.WriteLine (Regex.IsMatch ("However good, we...", regex)); // False
Console.WriteLine (Regex.IsMatch ("Very good, thanks!", regex));  // True</pre>

<p>We could improve these examples by adding <em>word boundary assertions</em>, which we introduce shortly.</p>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Anchors" data-type="sect2"><div class="sect2" id="anchors">
<h2 class="less_space">Anchors</h2>

<p><a contenteditable="false" data-primary="^ (caret)" data-secondary="in regular expressions" data-type="indexterm" id="id4704"/><a contenteditable="false" data-primary="anchors" data-type="indexterm" id="id4705"/><a contenteditable="false" data-primary="caret (^)" data-secondary="in regular expressions" data-type="indexterm" id="id4706"/><a contenteditable="false" data-primary="zero-width assertions" data-secondary="anchors" data-type="indexterm" id="id4707"/>The anchors <code>^</code> and <code>$</code> match a particular <em>position</em>. By default:</p>

<dl>
	<dt><code>^</code></dt>
	<dd>Matches the <em>start</em> of the string</dd>
	<dt><code>$</code></dt>
	<dd>Matches the <em>end</em> of the string</dd>
</dl>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>^</code> has two context-dependent meanings: an <em>anchor</em> and a <em>character class negator</em>.</p>

<p><code>$</code> has two context-dependent meanings: an <em>anchor</em> and a <em>replacement group denoter</em>.</p>
</div>

<p>For example:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("Not now", "^[Nn]o"));   // No
Console.WriteLine (Regex.Match ("f = 0.2F", "[Ff]$"));   // F</pre>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="RegexOptions.Multiline" data-type="indexterm" id="id4708"/>When you specify <code>RegexOptions.Multiline</code> or include <code>(?m)</code> in the expression:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="^ (caret)" data-secondary="in regular expressions" data-type="indexterm" id="id4709"/><a contenteditable="false" data-primary="caret (^)" data-secondary="in regular expressions" data-type="indexterm" id="id4710"/><code>^</code> matches the start of the string or <em>line</em> (directly after a <code>\n</code>).</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="$ (dollar sign)" data-secondary="in regular expressions" data-type="indexterm" id="id4711"/><a contenteditable="false" data-primary="dollar sign ($)" data-secondary="in regular expressions" data-type="indexterm" id="id4712"/><code>$</code> matches the end of the string or <em>line</em> (directly before a <code>\n</code>).</p>
	</li>
</ul>

<p>There’s a catch to using <code>$</code> in multiline mode: a new line in Windows is nearly always denoted with <code>\r\n</code> rather than just <code>\n</code>. This means that for <code>$</code> to be useful for Windows files, you must usually match the <code>\r</code>, as well, with a <em>positive lookahead</em>:</p>

<pre data-type="programlisting">
(?=\r?$)</pre>

<p>The <em>positive lookahead</em> ensures that <code>\r</code> doesn’t become part of the result. The following matches lines that end in <code>".txt"</code>:</p>

<pre data-type="programlisting">
string fileNames = "a.txt" + "\r\n" + "b.docx" + "\r\n" + "c.txt";
string r = @"<strong>.+\.txt(?=\r?$)</strong>";
foreach (Match m in Regex.Matches (fileNames, r, RegexOptions.Multiline))
  Console.Write (m + " ");

<em>OUTPUT: a.txt c.txt</em></pre>

<p>The following matches all empty lines in string <code>s</code>:</p>

<pre data-type="programlisting">
MatchCollection emptyLines = Regex.Matches (s, "<strong>^(?=\r?$)</strong>",
                                            RegexOptions.Multiline);</pre>

<p>The following matches all lines that are either empty or contain only whitespace:</p>

<pre data-type="programlisting">
MatchCollection blankLines = Regex.Matches (s, "<strong>^[ \t]*(?=\r?$)</strong>",
                                            RegexOptions.Multiline);</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because an anchor matches a position rather than a character, specifying an anchor on its own matches an empty string:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Match ("x", "<strong>$</strong>").Length);   // 0</pre>
</div>
</div></section>

<section data-pdf-bookmark="Word Boundaries" data-type="sect2"><div class="sect2" id="word_boundaries">
<h2>Word Boundaries</h2>

<p><a contenteditable="false" data-primary="b (word boundary assertion)" data-type="indexterm" id="id4713"/><a contenteditable="false" data-primary="word boundary assertions" data-type="indexterm" id="id4714"/><a contenteditable="false" data-primary="zero-width assertions" data-secondary="word boundaries" data-type="indexterm" id="id4715"/>The word boundary assertion <code>\b</code> matches where word characters (<code>\w</code>) adjoin either:</p>

<ul>
	<li>
	<p>Nonword characters (<code>\W</code>)</p>
	</li>
	<li>
	<p>The beginning/end of the string (<code>^</code> and <code>$</code>)</p>
	</li>
</ul>

<p><code>\b</code> is often used to match whole words:</p>

<pre data-type="programlisting">
foreach (Match m in Regex.Matches ("Wedding in Sarajevo", @"<strong>\b\w+\b</strong>"))
  Console.WriteLine (m);

<em>Wedding</em>
<em>in</em>
<em>Sarajevo</em></pre>

<p>The following statements highlight the effect of a word boundary:</p>

<pre data-type="programlisting">
int one = Regex.Matches ("Wedding in Sarajevo", @"<strong>\bin\b</strong>").Count; // 1
int two = Regex.Matches ("Wedding in Sarajevo", @"<strong>in</strong>").Count;     // 2</pre>

<p>The next query uses <em>positive lookahead</em> to return words followed by “(sic)”:<a contenteditable="false" data-primary="" data-startref="ch25.html3" data-type="indexterm" id="id4716"/><a contenteditable="false" data-primary="" data-startref="ch25.html2" data-type="indexterm" id="id4717"/></p>

<pre data-type="programlisting">
string text = "Don't loose (sic) your cool";
Console.Write (Regex.Match (text, @"<strong>\b\w+\b\s(?=\(sic\))</strong>"));  // loose</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Groups" data-type="sect1"><div class="sect1" id="groups">
<h1>Groups</h1>

<p><a contenteditable="false" data-primary="groups" data-secondary="regular expressions" data-type="indexterm" id="ch25.html4"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="groups" data-type="indexterm" id="ch25.html5"/>Sometimes, it’s useful to separate a regular expression into a series of subexpressions, or <em>groups</em>. For instance, consider the following regular expression that represents a US phone number such as 206-465-1918:</p>

<pre data-type="programlisting">
\d{3}-\d{3}-\d{4}</pre>

<p>Suppose that we want to separate this into two groups: area code and local number. We can achieve this by using parentheses to <em>capture</em> each group:</p>

<pre data-type="programlisting">
(\d{3})-(\d{3}-\d{4})</pre>

<p>We then retrieve the groups programmatically:</p>

<pre data-type="programlisting">
Match m = Regex.Match ("206-465-1918", @"<strong>(\d{3})-(\d{3}-\d{4})</strong>");

Console.WriteLine (m.Groups[1]);   // 206
Console.WriteLine (m.Groups[2]);   // 465-1918</pre>

<p>The zeroth group represents the entire match. In other words, it has the same value as the match’s <code>Value</code>:</p>

<pre data-type="programlisting">
Console.WriteLine (m.Groups[0]);   // 206-465-1918
Console.WriteLine (m);             // 206-465-1918</pre>

<p>Groups are part of the regular expressions language itself. This means that you can refer to a group within a regular expression. The <code>\n</code> syntax lets you index the group by group number <code>n</code> within the expression. For example, the expression <code>(\w)ee\1</code> matches <code>deed</code> and <code>peep</code>. In the following example, we find all words in a string starting and ending in the same letter:</p>

<pre data-type="programlisting">
foreach (Match m in Regex.Matches ("pop pope peep", @"<strong>\b(\w)\w+\1\b</strong>"))
  Console.Write (m + " ");  // pop peep</pre>

<p>The brackets around the <code>\w</code> instruct the regular expressions engine to store the submatch in a group (in this case, a single letter) so that it can be used later. We refer to that group later using <code>\1</code>, meaning the first group in the expression.</p>

<section data-pdf-bookmark="Named Groups" data-type="sect2"><div class="sect2" id="named_groups">
<h2>Named Groups</h2>

<p><a contenteditable="false" data-primary="groups" data-secondary="named groups" data-type="indexterm" id="id4718"/><a contenteditable="false" data-primary="named groups" data-type="indexterm" id="id4719"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="named groups" data-type="indexterm" id="id4720"/>In a long or complex expression, it can be easier to work with groups by <em>name</em> rather than index. Here’s a rewrite of the previous example, using a group that we name <code>'letter'</code>:</p>

<pre data-type="programlisting">
string regEx =
  @"<strong>\b</strong>"             +  // word boundary
  @"<strong>(?'letter'\w)</strong>"  +  // match first letter, and name it 'letter'
  @"<strong>\w+</strong>"            +  // match middle letters
  @"<strong>\k'letter'</strong>"     +  // match last letter, denoted by 'letter'
  @"<strong>\b</strong>";               // word boundary

foreach (Match m in Regex.Matches ("bob pope peep", regEx))
  Console.Write (m + " ");  // bob peep</pre>

<p>Here’s how to name a captured group:</p>

<pre data-type="programlisting">
(?'<em>group-name</em>'group-expr)  <em>or</em>  (?&lt;<em>group-name</em>&gt;group-expr)</pre>

<p>And here’s how to refer to a group:</p>

<pre data-type="programlisting">
\k'<em>group-name</em>'  <em>or</em>  \k&lt;<em>group-name</em>&gt;</pre>

<p>The following example matches a simple (non-nested) XML/HTML element by looking for start and end nodes with a matching name:</p>

<pre data-type="programlisting">
string regFind =
  @"<strong>&lt;(?'tag'\w+?).*&gt;</strong>" +  // lazy-match first tag, and name it 'tag'
  @"<strong>(?'text'.*?)</strong>"     +  // lazy-match text content, name it 'text'
  @"<strong>&lt;/\k'tag'&gt;</strong>";         // match last tag, denoted by 'tag'

Match m = Regex.Match ("&lt;h1&gt;hello&lt;/h1&gt;", regFind);
Console.WriteLine (m.Groups ["tag"]);          // h1
Console.WriteLine (m.Groups ["text"]);         // hello</pre>

<p>Allowing for all possible variations in XML structure, such as nested elements, is more complex. The .NET regular expressions engine has a sophisticated extension called “matched balanced constructs” that can assist with nested tags—information on this is available on the internet and in <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/mastering-regular-expressions/0596528124/"><em>Mastering Regular Expressions</em></a> (O’Reilly) by Jeffrey E. F. Friedl.<a contenteditable="false" data-primary="" data-startref="ch25.html5" data-type="indexterm" id="id4721"/><a contenteditable="false" data-primary="" data-startref="ch25.html4" data-type="indexterm" id="id4722"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Replacing and Splitting Text" data-type="sect1"><div class="sect1" id="replacing_and_splitting_text">
<h1>Replacing and Splitting Text</h1>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="RegEx.Replace" data-type="indexterm" id="id4723"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="replacing and splitting text" data-type="indexterm" id="id4724"/><a contenteditable="false" data-primary="text" data-secondary="replacing and splitting with regular expressions" data-type="indexterm" id="id4725"/>The <code>RegEx.Replace</code> method works like <code>string.Replace</code> except that it uses a regular expression.</p>

<p>The following replaces “cat” with “dog”. Unlike with <code>string.Replace</code>, “catapult” won’t change into “dogapult”, because we match on word boundaries:</p>

<pre data-type="programlisting">
string find = @"\bcat\b";
string replace = "dog";
Console.WriteLine (Regex.Replace ("catapult the cat", find, replace));

<em>OUTPUT: catapult the dog</em></pre>

<p>The replacement string can reference the original match with the <code>$0</code> substitution construct. The following example wraps numbers within a string in angle brackets:</p>

<pre data-type="programlisting">
string text = "10 plus 20 makes 30";
Console.WriteLine (Regex.Replace (text, @"<strong>\d+</strong>", @"<strong>&lt;$0&gt;</strong>"));

<em>OUTPUT: &lt;10&gt; plus &lt;20&gt; makes &lt;30&gt;</em></pre>

<p>You can access any captured groups with <code>$1</code>, <code>$2</code>, <code>$3</code>, and so on, or <code>${<em>name</em>}</code> for a named group. To illustrate how this can be useful, consider the regular expression in the previous section that matched a simple XML element. By rearranging the groups, we can form a replacement expression that moves the element’s content into an XML attribute:</p>

<pre data-type="programlisting">
string regFind =
  @"<strong>&lt;(?'tag'\w+?).*&gt;</strong>" +  // lazy-match first tag, and name it 'tag'
  @"<strong>(?'text'.*?)</strong>"     +  // lazy-match text content, name it 'text'
  @"<strong>&lt;/\k'tag'&gt;</strong>";         // match last tag, denoted by 'tag'

string regReplace =
  @"<strong>&lt;${tag}</strong>"         +  // &lt;tag
  @"<strong>value=""</strong>"        +  // value="
  @"<strong>${text}</strong>"         +  // text
  @"<strong>""/&gt;</strong>";              // "/&gt;

Console.Write (Regex.Replace ("&lt;msg&gt;hello&lt;/msg&gt;", regFind, regReplace));</pre>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;msg value="hello"/&gt;</pre>

<section data-pdf-bookmark="MatchEvaluator Delegate" data-type="sect2"><div class="sect2" id="matchevaluator_delegate">
<h2>MatchEvaluator Delegate</h2>

<p><a contenteditable="false" data-primary="MatchEvaluator delegate" data-type="indexterm" id="id4726"/><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="MatchEvaluator delegate" data-type="indexterm" id="id4727"/><a contenteditable="false" data-primary="text" data-secondary="MatchEvaluator delegate" data-type="indexterm" id="id4728"/><code>Replace</code> has an overload that takes a <code>MatchEvaluator</code> delegate, which is invoked per match. This allows you to delegate the content of the replacement string to C# code when the regular expressions language isn’t expressive enough:</p>

<pre data-type="programlisting">
Console.WriteLine (Regex.Replace ("5 is less than 10", @"<strong>\d+</strong>",
                   m =&gt; (int.Parse (m.Value) * 10).ToString()) );

<em>OUTPUT: 50 is less than 100</em></pre>

<p>In <a data-type="xref" href="#cookbook_regular_expressions">“Cookbook Regular Expressions”</a>, we show how to use a <code>Match​Eva⁠luator</code> to escape Unicode characters appropriately for HTML.</p>
</div></section>

<section data-pdf-bookmark="Splitting Text" data-type="sect2"><div class="sect2" id="splitting_text">
<h2>Splitting Text</h2>

<p><a contenteditable="false" data-primary="Regex..." data-secondary="Regex.Split" data-type="indexterm" id="id4729"/>The static <code>Regex.Split</code> method is a more powerful version of the <code>string.Split</code> method, with a regular expression denoting the separator pattern. In this example, we split a string, where any digit counts as a separator:</p>

<pre data-type="programlisting">
foreach (string s in Regex.Split ("a5b7c", @"<strong>\d</strong>"))
  Console.Write (s + " ");     // a b c</pre>

<p>The result, here, doesn’t include the separators themselves. You can include the separators, however, by wrapping the expression in a <em>positive lookahead</em>. The following splits a camel-case string into separate words:</p>

<pre data-type="programlisting">
foreach (string s in Regex.Split ("oneTwoThree", @"<strong>(?=[A-Z])</strong>"))
  Console.Write (s + " ");    // one Two Three</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Cookbook Regular Expressions" data-type="sect1"><div class="sect1" id="cookbook_regular_expressions">
<h1>Cookbook Regular Expressions</h1>

<section data-pdf-bookmark="Recipes" data-type="sect2"><div class="sect2" id="recipes">
<h2>Recipes</h2>

<section data-pdf-bookmark="Matching US Social Security number/phone number" data-type="sect3"><div class="sect3" id="matching_udotsdot_social_security_numbe">
<h3>Matching US Social Security number/phone number</h3>

<pre data-type="programlisting">
string ssNum = @"<strong>\d{3}-\d{2}-\d{4}</strong>";

Console.WriteLine (Regex.IsMatch ("123-45-6789", ssNum));      // True

string phone = @"<strong>(?x)</strong>
<strong>  ( \d{3}[-\s] | \(\d{3}\)\s? )</strong>
<strong>    \d{3}[-\s]?</strong>
<strong>    \d{4}</strong>";

Console.WriteLine (Regex.IsMatch ("123-456-7890",   phone));   // True
Console.WriteLine (Regex.IsMatch ("(123) 456-7890", phone));   // True</pre>
</div></section>

<section data-pdf-bookmark="Extracting “name = value” pairs (one per line)" data-type="sect3"><div class="sect3" id="extracting_quotation_markname_equals_va">
<h3>Extracting “name = value” pairs (one per line)</h3>

<p><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="cookbook regular expressions" data-type="indexterm" id="ch25.html6"/>Note that this starts with the <em>multiline</em> directive <code>(?m)</code>:</p>

<pre data-type="programlisting">
string r = @"<strong>(?m)^\s*(?'name'\w+)\s*=\s*(?'value'.*)\s*(?=\r?$)</strong>";

string text =
  @"id = 3
    secure = true
    timeout = 30";

foreach (Match m in Regex.Matches (text, r))
  Console.WriteLine (m.Groups["name"] + " is " + m.Groups["value"]);
<em>id is 3 secure is true timeout is 30</em></pre>
</div></section>

<section data-pdf-bookmark="Strong password validation" data-type="sect3"><div class="sect3" id="strong_password_validation">
<h3>Strong password validation</h3>

<p><a contenteditable="false" data-primary="passwords" data-secondary="validation" data-type="indexterm" id="id4730"/>The following checks whether a password has at least six characters and whether it contains a digit, symbol, or punctuation mark:</p>

<pre data-type="programlisting">
string r = @"<strong>(?x)^(?=.* ( \d | \p{P} | \p{S} )).{6,}</strong>";

Console.WriteLine (Regex.IsMatch ("abc12", r));     // False
Console.WriteLine (Regex.IsMatch ("abcdef", r));    // False
Console.WriteLine (Regex.IsMatch ("ab88yz", r));    // True</pre>
</div></section>

<section data-pdf-bookmark="Lines of at least 80 characters" data-type="sect3"><div class="sect3" id="lines_of_at_least_eightzero_characters">
<h3>Lines of at least 80 characters</h3>

<pre data-type="programlisting">
string r = @"<strong>(?m)^.{80,}(?=\r?$)</strong>";

string fifty = new string ('x', 50);
string eighty = new string ('x', 80);

string text = eighty + "\r\n" + fifty + "\r\n" + eighty;

Console.WriteLine (Regex.Matches (text, r).Count);   // 2</pre>
</div></section>

<section data-pdf-bookmark="Parsing dates/times (N/N/N H:M:S AM/PM)" data-type="sect3"><div class="sect3" id="parsing_datessolidustimes_left_parenthe">
<h3>Parsing dates/times (N/N/N H:M:S AM/PM)</h3>

<p><a contenteditable="false" data-primary="dates and times" data-secondary="parsing with regular expressions" data-type="indexterm" id="id4731"/>This expression handles a variety of numeric date formats—and works whether the year comes first or last. The <code>(?x)</code> directive improves readability by allowing whitespace; the <code>(?i)</code> switches off case sensitivity (for the optional AM/PM designator). You can then access each component of the match through the <code>Groups</code> collection:</p>

<pre data-type="programlisting">
string r = @"<strong>(?x)(?i)</strong>
 <strong>(\d{1,4}) [./-]</strong>
<strong><strong> (\d{1,2}) [./-]</strong></strong>
<strong><strong> (\d{1,4}) [\sT]</strong></strong>
<strong> (\d+):(\d+):(\d+) \s? (A\.?M\.?|P\.?M\.?)?</strong>";

string text = "01/02/2008 5:20:50 PM";

foreach (Group g in Regex.Match (text, r).Groups)
  Console.WriteLine (g.Value + " ");
<em>01/02/2008 5:20:50 PM 01 02 2008 5 20 50 PM</em></pre>

<p>(Of course, this doesn’t verify that the date/time is correct.)</p>
</div></section>

<section data-pdf-bookmark="Matching Roman numerals" data-type="sect3"><div class="sect3" id="matching_roman_numerals">
<h3>Matching Roman numerals</h3>

<pre data-type="programlisting">
string r =
  @"<strong>(?i)\bm*</strong>"         +
  @"<strong>(d?c{0,3}|c[dm])</strong>" +
  @"<strong>(l?x{0,3}|x[lc])</strong>" +
  @"<strong>(v?i{0,3}|i[vx])</strong>" +
  @"<strong>\b</strong>";

Console.WriteLine (Regex.IsMatch ("MCMLXXXIV", r));   // True</pre>
</div></section>

<section data-pdf-bookmark="Removing repeated words" data-type="sect3"><div class="sect3" id="removing_repeated_words">
<h3>Removing repeated words</h3>

<p>Here, we capture a named group called <code>dupe</code>:</p>

<pre data-type="programlisting">
string r = @"<strong>(?'dupe'\w+)\W\k'dupe'</strong>";

string text = "In the the beginning...";
Console.WriteLine (Regex.Replace (text, r, "${dupe}"));

<em>In the beginning</em></pre>
</div></section>

<section data-pdf-bookmark="Word count" data-type="sect3"><div class="sect3" id="word_count">
<h3>Word count</h3>

<pre data-type="programlisting">
string r = @"<strong>\b(\w|[-'])+\b</strong>";

string text = "It's all mumbo-jumbo to me";
Console.WriteLine (Regex.Matches (text, r).Count);   // 5</pre>
</div></section>

<section data-pdf-bookmark="Matching a GUID" data-type="sect3"><div class="sect3" id="matching_a_guid">
<h3>Matching a GUID</h3>

<pre data-type="programlisting">
string r =
  @"<strong>(?i)\b</strong>"           +
  @"<strong>[0-9a-fA-F]{8}\-</strong>" +
  @"<strong>[0-9a-fA-F]{4}\-</strong>" +
  @"<strong>[0-9a-fA-F]{4}\-</strong>" +
  @"<strong>[0-9a-fA-F]{4}\-</strong>" +
  @"<strong>[0-9a-fA-F]{12}</strong>"  +
  @"<strong>\b</strong>";

string text = "Its key is {3F2504E0-4F89-11D3-9A0C-0305E82C3301}.";
Console.WriteLine (Regex.Match (text, r).Index);                    // 12</pre>
</div></section>

<section data-pdf-bookmark="Parsing an XML/HTML tag" data-type="sect3"><div class="sect3" id="parsing_an_xmlsolidushtml_tag">
<h3>Parsing an XML/HTML tag</h3>

<p>Regex is useful for parsing HTML fragments—particularly when the document might be imperfectly formed:</p>

<pre data-type="programlisting">
string r =
  @"<strong>&lt;(?'tag'\w+?).*&gt;</strong>"  +  // lazy-match first tag, and name it 'tag'
  @"<strong>(?'text'.*?)</strong>"      +  // lazy-match text content, name it 'textd'
  @"<strong>&lt;/\k'tag'&gt;</strong>";          // match last tag, denoted by 'tag'

string text = "&lt;h1&gt;hello&lt;/h1&gt;";

Match m = Regex.Match (text, r);

Console.WriteLine (m.Groups ["tag"]);       // h1
Console.WriteLine (m.Groups ["text"]);      // hello</pre>
</div></section>

<section data-pdf-bookmark="Splitting a camel-cased word" data-type="sect3"><div class="sect3" id="splitting_a_camel_cased_word">
<h3>Splitting a camel-cased word</h3>

<p>This requires a <em>positive lookahead</em> to include the uppercase separators:</p>

<pre data-type="programlisting">
string r = @"<strong>(?=[A-Z])</strong>";

foreach (string s in Regex.Split ("oneTwoThree", r))
  Console.Write (s + " ");    // one Two Three</pre>
</div></section>

<section data-pdf-bookmark="Obtaining a legal filename" data-type="sect3"><div class="sect3" id="obtaining_a_legal_filename">
<h3>Obtaining a legal filename</h3>

<pre data-type="programlisting">
string input = "My \"good\" &lt;recipes&gt;.txt";

char[] invalidChars = System.IO.Path.GetInvalidFileNameChars();
string invalidString = Regex.Escape (new string (invalidChars));

string valid = Regex.Replace (input, "<strong>[</strong>" + invalidString + "<strong>]</strong>", "");
Console.WriteLine (valid);

<em>My good recipes.txt</em></pre>
</div></section>

<section data-pdf-bookmark="Escaping Unicode characters for HTML" data-type="sect3"><div class="sect3" id="escaping_unicode_characters_for_html">
<h3>Escaping Unicode characters for HTML</h3>

<pre data-type="programlisting">
string htmlFragment = "© 2007";

string result = Regex.Replace (htmlFragment, @"<strong>[\u0080-\uFFFF]</strong>",
                m =&gt; @"&amp;#" + ((int)m.Value[0]).ToString() + ";");

Console.WriteLine (result);        // &amp;#169; 2007</pre>
</div></section>

<section data-pdf-bookmark="Unescaping characters in an HTTP query string" data-type="sect3"><div class="sect3" id="unescaping_characters_in_an_http_query">
<h3>Unescaping characters in an HTTP query string</h3>

<pre data-type="programlisting">
string sample = "C%23 rocks";

string result = Regex.Replace (
    sample,
    @"%[0-9a-f][0-9a-f]", 
    m =&gt; ((char) Convert.ToByte (m.Value.Substring (1), 16)).ToString(),
    RegexOptions.IgnoreCase
);

Console.WriteLine (result);   // C# rocks</pre>
</div></section>

<section data-pdf-bookmark="Parsing Google search terms from a web stats log" data-type="sect3"><div class="sect3" id="parsing_google_search_terms_from_a_web">
<h3>Parsing Google search terms from a web stats log</h3>

<p>You should use this in conjunction with the previous example to unescape characters in the query string:<a contenteditable="false" data-primary="" data-startref="ch25.html6" data-type="indexterm" id="id4732"/></p>

<pre data-type="programlisting">
string sample = 
  "http://google.com/search?hl=en&amp;q=greedy+quantifiers+regex&amp;btnG=Search";

Match m = Regex.Match (sample, @"(?&lt;=google\..+search\?.*q=).+?(?=(&amp;|$))");

string[] keywords = m.Value.Split (
  new[] { '+' }, StringSplitOptions.RemoveEmptyEntries);

foreach (string keyword in keywords)
  Console.Write (keyword + " ");       // greedy quantifiers regex</pre>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Regular Expressions Language Reference" data-type="sect1"><div class="sect1" id="regular_expressions_language_reference">
<h1>Regular Expressions Language Reference</h1>

<p><a contenteditable="false" data-primary="regular expressions (Regex)" data-secondary="language reference" data-type="indexterm" id="ch25.html7"/>Tables <a data-type="xref" data-xrefstyle="select:labelnumber" href="#character_escapes">25-2</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="#regular_expression_option">25-12</a> summarize the regular expressions grammar and syntax supported in the .NET implementation.</p>

<table class="border" id="character_escapes">
	<caption><span class="label">Table 25-2. </span>Character escapes</caption>
	<thead>
		<tr>
			<th>Escape code sequence</th>
			<th>Meaning</th>
			<th>Hexadecimal equivalent</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>\a</code></td>
			<td>Bell</td>
			<td><code>\u0007</code></td>
		</tr>
		<tr>
			<td><code>\b</code></td>
			<td>Backspace</td>
			<td><code>\u0008</code></td>
		</tr>
		<tr>
			<td><code>\t</code></td>
			<td>Tab</td>
			<td><code>\u0009</code></td>
		</tr>
		<tr>
			<td><code>\r</code></td>
			<td>Carriage return</td>
			<td><code>\u000A</code></td>
		</tr>
		<tr>
			<td><code>\v</code></td>
			<td>Vertical tab</td>
			<td><code>\u000B</code></td>
		</tr>
		<tr>
			<td><code>\f</code></td>
			<td>Form feed</td>
			<td><code>\u000C</code></td>
		</tr>
		<tr>
			<td><code>\n</code></td>
			<td>Newline</td>
			<td><code>\u000D</code></td>
		</tr>
		<tr>
			<td><code>\e</code></td>
			<td>Escape</td>
			<td><code>\u001B</code></td>
		</tr>
		<tr>
			<td><code>\<em>nnn</em></code></td>
			<td>ASCII character <em>nnn</em> as octal (e.g., <code>\n052</code>)</td>
			<td> </td>
		</tr>
		<tr>
			<td><code>\x<em>nn</em></code></td>
			<td>ASCII character <em>nn</em> as hex (e.g., <code>\x3F</code>)</td>
			<td> </td>
		</tr>
		<tr>
			<td><code>\c<em>l</em></code></td>
			<td>ASCII control character <em>l</em> (e.g., <code>\cG</code> for Ctrl-G)</td>
			<td> </td>
		</tr>
		<tr>
			<td><code>\u<em>nnnn</em></code></td>
			<td>Unicode character <em>nnnn</em> as hex (e.g., <code>\u07DE</code>)</td>
			<td> </td>
		</tr>
		<tr>
			<td><code>\<em>symbol</em></code></td>
			<td>A nonescaped symbol</td>
			<td> </td>
		</tr>
	</tbody>
</table>

<p>Special case: within a regular expression, <code>\b</code> means word boundary, except in a <code>[ ]</code> set, in which <code>\b</code> means the backspace character.</p>

<table class="border" id="character_sets">
	<caption><span class="label">Table 25-3. </span>Character sets</caption>
	<thead>
		<tr>
			<th>Expression</th>
			<th>Meaning</th>
			<th>Inverse (“not”)</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>[abcdef]</code></td>
			<td>Matches a single character in the list</td>
			<td><span class="keep-together"><code>[^abcdef]</code></span></td>
		</tr>
		<tr>
			<td><code>[a-f]</code></td>
			<td>Matches a single character in a <em>range</em></td>
			<td><code>[^a-f]</code></td>
		</tr>
		<tr>
			<td><code>\d</code></td>
			<td>Matches a decimal digit<br/>
			Same as <code>[0-9]</code></td>
			<td><code>\D</code></td>
		</tr>
		<tr>
			<td><code>\w</code></td>
			<td>Matches a <em>word</em> character (by default, varies according to <span class="keep-together"><code>CultureInfo.CurrentCulture</code></span>; for example, in English, same as <code>[a-zA-Z_0-9]</code>)</td>
			<td><code>\W</code></td>
		</tr>
		<tr>
			<td><code>\s</code></td>
			<td>Matches a whitespace character<br/>
			Same as <code>[\n\r\t\f\v ]</code></td>
			<td><code>\S</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>\p{<em>category</em>}</code></span></td>
			<td>Matches a character in a specified <em>category</em> (see <a data-type="xref" href="#character_categories">Table 25-4</a>)</td>
			<td><code>\P</code></td>
		</tr>
		<tr>
			<td><code>.</code></td>
			<td>(Default mode) Matches any character except <code>\n</code></td>
			<td><code>\n</code></td>
		</tr>
		<tr>
			<td><code>.</code></td>
			<td>(<code>SingleLine</code> mode) Matches any character</td>
			<td><code>\n</code></td>
		</tr>
	</tbody>
</table>

<table class="border" id="character_categories">
	<caption><span class="label">Table 25-4. </span>Character categories</caption>
	<thead>
		<tr>
			<th>Quantifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>\p{L}</code></td>
			<td>Letters</td>
		</tr>
		<tr>
			<td><code>\p{Lu}</code></td>
			<td>Uppercase letters</td>
		</tr>
		<tr>
			<td><code>\p{Ll}</code></td>
			<td>Lowercase letters</td>
		</tr>
		<tr>
			<td><code>\p{N}</code></td>
			<td>Numbers</td>
		</tr>
		<tr>
			<td><code>\p{P}</code></td>
			<td>Punctuation</td>
		</tr>
		<tr>
			<td><code>\p{M}</code></td>
			<td>Diacritic marks</td>
		</tr>
		<tr>
			<td><code>\p{S}</code></td>
			<td>Symbols</td>
		</tr>
		<tr>
			<td><code>\p{Z}</code></td>
			<td>Separators</td>
		</tr>
		<tr>
			<td><code>\p{C}</code></td>
			<td>Control characters</td>
		</tr>
	</tbody>
</table>

<table class="border" id="quantifiers-id00084">
	<caption><span class="label">Table 25-5. </span>Quantifiers</caption>
	<thead>
		<tr>
			<th>Quantifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>*</code></td>
			<td>Zero or more matches</td>
		</tr>
		<tr>
			<td><code>+</code></td>
			<td>One or more matches</td>
		</tr>
		<tr>
			<td><code>?</code></td>
			<td>Zero or one match</td>
		</tr>
		<tr>
			<td><code>{<em>n</em>}</code></td>
			<td>Exactly <code><em>n</em></code> matches</td>
		</tr>
		<tr>
			<td><code>{<em>n</em>,}</code></td>
			<td>At least <code><em>n</em></code> matches</td>
		</tr>
		<tr>
			<td><code>{<em>n,m</em>}</code></td>
			<td>Between <code><em>n</em></code> and <code><em>m</em></code> matches</td>
		</tr>
	</tbody>
</table>

<p>The <code>?</code> suffix can be applied to any of the quantifiers to make them <em>lazy</em> rather than <em>greedy</em>.</p>

<table class="border" id="substitutions">
	<caption><span class="label">Table 25-6. </span>Substitutions</caption>
	<thead>
		<tr>
			<th>Expression</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>$0</code></td>
			<td>Substitutes the matched text</td>
		</tr>
		<tr>
			<td><code>$<em>group-number</em></code></td>
			<td>Substitutes an indexed <code><em>group-number</em></code> within the matched text</td>
		</tr>
		<tr>
			<td><code>${<em>group-name</em>}</code></td>
			<td>Substitutes a text <code><em>group-name</em></code> within the matched text</td>
		</tr>
	</tbody>
</table>

<p>Substitutions are specified only within a replacement pattern<a contenteditable="false" data-primary="" data-startref="ch25.html7" data-type="indexterm" id="id4733"/>.<a contenteditable="false" data-primary="" data-startref="ch25.html0" data-type="indexterm" id="id4734"/></p>

<table class="border" id="zero_width_assertions">
	<caption><span class="label">Table 25-7. </span>Zero-width assertions</caption>
	<thead>
		<tr>
			<th>Expression</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>^</code></td>
			<td>Start of string (or line in <em>multiline</em> mode)</td>
		</tr>
		<tr>
			<td><code>$</code></td>
			<td>End of string (or line in <em>multiline</em> mode)</td>
		</tr>
		<tr>
			<td><code>\A</code></td>
			<td>Start of string (ignores <em>multiline</em> mode)</td>
		</tr>
		<tr>
			<td><code>\z</code></td>
			<td>End of string (ignores <em>multiline</em> mode)</td>
		</tr>
		<tr>
			<td><code>\Z</code></td>
			<td>End of line or string</td>
		</tr>
		<tr>
			<td><code>\G</code></td>
			<td>Where search started</td>
		</tr>
		<tr>
			<td><code>\b</code></td>
			<td>On a word boundary</td>
		</tr>
		<tr>
			<td><code>\B</code></td>
			<td>Not on a word boundary</td>
		</tr>
		<tr>
			<td><code>(?=<em>expr</em>)</code></td>
			<td>Continue matching only if expression <code><em>expr</em></code> matches on right (<em>positive lookahead</em>)</td>
		</tr>
		<tr>
			<td><code>(?!<em>expr</em>)</code></td>
			<td>Continue matching only if expression <code><em>expr</em></code> doesn’t match on right (<em>negative lookahead</em>)</td>
		</tr>
		<tr>
			<td><code>(?&lt;=<em>expr</em>)</code></td>
			<td>Continue matching only if expression <code><em>expr</em></code> matches on left (<em>positive lookbehind</em>)</td>
		</tr>
		<tr>
			<td><code>(?&lt;!<em>expr</em>)</code></td>
			<td>Continue matching only if expression <code><em>expr</em></code> doesn’t match on left (<em>negative lookbehind</em>)</td>
		</tr>
		<tr>
			<td><code>(?&gt;<em>expr</em>)</code></td>
			<td>Subexpression <code><em>expr</em></code> is matched once and not backtracked</td>
		</tr>
	</tbody>
</table>

<table class="border" id="grouping_constructs">
	<caption><span class="label">Table 25-8. </span>Grouping constructs</caption>
	<thead>
		<tr>
			<th>Syntax</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>(<em>expr</em>)</code></td>
			<td>Capture matched expression <code><em>expr</em></code> into indexed group</td>
		</tr>
		<tr>
			<td><code>(?<em>number</em>)</code></td>
			<td>Capture matched substring into a specified group <code><em>number</em></code></td>
		</tr>
		<tr>
			<td><code>(?'<em>name</em>')</code></td>
			<td>Capture matched substring into group <code><em>name</em></code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>(?'<em>name1-name2</em>')</code></span></td>
			<td>Undefine <code><em>name2</em></code> and store interval and current group into <code><em>name1</em></code>; if <code><em>name2</em></code> is undefined, matching backtracks</td>
		</tr>
		<tr>
			<td><code>(?:<em>expr</em>)</code></td>
			<td>Noncapturing group</td>
		</tr>
	</tbody>
</table>

<table class="border" id="back_references">
	<caption><span class="label">Table 25-9. </span>Back references</caption>
	<thead>
		<tr>
			<th>Parameter syntax</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>\<em>index</em></code></td>
			<td>Reference a previously captured group by <code><em>index</em></code></td>
		</tr>
		<tr>
			<td><code>\k&lt;<em>name</em>&gt;</code></td>
			<td>Reference a previously captured group by <code><em>name</em></code></td>
		</tr>
	</tbody>
</table>

<table class="border" id="alternation">
	<caption><span class="label">Table 25-10. </span>Alternation</caption>
	<thead>
		<tr>
			<th>Expression syntax</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>|</code></td>
			<td>Logical <em>or</em></td>
		</tr>
		<tr>
			<td><code>(?(<em>expr</em>)<em>yes</em>|<em>no</em>)</code></td>
			<td>Matches <code><em>yes</em></code> if expression matches; otherwise, matches <code><em>no</em></code> (<code><em>no</em></code> is optional)</td>
		</tr>
		<tr>
			<td><code>(?(<em>name</em>)<em>yes</em>|<em>no</em>)</code></td>
			<td>Matches <code><em>yes</em></code> if named group has a match; otherwise, matches <code><em>no</em></code> (<code><em>no</em></code> is optional)</td>
		</tr>
	</tbody>
</table>

<table class="border" id="miscellaneous_constructs">
	<caption><span class="label">Table 25-11. </span>Miscellaneous constructs</caption>
	<thead>
		<tr>
			<th>Expression syntax</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>(?#<em>comment</em>)</code></td>
			<td>Inline comment</td>
		</tr>
		<tr>
			<td><code>#<em>comment</em></code></td>
			<td>Comment to end of line (works only in <code>IgnorePatternWhitespace</code> mode)</td>
		</tr>
	</tbody>
</table>

<table class="border" id="regular_expression_option">
	<caption><span class="label">Table 25-12. </span>Regular expression options</caption>
	<thead>
		<tr>
			<th>Option</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>(?i)</code></td>
			<td>Case-insensitive match (“ignore” case)</td>
		</tr>
		<tr>
			<td><code>(?m)</code></td>
			<td>Multiline mode; changes <code>^</code> and <code>$</code> so that they match beginning and end of any line</td>
		</tr>
		<tr>
			<td><code>(?n)</code></td>
			<td>Captures only explicitly named or numbered groups</td>
		</tr>
		<tr>
			<td><code>(?c)</code></td>
			<td>Compiles to Intermediate Language</td>
		</tr>
		<tr>
			<td><code>(?s)</code></td>
			<td>Single-line mode; changes meaning of “.” so that it matches every character</td>
		</tr>
		<tr>
			<td><code>(?x)</code></td>
			<td>Eliminates unescaped whitespace from the pattern</td>
		</tr>
		<tr>
			<td><code>(?r)</code></td>
			<td>Searches from right to left; can’t be specified midstream</td>
		</tr>
	</tbody>
</table>
</div></section>
</div></section></body></html>