<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>.NET Fundamentals</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab=".NET Fundamentals" data-pdf-bookmark="Chapter 6. .NET Fundamentals" data-type="chapter" epub:type="chapter"><div class="chapter" id="dotnet_fundamentals">
<h1><span class="label">Chapter 6. </span>.NET Fundamentals</h1>
<p><a contenteditable="false" data-primary=".NET" data-primary-sortas="NET" data-secondary="fundamentals" data-type="indexterm" id="ch06.html100"/>Many of the core facilities that you need when programming are provided not by the C# language but by types in the .NET BCL. In this chapter, we cover types that help with fundamental programming tasks, such as virtual equality comparison, order comparison, and type conversion. We also cover the basic .NET types, such as <code>String</code>, <code>DateTime</code>, and <code>Enum</code>.</p>
<p>The types in this section reside in the <code>System</code> namespace, with the following exceptions:</p>
<ul>
<li><p><code>StringBuilder</code> is defined in <code>System.Text</code>, as are the types for <em>text encodings</em>.</p></li>
<li><p><code>CultureInfo</code> and associated types are defined in <code>System.Globalization</code>.</p></li>
<li><p><code>XmlConvert</code> is defined in <code>System.Xml</code>.</p></li>
</ul>
<section data-pdf-bookmark="String and Text Handling" data-type="sect1"><div class="sect1" id="string_and_text_handling">
<h1>String and Text Handling</h1>
<section data-pdf-bookmark="Char" data-type="sect2"><div class="sect2" id="char">
<h2>Char</h2>
<p><a contenteditable="false" data-primary="char type" data-type="indexterm" id="id2676"/><a contenteditable="false" data-primary="System..." data-secondary="System.Char" data-type="indexterm" id="id2677"/><a contenteditable="false" data-primary="text handling" data-secondary="char type" data-type="indexterm" id="id2678"/><a contenteditable="false" data-primary="text handling" data-type="indexterm" id="ch06.html101"/>A C# <code>char</code> represents a single Unicode character and aliases the <code>System.Char</code> struct. In <a data-type="xref" href="ch02.html#chash_language_basics">Chapter 2</a>, we described how to express <code>char</code> literals:</p>
<pre data-type="programlisting">char c = 'A';
char newLine = '\n';</pre>
<p><code>System.Char</code> defines a range of static methods for working with characters, such as <code>ToUpper</code>, <code>ToLower</code>, and <code>IsWhiteSpace</code>. You can call these through either the <code>System.Char</code> type or its <code>char</code> alias:</p>
<pre data-type="programlisting">Console.WriteLine (System.Char.ToUpper ('c'));    // C
Console.WriteLine (char.IsWhiteSpace ('\t'));     // True</pre>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToLower" data-type="indexterm" id="id2679"/><a contenteditable="false" data-primary="To..." data-secondary="ToUpper" data-type="indexterm" id="id2680"/><code>ToUpper</code> and <code>ToLower</code> honor the end user’s locale, which can lead to subtle bugs. The following expression evaluates to <code>false</code> in Turkey:</p>
<pre data-type="programlisting">char.ToUpper ('i') == 'I'</pre>
<p>The reason is because in Turkey, <code>char.ToUpper ('i')</code> is <code>'İ'</code> (notice the dot on top!). To avoid this problem, <code>System.Char</code> (and <code>System.String</code>) also provides culture-invariant versions of <code>ToUpper</code> and <code>ToLower</code> ending with the word “Invariant.” These always apply English culture rules:</p>
<pre data-type="programlisting">Console.WriteLine (char.ToUpperInvariant ('i'));    // I</pre>
<p>This is a shortcut for:</p>
<pre data-type="programlisting">Console.WriteLine (char.ToUpper ('i', CultureInfo.InvariantCulture))</pre>
<p>For more on locales and culture, see <a data-type="xref" href="#formatting_and_parsing">“Formatting and Parsing”</a>.</p>
<p>Most of <code>char</code>’s remaining static methods are related to categorizing characters. <a data-type="xref" href="#static_methods_for_categorizing_charact">Table 6-1</a> lists these.</p>
<table class="border" id="static_methods_for_categorizing_charact">
<caption><span class="label">Table 6-1. </span>Static methods for categorizing characters</caption>
<thead>
<tr>
<th>Static method</th>
<th>Characters included</th>
<th>Unicode categories included</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IsLetter</code></td>
<td>A–Z, a–z, and letters of other alphabets</td>
<td><code>UpperCaseLetter</code><br/><code>LowerCaseLetter</code><br/><code>TitleCaseLetter</code><br/><code>ModifierLetter</code><br/><code>OtherLetter</code></td>
</tr>
<tr>
<td><code>IsUpper</code></td>
<td>Uppercase letters</td>
<td><code>UpperCaseLetter</code></td>
</tr>
<tr>
<td><code>IsLower</code></td>
<td>Lowercase letters</td>
<td><code>LowerCaseLetter</code></td>
</tr>
<tr>
<td><code>IsDigit</code></td>
<td>0–9 plus digits of other alphabets</td>
<td><code>DecimalDigitNumber</code></td>
</tr>
<tr>
<td><span class="keep-together"><code>IsLetterOrDigit</code></span></td>
<td>Letters plus digits</td>
<td>(<code>IsLetter</code>, <code>IsDigit</code>)</td>
</tr>
<tr>
<td><code>IsNumber</code></td>
<td>All digits plus Unicode fractions and Roman numeral symbols</td>
<td><code>DecimalDigitNumber</code><br/><code>LetterNumber</code><br/><code>OtherNumber</code></td>
</tr>
<tr>
<td><code>IsSeparator</code></td>
<td>Space plus all Unicode separator characters</td>
<td><code>LineSeparator</code><br/><code>ParagraphSeparator</code></td>
</tr>
<tr>
<td><code>IsWhiteSpace</code></td>
<td>All separators plus <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\f</code>, and <code>\v</code></td>
<td><code>LineSeparator</code><br/><code>ParagraphSeparator</code></td>
</tr>
<tr>
<td><code>IsPunctuation</code></td>
<td>Symbols used for punctuation in Western and other alphabets</td>
<td><code>DashPunctuation</code><br/><code>ConnectorPunctuation</code><br/><code>InitialQuotePunctuation</code><br/><code>FinalQuotePunctuation</code></td>
</tr>
<tr>
<td><code>IsSymbol</code></td>
<td>Most other printable symbols</td>
<td><code>MathSymbol</code><br/><code>ModifierSymbol</code><br/><code>OtherSymbol</code></td>
</tr>
<tr>
<td><code>IsControl</code></td>
<td>Nonprintable “control” characters below 0x20, such as <code>\r</code>, <code>\n</code>, <code>\t</code>, <code>\0</code>, and characters between 0x7F and 0x9A</td>
<td>(None)</td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="Get..." data-secondary="GetUnicodeCategory method" data-type="indexterm" id="id2681"/><a contenteditable="false" data-primary="UnicodeCategory enum" data-type="indexterm" id="id2682"/>For more granular categorization, <code>char</code> provides a static method called <code>GetUnicodeCategory</code>; this returns a <code>UnicodeCategory</code> enumeration whose members are shown in the rightmost column of <a data-type="xref" href="#static_methods_for_categorizing_charact">Table 6-1</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>By explicitly casting from an integer, it’s possible to produce a <code>char</code> outside the allocated Unicode set. To test a character’s validity, call <code>char.GetUnicodeCategory</code>: if the result is <code>UnicodeCategory.OtherNotAssigned</code>, the character is invalid.</p>
</div>
<p>A <code>char</code> is 16 bits wide—enough to represent any Unicode character in the <em>Basic Multilingual Plane</em>. To go beyond this, you must use surrogate pairs: we describe the methods for doing this in <a data-type="xref" href="#text_encodings_and_unicode">“Text Encodings and Unicode”</a>.</p>
</div></section>
<section data-pdf-bookmark="String" data-type="sect2"><div class="sect2" id="string">
<h2>String</h2>
<p><a contenteditable="false" data-primary="string type" data-type="indexterm" id="ch06.html102"/><a contenteditable="false" data-primary="System..." data-secondary="System.String" data-type="indexterm" id="id2683"/>A C# <code>string</code> (<code>== System.String</code>) is an immutable (unchangeable) sequence of characters. In <a data-type="xref" href="ch02.html#chash_language_basics">Chapter 2</a>, we described how to express string literals, perform equality comparisons, and concatenate two strings. This section covers the remaining functions for working with strings, exposed through the static and instance members of the <code>System.String</code> class.</p>
<section data-pdf-bookmark="Constructing strings" data-type="sect3"><div class="sect3" id="constructing_strings">
<h3>Constructing strings</h3>
<p><a contenteditable="false" data-primary="string type" data-secondary="constructing strings" data-type="indexterm" id="id2684"/>The simplest way to construct a string is to assign a literal, as we saw in <a data-type="xref" href="ch02.html#chash_language_basics">Chapter 2</a>:</p>
<pre data-type="programlisting">string s1 = "Hello";
string s2 = "First Line\r\nSecond Line";
string s3 = @"\\server\fileshare\helloworld.cs";</pre>
<p>To create a repeating sequence of characters, you can use <code>string</code>’s constructor:</p>
<pre data-type="programlisting">Console.Write (new string ('*', 10));      // **********</pre>
<p>You can also construct a string from a <code>char</code> array. The <code>ToCharArray</code> method does the reverse:</p>
<pre data-type="programlisting">char[] ca = "Hello".ToCharArray();
string s = new string (ca);              // s = "Hello"</pre>
<p><code>string</code>’s constructor is also overloaded to accept various (unsafe) pointer types, in order to create strings from types such as <code>char*</code>.</p>
</div></section>
<section data-pdf-bookmark="Null and empty strings" data-type="sect3"><div class="sect3" id="null_and_empty_strings">
<h3>Null and empty strings</h3>
<p><a contenteditable="false" data-primary="empty strings" data-type="indexterm" id="id2685"/><a contenteditable="false" data-primary="null strings" data-type="indexterm" id="id2686"/><a contenteditable="false" data-primary="string type" data-secondary="null/empty" data-type="indexterm" id="id2687"/>An empty string has a length of zero. To create an empty string, you can use either a literal or the static <code>string.Empty</code> field; to test for an empty string, you can either perform an equality comparison or test its <code>Length</code> property:</p>
<pre data-type="programlisting">string empty = "";
Console.WriteLine (empty == "");              // True
Console.WriteLine (empty == string.Empty);    // True
Console.WriteLine (empty.Length == 0);        // True</pre>
<p>Because strings are reference types, they can also be <code>null</code>:</p>
<pre data-type="programlisting">string nullString = null;
Console.WriteLine (nullString == null);        // True
Console.WriteLine (nullString == "");          // False
Console.WriteLine (nullString.Length == 0);    // NullReferenceException</pre>
<p><a contenteditable="false" data-primary="String..." data-secondary="string.IsNullOrEmpty" data-type="indexterm" id="id2688"/>The static <code>string.IsNullOrEmpty</code> method is a useful shortcut for testing whether a given string is either null or empty.</p>
</div></section>
<section data-pdf-bookmark="Accessing characters within a string" data-type="sect3"><div class="sect3" id="accessing_characters_within_a_string">
<h3>Accessing characters within a string</h3>
<p><a contenteditable="false" data-primary="characters, accessing within strings" data-type="indexterm" id="id2689"/><a contenteditable="false" data-primary="string type" data-secondary="accessing characters within" data-type="indexterm" id="id2690"/>A string’s indexer returns a single character at the given index. As with all functions that operate on strings, this is zero-indexed:</p>
<pre data-type="programlisting">string str  = "abcde";
char letter = str[1];        // letter == 'b'</pre>
<p><a contenteditable="false" data-primary="IEnumerable&lt;char&gt;" data-type="indexterm" id="id2691"/><code>string</code> also implements <code>IEnumerable&lt;char&gt;</code>, so you can <code>foreach</code> over its characters:</p>
<pre data-type="programlisting">foreach (char c in "123") Console.Write (c + ",");    // 1,2,3,</pre>
</div></section>
<section data-pdf-bookmark="Searching within strings" data-type="sect3"><div class="sect3" id="searching_within_strings">
<h3>Searching within strings</h3>
<p><a contenteditable="false" data-primary="searching" data-secondary="within strings" data-type="indexterm" id="id2692"/><a contenteditable="false" data-primary="string type" data-secondary="searching within strings" data-type="indexterm" id="id2693"/><a contenteditable="false" data-primary="EndsWith method" data-type="indexterm" id="id2694"/><a contenteditable="false" data-primary="StartsWith method" data-type="indexterm" id="id2695"/>The simplest methods for searching within strings are <code>StartsWith</code>, <code>EndsWith</code>, and <code>Contains</code>. These all return <code>true</code> or <code>false</code>:</p>
<pre data-type="programlisting">Console.WriteLine ("quick brown fox".EndsWith ("fox"));      // True
Console.WriteLine ("quick brown fox".Contains ("brown"));    // True</pre>
<p>These methods are overloaded to let you specify a <code>StringComparison</code> enum to control case and culture sensitivity (see <a data-type="xref" href="#ordinal_versus_culture_comparison">“Ordinal versus culture comparison”</a>). The default is to perform a case-sensitive match using rules applicable to the current (localized) culture. The following instead performs a case-insensitive search using the <em>invariant</em> culture’s rules:</p>
<pre data-type="programlisting">"abcdef".StartsWith ("aBc"<strong>, StringComparison.InvariantCultureIgnoreCase</strong>)</pre>
<p><code>IndexOf</code> returns the first position of a given character or substring (or <code>−1</code> if the substring isn’t found):</p>
<pre data-type="programlisting">Console.WriteLine ("abcde".IndexOf ("cd"));   // 2</pre>
<p><code>IndexOf</code> is also overloaded to accept a <code>startPosition</code> (an index from which to begin searching) as well as a <code>StringComparison</code> enum:</p>
<pre data-type="programlisting">Console.WriteLine ("abcde abcde".IndexOf ("CD", 6,
                   StringComparison.CurrentCultureIgnoreCase));    // 8</pre>
<p><a contenteditable="false" data-primary="LastIndexOf method" data-type="indexterm" id="id2696"/><code>LastIndexOf</code> is like <code>IndexOf</code>, but it works backward through the string.</p>
<p><a contenteditable="false" data-primary="IndexOfAny method" data-type="indexterm" id="id2697"/><code>IndexOfAny</code> returns the first matching position of any one of a set of characters:</p>
<pre data-type="programlisting">Console.Write ("ab,cd ef".IndexOfAny (new char[] {' ', ','} ));       // 2
Console.Write ("pas5w0rd".IndexOfAny ("0123456789".ToCharArray() ));  // 3</pre>
<p><code>LastIndexOfAny</code> does the same in the reverse direction.</p>
</div></section>
<section data-pdf-bookmark="Manipulating strings" data-type="sect3"><div class="sect3" id="manipulating_strings">
<h3>Manipulating strings</h3>
<p><a contenteditable="false" data-primary="string type" data-secondary="manipulating" data-type="indexterm" id="id2698"/>Because <code>String</code> is immutable, all the methods that “manipulate” a string return a new one, leaving the original untouched (the same goes for when you reassign a string variable).</p>
<p><a contenteditable="false" data-primary="Substring method" data-type="indexterm" id="id2699"/><code>Substring</code> extracts a portion of a string:</p>
<pre data-type="programlisting">string left3 = "12345".Substring (0, 3);     // left3 = "123";
string mid3  = "12345".Substring (1, 3);     // mid3 = "234";</pre>
<p>If you omit the length, you get the remainder of the string:</p>
<pre data-type="programlisting">string end3  = "12345".Substring (2);        // end3 = "345";</pre>
<p><code>Insert</code> and <code>Remove</code> insert or remove characters at a specified position:</p>
<pre data-type="programlisting">string s1 = "helloworld".Insert (5, ", ");    // s1 = "hello, world"
string s2 = s1.Remove (5, 2);                 // s2 = "helloworld";</pre>
<p><code>PadLeft</code> and <code>PadRight</code> pad a string to a given length with a specified character (or a space if unspecified):</p>
<pre data-type="programlisting">Console.WriteLine ("12345".PadLeft (9, '*'));  // ****12345
Console.WriteLine ("12345".PadLeft (9));       //     12345</pre>
<p>If the input string is longer than the padding length, the original string is returned unchanged.</p>
<p><code>TrimStart</code> and <code>TrimEnd</code> remove specified characters from the beginning or end of a string; <code>Trim</code> does both. By default, these functions remove whitespace characters (including spaces, tabs, new lines, and Unicode variations of these):</p>
<pre data-type="programlisting">Console.WriteLine ("  abc \t\r\n ".Trim().Length);   // 3</pre>
<p><a contenteditable="false" data-primary="Replace method" data-type="indexterm" id="id2700"/><code>Replace</code> replaces all (non-overlapping) occurrences of a particular character or substring:</p>
<pre data-type="programlisting">Console.WriteLine ("to be done".Replace (" ", " | ") );  // to | be | done
Console.WriteLine ("to be done".Replace (" ", "")    );  // tobedone</pre>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToLower" data-type="indexterm" id="id2701"/><a contenteditable="false" data-primary="To..." data-secondary="ToUpper" data-type="indexterm" id="id2702"/><code>ToUpper</code> and <code>ToLower</code> return uppercase and lowercase versions of the input string. By default, they honor the user’s current language settings; <code>ToUpperInvariant</code> and <code>ToLowerInvariant</code> always apply English alphabet rules.</p>
</div></section>
<section data-pdf-bookmark="Splitting and joining strings" data-type="sect3"><div class="sect3" id="splitting_and_joining_strings">
<h3>Splitting and joining strings</h3>
<p><a contenteditable="false" data-primary="Split method" data-type="indexterm" id="id2703"/><a contenteditable="false" data-primary="splitting strings" data-type="indexterm" id="id2704"/><a contenteditable="false" data-primary="string type" data-secondary="splitting/joining" data-type="indexterm" id="id2705"/><code>Split</code> divides a string into pieces:</p>
<pre data-type="programlisting">string[] words = "The quick brown fox".Split();

foreach (string word in words)
  Console.Write (word + "|");    // The|quick|brown|fox|</pre>
<p>By default, <code>Split</code> uses whitespace characters as delimiters; it’s also overloaded to accept a <code>params</code> array of <code>char</code> or <code>string</code> delimiters. <a contenteditable="false" data-primary="String..." data-secondary="StringSplitOptions enum" data-type="indexterm" id="id2706"/><code>Split</code> also optionally accepts a <code>StringSplitOptions</code> enum, which has an option to remove empty entries: this is useful when words are separated by several delimiters in a row.</p>
<p><a contenteditable="false" data-primary="Join method (strings)" data-type="indexterm" id="id2707"/><a contenteditable="false" data-primary="joining" data-secondary="strings" data-type="indexterm" id="id2708"/>The static <code>Join</code> method does the reverse of <code>Split</code>. It requires a delimiter and string array:</p>
<pre data-type="programlisting">string[] words = "The quick brown fox".Split();
string together = string.Join (" ", words);      // The quick brown fox</pre>
<p><a contenteditable="false" data-primary="Concat operator" data-type="indexterm" id="id2709"/>The static <code>Concat</code> method is similar to <code>Join</code> but accepts only a <code>params</code> string array and applies no separator. <code>Concat</code> is exactly equivalent to the <code>+</code> operator (the compiler, in fact, translates <code>+</code> to <code>Concat</code>):</p>
<pre data-type="programlisting">string sentence     = string.Concat ("The", " quick", " brown", " fox");
string sameSentence = "The" + " quick" + " brown" + " fox";</pre>
</div></section>
<section data-pdf-bookmark="String.Format and composite format strings" data-type="sect3"><div class="sect3" id="stringdotformat_and_composite_format_st">
<h3>String.Format and composite format strings</h3>
<p><a contenteditable="false" data-primary="composite format string" data-type="indexterm" id="id2710"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="format string" data-type="indexterm" id="id2711"/><a contenteditable="false" data-primary="string type" data-secondary="String.format and composite format strings" data-type="indexterm" id="id2712"/>The static <code>Format</code> method provides a convenient way to build strings that embed variables. The embedded variables (or values) can be of any type; the <code>Format</code> simply calls <code>ToString</code> on them.</p>
<p>The master string that includes the embedded variables is called a <em>composite format string</em>. <a contenteditable="false" data-primary="String..." data-secondary="string.Format" data-type="indexterm" id="id2713"/>When calling <code>String.Format</code>, you provide a composite format string followed by each of the embedded variables:</p>
<pre data-type="programlisting">string composite = "It's {0} degrees in {1} on this {2} morning";
string s = string.Format (composite, 35, "Perth", DateTime.Now.DayOfWeek);

// s == "It's 35 degrees in Perth on this Friday morning"</pre>
<p>(And that’s Celsius!)</p>
<p><a contenteditable="false" data-primary="{} (braces)" data-secondary="enclosing expressions in interpolated strings" data-type="indexterm" id="id2714"/><a contenteditable="false" data-primary="$ (dollar sign)" data-secondary="preceding interpolated strings" data-type="indexterm" id="id2715"/><a contenteditable="false" data-primary="braces ({})" data-secondary="enclosing expressions in interpolated strings" data-type="indexterm" id="id2716"/><a contenteditable="false" data-primary="dollar sign ($)" data-secondary="preceding interpolated strings" data-type="indexterm" id="id2717"/>We can use interpolated string literals to the same effect (see <a data-type="xref" href="ch02.html#string_type">“String Type”</a>). Just precede the string with the <code>$</code> symbol and put the expressions in braces:</p>
<pre data-type="programlisting">string s = <strong>$</strong>"It's hot this {DateTime.Now.DayOfWeek} morning";</pre>
<p><a contenteditable="false" data-primary="format item" data-type="indexterm" id="id2718"/>Each number in curly braces is called a <em>format item</em>. The number corresponds to the argument position and is optionally followed by:</p>
<ul>
<li><p>A comma and a <em>minimum width</em> to apply</p></li>
<li><p>A colon and a <em>format string</em></p></li>
</ul>
<p>The minimum width is useful for aligning columns. If the value is negative, the data is left-aligned; otherwise, it’s right-aligned:</p>
<pre class="pagebreak-before" data-type="programlisting">string composite = "Name=<strong>{0,-20}</strong> Credit Limit=<strong>{1,15:C}</strong>";

Console.WriteLine (string.Format (composite, "Mary", 500));
Console.WriteLine (string.Format (composite, "Elizabeth", 20000));</pre>
<p>Here’s the result:</p>
<pre data-type="programlisting">Name=Mary                 Credit Limit=        $500.00
Name=Elizabeth            Credit Limit=     $20,000.00</pre>
<p>Here’s the equivalent without using <code>string.Format</code>:</p>
<pre data-type="programlisting">string s = "Name=" + "Mary".PadRight (20) +
           " Credit Limit=" + 500.ToString ("C").PadLeft (15);</pre>
<p>The credit limit is formatted as currency by virtue of the <code>"C"</code> format string. We describe format strings in detail in <a data-type="xref" href="#formatting_and_parsing">“Formatting and Parsing”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Comparing Strings" data-type="sect2"><div class="sect2" id="comparing_strings">
<h2>Comparing Strings</h2>
<p><a contenteditable="false" data-primary="comparisons" data-secondary="string types" data-type="indexterm" id="ch06.html103"/><a contenteditable="false" data-primary="string type" data-secondary="comparing" data-type="indexterm" id="ch06.html104"/>In comparing two values, .NET differentiates the concepts of <em>equality comparison</em> and <em>order comparison</em>. Equality comparison tests whether two instances are semantically the same; order comparison tests which of two (if any) instances comes first when arranging them in ascending or descending sequence.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Equality comparison is not a <em>subset</em> of order comparison; the two systems have different purposes. It’s legal, for instance, to have two unequal values in the same ordering position. We resume this topic in <a data-type="xref" href="ch04.html#equality_comparison-id00016">“Equality Comparison”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="string equality comparison" data-type="indexterm" id="id2719"/><a contenteditable="false" data-primary="comparisons" data-secondary="string equality comparisons" data-type="indexterm" id="id2720"/><a contenteditable="false" data-primary="equality comparison" data-type="indexterm" id="id2721"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="string equality comparison" data-type="indexterm" id="id2722"/>For string equality comparison, you can use the <code>==</code> operator or one of <code>string</code>’s <code>Equals</code> methods. The latter are more versatile because they allow you to specify options such as case insensitivity.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Another difference is that <code>==</code> does not work reliably on strings if the variables are cast to the <code>object</code> type. We explain why this is so in <a data-type="xref" href="ch04.html#equality_comparison-id00016">“Equality Comparison”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="Compare method" data-type="indexterm" id="id2723"/><a contenteditable="false" data-primary="CompareOrdinal method" data-type="indexterm" id="id2724"/><a contenteditable="false" data-primary="CompareTo" data-type="indexterm" id="id2725"/><a contenteditable="false" data-primary="order comparison" data-type="indexterm" id="id2726"/>For string order comparison, you can use either the <code>CompareTo</code> instance method or the static <code>Compare</code> and <code>CompareOrdinal</code> methods. These return a positive or negative number, or zero, depending on whether the first value comes after, before, or alongside the second.</p>
<p>Before going into the details of each, we need to examine .NET’s underlying string comparison algorithms.</p>
<section data-pdf-bookmark="Ordinal versus culture comparison" data-type="sect3"><div class="sect3" id="ordinal_versus_culture_comparison">
<h3>Ordinal versus culture comparison</h3>
<p><a contenteditable="false" data-primary="comparisons" data-secondary="ordinal versus culture comparison" data-type="indexterm" id="id2727"/><a contenteditable="false" data-primary="culture sensitive string comparison" data-type="indexterm" id="id2728"/><a contenteditable="false" data-primary="ordinal string comparison" data-type="indexterm" id="id2729"/><a contenteditable="false" data-primary="string type" data-secondary="ordinal versus culture comparison" data-type="indexterm" id="id2730"/>There are two basic algorithms for string comparison: <em>ordinal</em> and <em>culture sensitive</em>. Ordinal comparisons interpret characters simply as numbers (according to their numeric Unicode value); culture-sensitive comparisons interpret characters with reference to a particular alphabet. There are two special cultures: the “current culture,” which is based on settings picked up from the computer’s control panel, and the “invariant culture,” which is the same on every computer (and closely matches American culture).</p>
<p>For equality comparison, both ordinal and culture-specific algorithms are useful. For ordering, however, culture-specific comparison is nearly always preferable: to order strings alphabetically, you need an alphabet. Ordinal relies on the numeric Unicode point values, which happen to put English characters in alphabetical order—but even then, not exactly as you might expect. For example, assuming case sensitivity, consider the strings <code>"Atom"</code>, <code>"atom"</code>, and <code>"Zamia"</code>. The invariant culture puts them in the following order:</p>
<pre data-type="programlisting">"atom", "Atom", "Zamia"</pre>
<p>Ordinal arranges them instead as follows:</p>
<pre data-type="programlisting">"Atom", "Zamia", "atom"</pre>
<p>This is because the invariant culture encapsulates an alphabet, which considers uppercase characters adjacent to their lowercase counterparts (aAbBcCdD...). The ordinal algorithm, however, puts all the uppercase characters first, and then all lowercase characters (A...Z, a...z). This is essentially a throwback to the ASCII character set invented in the 1960s.</p>
</div></section>
<section data-pdf-bookmark="String equality comparison" data-type="sect3"><div class="sect3" id="string_equality_comparison">
<h3>String equality comparison</h3>
<p><a contenteditable="false" data-primary="ordinal case-sensitive comparison" data-type="indexterm" id="id2731"/><a contenteditable="false" data-primary="string type" data-secondary="string equality comparisons" data-type="indexterm" id="id2732"/>Despite ordinal’s limitations, <code>string</code>’s <code>==</code> operator always performs <em>ordinal case-sensitive</em> comparison. The same goes for the instance version of <code>string.Equals</code> when called without arguments; this defines the “default” equality comparison behavior for the <code>string</code> type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The ordinal algorithm was chosen for <code>string</code>’s <code>==</code> and <code>Equals</code> functions because it’s both highly efficient and <em>deterministic</em>. String equality comparison is considered fundamental and is performed far more frequently than order comparison.</p>
<p>A “strict” notion of equality is also consistent with the general use of the <code>==</code> operator.</p>
</div>
<p>The following methods allow culture-aware or case-insensitive comparisons:</p>
<pre data-type="programlisting">public bool Equals (string value, StringComparison comparisonType);

public static bool Equals (string a, string b,
                           StringComparison comparisonType);</pre>
<p>The static version is advantageous in that it still works if one or both of the strings are <code>null</code>. <a contenteditable="false" data-primary="String..." data-secondary="StringComparison enum" data-type="indexterm" id="id2733"/><code>StringComparison</code> is an <code>enum</code> defined as follows:</p>
<pre data-type="programlisting">public enum StringComparison
{
  CurrentCulture,               // Case-sensitive
  CurrentCultureIgnoreCase,
  InvariantCulture,             // Case-sensitive
  InvariantCultureIgnoreCase,
  Ordinal,                      // Case-sensitive
  OrdinalIgnoreCase
}</pre>
<p>For example:</p>
<pre data-type="programlisting">Console.WriteLine (string.Equals ("foo", "FOO",
                   StringComparison.OrdinalIgnoreCase));   // True

Console.WriteLine ("ṻ" == "ǖ");                            // False

Console.WriteLine (string.Equals ("ṻ", "ǖ",
                   StringComparison.CurrentCulture));      // <em>?</em></pre>
<p>(The result of the third example is determined by the computer’s current language settings.)</p>
</div></section>
<section data-pdf-bookmark="String order comparison" data-type="sect3"><div class="sect3" id="string_order_comparison">
<h3>String order comparison</h3>
<p><a contenteditable="false" data-primary="comparisons" data-secondary="string order comparison" data-type="indexterm" id="id2734"/><a contenteditable="false" data-primary="string type" data-secondary="string order comparison" data-type="indexterm" id="id2735"/><code>String</code>’s <code>CompareTo</code> instance method performs <em>culture-sensitive</em>, <em>case-sensitive</em> order comparison. Unlike the <code>==</code> operator, <code>CompareTo</code> does not use ordinal comparison: for ordering, a culture-sensitive algorithm is much more useful. Here’s the method’s definition:</p>
<pre data-type="programlisting">public int CompareTo (string strB);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>CompareTo</code> instance method implements the generic <code>IComparable</code> interface, a standard comparison protocol used across the .NET libraries. This means <code>string</code>’s <code>CompareTo</code> defines the default ordering behavior of strings in such applications as sorted collections, for instance. For more information on <code>IComparable</code>, see <a data-type="xref" href="#order_comparison">“Order Comparison”</a>.</p>
</div>
<p>For other kinds of comparison, you can call the static <code>Compare</code> and <code>CompareOrdinal</code> methods:</p>
<pre data-type="programlisting">public static int Compare (string strA, string strB,
                           StringComparison comparisonType);

public static int Compare (string strA, string strB, bool ignoreCase,
                           CultureInfo culture);

public static int Compare (string strA, string strB, bool ignoreCase);

public static int CompareOrdinal (string strA, string strB);</pre>
<p>The last two methods are simply shortcuts for calling the first two methods.</p>
<p>All of the order comparison methods return a positive number, a negative number, or zero depending on whether the first value comes after, before, or alongside the second value:</p>
<pre data-type="programlisting">Console.WriteLine ("Boston".CompareTo ("Austin"));    // 1
Console.WriteLine ("Boston".CompareTo ("Boston"));    // 0
Console.WriteLine ("Boston".CompareTo ("Chicago"));   // -1
Console.WriteLine ("ṻ".CompareTo ("ǖ"));              // 1
Console.WriteLine ("foo".CompareTo ("FOO"));          // -1</pre>
<p>The following performs a case-insensitive comparison using the current culture:</p>
<pre data-type="programlisting">Console.WriteLine (string.Compare ("foo", "FOO", true));   // 0</pre>
<p><a contenteditable="false" data-primary="CultureInfo" data-type="indexterm" id="id2736"/>By supplying a <code>CultureInfo</code> object, you can plug in any alphabet: <a contenteditable="false" data-primary="" data-startref="ch06.html104" data-type="indexterm" id="id2737"/><a contenteditable="false" data-primary="" data-startref="ch06.html103" data-type="indexterm" id="id2738"/></p>
<pre data-type="programlisting">// CultureInfo is defined in the System.Globalization namespace

CultureInfo german = CultureInfo.GetCultureInfo ("de-DE");
int i = string.Compare ("Müller", "Muller", false, german);</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="StringBuilder" data-type="sect2"><div class="sect2" id="stringbuilder">
<h2>StringBuilder</h2>
<p><a contenteditable="false" data-primary="string type" data-secondary="StringBuilder class" data-type="indexterm" id="id2739"/><a contenteditable="false" data-primary="String..." data-secondary="StringBuilder class" data-type="indexterm" id="id2740"/>The <code>StringBuilder</code> class (<code>System.Text</code> namespace) represents a mutable (editable) string. With a <code>StringBuilder</code>, you can <code>Append</code>, <code>Insert</code>, <code>Remove</code>, and <code>Replace</code> substrings without replacing the whole <code>StringBuilder</code>.</p>
<p><code>StringBuilder</code>’s constructor optionally accepts an initial string value as well as a starting size for its internal capacity (default is 16 characters). If you go beyond this, <code>StringBuilder</code> automatically resizes its internal structures to accommodate (at a slight performance cost) up to its maximum capacity (default is <code>int.MaxValue</code>).</p>
<p>A popular use of <code>StringBuilder</code> is to build up a long string by repeatedly calling <code>Append</code>. This approach is much more efficient than repeatedly concatenating ordinary string types:</p>
<pre data-type="programlisting">StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 50; i++) <strong>sb.Append(i).Append(",");</strong></pre>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToString method" data-type="indexterm" id="id2741"/>To get the final result, call <code>ToString()</code>:</p>
<pre data-type="programlisting">Console.WriteLine (sb.ToString());

0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,</pre>
<p><code>AppendLine</code> performs an <code>Append</code> that adds a new line sequence (<code>"\r\n"</code> in Windows). <code>AppendFormat</code> accepts a composite format string, just like <code>String.Format</code>.</p>
<p>In addition to the <code>Insert</code>, <code>Remove</code>, and <code>Replace</code> methods (<code>Replace</code> works like string’s <code>Replace</code>), <code>StringBuilder</code> defines a <code>Length</code> property and a writable indexer for getting/setting individual characters.</p>
<p>To clear the contents of a <code>StringBuilder</code>, either instantiate a new one or set its <code>Length</code> to zero.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Setting a <code>StringBuilder</code>’s <code>Length</code> to zero doesn’t shrink its <em>internal</em> capacity. So, if the <code>StringBuilder</code> previously contained one million characters, it will continue to occupy around two megabytes of memory after zeroing its <code>Length</code>. If you want to release the memory, you must create a new <code>StringBuilder</code> and allow the old one to drop out of scope (and be garbage-collected).</p>
</div>
</div></section>
<section data-pdf-bookmark="Text Encodings and Unicode" data-type="sect2"><div class="sect2" id="text_encodings_and_unicode">
<h2>Text Encodings and Unicode</h2>
<p><a contenteditable="false" data-primary="string type" data-secondary="text encodings and Unicode" data-type="indexterm" id="ch06.html105"/><a contenteditable="false" data-primary="text encoding" data-type="indexterm" id="ch06.html106"/><a contenteditable="false" data-primary="text handling" data-secondary="text encodings and Unicode" data-type="indexterm" id="ch06.html107"/><a contenteditable="false" data-primary="Unicode" data-type="indexterm" id="ch06.html108"/><a contenteditable="false" data-primary="code point" data-type="indexterm" id="id2742"/>A <em>character set</em> is an allocation of characters, each with a numeric code, or <em>code point</em>. There are two character sets in common use: Unicode and ASCII. Unicode has an address space of approximately one million characters, of which about 100,000 are currently allocated. Unicode covers most spoken world languages as well as some historical languages and special symbols. <a contenteditable="false" data-primary="ASCII character set" data-type="indexterm" id="id2743"/>The ASCII set is simply the first 128 characters of the Unicode set, which covers most of what you see on a US-style keyboard. ASCII predates Unicode by 30 years and is still sometimes used for its simplicity and efficiency: each character is represented by one byte.</p>
<p>The .NET type system is designed to work with the Unicode character set. ASCII is implicitly supported, though, by virtue of being a subset of Unicode.</p>
<p>A <em>text encoding</em> maps characters from their numeric code point to a binary representation. In .NET, text encodings come into play primarily when dealing with text files or streams. When you read a text file into a string, a <em>text encoder</em> translates the file data from binary into the internal Unicode representation that the <code>char</code> and <code>string</code> types expect. A text encoding can restrict what characters can be represented as well as affect storage efficiency.</p>
<p>There are two categories of text encoding in .NET:</p>
<ul>
<li><p>Those that map Unicode characters to another character set</p></li>
<li><p>Those that use standard Unicode encoding schemes</p></li>
</ul>
<p>The first category contains legacy encodings such as IBM’s EBCDIC and 8-bit character sets with extended characters in the upper-128 region that were popular prior to Unicode (identified by a code page). The ASCII encoding is also in this category: it encodes the first 128 characters and drops everything else. This category contains the <em>nonlegacy</em> GB18030, as well, which is the mandatory standard for applications written in China—or sold to China—since 2000.</p>
<p>In the second category are UTF-8, UTF-16, and UTF-32 (and the obsolete UTF-7). Each differs in space efficiency. UTF-8 is the most space-efficient for most kinds of text: it uses <em>between one and four bytes</em> to represent each character. The first 128 characters require only a single byte, making it compatible with ASCII. UTF-8 is the most popular encoding for text files and streams (particularly on the internet), and it is the default for stream input/output (I/O) in .NET (in fact, it’s the default for almost everything that implicitly uses an encoding).</p>
<p>UTF-16 uses one or two 16-bit words to represent each character. This is what .NET uses internally to represent characters and strings. Some programs also write files in UTF-16.</p>
<p>UTF-32 is the least space-efficient: it maps each code point directly to 32 bits, so every character consumes four bytes. UTF-32 is rarely used for this reason. It does, however, make random access very easy because every character takes an equal number of bytes.</p>
<section data-pdf-bookmark="Obtaining an Encoding object" data-type="sect3"><div class="sect3" id="obtaining_an_encoding_object">
<h3>Obtaining an Encoding object</h3>
<p><a contenteditable="false" data-primary="Encoding object" data-type="indexterm" id="id2744"/><a contenteditable="false" data-primary="System..." data-secondary="System.Text" data-type="indexterm" id="id2745"/><a contenteditable="false" data-primary="text encoding" data-secondary="obtaining an Encoding object" data-type="indexterm" id="id2746"/>The <code>Encoding</code> class in <code>System.Text</code> is the common base type for classes that encapsulate text encodings. There are several subclasses—their purpose is to encapsulate families of encodings with similar features. The most common encodings can be obtained through dedicated static properties on <code>Encoding</code>:</p>
<table class="border">
<thead>
<tr>
<th>Encoding name</th>
<th>Static property on Encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTF-8</td>
<td><code>Encoding.UTF8</code></td>
</tr>
<tr>
<td>UTF-16</td>
<td><code>Encoding.Unicode</code> (<em>not</em> <code>UTF16</code>)</td>
</tr>
<tr>
<td>UTF-32</td>
<td><code>Encoding.UTF32</code></td>
</tr>
<tr>
<td>ASCII</td>
<td><code>Encoding.ASCII</code></td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="Encoding.GetEncoding" data-type="indexterm" id="id2747"/>You can obtain other encodings by calling <code>Encoding.GetEncoding</code> with <a contenteditable="false" data-primary="IANA (Internet Assigned Numbers Authority) Character Set" data-type="indexterm" id="id2748"/><a contenteditable="false" data-primary="Internet Assigned Numbers Authority (IANA) Character Set" data-type="indexterm" id="id2749"/>a standard Internet Assigned Numbers Authority (IANA) Character Set name:</p>
<pre data-type="programlisting">// In .NET 5+ and .NET Core, you must first call RegisterProvider:
Encoding.RegisterProvider (CodePagesEncodingProvider.Instance);

Encoding chinese = Encoding.GetEncoding ("GB18030");</pre>
<p><a contenteditable="false" data-primary="Get..." data-secondary="GetEncodings method" data-type="indexterm" id="id2750"/>The static <code>GetEncodings</code> method returns a list of all supported encodings along with their standard IANA names:</p>
<pre data-type="programlisting">foreach (EncodingInfo info in Encoding.GetEncodings())
  Console.WriteLine (info.Name);</pre>
<p>The other way to obtain an encoding is to directly instantiate an encoding class. Doing so allows you to set various options via constructor arguments, including:</p>
<ul>
<li><p>Whether to throw an exception if an invalid byte sequence is encountered when decoding. The default is false.</p></li>
<li><p>Whether to encode/decode UTF-16/UTF-32 with the most significant bytes first (<em>big endian</em>) or the least significant bytes first (<em>little endian</em>). The default is <em>little endian</em>, the standard on the Windows operating system.</p></li>
<li><p>Whether to emit a byte-order mark (a prefix that indicates <em>endianness</em>).</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Encoding for file and stream I/O" data-type="sect3"><div class="sect3" id="encoding_for_file_and_stream_isoliduso">
<h3>Encoding for file and stream I/O</h3>
<p><a contenteditable="false" data-primary="text encoding" data-secondary="file and stream I/O" data-type="indexterm" id="id2751"/>The most common application for an <code>Encoding</code> object is to control how text is read and written to a file or stream. For example, the following writes “Testing…” to a file called <em>data.txt</em> in UTF-16 encoding:</p>
<pre data-type="programlisting">System.IO.File.WriteAllText ("data.txt", "Testing...", Encoding.Unicode);</pre>
<p>If you omit the final argument, <code>WriteAllText</code> applies the ubiquitous UTF-8 encoding.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>UTF-8 is the default text encoding for all file and stream I/O.</p>
</div>
<p>We resume this subject in <a data-type="xref" href="ch15.html#streams_and_isoliduso">Chapter 15</a>, in <a data-type="xref" href="ch15.html#stream_adapters">“Stream Adapters”</a>.</p>
</div></section>
<section data-pdf-bookmark="Encoding to byte arrays" data-type="sect3"><div class="sect3" id="encoding_to_byte_arrays">
<h3>Encoding to byte arrays</h3>
<p><a contenteditable="false" data-primary="byte arrays" data-type="indexterm" id="id2752"/><a contenteditable="false" data-primary="text encoding" data-secondary="encoding to byte arrays" data-type="indexterm" id="id2753"/>You can also use an <code>Encoding</code> object to go to and from a byte array. <a contenteditable="false" data-primary="Get..." data-secondary="GetBytes method" data-type="indexterm" id="id2754"/>The <code>GetBytes</code> method converts from <code>string</code> to <code>byte[]</code> with the given encoding; <a contenteditable="false" data-primary="Get..." data-secondary="GetString method" data-type="indexterm" id="id2755"/><code>GetString</code> converts from <code>byte[]</code> to <code>string</code>:</p>
<pre data-type="programlisting">byte[] utf8Bytes  = System.Text.Encoding.UTF8.GetBytes    ("0123456789");
byte[] utf16Bytes = System.Text.Encoding.Unicode.GetBytes ("0123456789");
byte[] utf32Bytes = System.Text.Encoding.UTF32.GetBytes   ("0123456789");

Console.WriteLine (utf8Bytes.Length);    // 10
Console.WriteLine (utf16Bytes.Length);   // 20
Console.WriteLine (utf32Bytes.Length);   // 40

string original1 = System.Text.Encoding.UTF8.GetString    (utf8Bytes);
string original2 = System.Text.Encoding.Unicode.GetString (utf16Bytes);
string original3 = System.Text.Encoding.UTF32.GetString   (utf32Bytes);

Console.WriteLine (original1);          // 0123456789
Console.WriteLine (original2);          // 0123456789
Console.WriteLine (original3);          // 0123456789</pre>
</div></section>
<section data-pdf-bookmark="UTF-16 and surrogate pairs" data-type="sect3"><div class="sect3" id="utf_onesix_and_surrogate_pairs">
<h3>UTF-16 and surrogate pairs</h3>
<p><a contenteditable="false" data-primary="surrogate pairs" data-type="indexterm" id="id2756"/><a contenteditable="false" data-primary="text encoding" data-secondary="UTF-16 and surrogate pairs" data-type="indexterm" id="id2757"/><a contenteditable="false" data-primary="Unicode" data-secondary="UTF-16 and surrogate pairs" data-type="indexterm" id="id2758"/>Recall that .NET stores characters and strings in UTF-16. Because UTF-16 requires one or two 16-bit words per character, and a <code>char</code> is only 16 bits in length, some Unicode characters require two <code>char</code>s to represent. This has a couple of consequences:</p>
<ul>
<li><p>A string’s <code>Length</code> property can be greater than its real character count.</p></li>
<li><p>A single <code>char</code> is not always enough to fully represent a Unicode character.</p></li>
</ul>
<p><a contenteditable="false" data-primary="Basic Multilingual Plane (BMP)" data-type="indexterm" id="id2759"/><a contenteditable="false" data-primary="BMP (Basic Multilingual Plane)" data-type="indexterm" id="id2760"/>Most applications ignore this because nearly all commonly used characters fit into a section of Unicode called the <em>Basic Multilingual Plane</em> (BMP), which requires only one 16-bit word in UTF-16. The BMP covers several dozen world languages and includes more than 30,000 Chinese characters. Excluded are characters of some ancient languages, symbols for musical notation, some less common Chinese characters, and most emojis.</p>
<p>If you need to support two-word characters, the following static methods in <code>char</code> convert a 32-bit code point to a string of two <code>char</code>s, and back again:</p>
<pre data-type="programlisting">string ConvertFromUtf32 (int utf32)
int    ConvertToUtf32   (char highSurrogate, char lowSurrogate)</pre>
<p>Two-word characters are called <em>surrogates</em>. They are easy to spot because each word is in the range 0xD800 to 0xDFFF. You can use the following static methods in <code>char</code> to assist:</p>
<pre data-type="programlisting">bool IsSurrogate     (char c)
bool IsHighSurrogate (char c)
bool IsLowSurrogate  (char c)
bool IsSurrogatePair (char highSurrogate, char lowSurrogate)</pre>
<p><a contenteditable="false" data-primary="String..." data-secondary="StringInfo class" data-type="indexterm" id="id2761"/><a contenteditable="false" data-primary="System..." data-secondary="System.Globalization" data-type="indexterm" id="id2762"/>The <code>StringInfo</code> class in the <code>System.Globalization</code> namespace also provides a range of methods and properties for working with two-word characters.</p>
<p><a contenteditable="false" data-primary="" data-startref="ch06.html108" data-type="indexterm" id="id2763"/><a contenteditable="false" data-primary="" data-startref="ch06.html107" data-type="indexterm" id="id2764"/><a contenteditable="false" data-primary="" data-startref="ch06.html106" data-type="indexterm" id="id2765"/><a contenteditable="false" data-primary="" data-startref="ch06.html105" data-type="indexterm" id="id2766"/>Characters outside the BMP typically require special fonts and have limited operating system support.<a contenteditable="false" data-primary="" data-startref="ch06.html102" data-type="indexterm" id="id2767"/><a contenteditable="false" data-primary="" data-startref="ch06.html101" data-type="indexterm" id="id2768"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Dates and Times" data-type="sect1"><div class="sect1" id="dates_and_times">
<h1>Dates and Times</h1>
<p><a contenteditable="false" data-primary="dates and times" data-type="indexterm" id="ch06.html109"/>The following immutable structs in the <code>System</code> namespace do the job of representing dates and times:</p>
<p><code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code>, <code>DateOnly</code>, <code>TimeOnly</code></p>
<p>C# doesn’t define any special keywords that map to these types.</p>
<section data-pdf-bookmark="TimeSpan" data-type="sect2"><div class="sect2" id="timespan">
<h2>TimeSpan</h2>
<p><a contenteditable="false" data-primary="dates and times" data-secondary="TimeSpan" data-type="indexterm" id="id2769"/><a contenteditable="false" data-primary="TimeSpan" data-type="indexterm" id="id2770"/>A <code>TimeSpan</code> represents an interval of time—or a time of the day. In the latter role, it’s simply the “clock” time (without the date), which is equivalent to the time since midnight, assuming no daylight saving transition. A <code>TimeSpan</code> has a resolution of 100 ns, has a maximum value of about 10 million days, and can be positive or negative.</p>
<p>There are three ways to construct a <code>TimeSpan</code>:</p>
<ul>
<li><p>Through one of the constructors</p></li>
<li><p>By calling one of the static <code>From</code>… methods</p></li>
<li><p>By subtracting one <code>DateTime</code> from another</p></li>
</ul>
<p class="pagebreak-before">Here are the constructors:</p>
<pre data-type="programlisting">public TimeSpan (int hours, int minutes, int seconds);
public TimeSpan (int days, int hours, int minutes, int seconds);
public TimeSpan (int days, int hours, int minutes, int seconds,
                                                   int milliseconds);
public TimeSpan (int days, int hours, int minutes, int seconds,
                                      int milliseconds, int microseconds);
public TimeSpan (long ticks);   // Each tick = 100ns</pre>
<p>The static <code>From</code>… methods are more convenient when you want to specify an interval in just a single unit, such as minutes, hours, and so on:</p>
<pre data-type="programlisting">public static TimeSpan FromDays (double value);
public static TimeSpan FromHours (double value);
public static TimeSpan FromMinutes (double value);
public static TimeSpan FromSeconds (double value);
public static TimeSpan FromMilliseconds (double value);
public static TimeSpan FromMicroseconds (double value);</pre>
<p>For example:</p>
<pre data-type="programlisting">Console.WriteLine (new TimeSpan (2, 30, 0));     // 02:30:00
Console.WriteLine (TimeSpan.FromHours (2.5));    // 02:30:00
Console.WriteLine (TimeSpan.FromHours (-2.5));   // -02:30:00</pre>
<p><code>TimeSpan</code> overloads the <code>&lt;</code> and <code>&gt;</code> operators as well as the <code>+</code> and <code>-</code> operators. The following expression evaluates to a <code>TimeSpan</code> of 2.5 hours:</p>
<pre data-type="programlisting">TimeSpan.FromHours(2) + TimeSpan.FromMinutes(30);</pre>
<p>The next expression evaluates to one second short of 10 days:</p>
<pre data-type="programlisting">TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);   // 9.23:59:59</pre>
<p>Using this expression, we can illustrate the integer properties <code>Days</code>, <code>Hours</code>, <code>Minutes</code>, <code>Seconds</code>, and <code>Milliseconds</code>:</p>
<pre data-type="programlisting">TimeSpan nearlyTenDays = TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);

Console.WriteLine (nearlyTenDays.Days);          // 9
Console.WriteLine (nearlyTenDays.Hours);         // 23
Console.WriteLine (nearlyTenDays.Minutes);       // 59
Console.WriteLine (nearlyTenDays.Seconds);       // 59
Console.WriteLine (nearlyTenDays.Milliseconds);  // 0</pre>
<p>In contrast, the <code>Total</code>... properties return values of type <code>double</code> describing the entire time span:</p>
<pre data-type="programlisting">Console.WriteLine (nearlyTenDays.TotalDays);          // 9.99998842592593
Console.WriteLine (nearlyTenDays.TotalHours);         // 239.999722222222
Console.WriteLine (nearlyTenDays.TotalMinutes);       // 14399.9833333333
Console.WriteLine (nearlyTenDays.TotalSeconds);       // 863999
Console.WriteLine (nearlyTenDays.TotalMilliseconds);  // 863999000</pre>
<p><a contenteditable="false" data-primary="Parse method" data-type="indexterm" id="id2771"/>The static <code>Parse</code> method does the opposite of <code>ToString</code>, converting a string to a <code>TimeSpan</code>. <a contenteditable="false" data-primary="TryParse" data-type="indexterm" id="id2772"/><code>TryParse</code> does the same but returns <code>false</code> rather than throwing an exception if the conversion fails. The <code>XmlConvert</code> class also provides <code>TimeSpan</code>/string conversion methods that follow standard XML formatting protocols.</p>
<p>The default value for a <code>TimeSpan</code> is <code>TimeSpan.Zero</code>.</p>
<p><code>TimeSpan</code> can also be used to represent the time of the day (the elapsed time since midnight). To obtain the current time of day, call <code>DateTime.Now.TimeOfDay</code>.</p>
</div></section>
<section data-pdf-bookmark="DateTime and DateTimeOffset" data-type="sect2"><div class="sect2" id="datetime_and_datetimeoffset">
<h2>DateTime and DateTimeOffset</h2>
<p><a contenteditable="false" data-primary="dates and times" data-secondary="DateTime and DateTimeOffset" data-type="indexterm" id="ch06.html1010"/><a contenteditable="false" data-primary="DateTime" data-type="indexterm" id="ch06.html1011"/><a contenteditable="false" data-primary="DateTimeOffset" data-type="indexterm" id="ch06.html1012"/><code>DateTime</code> and <code>DateTimeOffset</code> are immutable structs for representing a date and, optionally, a time. They have a resolution of 100 ns and a range covering the years 0001 through 9999.</p>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="DateTimeOffset versus" data-type="indexterm" id="id2773"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="DateTime versus" data-type="indexterm" id="id2774"/><code>DateTimeOffset</code> is functionally similar to <code>DateTime</code>. <a contenteditable="false" data-primary="Coordinated Universal Time (UTC)" data-type="indexterm" id="id2775"/><a contenteditable="false" data-primary="UTC (Coordinated Universal Time)" data-type="indexterm" id="id2776"/>Its distinguishing feature is that it also stores a Coordinated Universal Time (UTC) offset; this allows more meaningful results when comparing values across different time zones.</p>
<section data-pdf-bookmark="Choosing between DateTime and DateTimeOffset" data-type="sect3"><div class="sect3" id="choosing_between_datetime_and_datetimeo">
<h3>Choosing between DateTime and DateTimeOffset</h3>
<p><code>DateTime</code> and <code>DateTimeOffset</code> differ in how they handle time zones. A <code>DateTime</code> incorporates a three-state flag indicating whether the <code>DateTime</code> is relative to the following:</p>
<ul>
<li><p>The local time on the current computer</p></li>
<li><p>UTC (the modern equivalent of Greenwich Mean Time)</p></li>
<li><p>Unspecified</p></li>
</ul>
<p>A <code>DateTimeOffset</code> is more specific—it stores the offset from UTC as a <code>TimeSpan</code>:</p>
<pre data-type="programlisting">July 01 2019 03:00:00 <strong>-06:00</strong></pre>
<p>This influences equality comparisons, which is the main factor in choosing between <code>DateTime</code> and <code>DateTimeOffset</code>. Specifically:</p>
<ul>
<li><p><code>DateTime</code> ignores the three-state flag in comparisons and considers two values equal if they have the same year, month, day, hour, minute, and so on.</p></li>
<li><p><code>DateTimeOffset</code> considers two values equal if they refer to the <em>same point in time</em>.</p></li>
</ul>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Daylight Saving Time can make this distinction important even if your application doesn’t need to handle multiple geographic time zones.</p>
</div>
<p>So, <code>DateTime</code> considers the following two values different, whereas <code>DateTimeOffset</code> considers them equal:</p>
<pre data-type="programlisting">July 01 2019 09:00:00 +00:00 (GMT)
July 01 2019 03:00:00 -06:00 (local time, Central America)</pre>
<p>In most cases, <code>DateTimeOffset</code>’s equality logic is preferable. For example, in calculating which of two international events is more recent, a <code>DateTimeOffset</code> implicitly gives the correct answer. Similarly, a hacker plotting a Distributed Denial of Service attack would reach for a <code>DateTimeOffset</code>! To do the same with <code>DateTime</code> requires standardizing on a single time zone (typically UTC) throughout your application. This is problematic for two reasons:</p>
<ul>
<li><p>To be friendly to the end user, UTC <code>DateTime</code>s require explicit conversion to local time prior to formatting.</p></li>
<li><p>It’s easy to forget and incorporate a local <code>DateTime</code>.</p></li>
</ul>
<p><code>DateTime</code> is better, though, at specifying a value relative to the local computer at runtime—for example, if you want to schedule an archive at each of your international offices for next Sunday, at 3 A.M. local time (when there’s least activity). Here, <code>DateTime</code> would be more suitable because it would respect each site’s local time.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Internally, <code>DateTimeOffset</code> uses a short integer to store the UTC offset in minutes. It doesn’t store any regional information, so there’s nothing present to indicate whether an offset of +08:00, for instance, refers to Singapore time or Perth time.</p>
</div>
<p>We revisit time zones and equality comparison in more depth in <a data-type="xref" href="#dates_and_time_zones">“Dates and Time Zones”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>SQL Server 2008 introduced direct support for <code>DateTimeOffset</code> through a new data type of the same name.</p>
</div>
</div></section>
<section data-pdf-bookmark="Constructing a DateTime" data-type="sect3"><div class="sect3" id="constructing_a_datetime">
<h3>Constructing a DateTime</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="constructing" data-type="indexterm" id="id2777"/><code>DateTime</code> defines constructors that accept integers for the year, month, and day—and optionally, the hour, minute, second, millisecond (and microsecond, from .NET 7):</p>
<pre data-type="programlisting">public DateTime (int year, int month, int day);

public DateTime (int year, int month, int day,
                 int hour, int minute, int second, int millisecond);</pre>
<p>If you specify only a date, the time is implicitly set to midnight (0:00).</p>
<p>The <code>DateTime</code> constructors also allow you to specify a <code>DateTimeKind</code>—an enum with the following values:</p>
<pre data-type="programlisting">Unspecified, Local, Utc</pre>
<p>This corresponds to the three-state flag described in the preceding section. <code>Unspecified</code> is the default, and it means that the <code>DateTime</code> is time-zone-agnostic. <code>Local</code> means relative to the local time zone on the current computer. A local <code>DateTime</code> does not include information about <em>which particular time zone</em> it refers to, or, unlike <code>DateTimeOffset</code>, the numeric offset from UTC.</p>
<p>A <code>DateTime</code>’s <code>Kind</code> property returns its <code>DateTimeKind</code>.</p>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Globalization" data-type="indexterm" id="id2778"/><code>DateTime</code>’s constructors are also overloaded to accept a <code>Calendar</code> object, as well. This allows you to specify a date using any of the <code>Calendar</code> subclasses defined in <code>System.Globalization</code>:</p>
<pre data-type="programlisting">DateTime d = new DateTime (5767, 1, 1,
                          new System.Globalization.HebrewCalendar());

Console.WriteLine (d);    // 12/12/2006 12:00:00 AM</pre>
<p>(The formatting of the date in this example depends on your computer’s control panel settings.) A <code>DateTime</code> always uses the default Gregorian calendar—this example, a one-time conversion, takes place during construction. To perform computations using another calendar, you must use the methods on the <code>Calendar</code> subclass itself.</p>
<p>You can also construct a <code>DateTime</code> with a single <em>ticks</em> value of type <code>long</code>, where <em>ticks</em> is the number of 100-ns intervals from midnight 01/01/0001.</p>
<p>For interoperability, <code>DateTime</code> provides the static <code>FromFileTime</code> and <code>FromFileTimeUtc</code> methods for converting from a Windows file time (specified as a <code>long</code>) and <code>FromOADate</code> for converting from an OLE automation date/time (specified as a <code>double</code>).</p>
<p>To construct a <code>DateTime</code> from a string, call the static <code>Parse</code> or <code>ParseExact</code> method. Both methods accept optional flags and format providers; <code>ParseExact</code> also accepts a format string. We discuss parsing in greater detail in <a data-type="xref" href="#formatting_and_parsing">“Formatting and Parsing”</a>.</p>
</div></section>
<section data-pdf-bookmark="Constructing a DateTimeOffset" data-type="sect3"><div class="sect3" id="constructing_a_datetimeoffset">
<h3>Constructing a DateTimeOffset</h3>
<p><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="constructing" data-type="indexterm" id="id2779"/><code>DateTimeOffset</code> has a similar set of constructors. The difference is that you also specify a UTC offset as a <code>TimeSpan</code>:</p>
<pre data-type="programlisting">public DateTimeOffset (int year, int month, int day,
                       int hour, int minute, int second,
                       <strong>TimeSpan offset</strong>);

public DateTimeOffset (int year, int month, int day,
                       int hour, int minute, int second, int millisecond,
                       <strong>TimeSpan offset</strong>);</pre>
<p>The <code>TimeSpan</code> must amount to a whole number of minutes; otherwise, an exception is thrown.</p>
<p><code>DateTimeOffset</code> also has constructors that accept a <code>Calendar</code> object, a <code>long</code> <em>ticks</em> value, and static <code>Parse</code> and <code>ParseExact</code> methods that accept a string.</p>
<p>You can construct a <code>DateTimeOffset</code> from an existing <code>DateTime</code> either by using these constructors:</p>
<pre data-type="programlisting">public DateTimeOffset (DateTime dateTime);
public DateTimeOffset (DateTime dateTime, TimeSpan offset);</pre>
<p>or with an implicit cast:</p>
<pre data-type="programlisting">DateTimeOffset dt = new DateTime (2000, 2, 3);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The implicit cast from <code>DateTime</code> to <code>DateTimeOffset</code> is handy because most of the .NET BCL supports <code>DateTime</code>—not <code>DateTimeOffset</code>.</p>
</div>
<p>If you don’t specify an offset, it’s inferred from the <code>DateTime</code> value using these rules:</p>
<ul>
<li><p>If the <code>DateTime</code> has a <code>DateTimeKind</code> of <code>Utc</code>, the offset is zero.</p></li>
<li><p>If the <code>DateTime</code> has a <code>DateTimeKind</code> of <code>Local</code> or <code>Unspecified</code> (the default), the offset is taken from the current local time zone.</p></li>
</ul>
<p>To convert in the other direction, <code>DateTimeOffset</code> provides three properties that return values of type <code>DateTime</code>:</p>
<ul>
<li><p>The <code>UtcDateTime</code> property returns a <code>DateTime</code> in UTC time.</p></li>
<li><p>The <code>LocalDateTime</code> property returns a <code>DateTime</code> in the current local time zone (converting it if necessary).</p></li>
<li><p>The <code>DateTime</code> property returns a <code>DateTime</code> in whatever zone it was specified, with a <code>Kind</code> of <code>Unspecified</code> (i.e., it returns the UTC time plus the offset).</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="The current DateTime/DateTimeOffset" data-type="sect3"><div class="sect3" id="the_current_datetimesolidusdatetimeoffs">
<h3>The current DateTime/DateTimeOffset</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="returning current date/time with" data-type="indexterm" id="id2780"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="returning current date/time with" data-type="indexterm" id="id2781"/>Both <code>DateTime</code> and <code>DateTimeOffset</code> have a static <code>Now</code> property that returns the current date and time:</p>
<pre data-type="programlisting">Console.WriteLine (DateTime.Now);         // 11/11/2019 1:23:45 PM
Console.WriteLine (DateTimeOffset.Now);   // 11/11/2019 1:23:45 PM -06:00</pre>
<p><code>DateTime</code> also provides a <code>Today</code> property that returns just the date portion:</p>
<pre data-type="programlisting">Console.WriteLine (DateTime.Today);       // 11/11/2019 12:00:00 AM</pre>
<p>The static <code>UtcNow</code> property returns the current date and time in UTC:</p>
<pre data-type="programlisting">Console.WriteLine (DateTime.UtcNow);        // 11/11/2019 7:23:45 AM
Console.WriteLine (DateTimeOffset.UtcNow);  // 11/11/2019 7:23:45 AM +00:00</pre>
<p>The precision of all these methods depends on the operating system and is typically in the 10 to 20 ms region.</p>
</div></section>
<section data-pdf-bookmark="Working with dates and times" data-type="sect3"><div class="sect3" id="working_with_dates_and_times">
<h3>Working with dates and times</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="working with dates and times" data-type="indexterm" id="id2782"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="working with dates and times" data-type="indexterm" id="id2783"/><code>DateTime</code> and <code>DateTimeOffset</code> provide a similar set of instance properties that return various date/time elements:</p>
<pre data-type="programlisting">DateTime dt = new DateTime (2000, 2, 3,
                            10, 20, 30);

Console.WriteLine (dt.Year);         // 2000
Console.WriteLine (dt.Month);        // 2
Console.WriteLine (dt.Day);          // 3
Console.WriteLine (dt.DayOfWeek);    // Thursday
Console.WriteLine (dt.DayOfYear);    // 34

Console.WriteLine (dt.Hour);         // 10
Console.WriteLine (dt.Minute);       // 20
Console.WriteLine (dt.Second);       // 30
Console.WriteLine (dt.Millisecond);  // 0
Console.WriteLine (dt.Ticks);        // 630851700300000000
Console.WriteLine (dt.TimeOfDay);    // 10:20:30  (returns a TimeSpan)</pre>
<p><code>DateTimeOffset</code> also has an <code>Offset</code> property of type <code>TimeSpan</code>.</p>
<p>Both types provide the following instance methods to perform computations (most accept an argument of type <code>double</code> or <code>int</code>):</p>
<pre data-type="programlisting">AddYears  AddMonths   AddDays
AddHours  AddMinutes  AddSeconds  AddMilliseconds  AddTicks</pre>
<p>These all return a new <code>DateTime</code> or <code>DateTimeOffset</code>, and they take into account such things as leap years. You can pass in a negative value to subtract.</p>
<p>The <code>Add</code> method adds a <code>TimeSpan</code> to a <code>DateTime</code> or <code>DateTimeOffset</code>. The <code>+</code> operator is overloaded to do the same job:</p>
<pre data-type="programlisting">TimeSpan ts = TimeSpan.FromMinutes (90);
Console.WriteLine (dt.Add (ts));
Console.WriteLine (dt + ts);             // same as above</pre>
<p>You can also subtract a <code>TimeSpan</code> from a <code>DateTime</code>/<code>DateTimeOffset</code> and subtract one <code>DateTime</code>/<code>DateTimeOffset</code> from another. The latter gives you a <code>TimeSpan</code>:</p>
<pre data-type="programlisting">DateTime thisYear = new DateTime (2015, 1, 1);
DateTime nextYear = thisYear.AddYears (1);
TimeSpan oneYear = nextYear - thisYear;</pre>
</div></section>
<section data-pdf-bookmark="Formatting and parsing datetimes" data-type="sect3"><div class="sect3" id="formatting_and_parsing_datetimes">
<h3>Formatting and parsing datetimes</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="formatting/parsing datetimes" data-type="indexterm" id="id2784"/><a contenteditable="false" data-primary="To..." data-secondary="ToString method" data-type="indexterm" id="id2785"/>Calling <code>ToString</code> on a <code>DateTime</code> formats the result as a <em>short date</em> (all numbers) followed by a <em>long time</em> (including seconds); for example:</p>
<pre data-type="programlisting">11/11/2019 11:50:30 AM</pre>
<p>The operating system’s control panel, by default, determines such things as whether the day, month, or year comes first, the use of leading zeros, and whether 12- or 24-hour time is used.</p>
<p>Calling <code>ToString</code> on a <code>DateTimeOffset</code> is the same, except that the offset is also returned:</p>
<pre data-type="programlisting">11/11/2019 11:50:30 AM -06:00</pre>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToLongDateString method" data-type="indexterm" id="id2786"/><a contenteditable="false" data-primary="To..." data-secondary="ToShortDateString method" data-type="indexterm" id="id2787"/>The <code>ToShortDateString</code> and <code>ToLongDateString</code> methods return just the date portion. The long date format is also determined by the control panel; an example is “Wednesday, 11 November 2015.” <code>ToShortTimeString</code> and <code>ToLongTimeString</code> return just the time portion, such as 17:10:10 (the former excludes seconds).</p>
<p>These four just-described methods are actually shortcuts to four different <em>format strings</em>. <code>ToString</code> is overloaded to accept a format string and provider, allowing you to specify a wide range of options and control how regional settings are applied. We describe this in <a data-type="xref" href="#formatting_and_parsing">“Formatting and Parsing”</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><code>DateTime</code>s and <code>DateTimeOffset</code>s can be misparsed if the culture settings differ from those in force when formatting takes place. You can avoid this problem by using <code>ToString</code> in conjunction with a format string that ignores culture settings (such as “o”):</p>
<pre data-type="programlisting">DateTime dt1 = DateTime.Now;
string cannotBeMisparsed = dt1.<strong>ToString ("o")</strong>;
DateTime dt2 = DateTime.Parse (cannotBeMisparsed);</pre>
</div>
<p>The static <code>Parse</code>/<code>TryParse</code> and <code>ParseExact</code>/<code>TryParseExact</code> methods do the reverse of <code>ToString</code>, converting a string to a <code>DateTime</code> or <code>DateTimeOffset</code>. These methods are also overloaded to accept a format provider. The <code>Try</code>* methods return <code>false</code> instead of throwing a <code>FormatException</code>.</p>
</div></section>
<section data-pdf-bookmark="Null DateTime and DateTimeOffset values" data-type="sect3"><div class="sect3" id="null_datetime_and_datetimeoffset_values">
<h3>Null DateTime and DateTimeOffset values</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="null values" data-type="indexterm" id="id2788"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="null values" data-type="indexterm" id="id2789"/>Because <code>DateTime</code> and <code>DateTimeOffset</code> are structs, they are not intrinsically nullable. When you need nullability, there are two ways around this:</p>
<ul>
<li><p>Use a <code>Nullable</code> type (i.e., <code>DateTime?</code> or <code>DateTimeOffset?</code>).</p></li>
<li><p><a contenteditable="false" data-primary="DateTime.MinValue" data-type="indexterm" id="id2790"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="formatting/parsing datetimes" data-type="indexterm" id="id2791"/>Use the static field <code>DateTime.MinValue</code> or <code>DateTimeOffset.MinValue</code> (the <em>default values</em> for these types).</p></li>
</ul>
<p>A nullable type is usually the best approach because the compiler helps to prevent mistakes. <code>DateTime.MinValue</code> is useful for backward compatibility with code written prior to C# 2.0 (when nullable value types were introduced).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Calling <code>ToUniversalTime</code> or <code>ToLocalTime</code> on a <code>DateTime.MinValue</code> can result in it no longer being <code>DateTime.MinValue</code> (depending on which side of GMT you are on). If you’re right on GMT (England, outside daylight saving), the problem won’t arise at all because local and UTC times are the same. This is your compensation for the English winter! <a contenteditable="false" data-primary="" data-startref="ch06.html1012" data-type="indexterm" id="id2792"/><a contenteditable="false" data-primary="" data-startref="ch06.html1011" data-type="indexterm" id="id2793"/><a contenteditable="false" data-primary="" data-startref="ch06.html1010" data-type="indexterm" id="id2794"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="DateOnly and TimeOnly" data-type="sect2"><div class="sect2" id="dateonly_and_timeonly">
<h2>DateOnly and TimeOnly</h2>
<p>The <code>DateOnly</code> and <code>TimeOnly</code> structs (from .NET 6) exist for when you <em>only</em> want to represent a date or time.</p>
<p><code>DateOnly</code> is similar to <code>DateTime</code>, but without a time component. <code>DateOnly</code> also lacks <code>DateTimeKind</code>; in effect, it’s always <code>Unspecified</code> and has no concept of <code>Local</code> or <code>Utc</code>. The historical alternative to <code>DateOnly</code> was to use <code>DateTime</code> with a zero time (midnight). The difficulty with this approach is that equality comparisons fail when a non-zero time find its way into your code.</p>
<p><code>TimeOnly</code> is similar to <code>DateTime</code>, but without a date component. <code>TimeOnly</code> is intended for capturing the time of day and is suitable for applications such as recording alarm times or opening hours.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Dates and Time Zones" data-type="sect1"><div class="sect1" id="dates_and_time_zones">
<h1>Dates and Time Zones</h1>
<p><a contenteditable="false" data-primary="dates and times" data-secondary="dates and time zones" data-type="indexterm" id="ch06.html1013"/><a contenteditable="false" data-primary="time zones" data-type="indexterm" id="ch06.html1014"/>In this section, we examine in more detail how time zones influence <code>DateTime</code> and <code>DateTimeOffset</code>. We also look at the <code>TimeZoneInfo</code> type, which provides information on time zone offsets and Daylight Saving Time.</p>
<section data-pdf-bookmark="DateTime and Time Zones" data-type="sect2"><div class="sect2" id="datetime_and_time_zones">
<h2>DateTime and Time Zones</h2>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="time zones and" data-type="indexterm" id="id2795"/><a contenteditable="false" data-primary="time zones" data-secondary="DateTime and" data-type="indexterm" id="id2796"/><code>DateTime</code> is simplistic in its handling of time zones. Internally, it stores a <code>DateTime</code> using two pieces of information:</p>
<ul>
<li><p>A 62-bit number, indicating the number of ticks since 1/1/0001</p></li>
<li><p>A 2-bit enum, indicating the <code>DateTimeKind</code> (<code>Unspecified</code>, <code>Local</code>, or <code>Utc</code>)</p></li>
</ul>
<p>When you compare two <code>DateTime</code> instances, only their <em>ticks</em> values are compared; their <code>DateTimeKind</code>s are ignored:</p>
<pre data-type="programlisting">DateTime dt1 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Local);
DateTime dt2 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Utc);
Console.WriteLine (dt1 == dt2);          // True
DateTime local = DateTime.Now;
DateTime utc = local.ToUniversalTime();
Console.WriteLine (local == utc);        // False</pre>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToLocalTime" data-type="indexterm" id="id2797"/><a contenteditable="false" data-primary="To..." data-secondary="ToUniversalTime" data-type="indexterm" id="id2798"/>The instance methods <code>ToUniversalTime</code>/<code>ToLocalTime</code> convert to universal/local time. These apply the computer’s current time zone settings and return a new <code>DateTime</code> with a <code>DateTimeKind</code> of <code>Utc</code> or <code>Local</code>. No conversion happens if you call <code>ToUniversalTime</code> on a <code>DateTime</code> that’s already <code>Utc</code>, or <code>ToLocalTime</code> on a <code>DateTime</code> that’s already <code>Local</code>. You will get a conversion, however, if you call <code>ToUniversalTime</code> or <code>ToLocalTime</code> on a <code>DateTime</code> that’s <code>Unspecified</code>.</p>
<p class="pagebreak-before">You can construct a <code>DateTime</code> that differs from another only in <code>Kind</code> with the static <code>DateTime.SpecifyKind</code> method:</p>
<pre data-type="programlisting">DateTime d = new DateTime (2015, 12, 12);  // Unspecified
DateTime utc = DateTime.SpecifyKind (d, DateTimeKind.Utc);
Console.WriteLine (utc);            // 12/12/2015 12:00:00 AM</pre>
</div></section>
<section data-pdf-bookmark="DateTimeOffset and Time Zones" data-type="sect2"><div class="sect2" id="datetimeoffset_and_time_zones">
<h2>DateTimeOffset and Time Zones</h2>
<p><a contenteditable="false" data-primary="Coordinated Universal Time (UTC)" data-type="indexterm" id="id2799"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="time zones and" data-type="indexterm" id="id2800"/><a contenteditable="false" data-primary="time zones" data-secondary="DateTimeOffset and" data-type="indexterm" id="id2801"/><a contenteditable="false" data-primary="UTC (Coordinated Universal Time)" data-type="indexterm" id="id2802"/>Internally, <code>DateTimeOffset</code> comprises a <code>DateTime</code> field whose value is always in UTC, and a 16-bit integer field for the UTC offset in minutes. Comparisons look only at the (UTC) <code>DateTime</code>; the <code>Offset</code> is used primarily for formatting.</p>
<p>The <code>ToUniversalTime</code>/<code>ToLocalTime</code> methods return a <code>DateTimeOffset</code> representing the same point in time but with a UTC or local offset. Unlike with <code>DateTime</code>, these methods don’t affect the underlying date/time value, only the offset:</p>
<pre data-type="programlisting">DateTimeOffset local = DateTimeOffset.Now;
DateTimeOffset utc   = local.ToUniversalTime();

Console.WriteLine (local.Offset);   // -06:00:00 (in Central America)
Console.WriteLine (utc.Offset);     // 00:00:00

Console.WriteLine (local == utc);                 // True</pre>
<p>To include the <code>Offset</code> in the comparison, you must use the <code>EqualsExact</code> method:</p>
<pre data-type="programlisting">Console.WriteLine (local.EqualsExact (utc));      // False</pre>
</div></section>
<section data-pdf-bookmark="TimeZoneInfo" data-type="sect2"><div class="sect2" id="timezoneinfo-id00046">
<h2>TimeZoneInfo</h2>
<p><a contenteditable="false" data-primary="time zones" data-secondary="TimeZoneInfo" data-type="indexterm" id="ch06.html1015"/><a contenteditable="false" data-primary="TimeZoneInfo" data-type="indexterm" id="ch06.html1016"/>The <code>TimeZoneInfo</code> class provides information on time zone names, UTC offsets, and Daylight Saving Time rules.</p>
<section data-pdf-bookmark="TimeZone" data-type="sect3"><div class="sect3" id="timezone">
<h3>TimeZone</h3>
<p><a contenteditable="false" data-primary="TimeZone.CurrentTimeZone method" data-type="indexterm" id="id2803"/>The static <code>TimeZone.CurrentTimeZone</code> method returns a <code>TimeZone</code></p>
<pre data-type="programlisting">TimeZone zone = TimeZone.CurrentTimeZone;
Console.WriteLine (zone.StandardName);      // Pacific Standard Time
Console.WriteLine (zone.DaylightName);      // Pacific Daylight Time</pre>
<p>The <code>GetDaylightChanges</code> method returns specific Daylight Saving Time information for a given year:</p>
<pre data-type="programlisting">DaylightTime day = zone.GetDaylightChanges (2019);
Console.WriteLine (day.Start.ToString ("M"));       // 10 March
Console.WriteLine (day.End.ToString ("M"));         // 03 November
Console.WriteLine (day.Delta);                      // 01:00:00</pre>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="TimeZoneInfo" data-type="sect3"><div class="sect3" id="timezoneinfo-id00097">
<h3 class="less_space">TimeZoneInfo</h3>
<p>The static <code>TimeZoneInfo.Local</code> method returns a <code>TimeZoneInfo</code> object based on the current local settings. The following demonstrates the result if run in California:</p>
<pre data-type="programlisting">TimeZoneInfo zone = TimeZoneInfo.Local;
Console.WriteLine (zone.StandardName);      // Pacific Standard Time
Console.WriteLine (zone.DaylightName);      // Pacific Daylight Time</pre>
<p>The <code>IsDaylightSavingTime</code> and <code>GetUtcOffset</code> methods work as follows:</p>
<pre data-type="programlisting">DateTime dt1 = new DateTime (2019, 1, 1);   // DateTimeOffset works, too
DateTime dt2 = new DateTime (2019, 6, 1);
Console.WriteLine (zone.IsDaylightSavingTime (dt1));     // True
Console.WriteLine (zone.IsDaylightSavingTime (dt2));     // False
Console.WriteLine (zone.GetUtcOffset (dt1));             // -08:00:00
Console.WriteLine (zone.GetUtcOffset (dt2));             // -07:00:00</pre>
<p>You can obtain a <code>TimeZoneInfo</code> for any of the world’s time zones by calling <code>Find​Sys⁠temTimeZoneById</code> with the zone ID. We’ll switch to Western Australia for reasons that will soon become clear:</p>
<pre data-type="programlisting">TimeZoneInfo wa = TimeZoneInfo.FindSystemTimeZoneById
                  ("W. Australia Standard Time");

Console.WriteLine (wa.Id);                   // W. Australia Standard Time
Console.WriteLine (wa.DisplayName);          // (GMT+08:00) Perth
Console.WriteLine (wa.BaseUtcOffset);        // 08:00:00
Console.WriteLine (wa.SupportsDaylightSavingTime);     // True</pre>
<p>The <code>Id</code> property corresponds to the value passed to <code>FindSystemTimeZoneById</code>. The static <code>GetSystemTimeZones</code> method returns all world time zones; hence, you can list all valid zone ID strings as follows:</p>
<pre data-type="programlisting">foreach (TimeZoneInfo z in TimeZoneInfo.GetSystemTimeZones())
  Console.WriteLine (z.Id);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also create a custom time zone by calling <code>TimeZoneInfo.CreateCustomTimeZone</code>. Because <code>TimeZoneInfo</code> is immutable, you must pass in all the relevant data as method arguments.</p>
<p>You can serialize a predefined or custom time zone to a (semi) human-readable string by calling <code>ToSerializedString</code>—and deserialize it by calling <code>TimeZoneInfo.FromSerializedString</code>.</p>
</div>
<p><a contenteditable="false" data-primary="ConvertTime method" data-type="indexterm" id="id2804"/>The static <code>ConvertTime</code> method converts a <code>DateTime</code> or <code>DateTimeOffset</code> from one time zone to another. You can include either just a destination <code>TimeZoneInfo</code>, or both source and destination <code>TimeZoneInfo</code> objects. You can also convert directly from or to UTC with the methods <code>ConvertTimeFromUtc</code> and <code>ConvertTimeToUtc</code>.</p>
<p>For working with Daylight Saving Time, <code>TimeZoneInfo</code> provides the following additional methods:</p>
<ul>
<li><p><code>IsInvalidTime</code> returns <code>true</code> if a <code>DateTime</code> is within the hour (or delta) that’s skipped when the clocks move forward.</p></li>
<li><p><code>IsAmbiguousTime</code> returns <code>true</code> if a <code>DateTime</code> or <code>DateTimeOffset</code> is within the hour (or delta) that’s repeated when the clocks move back.</p></li>
<li><p><code>GetAmbiguousTimeOffsets</code> returns an array of <code>TimeSpan</code>s representing the valid offset choices for an ambiguous <code>DateTime</code> or <code>DateTimeOffset</code>.</p></li>
</ul>
<p>You can’t obtain simple dates from a <code>TimeZoneInfo</code> indicating the start and end of Daylight Saving Time. Instead, you must call <code>GetAdjustmentRules</code>, which returns a declarative summary of all daylight saving rules that apply to all years. Each rule has a <code>DateStart</code> and <code>DateEnd</code> indicating the date range within which the rule is valid:</p>
<pre data-type="programlisting">foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())
  Console.WriteLine ("Rule: applies from " + rule.DateStart +
                                    " to " + rule.DateEnd);</pre>
<p>Western Australia first introduced Daylight Saving Time in 2006, <em>midseason</em> (and then rescinded it in 2009). This required a special rule for the first year; hence, there are two rules:</p>
<pre data-type="programlisting">Rule: applies from 1/01/2006 12:00:00 AM to 31/12/2006 12:00:00 AM
Rule: applies from 1/01/2007 12:00:00 AM to 31/12/2009 12:00:00 AM</pre>
<p>Each <code>AdjustmentRule</code> has a <code>DaylightDelta</code> property of type <code>TimeSpan</code> (this is one hour in almost every case) and properties called <code>DaylightTransitionStart</code> and <code>DaylightTransitionEnd</code>. The latter two are of type <code>TimeZoneInfo.TransitionTime</code>, which has the following properties:</p>
<pre data-type="programlisting">public bool IsFixedDateRule { get; }
public DayOfWeek DayOfWeek { get; }
public int Week { get; }
public int Day { get; }
public int Month { get; }
public DateTime TimeOfDay { get; }</pre>
<p>A transition time is somewhat complicated in that it needs to represent both fixed and floating dates. An example of a floating date is “the last Sunday in March.” Here are the rules for interpreting a transition time:</p>
<ol>
<li><p>If, for an end transition, <code>IsFixedDateRule</code> is <code>true</code>, <code>Day</code> is <code>1</code>, <code>Month</code> is <code>1</code>, and <code>TimeOfDay</code> is <code>DateTime.MinValue</code>, there is no end to Daylight Saving Time in that year (this can happen only in the southern hemisphere, upon the initial introduction of daylight saving time to a region).</p></li>
<li><p>Otherwise, if <code>IsFixedDateRule</code> is <code>true</code>, the <code>Month</code>, <code>Day</code>, and <code>TimeOfDay</code> properties determine the start or end of the adjustment rule.</p></li>
<li><p>Otherwise, if <code>IsFixedDateRule</code> is <code>false</code>, the <code>Month</code>, <code>DayOfWeek</code>, <code>Week</code>, and <code>TimeOfDay</code> properties determine the start or end of the adjustment rule.</p></li>
</ol>
<p>In the last case, <code>Week</code> refers to the week of the month, with “5” meaning the last week. We can demonstrate this by enumerating the adjustment rules for our <code>wa</code> time zone:<a contenteditable="false" data-primary="" data-startref="ch06.html1016" data-type="indexterm" id="id2805"/><a contenteditable="false" data-primary="" data-startref="ch06.html1015" data-type="indexterm" id="id2806"/></p>
<pre data-type="programlisting">foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())
{
  Console.WriteLine ("Rule: applies from " + rule.DateStart +
                                    " to " + rule.DateEnd);

  Console.WriteLine ("   Delta: " + rule.DaylightDelta);

  Console.WriteLine ("   Start: " + FormatTransitionTime
                                   (rule.DaylightTransitionStart, false));

  Console.WriteLine ("   End:   " + FormatTransitionTime
                                   (rule.DaylightTransitionEnd, true));
  Console.WriteLine();
}</pre>
<p><a contenteditable="false" data-primary="FormatTransitionTime" data-type="indexterm" id="id2807"/>In <code>FormatTransitionTime</code>, we honor the rules just described:</p>
<pre data-type="programlisting">static string FormatTransitionTime (TimeZoneInfo.TransitionTime tt,
                                    bool endTime)
{
  if (endTime &amp;&amp; tt.IsFixedDateRule
              &amp;&amp; tt.Day == 1 &amp;&amp; tt.Month == 1
              &amp;&amp; tt.TimeOfDay == DateTime.MinValue)
    return "-";

  string s;
  if (tt.IsFixedDateRule)
    s = tt.Day.ToString();
  else
    s = "The " +
        "first second third fourth last".Split() [tt.Week - 1] +
        " " + tt.DayOfWeek + " in";

  return s + " " + DateTimeFormatInfo.CurrentInfo.MonthNames [tt.Month-1]
           + " at " + tt.TimeOfDay.TimeOfDay;
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Daylight Saving Time and DateTime" data-type="sect2"><div class="sect2" id="daylight_saving_time_and_datetime">
<h2>Daylight Saving Time and DateTime</h2>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="daylight saving time and" data-type="indexterm" id="id2808"/><a contenteditable="false" data-primary="daylight saving time" data-type="indexterm" id="id2809"/>If you use a <code>DateTimeOffset</code> or a UTC <code>DateTime</code>, equality comparisons are unimpeded by the effects of Daylight Saving Time. But with local <code>DateTime</code>s, daylight saving can be problematic.</p>
<p>We can summarize the rules as follows:</p>
<ul>
<li><p>Daylight saving affects local time but not UTC time.</p></li>
<li><p>When the clocks turn back, comparisons that rely on time moving forward will break if (and only if) they use local <code>DateTime</code>s.</p></li>
<li><p>You can always reliably round-trip between UTC and local times (on the same computer)—even as the clocks turn back.</p></li>
</ul>
<p><a contenteditable="false" data-primary="time zones" data-secondary="Daylight Saving Time and DateTime" data-type="indexterm" id="id2810"/>The <code>IsDaylightSavingTime</code> tells you whether a given local <code>DateTime</code> is subject to Daylight Saving Time. UTC times always return <code>false</code>:</p>
<pre data-type="programlisting">Console.Write (DateTime.Now.IsDaylightSavingTime());     // True or False
Console.Write (DateTime.UtcNow.IsDaylightSavingTime());  // Always False</pre>
<p>Assuming <code>dto</code> is a <code>DateTimeOffset</code>, the following expression does the same:</p>
<pre data-type="programlisting">dto.LocalDateTime.IsDaylightSavingTime</pre>
<p>The end of Daylight Saving Time presents a particular complication for algorithms that use local time, because when the clocks go back, the same hour (or more precisely, <code>Delta</code>) repeats itself.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="To..." data-secondary="ToUniversalTime" data-type="indexterm" id="id2811"/>You can reliably compare any two <code>DateTime</code>s by first calling <code>ToUniversalTime</code> on each. This strategy fails if (and only if) exactly one of them has a <code>DateTimeKind</code> of <code>Unspecified</code>. This potential for failure is another reason for favoring <code>DateTimeOffset</code>.<a contenteditable="false" data-primary="" data-startref="ch06.html1014" data-type="indexterm" id="id2812"/><a contenteditable="false" data-primary="" data-startref="ch06.html1013" data-type="indexterm" id="id2813"/><a contenteditable="false" data-primary="" data-startref="ch06.html109" data-type="indexterm" id="id2814"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Formatting and Parsing" data-type="sect1"><div class="sect1" id="formatting_and_parsing">
<h1>Formatting and Parsing</h1>
<p><a contenteditable="false" data-primary="formatting and parsing" data-type="indexterm" id="ch06.html1017"/>Formatting means converting <em>to</em> a string; parsing means converting <em>from</em> a string. The need to format or parse arises frequently in programming, in a variety of situations. Hence, .NET provides a variety of mechanisms:</p>
<dl>
<dt><code>ToString</code> and <code>Parse</code></dt>
<dd>These methods provide default functionality for many types.</dd>
<dt>Format providers</dt>
<dd>These manifest as additional <code>ToString</code> (and <code>Parse</code>) methods that accept a <em>format string</em> and/or a <em>format provider</em>. Format providers are highly flexible and culture-aware. .NET includes format providers for the numeric types and <code>DateTime</code>/<code>DateTimeOffset</code>.</dd>
<dt><code>XmlConvert</code></dt>
<dd>This is a static class with methods that format and parse while honoring XML standards. <code>XmlConvert</code> is also useful for general-purpose conversion when you need culture independence or you want to preempt misparsing. <code>XmlConvert</code> supports the numeric types, <code>bool</code>, <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code>, and <code>Guid</code>.</dd>
<dt>Type converters</dt>
<dd>These target designers and XAML parsers.</dd>
</dl>
<p>In this section, we discuss the first two mechanisms, focusing particularly on format providers. We then describe <code>XmlConvert</code>, type converters, and other conversion mechanisms.</p>
<section data-pdf-bookmark="ToString and Parse" data-type="sect2"><div class="sect2" id="tostring_and_parse">
<h2>ToString and Parse</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="ToString and Parse methods" data-type="indexterm" id="id2815"/><a contenteditable="false" data-primary="Parse method" data-type="indexterm" id="id2816"/><a contenteditable="false" data-primary="To..." data-secondary="ToString method" data-type="indexterm" id="id2817"/>The simplest formatting mechanism is the <code>ToString</code> method. It gives meaningful output on all simple value types (<code>bool</code>, <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code>, <code>Guid</code>, and all the numeric types). For the reverse operation, each of these types defines a static <code>Parse</code> method:</p>
<pre data-type="programlisting">string s = true.ToString();     // s = "True"
bool b = bool.Parse (s);        // b = true</pre>
<p><a contenteditable="false" data-primary="TryParse" data-type="indexterm" id="id2818"/>If the parsing fails, a <code>FormatException</code> is thrown. Many types also define a <code>TryParse</code> method, which returns <code>false</code> if the conversion fails rather than throwing an exception:</p>
<pre data-type="programlisting">bool failure = int.TryParse ("qwerty", out int i1);
bool success = int.TryParse ("123", out int i2);</pre>
<p>If you don’t care about the output and want to test only whether parsing would succeed, you can use a discard:</p>
<pre data-type="programlisting">bool success = int.TryParse ("123", out int _);</pre>
<p>If you anticipate an error, calling <code>TryParse</code> is faster and more elegant than calling <code>Parse</code> in an exception handling block.</p>
<p>The <code>Parse</code> and <code>TryParse</code> methods on <code>DateTime</code>(<code>Offset</code>) and the numeric types respect local culture settings; you can change this by specifying a <code>CultureInfo</code> object. Specifying invariant culture is often a good idea. For instance, parsing “1.234” into a <code>double</code> gives us 1234 in Germany:</p>
<pre data-type="programlisting">Console.WriteLine (double.Parse ("1.234"));   // 1234  (In Germany)</pre>
<p>This is because in Germany, the period indicates a thousands separator rather than a decimal point. Specifying <em>invariant culture</em> fixes this:</p>
<pre data-type="programlisting">double x = double.Parse ("1.234", <strong>CultureInfo.InvariantCulture</strong>);</pre>
<p>The same applies when calling <code>ToString()</code>:</p>
<pre data-type="programlisting">string x = 1.234.ToString (CultureInfo.InvariantCulture);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From .NET 8, the .NET numeric and date/time types (as well as other simple types) allow direct formatting and parsing of UTF-8, via new <code>TryFormat</code> and <code>Parse</code>/<code>TryParse</code> methods that operate on a byte array or <code>Span&lt;byte&gt;</code> (see <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>). In high-performance scenarios, this can be more efficient than working with ordinary (UTF-16) strings and performing a separate UTF-8 encoding/decoding.</p>
</div>
</div></section>
<section data-pdf-bookmark="Format Providers" data-type="sect2"><div class="sect2" id="format_providers">
<h2>Format Providers</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="format providers" data-type="indexterm" id="ch06.html1018"/>Sometimes, you need more control over how formatting and parsing take place. There are dozens of ways to format a <code>DateTime(Offset)</code>, for instance. Format providers allow extensive control over formatting and parsing, and are supported for numeric types and date/times. Format providers are also used by user interface controls for formatting and parsing.</p>
<p><a contenteditable="false" data-primary="IFormattable" data-type="indexterm" id="id2819"/>The gateway to using a format provider is <code>IFormattable</code>. All numeric types—and <code>DateTime(Offset)</code>—implement this interface:</p>
<pre data-type="programlisting">public interface IFormattable
{
  string ToString (string format, IFormatProvider formatProvider);
}</pre>
<p>The first argument is the <em>format string</em>; the second is the <em>format provider</em>. The format string provides instructions; the format provider determines how the instructions are translated. For example:</p>
<pre data-type="programlisting">NumberFormatInfo f = new NumberFormatInfo();
f.CurrencySymbol = "$$";
Console.WriteLine (3.ToString ("C", f));          // $$ 3.00</pre>
<p>Here, <code>"C"</code> is a format string that indicates <em>currency</em>, and the <code>NumberFormatInfo</code> object is a format provider that determines how currency—and other numeric representations—are rendered. This mechanism allows for globalization.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All format strings for numbers and dates are listed in <a data-type="xref" href="#standard_format_strings_and_parsing_fla">“Standard Format Strings and Parsing Flags”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="CultureInfo.CurrentCulture" data-type="indexterm" id="id2820"/>If you specify a <code>null</code> format string or provider, a default is applied. The default format provider is <code>CultureInfo.CurrentCulture</code>, which, unless reassigned, reflects the computer’s runtime control panel settings. For example, on this computer:</p>
<pre data-type="programlisting">Console.WriteLine (10.3.ToString ("C", null));  // $10.30</pre>
<p>For convenience, most types overload <code>ToString</code> such that you can omit a <code>null</code> provider:</p>
<pre data-type="programlisting">Console.WriteLine (10.3.ToString ("C"));     // $10.30
Console.WriteLine (10.3.ToString ("F4"));    // 10.3000 (Fix to 4 D.P.)</pre>
<p>Calling <code>ToString</code> on a <code>DateTime</code>(<code>Offset</code>) or a numeric type with no arguments is equivalent to using a default format provider, with an empty format string.</p>
<p>.NET defines three format providers (all of which implement <code>IFormatProvider</code>):</p>
<pre data-type="programlisting">NumberFormatInfo
DateTimeFormatInfo
CultureInfo</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All <code>enum</code> types are also formattable, though there’s no special <code>IFormatProvider</code> class.</p>
</div>
<section data-pdf-bookmark="Format providers and CultureInfo" data-type="sect3"><div class="sect3" id="format_providers_and_cultureinfo">
<h3>Format providers and CultureInfo</h3>
<p><a contenteditable="false" data-primary="CultureInfo" data-type="indexterm" id="id2821"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="format providers and CultureInfo" data-type="indexterm" id="id2822"/>Within the context of format providers, <code>CultureInfo</code> acts as an indirection mechanism for the other two format providers, returning a <code>NumberFormatInfo</code> or <code>Date​Ti⁠meFormatInfo</code> object applicable to the culture’s regional settings.</p>
<p>In the following example, we request a specific culture (<em>en</em>glish language in <em>G</em>reat <em>B</em>ritain):</p>
<pre data-type="programlisting">CultureInfo uk = CultureInfo.GetCultureInfo ("en-GB");
Console.WriteLine (3.ToString ("C", uk));      // £3.00</pre>
<p>This executes using the default <code>NumberFormatInfo</code> object applicable to the en-GB culture.</p>
<p>The next example formats a <code>DateTime</code> with invariant culture. Invariant culture is always the same, regardless of the computer’s settings:</p>
<pre data-type="programlisting">DateTime dt = new DateTime (2000, 1, 2);
CultureInfo iv = CultureInfo.InvariantCulture;
Console.WriteLine (dt.ToString (iv));            // 01/02/2000 00:00:00
Console.WriteLine (dt.ToString ("d", iv));       // 01/02/2000</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Invariant culture is based on American culture, with the following differences:</p>
<ul>
<li><p>The currency symbol is ☼ instead of $.</p></li>
<li><p>Dates and times are formatted with leading zeros (though still with the month first).</p></li>
<li><p>Time uses the 24-hour format rather than an AM/PM designator.</p></li>
</ul>
</div>
</div></section>
<section data-pdf-bookmark="Using NumberFormatInfo or DateTimeFormatInfo" data-type="sect3"><div class="sect3" id="using_numberformatinfo_or_datetimeforma">
<h3>Using NumberFormatInfo or DateTimeFormatInfo</h3>
<p><a contenteditable="false" data-primary="DateTimeFormatInfo" data-type="indexterm" id="id2823"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="DateTimeFormatInfo" data-type="indexterm" id="id2824"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="NumberFormatInfo" data-type="indexterm" id="id2825"/><a contenteditable="false" data-primary="NumberFormatInfo" data-type="indexterm" id="id2826"/>In the next example, we instantiate a <code>NumberFormatInfo</code> and change the group separator from a comma to a space. We then use it to format a number to three decimal places:</p>
<pre data-type="programlisting">NumberFormatInfo f = new NumberFormatInfo ();
f.NumberGroupSeparator = " ";
Console.WriteLine (12345.6789.ToString ("N3", f));   // 12 345.679</pre>
<p>The initial settings for a <code>NumberFormatInfo</code> or <code>DateTimeFormatInfo</code> are based on the invariant culture. Sometimes, however, it’s more useful to choose a different starting point. To do this, you can <code>Clone</code> an existing format provider:</p>
<pre data-type="programlisting">NumberFormatInfo f = (NumberFormatInfo)
                      CultureInfo.CurrentCulture.NumberFormat.Clone();</pre>
<p>A cloned format provider is always writable—even if the original was read-only.</p>
</div></section>
<section data-pdf-bookmark="Composite formatting" data-type="sect3"><div class="sect3" id="composite_formatting">
<h3>Composite formatting</h3>
<p><a contenteditable="false" data-primary="composite formatting" data-type="indexterm" id="id2827"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="composite formatting" data-type="indexterm" id="id2828"/>Composite format strings allow you to combine variable substitution with format strings. <a contenteditable="false" data-primary="String..." data-secondary="string.Format" data-type="indexterm" id="id2829"/>The static <code>string.Format</code> method accepts a composite format string (we illustrated this in <a data-type="xref" href="#stringdotformat_and_composite_format_st">“String.Format and composite format strings”</a>):</p>
<pre data-type="programlisting">string composite = "Credit=<strong>{0:C}</strong>";
Console.WriteLine (string.Format (composite, 500));   // Credit=$500.00</pre>
<p><a contenteditable="false" data-primary="Console class" data-type="indexterm" id="id2830"/>The <code>Console</code> class itself overloads its <code>Write</code> and <code>WriteLine</code> methods to accept composite format strings, allowing us to shorten this example slightly:</p>
<pre data-type="programlisting">Console.WriteLine ("Credit={0:C}", 500);   // Credit=$500.00</pre>
<p>You can also append a composite format string to a <code>StringBuilder</code> (via <code>AppendFormat</code>), and to a <code>TextWriter</code> for I/O (see <a data-type="xref" href="ch15.html#streams_and_isoliduso">Chapter 15</a>).</p>
<p><code>string.Format</code> accepts an optional format provider. A simple application for this is to call <code>ToString</code> on an arbitrary object while passing in a format provider:</p>
<pre data-type="programlisting">string s = string.Format (CultureInfo.InvariantCulture, "{0}", someObject);</pre>
<p>This is equivalent to the following:</p>
<pre data-type="programlisting">string s;
if (someObject is IFormattable)
  s = ((IFormattable)someObject).ToString (null,
                                           CultureInfo.InvariantCulture);
else if (someObject == null)
  s = "";
else
  s = someObject.ToString();</pre>
</div></section>
<section data-pdf-bookmark="Parsing with format providers" data-type="sect3"><div class="sect3" id="parsing_with_format_providers">
<h3>Parsing with format providers</h3>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="parsing with format providers" data-type="indexterm" id="id2831"/>There’s no standard interface for parsing through a format provider. Instead, each participating type overloads its static <code>Parse</code> (and <code>TryParse</code>) method to accept a format provider, and optionally, a <code>NumberStyles</code> or <code>DateTimeStyles</code> enum.</p>
<p><a contenteditable="false" data-primary="NumberStyles" data-type="indexterm" id="id2832"/><code>NumberStyles</code> and <code>DateTimeStyles</code> control how parsing works: they let you specify such things as whether parentheses or a currency symbol can appear in the input string. (By default, the answer to both questions is <em>no</em>.) For example:</p>
<pre data-type="programlisting">int error = int.Parse ("(2)");   // Exception thrown

int minusTwo = int.Parse ("(2)", NumberStyles.Integer |
                                 NumberStyles.AllowParentheses);   // OK

decimal fivePointTwo = decimal.Parse ("£5.20", NumberStyles.Currency,
                       CultureInfo.GetCultureInfo ("en-GB"));</pre>
<p>The next section lists all <code>NumberStyles</code> and <code>DateTimeStyles</code> members as well as the default parsing rules for each type.</p>
</div></section>
<section data-pdf-bookmark="IFormatProvider and ICustomFormatter" data-type="sect3"><div class="sect3" id="iformatprovider_and_icustomformatter">
<h3>IFormatProvider and ICustomFormatter</h3>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="IFormatProvider and ICustomFormatter" data-type="indexterm" id="id2833"/><a contenteditable="false" data-primary="IFormatProvider" data-type="indexterm" id="id2834"/>All format providers implement <code>IFormatProvider</code>:</p>
<pre data-type="programlisting">public interface IFormatProvider { object GetFormat (Type formatType); }</pre>
<p>The purpose of this method is to provide indirection—this is what allows <code>CultureInfo</code> to defer to an appropriate <code>NumberFormatInfo</code> or <code>DateTimeFormatInfo</code> object to do the work.</p>
<p>By implementing <code>IFormatProvider</code>—along with <code>ICustomFormatter</code>—you can also write your own format provider that works in conjunction with existing types. <a contenteditable="false" data-primary="ICustomFormatter" data-type="indexterm" id="id2835"/><code>ICustomFormatter</code> defines a single method, as follows:</p>
<pre data-type="programlisting">string Format (string format, object arg, IFormatProvider formatProvider);</pre>
<p>The following custom format provider writes numbers as words:</p>
<pre data-type="programlisting">public class WordyFormatProvider : IFormatProvider, ICustomFormatter
{
  static readonly string[] _numberWords =
   "zero one two three four five six seven eight nine minus point".Split();

  IFormatProvider _parent;   // Allows consumers to chain format providers

  public WordyFormatProvider () : this (CultureInfo.CurrentCulture) { }
  public WordyFormatProvider (IFormatProvider parent) =&gt; _parent = parent;

  public object GetFormat (Type formatType)
  {
    if (formatType == typeof (ICustomFormatter)) return this;
    return null;
  }

  public string Format (string format, object arg, IFormatProvider prov)
  {
    // If it's not our format string, defer to the parent provider:
    if (arg == null || format != "W")
      return string.Format (_parent, "{0:" + format + "}", arg);

    StringBuilder result = new StringBuilder();
    string digitList = string.Format (CultureInfo.InvariantCulture,
                                      "{0}", arg);
    foreach (char digit in digitList)
    {
      int i = "0123456789-.".IndexOf (digit,
                                      StringComparison.InvariantCulture);
      if (i == -1) continue;
      if (result.Length &gt; 0) result.Append (' ');
      result.Append (_numberWords[i]);
    }
    return result.ToString();
  }
}</pre>
<p>Notice that in the <code>Format</code> method, we used <code>string.Format</code>—with <code>InvariantCulture</code>—to convert the input number to a string. It would have been simpler just to call <code>ToString()</code> on <code>arg</code>, but then <code>CurrentCulture</code> would have been used, instead. The reason for needing the invariant culture is evident a few lines later:</p>
<pre data-type="programlisting">int i = "0123456789-.".IndexOf (digit, StringComparison.InvariantCulture);</pre>
<p>It’s critical here that the number string comprises only the characters <code>0123456789-.</code> and not any internationalized versions of these.</p>
<p>Here’s an example of using <code>WordyFormatProvider</code>:</p>
<pre data-type="programlisting">double n = -123.45;
IFormatProvider fp = new WordyFormatProvider();
Console.WriteLine (string.Format (fp, "{0:C} in words is {0:W}", n));

// -$123.45 in words is minus one two three point four five</pre>
<p>You can use custom format providers only in composite format strings.<a contenteditable="false" data-primary="" data-startref="ch06.html1018" data-type="indexterm" id="id2836"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Standard Format Strings and Parsing Flags" data-type="sect1"><div class="sect1" id="standard_format_strings_and_parsing_fla">
<h1>Standard Format Strings and Parsing Flags</h1>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="standard format strings and parsing flags" data-type="indexterm" id="ch06.html1019"/>The standard format strings control how a numeric type or <code>DateTime</code>/<code>DateTimeOffset</code> is converted to a string. There are two kinds of format strings:</p>
<dl>
<dt>Standard format strings</dt>
<dd>With these, you provide general guidance. A standard format string consists of a single letter, followed, optionally, by a digit (whose meaning depends on the letter). An example is <code>"C"</code> or <code>"F2"</code>.</dd>
<dt>Custom format strings</dt>
<dd>With these, you micromanage every character with a template. An example is <code>"0:#.000E+00"</code>.</dd>
</dl>
<p>Custom format strings are unrelated to custom format providers.</p>
<section data-pdf-bookmark="Numeric Format Strings" data-type="sect2"><div class="sect2" id="numeric_format_strings">
<h2>Numeric Format Strings</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="numeric format strings" data-type="indexterm" id="id2837"/><a contenteditable="false" data-primary="numeric format strings" data-type="indexterm" id="id2838"/><a data-type="xref" href="#standard_numeric_format_strings">Table 6-2</a> lists all standard numeric format strings.</p>
<table class="border" id="standard_numeric_format_strings">
<caption><span class="label">Table 6-2. </span>Standard numeric format strings</caption>
<thead>
<tr>
<th>Letter</th>
<th>Meaning</th>
<th>Sample input</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>G</code> or <code>g</code></td>
<td>“General”</td>
<td><code>1.2345, "G"</code><br/><code>0.00001, "G"</code><br/><code>0.00001, "g"</code><br/><code>1.2345, "G3"</code><br/><code>12345, "G3"</code></td>
<td><code>1.2345</code><br/><code>1E-05</code><br/><code>1e-05</code><br/><code>1.23</code><br/><code>1.23E04</code></td>
<td>Switches to exponential notation for small or large numbers.<br/><code>G3</code> limits precision to three digits in <em>total</em> (before + after point).</td>
</tr>
<tr>
<td><code>F</code></td>
<td>Fixed point</td>
<td><code>2345.678, "F2"</code><br/><code>2345.6, "F2"</code></td>
<td><code>2345.68</code><br/><code>2345.60</code></td>
<td><code>F2</code> rounds to two decimal places.</td>
</tr>
<tr>
<td><code>N</code></td>
<td>Fixed point with <em>group separator</em> (“Numeric”)</td>
<td><code>2345.678, "N2"</code><br/><code>2345.6, "N2"</code></td>
<td><code>2,345.68</code><br/><code>2,345.60</code></td>
<td>As above, with group (1,000s) separator (details from format provider).</td>
</tr>
<tr>
<td><code>D</code></td>
<td>Pad with leading zeros</td>
<td><code>123, "D5"</code><br/><code>123, "D1"</code></td>
<td><code>00123</code><br/><code>123</code></td>
<td>For integral types only.<br/><code>D5</code> pads left to five digits; does not truncate.</td>
</tr>
<tr>
<td><code>E</code> or <code>e</code></td>
<td>Force exponential notation</td>
<td><code>56789, "E"</code><br/><code>56789, "e"</code><br/><code>56789, "E2"</code></td>
<td><code>5.678900E+004</code><br/><code>5.678900e+004</code><br/><code>5.68E+004</code></td>
<td>Six-digit default precision.</td>
</tr>
<tr>
<td><code>C</code></td>
<td>Currency</td>
<td><code>1.2, "C"</code><br/><code>1.2, "C4"</code></td>
<td><code>$1.20</code><br/><code>$1.2000</code></td>
<td><code>C</code> with no digit uses default number of D.P. from format provider.</td>
</tr>
<tr>
<td><code>P</code></td>
<td>Percent</td>
<td><code>.503, "P"</code><br/><code>.503, "P0"</code></td>
<td><code>50.30%</code><br/><code>50%</code></td>
<td>Uses symbol and layout from format provider.<br/>Decimal places can optionally be overridden.</td>
</tr>
<tr>
<td><code>X</code> or <code>x</code></td>
<td>Hexadecimal</td>
<td><code>47, "X"</code><br/><code>47, "x"</code><br/><code>47, "X4"</code></td>
<td><code>2F</code><br/><code>2f</code><br/><code>002F</code></td>
<td><code>X</code> for uppercase hex digits; <code>x</code> for lowercase hex digits.<br/>Integrals only.</td>
</tr>
<tr>
<td><code>R</code> or <code>G9/G17</code></td>
<td>Round-trip</td>
<td><code>1f / 3f, "R"</code></td>
<td><code>0.3333333<strong>43</strong></code></td>
<td>Use <code>R</code> for <code>BigInteger</code>, <code>G17</code> for <code>double</code>, or <code>G9</code> for <code>float</code>.</td>
</tr>
</tbody>
</table>
<p>Supplying no numeric format string (or a null or blank string) is equivalent to using the <code>"G"</code> standard format string followed by no digit. This exhibits the following behavior:</p>
<ul>
<li><p>Numbers smaller than 10<sup>−4</sup> or larger than the type’s precision are expressed in exponential (scientific) notation.</p></li>
<li><p>The two decimal places at the limit of <code>float</code> or <code>double</code>’s precision are rounded away to mask the inaccuracies inherent in conversion to decimal from their underlying binary form.</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The automatic rounding just described is usually beneficial and goes unnoticed. However, it can cause trouble if you need to round-trip a number—in other words, convert it to a string and back again (maybe repeatedly) while preserving value equality. For this reason, the <code>R</code>,<code> G17</code>, and <code>G9</code> format strings exist to circumvent this implicit rounding.</p>
</div>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="custom numeric format strings" data-type="indexterm" id="id2839"/><a data-type="xref" href="#custom_numeric_format_strings">Table 6-3</a> lists custom numeric format strings.</p>
<table class="border" id="custom_numeric_format_strings">
<caption><span class="label">Table 6-3. </span>Custom numeric format strings</caption>
<thead>
<tr>
<th>Specifier</th>
<th>Meaning</th>
<th>Sample input</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#</code></td>
<td>Digit placeholder</td>
<td><code>12.345, ".##"</code><br/><code>12.345, ".####"</code></td>
<td><code>12.35</code><br/><code>12.345</code></td>
<td>Limits digits after D.P.</td>
</tr>
<tr>
<td><code>0</code></td>
<td>Zero placeholder</td>
<td><code>12.345, ".00"</code><br/><code>12.345, ".0000"</code><br/><code>99, "000.00"</code></td>
<td><code>12.35</code><br/><code>12.3450</code><br/><code>099.00</code></td>
<td>As above, but also pads with zeros before and after D.P.</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Decimal point</td>
<td/>
<td/>
<td>Indicates D.P.<br/>Actual symbol comes from <code>NumberFormatInfo</code>.</td>
</tr>
<tr>
<td><code>,</code></td>
<td>Group separator</td>
<td><code>1234, "#,###,###"</code><br/><code>1234, "0,000,000"</code></td>
<td><code>1,234</code><br/><code>0,001,234</code></td>
<td>Symbol comes from <code>NumberFormatInfo</code>.</td>
</tr>
<tr>
<td><code>,</code><br/>(as above)</td>
<td>Multiplier</td>
<td><code>1000000, "#,"</code><br/><code>1000000, "#,,</code></td>
<td><code>1000</code><br/><code>1</code></td>
<td>If comma is at end or before D.P., it acts as a multiplier—dividing result by 1,000, 1,000,000, etc.</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Percent notation</td>
<td><code>0.6, "00%"</code></td>
<td><code>60%</code></td>
<td>First multiplies by 100 and then substitutes percent symbol obtained from <code>NumberFormatInfo</code>.</td>
</tr>
<tr>
<td><code>E0, e0, E+0, e+0 E-0, e-0</code></td>
<td>Exponent notation</td>
<td><code>1234, "0E0"</code><br/><code>1234, "0E+0"</code><br/><code>1234, "0.00E00"</code><br/><code>1234, "0.00e00"</code></td>
<td><code>1E3</code><br/><code>1E+3</code><br/><code>1.23E03</code><br/><code>1.23e03</code></td>
<td/>
</tr>
<tr>
<td><code>\</code></td>
<td>Literal character quote</td>
<td><code>50, @"\#0"</code></td>
<td><code>#50</code></td>
<td>Use in conjunction with an <code>@</code> prefix on the string—or use <code>\\</code></td>
</tr>
<tr>
<td><code>'xx''xx'</code></td>
<td>Literal string quote</td>
<td><code>50, "0 '...'"</code></td>
<td><code>50 ...</code></td>
<td/>
</tr>
<tr>
<td><code>;</code></td>
<td>Section separator</td>
<td><code>15, "#;(#);zero"</code></td>
<td><code>15</code></td>
<td>(If positive)</td>
</tr>
<tr>
<td/>
<td/>
<td><code>-5, "#;(#);zero"</code></td>
<td><code>(5)</code></td>
<td>(If negative)</td>
</tr>
<tr>
<td/>
<td/>
<td><code>0, "#;(#);zero"</code></td>
<td><code>zero</code></td>
<td>(If zero)</td>
</tr>
<tr>
<td>Any other char</td>
<td>Literal</td>
<td><code>35.2, "$0 . 00c"</code></td>
<td><code>$35 . 20c</code></td>
<td/>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="NumberStyles" data-type="sect2"><div class="sect2" id="numberstyles">
<h2>NumberStyles</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="NumberStyles" data-type="indexterm" id="id2840"/><a contenteditable="false" data-primary="NumberStyles" data-type="indexterm" id="id2841"/>Each numeric type defines a static <code>Parse</code> method that accepts a <code>NumberStyles</code> argument. <code>NumberStyles</code> is a flags enum that lets you determine how the string is read as it’s converted to a numeric type. It has the following combinable members:</p>
<pre data-type="programlisting">AllowLeadingWhite    AllowTrailingWhite
AllowLeadingSign     AllowTrailingSign
AllowParentheses     AllowDecimalPoint
AllowThousands       AllowExponent
AllowCurrencySymbol  AllowHexSpecifier</pre>
<p><code>NumberStyles</code> also defines these composite members:</p>
<pre data-type="programlisting">None  Integer  Float  Number  HexNumber  Currency  Any</pre>
<p>Except for <code>None</code>, all composite values include <code>AllowLeadingWhite</code> and <code>Allow​Trai⁠lingWhite</code>. <a data-type="xref" href="#composite_numberstyles">Figure 6-1</a> shows their remaining makeup, with the most useful three emphasized.</p>
<figure><div class="figure" id="composite_numberstyles">
<img alt="Composite NumberStyles" src="assets/cn10_0601.png"/>
<h6><span class="label">Figure 6-1. </span>Composite NumberStyles</h6>
</div></figure>
<p>When you call <code>Parse</code> without specifying any flags, the defaults illustrated in <a data-type="xref" href="#default_parsing_flags_for_numeric_types">Figure 6-2</a> are applied.</p>
<figure><div class="figure" id="default_parsing_flags_for_numeric_types">
<img alt="Default parsing flags for numeric types" src="assets/cn10_0602.png"/>
<h6><span class="label">Figure 6-2. </span>Default parsing flags for numeric types</h6>
</div></figure>
<p>If you don’t want the defaults shown in <a data-type="xref" href="#default_parsing_flags_for_numeric_types">Figure 6-2</a>, you must explicitly specify <code>NumberStyles</code>:</p>
<pre data-type="programlisting">int thousand = int.Parse ("3E8", NumberStyles.HexNumber);
int minusTwo = int.Parse ("(2)", NumberStyles.Integer |
                                 NumberStyles.AllowParentheses);
double aMillion = double.Parse ("1,000,000", NumberStyles.Any);
decimal threeMillion = decimal.Parse ("3e6", NumberStyles.Any);
decimal fivePointTwo = decimal.Parse ("$5.20", NumberStyles.Currency);</pre>
<p>Because we didn’t specify a format provider, this example works with your local currency symbol, group separator, decimal point, and so on. The next example is hardcoded to work with the euro sign and a blank group separator for currencies:</p>
<pre data-type="programlisting">NumberFormatInfo ni = new NumberFormatInfo();
ni.CurrencySymbol = "€";
ni.CurrencyGroupSeparator = " ";
double million = double.Parse ("€1 000 000", NumberStyles.Currency, ni);</pre>
</div></section>
<section data-pdf-bookmark="Date/Time Format Strings" data-type="sect2"><div class="sect2" id="datesolidustime_format_strings">
<h2>Date/Time Format Strings</h2>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="format strings" data-type="indexterm" id="ch06.html1020"/><a contenteditable="false" data-primary="DateTimeOffset" data-secondary="format strings" data-type="indexterm" id="ch06.html1021"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="Date/Time format strings" data-type="indexterm" id="ch06.html1022"/>Format strings for <code>DateTime</code>/<code>DateTimeOffset</code> can be divided into two groups based on whether they honor culture and format provider settings. <a data-type="xref" href="#culture_sensitive_datesolidustime_forma">Table 6-4</a> lists those that do; <a data-type="xref" href="#culture_insensitive_datesolidustime_for">Table 6-5</a> lists those that don’t. The sample output comes from formatting the following <code>DateTime</code> (with <em>invariant culture</em>, in the case of <a data-type="xref" href="#culture_sensitive_datesolidustime_forma">Table 6-4</a>):</p>
<pre data-type="programlisting">new DateTime (2000, 1, 2,  17, 18, 19);</pre>
<table class="border" id="culture_sensitive_datesolidustime_forma">
<caption><span class="label">Table 6-4. </span>Culture-sensitive date/time format strings</caption>
<thead>
<tr>
<th><strong>Format string</strong></th>
<th><strong>Meaning</strong></th>
<th><strong>Sample output</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code></td>
<td>Short date</td>
<td><code>01/02/2000</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>Long date</td>
<td><code>Sunday, 02 January 2000</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td>Short time</td>
<td><code>17:18</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td>Long time</td>
<td><code>17:18:19</code></td>
</tr>
<tr>
<td><code>f</code></td>
<td>Long date + short time</td>
<td><code>Sunday, 02 January 2000 17:18</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td>Long date + long time</td>
<td><code>Sunday, 02 January 2000 17:18:19</code></td>
</tr>
<tr>
<td><code>g</code></td>
<td>Short date + short time</td>
<td><code>01/02/2000 17:18</code></td>
</tr>
<tr>
<td><code>G</code> (default)</td>
<td>Short date + long time</td>
<td><code>01/02/2000 17:18:19</code></td>
</tr>
<tr>
<td><code>m, M</code></td>
<td>Month and day</td>
<td><code>02 January</code></td>
</tr>
<tr>
<td><code>y, Y</code></td>
<td>Year and month</td>
<td><code>January 2000</code></td>
</tr>
</tbody>
</table>
<table class="border" id="culture_insensitive_datesolidustime_for">
<caption><span class="label">Table 6-5. </span>Culture-insensitive date/time format strings</caption>
<thead>
<tr>
<th>Format string</th>
<th>Meaning</th>
<th>Sample output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>o</code></td>
<td>Round-trippable</td>
<td><code>2000-01-02T17:18:19.0000000</code></td>
<td>Will append time zone information unless <span class="keep-together"><code>DateTimeKind</code></span> is <span class="keep-together"><code>Unspecified</code></span></td>
</tr>
<tr>
<td><code>r</code>, <code>R</code></td>
<td>RFC 1123 standard</td>
<td><code>Sun, 02 Jan 2000 17:18:19 GMT</code></td>
<td>You must explicitly convert to UTC with <span class="keep-together"><code>DateTime.ToUniversalTime</code></span></td>
</tr>
<tr>
<td><code>s</code></td>
<td>Sortable; ISO 8601</td>
<td><code>2000-01-02T17:18:19</code></td>
<td>Compatible with text-based sorting</td>
</tr>
<tr>
<td><code>u</code></td>
<td>“Universal” sortable</td>
<td><code>2000-01-02 17:18:19Z</code></td>
<td>Similar to above; must explicitly convert to UTC</td>
</tr>
<tr>
<td><code>U</code></td>
<td>UTC</td>
<td><code>Sunday, 02 January 2000 17:18:19</code></td>
<td>Long date + short time, converted to UTC</td>
</tr>
</tbody>
</table>
<p>The format strings <code>"r"</code>, <code>"R"</code>, and <code>"u"</code> emit a suffix that implies UTC; yet they don’t automatically convert a local to a UTC <code>DateTime</code> (so you must do the conversion yourself). Ironically, <code>"U"</code> automatically converts to UTC, but doesn’t write a time zone suffix! In fact, <code>"o"</code> is the only format specifier in the group that can write an unambiguous <code>DateTime</code> without intervention.</p>
<p><code>DateTimeFormatInfo</code> also supports custom format strings: these are analogous to numeric custom format strings. The list is extensive and is available online in Microsoft’s documentation. Here’s an example of a custom format string:</p>
<pre data-type="programlisting">yyyy-MM-dd HH:mm:ss</pre>
<section data-pdf-bookmark="Parsing and misparsing DateTimes" data-type="sect3"><div class="sect3" id="parsing_and_misparsing_datetimes">
<h3>Parsing and misparsing DateTimes</h3>
<p><a contenteditable="false" data-primary="DateTime" data-secondary="parsing/misparsing" data-type="indexterm" id="id2842"/>Strings that put the month or day first are ambiguous and can easily be misparsed—particularly if you have global customers. This is not a problem in user interface controls, because the same settings are in force when parsing as when formatting. But when writing to a file, for instance, day/month misparsing can be a real problem. There are two solutions:</p>
<ul>
<li><p>Always state the same explicit culture when formatting and parsing (e.g., invariant culture).</p></li>
<li><p>Format <code>DateTime</code> and <code>DateTimeOffset</code>s in a manner <em>independent</em> of culture.</p></li>
</ul>
<p>The second approach is more robust—particularly if you choose a format that puts the four-digit year first: such strings are much more difficult to misparse by another party. Further, strings formatted with a <em>standards-compliant</em> year-first format (such as <code>"o"</code>) can parse correctly alongside locally formatted strings—rather like a “universal donor.” (Dates formatted with <code>"s"</code> or <code>"u"</code> have the further benefit of being sortable.)</p>
<p>To illustrate, suppose that we generate a culture-insensitive <code>DateTime</code> string <code>s</code> as follows:</p>
<pre data-type="programlisting">string s = DateTime.Now.ToString ("o");</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>"o"</code> format string includes milliseconds in the output. The following custom format string gives the same result as <code>"o"</code>, but without milliseconds:</p>
<pre data-type="programlisting">yyyy-MM-ddTHH:mm:ss K</pre>
</div>
<p>We can reparse this in two ways. <code>ParseExact</code> demands strict compliance with the specified format string:</p>
<pre data-type="programlisting">DateTime dt1 = DateTime.ParseExact (s, "o", null);</pre>
<p>(You can achieve a similar result with <code>XmlConvert</code>’s <code>ToString</code> and <code>ToDateTime</code> methods.)</p>
<p><code>Parse</code>, however, implicitly accepts both the <code>"o"</code> format and the <code>CurrentCulture</code> format:</p>
<pre data-type="programlisting">DateTime dt2 = DateTime.Parse (s);</pre>
<p>This works with both <code>DateTime</code> and <code>DateTimeOffset</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>ParseExact</code> is usually preferable if you know the format of the string that you’re parsing. It means that if the string is incorrectly formatted, an exception will be thrown—which is usually better than risking a misparsed date<a contenteditable="false" data-primary="" data-startref="ch06.html1022" data-type="indexterm" id="id2843"/><a contenteditable="false" data-primary="" data-startref="ch06.html1021" data-type="indexterm" id="id2844"/><a contenteditable="false" data-primary="" data-startref="ch06.html1020" data-type="indexterm" id="id2845"/>.</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="DateTimeStyles" data-type="sect2"><div class="sect2" id="datetimestyles">
<h2>DateTimeStyles</h2>
<p><a contenteditable="false" data-primary="DateTimeStyles" data-type="indexterm" id="id2846"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="DateTimeStyles" data-type="indexterm" id="id2847"/><code>DateTimeStyles</code> is a flags enum that provides additional instructions when calling <code>Parse</code> on a <code>DateTime</code>(<code>Offset</code>). Here are its members:</p>
<pre data-type="programlisting">None,
AllowLeadingWhite, AllowTrailingWhite, AllowInnerWhite,
AssumeLocal, AssumeUniversal, AdjustToUniversal,
NoCurrentDateDefault, RoundTripKind</pre>
<p>There is also a composite member, <code>AllowWhiteSpaces</code>:</p>
<pre data-type="programlisting">AllowWhiteSpaces = AllowLeadingWhite | AllowTrailingWhite | AllowInnerWhite</pre>
<p>The default is <code>None</code>. This means that extra whitespace is normally prohibited (whitespace that’s part of a standard <code>DateTime</code> pattern is exempt).</p>
<p><code>AssumeLocal</code> and <code>AssumeUniversal</code> apply if the string doesn’t have a time zone suffix (such as <code>Z</code> or <code>+9:00</code>). <code>AdjustToUniversal</code> still honors time zone suffixes, but then converts to UTC using the current regional settings.</p>
<p>If you parse a string comprising a time but no date, today’s date is applied by default. If you apply the <code>NoCurrentDateDefault</code> flag, however, it instead uses 1st January 0001.<a contenteditable="false" data-primary="" data-startref="ch06.html1017" data-type="indexterm" id="id2848"/></p>
</div></section>
<section data-pdf-bookmark="Enum Format Strings" data-type="sect2"><div class="sect2" id="enum_format_strings-id00015">
<h2>Enum Format Strings</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="format strings" data-type="indexterm" id="id2849"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="enum format strings" data-type="indexterm" id="id2850"/>In <a data-type="xref" href="ch03.html#enums-id00013">“Enums”</a>, we described formatting and parsing enum values. <a data-type="xref" href="#enum_format_strings-id00066">Table 6-6</a> lists each format string and the result of applying it to the following expression:<a contenteditable="false" data-primary="" data-startref="ch06.html1019" data-type="indexterm" id="id2851"/></p>
<pre data-type="programlisting">Console.WriteLine (System.ConsoleColor.Red.ToString (formatString));</pre>
<table class="border" id="enum_format_strings-id00066">
<caption><span class="label">Table 6-6. </span>Enum format strings</caption>
<thead>
<tr>
<th>Format string</th>
<th>Meaning</th>
<th>Sample output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>G</code> or <code>g</code></td>
<td>“General”</td>
<td><code>Red</code></td>
<td>Default</td>
</tr>
<tr>
<td><code>F</code> or <code>f</code></td>
<td>Treat as though <code>Flags</code> attribute were present</td>
<td><code>Red</code></td>
<td>Works on combined members even if <code>enum</code> has no <code>Flags</code> attribute</td>
</tr>
<tr>
<td><code>D</code> or <code>d</code></td>
<td>Decimal value</td>
<td><code>12</code></td>
<td>Retrieves underlying integral value</td>
</tr>
<tr>
<td><code>X</code> or <code>x</code></td>
<td>Hexadecimal value</td>
<td><code>0000000C</code></td>
<td>Retrieves underlying integral value</td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="Other Conversion Mechanisms" data-type="sect1"><div class="sect1" id="other_conversion_mechanisms">
<h1>Other Conversion Mechanisms</h1>
<p>In the previous two sections, we covered format providers—.NET’s primary mechanism for formatting and parsing. Other important conversion mechanisms are scattered through various types and namespaces. Some convert to and from <code>string</code>, and some do other kinds of conversions. In this section, we discuss the following topics:</p>
<ul>
<li><p>The <code>Convert</code> class and its functions:</p>
<ul>
<li><p>Real to integral conversions that round rather than truncate</p></li>
<li><p>Parsing numbers in base 2, 8, and 16</p></li>
<li><p>Dynamic conversions</p></li>
<li><p>Base-64 translations</p></li>
</ul></li>
<li><p><code>XmlConvert</code> and its role in formatting and parsing for XML</p></li>
<li><p>Type converters and their role in formatting and parsing for designers and XAML</p></li>
<li><p><code>BitConverter</code>, for binary conversions</p></li>
</ul>
<section data-pdf-bookmark="Convert" data-type="sect2"><div class="sect2" id="convert">
<h2>Convert</h2>
<p><a contenteditable="false" data-primary="Convert class" data-type="indexterm" id="ch06.html1023"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="Convert class" data-type="indexterm" id="ch06.html1024"/>.NET calls the following types <em>base types</em>:</p>
<ul>
<li><p><code>bool</code>, <code>char</code>, <code>string</code>, <code>System.DateTime</code>, and <code>System.DateTimeOffset</code></p></li>
<li><p>All the C# numeric types</p></li>
</ul>
<p>The static <code>Convert</code> class defines methods for converting every base type to every other base type. Unfortunately, most of these methods are useless: either they throw exceptions or they are redundant alongside implicit casts. Among the clutter, however, are some useful methods, listed in the following sections.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="IConvertible" data-type="indexterm" id="id2852"/>All base types (explicitly) implement <code>IConvertible</code>, which defines methods for converting to every other base type. In most cases, the implementation of each of these methods simply calls a method in <code>Convert</code>. On rare occasions, it can be useful to write a method that accepts an argument of type <code>IConvertible</code>.</p>
</div>
<section data-pdf-bookmark="Rounding real to integral conversions" data-type="sect3"><div class="sect3" id="rounding_real_to_integral_conversions">
<h3>Rounding real to integral conversions</h3>
<p><a contenteditable="false" data-primary="Convert class" data-secondary="rounding real to integral conversions" data-type="indexterm" id="id2853"/><a contenteditable="false" data-primary="rounding, real to integral conversions" data-type="indexterm" id="id2854"/>In <a data-type="xref" href="ch02.html#chash_language_basics">Chapter 2</a>, we saw how implicit and explicit casts allow you to convert between numeric types. In summary:</p>
<ul>
<li><p>Implicit casts work for nonlossy conversions (e.g., <code>int</code> to <code>double</code>).</p></li>
<li><p>Explicit casts are required for lossy conversions (e.g., <code>double</code> to <code>int</code>).</p></li>
</ul>
<p>Casts are optimized for efficiency; hence, they <em>truncate</em> data that won’t fit. This can be a problem when converting from a real number to an integer, because often you want to <em>round</em> rather than truncate. <code>Convert</code>’s numerical conversion methods address just this issue—they always <em>round</em>:</p>
<pre data-type="programlisting">double d = 3.9;
int i = <strong>Convert.ToInt32</strong> (d);    // i == 4</pre>
<p><a contenteditable="false" data-primary="banker's rounding" data-type="indexterm" id="id2855"/><a contenteditable="false" data-primary="Convert class" data-secondary="banker's rounding" data-type="indexterm" id="id2856"/><code>Convert</code> uses <em>banker’s rounding</em>, which snaps midpoint values to even integers (this avoids positive or negative bias). If banker’s rounding is a problem, first call <code>Math.Round</code> on the real number: this accepts an additional argument that allows you to control midpoint rounding.</p>
</div></section>
<section data-pdf-bookmark="Parsing numbers in base 2, 8, and 16" data-type="sect3"><div class="sect3" id="parsing_numbers_in_base_twocomma_eightc">
<h3>Parsing numbers in base 2, 8, and 16</h3>
<p><a contenteditable="false" data-primary="Convert class" data-secondary="parsing numbers in base 2, 8, and 16" data-type="indexterm" id="id2857"/>Hidden among the <code>To(<em>integral-type</em>)</code> methods are overloads that parse numbers in another base:</p>
<pre data-type="programlisting">int thirty = Convert.ToInt32  ("1E", 16);    // Parse in hexadecimal
uint five  = Convert.ToUInt32 ("101", 2);    // Parse in binary</pre>
<p>The second argument specifies the base. It can be any base you like—as long as it’s 2, 8, 10, or 16!</p>
</div></section>
<section data-pdf-bookmark="Dynamic conversions" data-type="sect3"><div class="sect3" id="dynamic_conversions-id00062">
<h3>Dynamic conversions</h3>
<p><a contenteditable="false" data-primary="ChangeType method" data-type="indexterm" id="id2858"/><a contenteditable="false" data-primary="Convert class" data-secondary="dynamic conversions" data-type="indexterm" id="id2859"/><a contenteditable="false" data-primary="dynamic conversions" data-type="indexterm" id="id2860"/>Occasionally, you need to convert from one type to another, but you don’t know what the types are until runtime. For this, the <code>Convert</code> class provides a <code>ChangeType</code> method:</p>
<pre data-type="programlisting">public static object ChangeType (object value, Type conversionType);</pre>
<p>The source and target types must be one of the “base” types. <code>ChangeType</code> also accepts an optional <code>IFormatProvider</code> argument. Here’s an example:</p>
<pre data-type="programlisting">Type targetType = typeof (int);
object source = "42";

object result = Convert.ChangeType (source, targetType);

Console.WriteLine (result);             // 42
Console.WriteLine (result.GetType());   // System.Int32</pre>
<p>An example of when this might be useful is in writing a deserializer that can work with multiple types. It can also convert any enum to its integral type (see <a data-type="xref" href="ch03.html#enums-id00013">“Enums”</a>).</p>
<p>A limitation of <code>ChangeType</code> is that you cannot specify a format string or parsing flag.</p>
</div></section>
<section data-pdf-bookmark="Base-64 conversions" data-type="sect3"><div class="sect3" id="base_sixfour_conversions">
<h3>Base-64 conversions</h3>
<p><a contenteditable="false" data-primary="Convert class" data-secondary="base-64 conversions" data-type="indexterm" id="id2861"/>Sometimes, you need to include binary data such as a bitmap within a text document such as an XML file or email message. Base 64 is a ubiquitous means of encoding binary data as readable characters, using 64 characters from the ASCII set.</p>
<p><code>Convert</code>’s <code>ToBase64String</code> method converts from a byte array to base 64; <code>FromBase64String</code> does the reverse. <a contenteditable="false" data-primary="" data-startref="ch06.html1024" data-type="indexterm" id="id2862"/><a contenteditable="false" data-primary="" data-startref="ch06.html1023" data-type="indexterm" id="id2863"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="XmlConvert" data-type="sect2"><div class="sect2" id="xmlconvert">
<h2>XmlConvert</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="XmlConvert" data-type="indexterm" id="id2864"/><a contenteditable="false" data-primary="XmlConvert" data-type="indexterm" id="id2865"/>If you’re dealing with data that’s originated from or destined for an XML file, <code>XmlConvert</code> (in the <code>System.Xml</code> namespace) provides the most suitable methods for formatting and parsing. The methods in <code>XmlConvert</code> handle the nuances of XML formatting without needing special format strings. For instance, <code>true</code> in XML is “true” and not “True.” The .NET BCL internally uses <code>XmlConvert</code> extensively. <code>XmlConvert</code> is also good for general-purpose, culture-independent serialization.</p>
<p>The formatting methods in <code>XmlConvert</code> are all provided as overloaded <code>ToString</code> methods; the parsing methods are called <code>ToBoolean</code>, <code>ToDateTime</code>, and so on:</p>
<pre data-type="programlisting">string s = XmlConvert.ToString (true);         // s = "true"
bool isTrue = XmlConvert.ToBoolean (s);</pre>
<p>The methods that convert to and from <code>DateTime</code> accept an <code>XmlDateTimeSerializationMode</code> argument. This is an <code>enum</code> with the following values:</p>
<pre data-type="programlisting">Unspecified, Local, Utc, RoundtripKind</pre>
<p><code>Local</code> and <code>Utc</code> cause a conversion to take place when formatting (if the <code>DateTime</code> is not already in that time zone). The time zone is then appended to the string:</p>
<pre data-type="programlisting">2010-02-22T14:08:30.9375           // Unspecified
2010-02-22T14:07:30.9375+09:00     // Local
2010-02-22T05:08:30.9375Z          // Utc</pre>
<p><code>Unspecified</code> strips away any time-zone information embedded in the <code>DateTime</code> (i.e., <code>DateTimeKind</code>) before formatting. <code>RoundtripKind</code> honors the <code>DateTime</code>’s <code>DateTimeKind</code>—so when it’s reparsed, the resultant <code>DateTime</code> struct will be exactly as it was originally.</p>
</div></section>
<section data-pdf-bookmark="Type Converters" data-type="sect2"><div class="sect2" id="type_converters">
<h2>Type Converters</h2>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="type converters" data-type="indexterm" id="id2866"/><a contenteditable="false" data-primary="type converters" data-type="indexterm" id="id2867"/>Type converters are designed to format and parse in design-time environments. <a contenteditable="false" data-primary="Extensible Application Markup Language (XAML) files" data-type="indexterm" id="id2868"/><a contenteditable="false" data-primary="XAML (Extensible Application Markup Language) files" data-type="indexterm" id="id2869"/>They also parse values in Extensible Application Markup Language (XAML) documents—as used in Windows Presentation Foundation (WPF).</p>
<p>In .NET, there are more than 100 type converters—covering such things as colors, images, and URIs. In contrast, format providers are implemented for only a handful of simple value types.</p>
<p>Type converters typically parse strings in a variety of ways—without needing hints. For instance, in a WPF application in Visual Studio, if you assign a control a background color by typing <code>"Beige"</code> into the appropriate property window, <code>Color</code>’s type converter figures out that you’re referring to a color name and not an RGB string or system color. This flexibility can sometimes make type converters useful in contexts outside of designers and XAML documents.</p>
<p>All type converters subclass <code>TypeConverter</code> in <code>System.ComponentModel</code>. To obtain a <code>TypeConverter</code>, call <code>TypeDescriptor.GetConverter</code>. The following obtains a <code>TypeConverter</code> for the <code>Color</code> type (in the <code>System.Drawing</code> namespace):</p>
<pre data-type="programlisting">TypeConverter cc = TypeDescriptor.GetConverter (typeof (Color));</pre>
<p>Among many other methods, <code>TypeConverter</code> defines methods to <code>ConvertToString</code> and <code>ConvertFromString</code>. We can call these as follows:</p>
<pre data-type="programlisting">Color beige  = (Color) cc.ConvertFromString ("Beige");
Color purple = (Color) cc.ConvertFromString ("#800080");
Color window = (Color) cc.ConvertFromString ("Window");</pre>
<p>By convention, type converters have names ending in <em>Converter</em> and are usually in the same namespace as the type they’re converting. A type links to its converter via a <code>TypeConverterAttribute</code>, allowing designers to pick up converters automatically.</p>
<p>Type converters can also provide design-time services such as generating standard value lists for populating a drop-down list in a designer or assisting with code serialization.</p>
</div></section>
<section data-pdf-bookmark="BitConverter" data-type="sect2"><div class="sect2" id="bitconverter">
<h2>BitConverter</h2>
<p><a contenteditable="false" data-primary="BitConverter" data-type="indexterm" id="id2870"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="BitConverter" data-type="indexterm" id="id2871"/>Most base types can be converted to a byte array, by calling <code>BitConverter</code>.<code>GetBytes</code>:</p>
<pre data-type="programlisting">foreach (byte b in BitConverter.GetBytes (3.5))
  Console.Write (b + " ");                          // 0 0 0 0 0 0 12 64</pre>
<p><code>BitConverter</code> also provides methods, such as <code>ToDouble</code>, for converting in the other direction.</p>
<p>The <code>decimal</code> and <code>DateTime</code>(<code>Offset</code>) types are not supported by <code>BitConverter</code>. You can, however, convert a <code>decimal</code> to an <code>int</code> array by calling <code>decimal.GetBits</code>. To go the other way around, <code>decimal</code> provides a constructor that accepts an <code>int</code> array.</p>
<p>In the case of <code>DateTime</code>, you can call <code>ToBinary</code> on an instance—this returns a <code>long</code> (upon which you can then use <code>BitConverter</code>). The static <code>DateTime.FromBinary</code> method does the reverse.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Globalization" data-type="sect1"><div class="sect1" id="globalization">
<h1>Globalization</h1>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="globalization" data-type="indexterm" id="id2872"/><a contenteditable="false" data-primary="globalization" data-type="indexterm" id="id2873"/><a contenteditable="false" data-primary="internationalization" data-type="indexterm" id="id2874"/>There are two aspects to <em>internationalizing</em> an application: <em>globalization</em> and <em>localization</em>.</p>
<p><a contenteditable="false" data-primary="globalization" data-secondary="defined" data-type="indexterm" id="id2875"/><em>Globalization</em> is concerned with three tasks (in decreasing order of importance):</p>
<ol>
<li><p>Making sure that your program doesn’t <em>break</em> when run in another culture</p></li>
<li><p>Respecting a local culture’s formatting rules; for instance, when displaying dates</p></li>
<li><p>Designing your program so that it picks up culture-specific data and strings from satellite assemblies that you can later write and deploy</p></li>
</ol>
<p><a contenteditable="false" data-primary="localization" data-type="indexterm" id="id2876"/><em>Localization</em> means concluding that last task by writing satellite assemblies for specific cultures. You can do this <em>after</em> writing your program (we cover the details in <a data-type="xref" href="ch17.html#resources_and_satellite_assemblies">“Resources and Satellite Assemblies”</a>).</p>
<p>.NET helps you with the second task by applying culture-specific rules by default. We’ve already seen how calling <code>ToString</code> on a <code>DateTime</code> or number respects local formatting rules. Unfortunately, this makes it easy to fail the first task and have your program break because you’re expecting dates or numbers to be formatted according to an assumed culture. The solution, as we’ve seen, is either to specify a culture (such as the invariant culture) when formatting and parsing or to use culture-independent methods such as those in <code>XmlConvert</code>.</p>
<section data-pdf-bookmark="Globalization Checklist" data-type="sect2"><div class="sect2" id="globalization_checklist">
<h2>Globalization Checklist</h2>
<p><a contenteditable="false" data-primary="globalization" data-secondary="checklist" data-type="indexterm" id="id2877"/>We’ve already covered the important points in this chapter. Here’s a summary of the essential work required:</p>
<ul>
<li><p>Understand Unicode and text encodings (see <a data-type="xref" href="#text_encodings_and_unicode">“Text Encodings and Unicode”</a>).</p></li>
<li><p>Be mindful that methods such as <code>ToUpper</code> and <code>ToLower</code> on <code>char</code> and <code>string</code> are culture sensitive: use <code>ToUpperInvariant</code>/<code>ToLowerInvariant</code> unless you want culture sensitivity.</p></li>
<li><p>Favor culture-independent formatting and parsing mechanisms for <code>DateTime</code> and <code>DateTimeOffset</code>s such as <code>ToString("o")</code> and <code>XmlConvert</code>.</p></li>
<li><p>Otherwise, specify a culture when formatting/parsing numbers or date/times (unless you <em>want</em> local-culture behavior).</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Testing" data-type="sect2"><div class="sect2" id="testing">
<h2>Testing</h2>
<p><a contenteditable="false" data-primary="globalization" data-secondary="testing against different cultures" data-type="indexterm" id="id2878"/>You can test against different cultures by reassigning <code>Thread</code>’s <code>CurrentCulture</code> property (in <code>System.Threading</code>). The following changes the current culture to Turkey:</p>
<pre data-type="programlisting">Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo ("tr-TR");</pre>
<p>Turkey is a particularly good test case because:</p>
<ul>
<li><p><code>"i".ToUpper() != "I"</code> and <code>"I".ToLower() != "i"</code>.</p></li>
<li><p>Dates are formatted as day.month.year (note the period separator).</p></li>
<li><p>The decimal point indicator is a comma instead of a period.</p></li>
</ul>
<p>You can also experiment by changing the number and date formatting settings in the Windows Control Panel: these are reflected in the default culture (<code>CultureInfo.CurrentCulture</code>).</p>
<p><code>CultureInfo.GetCultures()</code> returns an array of all available cultures.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Thread</code> and <code>CultureInfo</code> also support a <code>CurrentUICulture</code> property. This is concerned more with localization, which we cover in <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>.</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Working with Numbers" data-type="sect1"><div class="sect1" id="working_with_numbers">
<h1>Working with Numbers</h1>
<section data-pdf-bookmark="Conversions" data-type="sect2"><div class="sect2" id="conversions">
<h2>Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="numeric types" data-type="indexterm" id="id2879"/><a contenteditable="false" data-primary="numeric types" data-secondary="conversions" data-type="indexterm" id="id2880"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="working with numbers" data-type="indexterm" id="ch06.html1025"/><a contenteditable="false" data-primary="numeric types" data-type="indexterm" id="ch06.html1026"/>We covered numeric conversions in previous chapters and sections; <a data-type="xref" href="#summary_of_numeric_conversions">Table 6-7</a> summarizes all of the options.</p>
<table class="border" id="summary_of_numeric_conversions">
<caption><span class="label">Table 6-7. </span>Summary of numeric conversions</caption>
<thead>
<tr>
<th>Task</th>
<th>Functions</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parsing base 10 numbers</td>
<td><code>Parse</code><br/> <code>TryParse</code></td>
<td><code>double d = double.Parse ("3.5");</code><br/><code>int i;</code><br/> <code>bool ok = int.TryParse ("3", out i);</code></td>
</tr>
<tr>
<td>Parsing from base 2, 8, or 16</td>
<td><code>Convert.ToIntegral</code></td>
<td><code>int i = Convert.ToInt32 ("1E", 16);</code></td>
</tr>
<tr>
<td>Formatting to hexadecimal</td>
<td><code>ToString ("X")</code></td>
<td><code>string hex = 45.ToString ("X");</code></td>
</tr>
<tr>
<td>Lossless numeric conversion</td>
<td>Implicit cast</td>
<td><code>int i = 23;</code><br/> <code>double d = i;</code></td>
</tr>
<tr>
<td><em>Truncating</em> numeric conversion</td>
<td>Explicit cast</td>
<td><code>double d = 23.5;</code><br/> <code>int i = (int) d;</code></td>
</tr>
<tr>
<td><em>Rounding</em> numeric conversion (real to integral)</td>
<td><code>Convert.ToIntegral</code></td>
<td><code>double d = 23.5;</code><br/> <code>int i = Convert.ToInt32 (d);</code></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Math" data-type="sect2"><div class="sect2" id="math">
<h2>Math</h2>
<p><a contenteditable="false" data-primary="Math class" data-type="indexterm" id="id2881"/><a contenteditable="false" data-primary="numeric types" data-secondary="Math class" data-type="indexterm" id="id2882"/><a data-type="xref" href="#methods_in_the_static_math_class">Table 6-8</a> lists the key members of the static <code>Math</code> class. The trigonometric functions accept arguments of type <code>double</code>; other methods such as <code>Max</code> are overloaded to operate on all numeric types. The <code>Math</code> class also defines the mathematical constants <code>E</code> (<em>e</em>) and <code>PI</code>.</p>
<table class="border" id="methods_in_the_static_math_class">
<caption><span class="label">Table 6-8. </span>Methods in the static Math class</caption>
<thead>
<tr>
<th>Category</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rounding</td>
<td><code>Round</code>, <code>Truncate</code>, <code>Floor</code>, <code>Ceiling</code></td>
</tr>
<tr>
<td>Maximum/minimum</td>
<td><code>Max</code>, <code>Min</code></td>
</tr>
<tr>
<td>Absolute value and sign</td>
<td><code>Abs</code>, <code>Sign</code></td>
</tr>
<tr>
<td>Square root</td>
<td><code>Sqrt</code></td>
</tr>
<tr>
<td>Raising to a power</td>
<td><code>Pow</code>, <code>Exp</code></td>
</tr>
<tr>
<td>Logarithm</td>
<td><code>Log</code>, <code>Log10</code></td>
</tr>
<tr>
<td>Trigonometric</td>
<td><code>Sin</code>, <code>Cos</code>, <code>Tan</code>,<br/><code>Sinh</code>, <code>Cosh</code>, <code>Tanh</code>,<br/><code>Asin</code>, <code>Acos</code>, <code>Atan</code></td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="Round method" data-type="indexterm" id="id2883"/>The <code>Round</code> method lets you specify the number of decimal places with which to round as well as how to handle midpoints (away from zero, or with banker’s rounding). <code>Floor</code> and <code>Ceiling</code> round to the nearest integer: <code>Floor</code> always rounds down, and <code>Ceiling</code> always rounds up—even with negative numbers.</p>
<p><code>Max</code> and <code>Min</code> accept only two arguments. If you have an array or sequence of numbers, use the <code>Max</code> and <code>Min</code> extension methods in <code>System.Linq.Enumerable</code>.</p>
</div></section>
<section data-pdf-bookmark="BigInteger" data-type="sect2"><div class="sect2" id="biginteger">
<h2>BigInteger</h2>
<p><a contenteditable="false" data-primary="BigInteger struct" data-type="indexterm" id="id2884"/><a contenteditable="false" data-primary="numeric types" data-secondary="BigInteger struct" data-type="indexterm" id="id2885"/>The <code>BigInteger</code> struct is a specialized numeric type. It resides in the <code>System.Numerics</code> namespace and allows you to represent an arbitrarily large integer without any loss of precision.</p>
<p>C# doesn’t provide native support for <code>BigInteger</code>, so there’s no way to represent <code>BigInteger</code> literals. You can, however, implicitly convert from any other integral type to a <code>BigInteger</code>:</p>
<pre data-type="programlisting">BigInteger twentyFive = 25;      // implicit conversion from integer</pre>
<p>To represent a bigger number, such as one googol (10<sup>100</sup>), you can use one of <code>BigInteger</code>’s static methods, such as <code>Pow</code> (raise to the power):</p>
<pre data-type="programlisting">BigInteger googol = BigInteger.Pow (10, 100);</pre>
<p>Alternatively, you can <code>Parse</code> a string:</p>
<pre data-type="programlisting">BigInteger googol = BigInteger.Parse ("1".PadRight (101, '0'));</pre>
<p>Calling <code>ToString()</code> on this prints every digit:</p>
<pre data-type="programlisting">Console.WriteLine (googol.<strong>ToString()</strong>); // 10000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000</pre>
<p>You can perform potentially lossy conversions between <code>BigInteger</code> and the standard numeric types by using the explicit cast operator:</p>
<pre data-type="programlisting">double g2 = (double) googol;        // Explicit cast
BigInteger g3 = (BigInteger) g2;    // Explicit cast
Console.WriteLine (g3);</pre>
<p>The output from this demonstrates the loss of precision:</p>
<pre data-type="programlisting">9999999999999999673361688041166912...</pre>
<p><code>BigInteger</code> overloads all the arithmetic operators including remainder (<code>%</code>) as well as the comparison and equality operators.</p>
<p>You can also construct a <code>BigInteger</code> from a byte array. The following code generates a 32-byte random number suitable for cryptography and then assigns it to a <code>BigInteger</code>:</p>
<pre data-type="programlisting">// This uses the System.Security.Cryptography namespace:
RandomNumberGenerator rand = RandomNumberGenerator.Create();
byte[] bytes = new byte [32];
rand.GetBytes (bytes);
var bigRandomNumber = new BigInteger (bytes);   // Convert to BigInteger</pre>
<p>The advantage of storing such a number in a <code>BigInteger</code> over a byte array is that you get value-type semantics. Calling <code>ToByteArray</code> converts a <code>BigInteger</code> back to a byte array.</p>
</div></section>
<section data-pdf-bookmark="Half" data-type="sect2"><div class="sect2" id="half">
<h2>Half</h2>
<p><a contenteditable="false" data-primary="Half struct" data-type="indexterm" id="id2886"/>The <code>Half</code> struct is a 16-bit floating point type, and was introduced with .NET 5. <code>Half</code> is intended mainly for interoperating with graphics card processors and does not have native support in most CPUs.</p>
<p>You can convert between <code>Half</code> and <code>float</code> or <code>double</code> via an explicit cast:</p>
<pre data-type="programlisting">Half h = (Half) 123.456;
Console.WriteLine (h);     // 123.44  (note loss of precision)</pre>
<p>There are no arithmetic operations defined for this type, so you must convert to another type such as <code>float</code> or <code>double</code> in order to perform calculations.</p>
<p><code>Half</code> has a range of -65500 to 65500:</p>
<pre data-type="programlisting">Console.WriteLine (Half.MinValue);   // -65500
Console.WriteLine (Half.MaxValue);   // 65500</pre>
<p>Note the loss of precision at the maximum range:</p>
<pre data-type="programlisting">Console.WriteLine ((Half)65500);     // 65500
Console.WriteLine ((Half)65490);     // 65500
Console.WriteLine ((Half)65480);     // 65470</pre>
</div></section>
<section data-pdf-bookmark="Complex" data-type="sect2"><div class="sect2" id="complex">
<h2>Complex</h2>
<p><a contenteditable="false" data-primary="Complex struct" data-type="indexterm" id="id2887"/><a contenteditable="false" data-primary="numeric types" data-secondary="Complex struct" data-type="indexterm" id="id2888"/>The <code>Complex</code> struct is another specialized numeric type that represents complex numbers with real and imaginary components of type <code>double</code>. <code>Complex</code> resides in the namespace (along with <code>BigInteger</code>).</p>
<p>To use <code>Complex</code>, instantiate the struct, specifying the real and imaginary values:</p>
<pre data-type="programlisting">var c1 = new Complex (2, 3.5);
var c2 = new Complex (3, 0);</pre>
<p>There are also implicit conversions from the standard numeric types.</p>
<p>The <code>Complex</code> struct exposes properties for the real and imaginary values as well as the phase and magnitude:</p>
<pre data-type="programlisting">Console.WriteLine (c1.Real);       // 2
Console.WriteLine (c1.Imaginary);  // 3.5
Console.WriteLine (c1.Phase);      // 1.05165021254837
Console.WriteLine (c1.Magnitude);  // 4.03112887414927</pre>
<p>You can also construct a <code>Complex</code> number by specifying magnitude and phase:</p>
<pre data-type="programlisting">Complex c3 = Complex.FromPolarCoordinates (1.3, 5);</pre>
<p>The standard arithmetic operators are overloaded to work on <code>Complex</code> numbers:</p>
<pre data-type="programlisting">Console.WriteLine (c1 + c2);    // (5, 3.5)
Console.WriteLine (c1 * c2);    // (6, 10.5)</pre>
<p>The <code>Complex</code> struct exposes static methods for more advanced functions, including the following:</p>
<ul>
<li><p>Trigonometric (<code>Sin</code>, <code>Asin</code>, <code>Sinh</code>, <code>Tan</code>, etc.)</p></li>
<li><p>Logarithms and exponentiations</p></li>
<li><p><code>Conjugate</code></p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Random" data-type="sect2"><div class="sect2" id="random">
<h2>Random</h2>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="Random class" data-type="indexterm" id="id2889"/><a contenteditable="false" data-primary="Random class" data-type="indexterm" id="id2890"/>The <code>Random</code> class generates a pseudorandom sequence of random <code>byte</code>s, <code>integer</code>s, or <code>double</code>s.</p>
<p>To use <code>Random</code>, you first instantiate it, optionally providing a seed to initiate the random number series. Using the same seed guarantees the same series of numbers (if run under the same CLR version), which is sometimes useful when you want reproducibility:</p>
<pre data-type="programlisting">Random r1 = new Random (1);
Random r2 = new Random (1);
Console.WriteLine (r1.Next (100) + ", " + r1.Next (100));      // 24, 11
Console.WriteLine (r2.Next (100) + ", " + r2.Next (100));      // 24, 11</pre>
<p>If you don’t want reproducibility, you can construct <code>Random</code> with no seed; in that case, it uses the current system time to make one up.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Because the system clock has limited granularity, two <code>Random</code> instances created close together (typically within 10 ms) will yield the same sequence of values. A common trap is to instantiate a new <code>Random</code> object every time you need a random number rather than reusing the <em>same</em> object.</p>
<p>A good pattern is to declare a single static <code>Random</code> instance. In multithreaded scenarios, however, this can cause trouble because <code>Random</code> objects are not thread-safe. We describe a workaround in <a data-type="xref" href="ch21.html#thread_local_storage">“Thread-Local Storage”</a>.</p>
</div>
<p>Calling <code>Next(<em>n</em>)</code> generates a random integer between 0 and <code><em>n</em>−1</code>. <code>NextDouble</code> generates a random <code>double</code> between 0 and 1. <code>NextBytes</code> fills a byte array with random values.</p>
<p>From .NET 8, the <code>Random</code> class includes a <code>GetItems</code> method, which picks <em>n</em> random items from a collection. The following code picks two random numbers from a collection of five:</p>
<pre data-type="programlisting">int[] numbers = { 10, 20, 30, 40, 50 };
int[] randomTwo = new Random().GetItems (numbers, 2);</pre>
<p>From .NET 8, there’s also a <code>Shuffle</code> method to randomize the order of items within an array or span.</p>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Security.Cryptography" data-type="indexterm" id="id2891"/><code>Random</code> is not considered random enough for high-security applications such as cryptography. For this, .NET provides a <em>cryptographically strong</em> random number generator, in the <code>System.Security.Cryptography</code> namespace. Here’s how to use it:</p>
<pre data-type="programlisting">var rand = System.Security.Cryptography.RandomNumberGenerator.Create();
byte[] bytes = new byte [32];
rand.GetBytes (bytes);       // Fill the byte array with random numbers.</pre>
<p>The downside is that it’s less flexible: filling a byte array is the only means of obtaining random numbers. To obtain an integer, you must use <code>BitConverter</code>:<a contenteditable="false" data-primary="" data-startref="ch06.html1026" data-type="indexterm" id="id2892"/><a contenteditable="false" data-primary="" data-startref="ch06.html1025" data-type="indexterm" id="id2893"/></p>
<pre data-type="programlisting">byte[] bytes = new byte [4];
rand.GetBytes (bytes);
int i = BitConverter.ToInt32 (bytes, 0);</pre>
</div></section>
<section data-pdf-bookmark="BitOperations" data-type="sect2"><div class="sect2" id="bitoperations">
<h2>BitOperations</h2>
<p><a contenteditable="false" data-primary="BitOperations" data-type="indexterm" id="id2894"/><a contenteditable="false" data-primary="System..." data-secondary="System.Numerics.BitOperations" data-type="indexterm" id="id2895"/>The <code>System.Numerics.BitOperations</code> class (from .NET 6) exposes the following methods to help with base-2 operations:</p>
<dl>
<dt><code>IsPow2</code></dt>
<dd>Returns true if a number is a power of 2</dd>
<dt><code>LeadingZeroCount</code>/<code>TrailingZeroCount</code></dt>
<dd>Returns the number of leading zeros, when formatted as a base-2 32-bit or 64-bit unsigned integer</dd>
<dt><code>Log2</code></dt>
<dd>Returns the integer base-2 log of an unsigned integer</dd>
<dt><code>PopCount</code></dt>
<dd>Returns the number of bits set to 1 in an unsigned integer</dd>
<dt><code>RotateLeft</code>/<code>RotateRight</code></dt>
<dd>Performs a bitwise left/right rotation</dd>
<dt><code>RoundUpToPowerOf2</code></dt>
<dd>Rounds an unsigned integer up to the closest power of 2</dd>
</dl>
</div></section>
</div></section>
<section data-pdf-bookmark="Enums" data-type="sect1"><div class="sect1" id="enums-id00064">
<h1>Enums</h1>
<p><a contenteditable="false" data-primary="enums" data-type="indexterm" id="ch06.html1027"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="enums" data-type="indexterm" id="ch06.html1028"/>In <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>, we described C#’s enum type and showed how to combine members, test equality, use logical operators, and perform conversions. <a contenteditable="false" data-primary="System..." data-secondary="System.Enum" data-type="indexterm" id="id2896"/>.NET extends C#’s support for enums through the <code>System.Enum</code> type. This type has two roles:</p>
<ul>
<li><p>Providing type unification for all <code>enum</code> types</p></li>
<li><p>Defining static utility methods</p></li>
</ul>
<p><a contenteditable="false" data-primary="type unification" data-type="indexterm" id="id2897"/><em>Type unification</em> means that you can implicitly cast any enum member to a <span class="keep-together"><code>System.Enum</code></span> instance:</p>
<pre data-type="programlisting">Display (Nut.Macadamia);     // Nut.Macadamia
Display (Size.Large);        // Size.Large

void Display (Enum value)
{
  Console.WriteLine (value.GetType().Name + "." + value.ToString());
}

enum Nut  { Walnut, Hazelnut, Macadamia }
enum Size { Small, Medium, Large }</pre>
<p>The static utility methods on <code>System.Enum</code> are primarily related to performing conversions and obtaining lists of members.</p>
<section data-pdf-bookmark="Enum Conversions" data-type="sect2"><div class="sect2" id="enum_conversions-id00065">
<h2>Enum Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="enums" data-type="indexterm" id="ch06.html1029"/><a contenteditable="false" data-primary="enums" data-secondary="conversions" data-type="indexterm" id="ch06.html1030"/>There are three ways to represent an enum value:</p>
<ul>
<li><p>As an <code>enum</code> member</p></li>
<li><p>As its underlying integral value</p></li>
<li><p>As a string</p></li>
</ul>
<p>In this section, we describe how to convert between each.</p>
<section data-pdf-bookmark="Enum to integral conversions" data-type="sect3"><div class="sect3" id="enum_to_integral_conversions">
<h3>Enum to integral conversions</h3>
<p><a contenteditable="false" data-primary="enums" data-secondary="enum to integral conversions" data-type="indexterm" id="id2898"/><a contenteditable="false" data-primary="integral types" data-secondary="enum conversions" data-type="indexterm" id="id2899"/>Recall that an explicit cast converts between an <code>enum</code> member and its integral value. An explicit cast is the correct approach if you know the <code>enum</code> type at compile time:</p>
<pre data-type="programlisting">[Flags] 
public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }
...
int i = <strong>(int)</strong> BorderSides.Top;            // i == 4
BorderSides side = <strong>(BorderSides)</strong> i;       // side == BorderSides.Top</pre>
<p>You can cast a <code>System.Enum</code> instance to its integral type in the same way. The trick is to first cast to an <code>object</code> and then the integral type:</p>
<pre data-type="programlisting">static int GetIntegralValue (Enum anyEnum)
{
  return (int) (object) anyEnum;
}</pre>
<p>This relies on you knowing the integral type: the method we just wrote would crash if passed an <code>enum</code> whose integral type was <code>long</code>. To write a method that works with an <code>enum</code> of any integral type, you can take one of three approaches. The first is to call <code>Convert.ToDecimal</code>:</p>
<pre data-type="programlisting">static decimal GetAnyIntegralValue (Enum anyEnum)
{
  return Convert.ToDecimal (anyEnum);
}</pre>
<p>This works because every integral type (including <code>ulong</code>) can be converted to decimal without loss of information. The second approach is to call <code>Enum.GetUnderlyingType</code> in order to obtain the <code>enum</code>’s integral type, and then call <code>Convert.ChangeType</code>:</p>
<pre data-type="programlisting">static object GetBoxedIntegralValue (Enum anyEnum)
{
  Type integralType = Enum.GetUnderlyingType (anyEnum.GetType());
  return Convert.ChangeType (anyEnum, integralType);
}</pre>
<p>This preserves the original integral type, as the following example shows:</p>
<pre data-type="programlisting">object result = GetBoxedIntegralValue (BorderSides.Top);
Console.WriteLine (result);                               // 4
Console.WriteLine (result.GetType());                     // System.Int32</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Our <code>GetBoxedIntegralType</code> method in fact performs no value conversion; rather, it <em>reboxes</em> the same value in another type. It translates an integral value in <em>enum-type</em> clothing to an integral value in <em>integral-type</em> clothing. We describe this further in <a data-type="xref" href="#how_enums_work">“How Enums Work”</a>.</p>
</div>
<p>The third approach is to call <code>Format</code> or <code>ToString</code> specifying the <code>"d"</code> or <code>"D"</code> format string. This gives you the <code>enum</code>’s integral value as a string, and it is useful when writing custom serialization formatters:</p>
<pre data-type="programlisting">static string GetIntegralValueAsString (Enum anyEnum)
{
  return anyEnum.ToString ("D");      // returns something like "4"
}</pre>
</div></section>
<section data-pdf-bookmark="Integral to enum conversions" data-type="sect3"><div class="sect3" id="integral_to_enum_conversions">
<h3>Integral to enum conversions</h3>
<p><a contenteditable="false" data-primary="Enum..." data-secondary="Enum.ToObject" data-type="indexterm" id="id2900"/><a contenteditable="false" data-primary="enums" data-secondary="integral to enum conversions" data-type="indexterm" id="id2901"/><code>Enum.ToObject</code> converts an integral value to an <code>enum</code> instance of the given type:</p>
<pre data-type="programlisting">object bs = Enum.ToObject (typeof (BorderSides), 3);
Console.WriteLine (bs);                              // Left, Right</pre>
<p>This is the dynamic equivalent of the following:</p>
<pre data-type="programlisting">BorderSides bs = (BorderSides) 3;</pre>
<p><code>ToObject</code> is overloaded to accept all integral types as well as <code>object</code>. (The latter works with any boxed integral type.)</p>
</div></section>
<section data-pdf-bookmark="String conversions" data-type="sect3"><div class="sect3" id="string_conversions">
<h3>String conversions</h3>
<p><a contenteditable="false" data-primary="enums" data-secondary="string conversions" data-type="indexterm" id="id2902"/><a contenteditable="false" data-primary="string type" data-secondary="enum conversions" data-type="indexterm" id="id2903"/>To convert an <code>enum</code> to a string, you can either call the static <code>Enum.Format</code> method or call <code>ToString</code> on the instance. Each method accepts a format string, which can be <code>"G"</code> for default formatting behavior, <code>"D"</code> to emit the underlying integral value as a string, <code>"X"</code> for the same in hexadecimal, or <code>"F"</code> to format combined members of an enum without the <code>Flags</code> attribute. We listed examples of these in <a data-type="xref" href="#standard_format_strings_and_parsing_fla">“Standard Format Strings and Parsing Flags”</a>.</p>
<p><a contenteditable="false" data-primary="Enum..." data-secondary="Enum.Parse" data-type="indexterm" id="id2904"/><code>Enum.Parse</code> converts a string to an <code>enum</code>. It accepts the <code>enum</code> type and a string that can include multiple members:</p>
<pre data-type="programlisting">BorderSides leftRight = (BorderSides) Enum.Parse (typeof (BorderSides),
                                                  "Left, Right");</pre>
<p>An optional third argument lets you perform case-insensitive parsing. An <code>ArgumentException</code> is thrown if the member is not found.<a contenteditable="false" data-primary="" data-startref="ch06.html1030" data-type="indexterm" id="id2905"/><a contenteditable="false" data-primary="" data-startref="ch06.html1029" data-type="indexterm" id="id2906"/></p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Enumerating Enum Values" data-type="sect2"><div class="sect2" id="enumerating_enum_values">
<h2 class="less_space">Enumerating Enum Values</h2>
<p><a contenteditable="false" data-primary="Enum..." data-secondary="Enum.GetValues" data-type="indexterm" id="id2907"/><a contenteditable="false" data-primary="enums" data-secondary="enumerating enum values" data-type="indexterm" id="id2908"/><code>Enum.GetValues</code> returns an array comprising all members of a particular <code>enum</code> type:</p>
<pre data-type="programlisting">foreach (Enum value in Enum.GetValues (typeof (BorderSides)))
  Console.WriteLine (value);</pre>
<p>Composite members such as <code>LeftRight = Left | Right</code> are included, too.</p>
<p><a contenteditable="false" data-primary="Enum..." data-secondary="Enum.GetNames" data-type="indexterm" id="id2909"/><code>Enum.GetNames</code> performs the same function, but returns an array of <em>strings</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Internally, the CLR implements <code>GetValues</code> and <code>GetNames</code> by reflecting over the fields in the <code>enum</code>’s type. The results are cached for efficiency.</p>
</div>
</div></section>
<section data-pdf-bookmark="How Enums Work" data-type="sect2"><div class="sect2" id="how_enums_work">
<h2>How Enums Work</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="semantics of" data-type="indexterm" id="id2910"/>The semantics of <code>enum</code>s are enforced largely by the compiler. In the CLR, there’s no runtime difference between an <code>enum</code> instance (when unboxed) and its underlying integral value. Further, an <code>enum</code> definition in the CLR is merely a subtype of <code>System.Enum</code> with static integral-type fields for each member. This makes the ordinary use of an <code>enum</code> highly efficient, with a runtime cost matching that of integral constants.</p>
<p>The downside of this strategy is that <code>enum</code>s can provide <em>static</em> but not <em>strong</em> type safety. We saw an example of this in <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>:</p>
<pre data-type="programlisting">[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }
...
BorderSides b = BorderSides.Left;
b += 1234;                          // No error!</pre>
<p>When the compiler is unable to perform validation (as in this example), there’s no backup from the runtime to throw an exception.</p>
<p>What we said about there being no runtime difference between an <code>enum</code> instance and its integral value might seem at odds with the following:</p>
<pre data-type="programlisting">[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }
...
Console.WriteLine (BorderSides.Right.ToString());        // Right
Console.WriteLine (BorderSides.Right.GetType().Name);    // BorderSides</pre>
<p>Given the nature of an <code>enum</code> instance at runtime, you’d expect this to print <code>2</code> and <code>Int32</code>! The reason for its behavior is down to some more compile-time trickery. C# explicitly <em>boxes</em> an <code>enum</code> instance before calling its virtual methods—such as <code>ToString</code> or <code>GetType</code>. And when an <code>enum</code> instance is boxed, it gains a runtime wrapping that references its <code>enum</code> type.<a contenteditable="false" data-primary="" data-startref="ch06.html1028" data-type="indexterm" id="id2911"/><a contenteditable="false" data-primary="" data-startref="ch06.html1027" data-type="indexterm" id="id2912"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The Guid Struct" data-type="sect1"><div class="sect1" id="the_guid_struct">
<h1>The Guid Struct</h1>
<p><a contenteditable="false" data-primary="formatting and parsing" data-secondary="Guid struct" data-type="indexterm" id="id2913"/><a contenteditable="false" data-primary="Guid struct" data-type="indexterm" id="id2914"/>The <code>Guid</code> struct represents a globally unique identifier: a 16-byte value that, when generated, is almost certainly unique in the world. <code>Guid</code>s are often used for keys of various sorts, in applications and databases. There are 2<sup>128</sup>, or 3.4 × 10<sup>38</sup>, unique <code>Guids</code>.</p>
<p><a contenteditable="false" data-primary="Guid.NewGuid" data-type="indexterm" id="id2915"/>The static <code>Guid.NewGuid</code> method generates a unique <code>Guid</code>:</p>
<pre data-type="programlisting">Guid g = Guid.NewGuid ();
Console.WriteLine (g.ToString());  // 0d57629c-7d6e-4847-97cb-9e2fc25083fe</pre>
<p>To instantiate an existing value, you use one of the constructors. The two most useful constructors are:</p>
<pre data-type="programlisting">public Guid (byte[] b);    // Accepts a 16-byte array
public Guid (string g);    // Accepts a formatted string</pre>
<p>When represented as a string, a <code>Guid</code> is formatted as a 32-digit hexadecimal number, with optional hyphens after the 8th, 12th, 16th, and 20th digits. The whole string can also be optionally wrapped in brackets or braces:</p>
<pre data-type="programlisting">Guid g1 = new Guid ("{0d57629c-7d6e-4847-97cb-9e2fc25083fe}");
Guid g2 = new Guid ("0d57629c7d6e484797cb9e2fc25083fe");
Console.WriteLine (g1 == g2);  // True</pre>
<p>Being a struct, a <code>Guid</code> honors value-type semantics; hence, the equality operator works in the preceding example.</p>
<p>The <code>ToByteArray</code> method converts a <code>Guid</code> to a byte array.</p>
<p>The static <code>Guid.Empty</code> property returns an empty <code>Guid</code> (all zeros). This is often used in place of <code>null</code>.</p>
</div></section>
<section data-pdf-bookmark="Equality Comparison" data-type="sect1"><div class="sect1" id="equality_comparison-id00067">
<h1>Equality Comparison</h1>
<p><a contenteditable="false" data-primary="equality comparison" data-type="indexterm" id="ch06.html1031"/><a contenteditable="false" data-primary="formatting and parsing" data-secondary="equality comparison" data-type="indexterm" id="ch06.html1032"/>Until now, we’ve assumed that the <code>==</code> and <code>!=</code> operators are all there is to equality comparison. The issue of equality, however, is more complex and subtler, sometimes requiring the use of additional methods and interfaces. This section explores the standard C# and .NET protocols for equality, focusing particularly on two questions:</p>
<ul>
<li><p>When are <code>==</code> and <code>!=</code> adequate—and inadequate—for equality comparison, and what are the alternatives?</p></li>
<li><p>How and when should you customize a type’s equality logic?</p></li>
</ul>
<p>But before exploring the details of equality protocols and how to customize them, we first must look at the preliminary concept of value versus referential equality.</p>
<section data-pdf-bookmark="Value Versus Referential Equality" data-type="sect2"><div class="sect2" id="value_versus_referential_equality">
<h2>Value Versus Referential Equality</h2>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="value equality versus referential equality" data-type="indexterm" id="id2916"/><a contenteditable="false" data-primary="referential equality" data-type="indexterm" id="id2917"/><a contenteditable="false" data-primary="value equality" data-type="indexterm" id="id2918"/>There are two kinds of equality:</p>
<dl>
<dt>Value equality</dt>
<dd>Two values are <em>equivalent</em> in some sense.</dd>
<dt>Referential equality</dt>
<dd>Two references refer to <em>exactly the same object</em>.</dd>
</dl>
<p>Unless overridden:</p>
<ul>
<li><p>Value types use <em>value equality</em>.</p></li>
<li><p>Reference types use <em>referential equality</em>. (This is overridden with anonymous types and records.)</p></li>
</ul>
<p>Value types, in fact, can use <em>only</em> value equality (unless boxed). A simple demonstration of value equality is to compare two numbers:</p>
<pre data-type="programlisting">int x = 5, y = 5;
Console.WriteLine (x == y);   // True <em>(by virtue of value equality)</em></pre>
<p><a contenteditable="false" data-primary="DateTimeOffset" data-type="indexterm" id="id2919"/>A more elaborate demonstration is to compare two <code>DateTimeOffset</code> structs. The following prints <code>True</code> because the two <code>DateTimeOffset</code>s refer to the <em>same point in time</em> and so are considered equivalent:</p>
<pre data-type="programlisting">var dt1 = new DateTimeOffset (2010, 1, 1, <strong>1</strong>, 1, 1, TimeSpan.FromHours(<strong>8</strong>));
var dt2 = new DateTimeOffset (2010, 1, 1, <strong>2</strong>, 1, 1, TimeSpan.FromHours(<strong>9</strong>));
Console.WriteLine (dt1 == dt2);   // True</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>DateTimeOffset</code> is a struct whose equality semantics have been tweaked. <a contenteditable="false" data-primary="structural equality" data-type="indexterm" id="id2920"/>By default, structs exhibit a special kind of value equality called <em>structural equality</em> in which two values are considered equal if all of their members are equal. (You can see this by creating a struct and calling its <code>Equals</code> method; more on this later.)</p>
</div>
<p>Reference types exhibit referential equality by default. In the following example, <code>f1</code> and <code>f2</code> are not equal, despite their objects having identical content:</p>
<pre data-type="programlisting">class Foo { public int X; }
...
Foo f1 = new Foo { X = 5 };
Foo f2 = new Foo { X = 5 };
Console.WriteLine (f1 == f2);   // False</pre>
<p>In contrast, <code>f3</code> and <code>f1</code> are equal because they reference the same object:</p>
<pre data-type="programlisting">Foo f3 = f1;
Console.WriteLine (f1 == f3);   // True</pre>
<p class="pagebreak-before">Later in this section, we explain how you can <em>customize</em> reference types to exhibit value equality. An example of this is the <code>Uri</code> class in the <code>System</code> namespace:</p>
<pre data-type="programlisting">Uri uri1 = new Uri ("http://www.linqpad.net");
Uri uri2 = new Uri ("http://www.linqpad.net");
Console.WriteLine (uri1 == uri2);              // True</pre>
<p>The <code>string</code> class exhibits similar behavior:</p>
<pre data-type="programlisting">var s1 = "http://www.linqpad.net";
var s2 = "http://" + "www.linqpad.net";
Console.WriteLine (s1 == s2);       // True</pre>
</div></section>
<section data-pdf-bookmark="Standard Equality Protocols" data-type="sect2"><div class="sect2" id="standard_equality_protocols">
<h2>Standard Equality Protocols</h2>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="standard equality protocols" data-type="indexterm" id="ch06.html1033"/>There are three standard protocols that types can implement for equality comparison:</p>
<ul>
<li><p>The <code>==</code> and <code>!=</code> operators</p></li>
<li><p>The virtual <code>Equals</code> method in <code>object</code></p></li>
<li><p>The <code>IEquatable&lt;T&gt;</code> interface</p></li>
</ul>
<p>In addition, there are the <em>pluggable</em> protocols and the <code>IStructuralEquatable</code> interface, which we describe in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>.</p>
<section data-pdf-bookmark="== and !=" data-type="sect3"><div class="sect3" id="equalsequals_and_exclamation_markequals">
<h3>== and !=</h3>
<p><a contenteditable="false" data-primary="!= (inequality operator)" data-type="indexterm" id="id2921"/><a contenteditable="false" data-primary="== (equality operator)" data-type="indexterm" id="id2922"/><a contenteditable="false" data-primary="equality operator (==)" data-type="indexterm" id="id2923"/><a contenteditable="false" data-primary="inequality operator (!=)" data-type="indexterm" id="id2924"/>We’ve already seen in many examples how the standard <code>==</code> and <code>!=</code> operators perform equality/inequality comparisons. The subtleties with <code>==</code> and <code>!=</code> arise because they are <em>operators</em>; thus, they are statically resolved (in fact, they are implemented as <code>static</code> functions). So, when you use <code>==</code> or <code>!=</code>, C# makes a <em>compile-time</em> decision as to which type will perform the comparison, and no <code>virtual</code> behavior comes into play. This is normally desirable. In the following example, the compiler hardwires <code>==</code> to the <code>int</code> type because <code>x</code> and <code>y</code> are both <code>int</code>:</p>
<pre data-type="programlisting">int x = 5;
int y = 5;
Console.WriteLine (x == y);      // True</pre>
<p>But in the next example, the compiler wires the <code>==</code> operator to the <code>object</code> type:</p>
<pre data-type="programlisting">object x = 5;
object y = 5;
Console.WriteLine (x == y);      // False</pre>
<p><a contenteditable="false" data-primary="referential equality" data-type="indexterm" id="id2925"/>Because <code>object</code> is a class (and so a reference type), <code>object</code>’s <code>==</code> operator uses <em>referential equality</em> to compare <code>x</code> and <code>y</code>. The result is <code>false</code> because <code>x</code> and <code>y</code> each refer to different boxed objects on the heap.</p>
</div></section>
<section data-pdf-bookmark="The virtual Object.Equals method" data-type="sect3"><div class="sect3" id="the_virtual_objectdotequals_method">
<h3>The virtual Object.Equals method</h3>
<p><a contenteditable="false" data-primary="Object..." data-secondary="Object.Equals method" data-type="indexterm" id="ch06.html1034"/><a contenteditable="false" data-primary="Object..." data-secondary="object.Equals virtual method" data-type="indexterm" id="id2926"/>To correctly equate <code>x</code> and <code>y</code> in the preceding example, we can use the virtual <code>Equals</code> method. <code>Equals</code> is defined in <code>System.Object</code> and so is available to all types:</p>
<pre data-type="programlisting">object x = 5;
object y = 5;
Console.WriteLine (<strong>x.Equals (y)</strong>);      // True</pre>
<p><code>Equals</code> is resolved at runtime—according to the object’s actual type. In this case, it calls <code>Int32</code>’s <code>Equals</code> method, which applies <em>value equality</em> to the operands, returning <code>true</code>. With reference types, <code>Equals</code> performs referential equality comparison by default; with structs, <code>Equals</code> performs structural comparison by calling <code>Equals</code> on each of its fields.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_the_complexityquestion_mark">
<h1>Why the Complexity?</h1>
<p>You might wonder why the designers of C# didn’t avoid the problem by making <code>==</code> virtual and thus functionally identical to <code>Equals</code>. There are three reasons for this:</p>
<ul>
<li><p>If the first operand is null, <code>Equals</code> fails with a <code>NullReferenceException</code>; a static operator does not.</p></li>
<li><p>Because the <code>==</code> operator is statically resolved, it executes extremely quickly. This means that you can write computationally intensive code without penalty—and without needing to learn another language such as C++.</p></li>
<li><p>Sometimes it can be useful to have <code>==</code> and <code>Equals</code> apply different definitions of equality. We describe this scenario later in this section.</p></li>
</ul>
<p>Essentially, the complexity of the design reflects the complexity of the situation: the concept of equality covers a multitude of scenarios.</p>
</div></aside>
<p>Hence, <code>Equals</code> is suitable for equating two objects in a type-agnostic fashion. The following method equates two objects of any type:</p>
<pre data-type="programlisting">public static bool AreEqual (object obj1, object obj2) 
  =&gt; obj1.Equals (obj2);</pre>
<p>There is one case, however, in which this fails. If the first argument is <code>null</code>, you get a <code>NullReferenceException</code>. Here’s the fix:</p>
<pre data-type="programlisting">public static bool AreEqual (object obj1, object obj2)
{
  <strong>if (obj1 == null) return obj2 == null;</strong>
  return obj1.Equals (obj2);
}</pre>
<p>Or, more succinctly:</p>
<pre data-type="programlisting">public static bool AreEqual (object obj1, object obj2)
  =&gt; obj1 == null ? obj2 == null : obj1.Equals (obj2);</pre>
</div></section>
<section data-pdf-bookmark="The static object.Equals method" data-type="sect3"><div class="sect3" id="the_static_objectdotequals_method">
<h3>The static object.Equals method</h3>
<p><a contenteditable="false" data-primary="Object..." data-secondary="object.Equals static method" data-type="indexterm" id="id2927"/>The <code>object</code> class provides a static helper method that does the work of <code>AreEqual</code> in the preceding example. Its name is <code>Equals</code>—just like the virtual method—but there’s no conflict because it accepts <em>two</em> arguments:</p>
<pre data-type="programlisting">public static bool Equals (object objA, object objB)</pre>
<p>This provides a null-safe equality comparison algorithm for when the types are unknown at compile time:</p>
<pre data-type="programlisting">object x = 3, y = 3;
Console.WriteLine (object.Equals (x, y));   // True
x = null;
Console.WriteLine (object.Equals (x, y));   // False
y = null;
Console.WriteLine (object.Equals (x, y));   // True</pre>
<p>A useful application is when writing generic types. The following code will not compile if <code>object.Equals</code> is replaced with the <code>==</code> or <code>!=</code> operator:</p>
<pre data-type="programlisting">class Test &lt;T&gt;
{
  T _value;
  public void SetValue (T newValue)
  {
    <strong>if (!object.Equals (newValue, _value))</strong>
    {
      _value = newValue;
      OnValueChanged();
    }
  }
  protected virtual void OnValueChanged() { ... }
}</pre>
<p>Operators are prohibited here because the compiler cannot bind to the static method of an unknown type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="EqualityComparer&lt;T&gt;" data-type="indexterm" id="id2928"/>A more elaborate way to implement this comparison is with the <code>EqualityComparer&lt;T&gt;</code> class. This has the advantage of avoiding boxing:</p>
<pre data-type="programlisting">if (!<strong>EqualityComparer&lt;T&gt;.Default.Equals</strong> (newValue, _value))</pre>
<p>We discuss <code>EqualityComparer&lt;T&gt;</code> in more detail in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a> (see <a data-type="xref" href="ch07.html#plugging_in_equality_and_order">“Plugging in Equality and Order”</a>).<a contenteditable="false" data-primary="" data-startref="ch06.html1034" data-type="indexterm" id="id2929"/></p>
</div>
</div></section>
<section data-pdf-bookmark="The static object.ReferenceEquals method" data-type="sect3"><div class="sect3" id="the_static_objectdotreferenceequals_met">
<h3>The static object.ReferenceEquals method</h3>
<p><a contenteditable="false" data-primary="Object..." data-secondary="object.ReferenceEquals method" data-type="indexterm" id="id2930"/>Occasionally, you need to force referential equality comparison. The static <code>object.ReferenceEquals</code> method does just that:</p>
<pre data-type="programlisting">Widget w1 = new Widget();
Widget w2 = new Widget();
<strong>Console.WriteLine (object.ReferenceEquals (w1, w2));     // False</strong>

class Widget { ... }</pre>
<p>You might want to do this because it’s possible for <code>Widget</code> to override the virtual <code>Equals</code> method such that <code>w1.Equals(w2)</code> would return <code>true</code>. Further, it’s possible for <code>Widget</code> to overload the <code>==</code> operator so that <code>w1==w2</code> would also return <code>true</code>. In such cases, calling <code>object.ReferenceEquals</code> guarantees normal referential equality semantics.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another way to force referential equality comparison is to cast the values to <code>object</code> and then apply the <code>==</code> operator.</p>
</div>
</div></section>
<section data-pdf-bookmark="The IEquatable&lt;T&gt; interface" data-type="sect3"><div class="sect3" id="the_iequatableless_thantgreater_than_in">
<h3>The IEquatable&lt;T&gt; interface</h3>
<p><a contenteditable="false" data-primary="IEquatable&lt;T&gt;" data-type="indexterm" id="id2931"/>A consequence of calling <code>object.Equals</code> is that it forces boxing on value types. This is undesirable in highly performance-sensitive scenarios because boxing is relatively expensive compared to the actual comparison. A solution was introduced in C# 2.0, with the <code>IEquatable&lt;T&gt;</code> interface:</p>
<pre data-type="programlisting">public interface IEquatable&lt;T&gt;
{
  bool Equals (T other);
}</pre>
<p>The idea is that <code>IEquatable&lt;T&gt;</code>, when implemented, gives the same result as calling <code>object</code>’s virtual <code>Equals</code> method—but more quickly. Most basic .NET types implement <code>IEquatable&lt;T&gt;</code>. You can use <code>IEquatable&lt;T&gt;</code> as a constraint in a generic type:</p>
<pre data-type="programlisting">class Test&lt;T&gt; <strong>where T : IEquatable&lt;T&gt;</strong>
{
  public bool IsEqual (T a, T b)
  {
    return <strong>a.Equals (b)</strong>;     // No boxing with generic T
  }
}</pre>
<p>If we remove the generic constraint, the class would still compile, but <code>a.Equals(b)</code> would instead bind to the slower <code>object.Equals</code> (slower assuming <code>T</code> was a value type).</p>
</div></section>
<section data-pdf-bookmark="When Equals and == are not equal" data-type="sect3"><div class="sect3" id="when_equals_and_equalsequals_are_not_eq">
<h3>When Equals and == are not equal</h3>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="Equals method versus" data-type="indexterm" id="id2932"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="Equals method versus" data-type="indexterm" id="id2933"/><a contenteditable="false" data-primary="Equals method" data-secondary="equality operator (==) versus" data-type="indexterm" id="id2934"/>We said earlier that it’s sometimes useful for <code>==</code> and <code>Equals</code> to apply different definitions of equality. For example:</p>
<pre data-type="programlisting">double x = double.NaN;
Console.WriteLine (x == x);            // <strong>False</strong>
Console.WriteLine (x.Equals (x));      // True</pre>
<p>The <code>double</code> type’s <code>==</code> operator enforces that one <code>NaN</code> can never equal anything <span class="keep-together">else—even</span> another <code>NaN</code>. This is most natural from a mathematical perspective, and it reflects the underlying CPU behavior. The <code>Equals</code> method, however, is obliged to apply <em>reflexive</em> equality; in other words:</p>
<ul class="simplelist">
<li><p><code>x.Equals (x)</code> must <em>always</em> return true.</p></li>
</ul>
<p>Collections and dictionaries rely on <code>Equals</code> behaving this way; otherwise, they could not find an item they previously stored.</p>
<p>Having <code>Equals</code> and <code>==</code> apply different definitions of equality is actually quite rare with value types. A more common scenario is with reference types; this happens when the author customizes <code>Equals</code> so that it performs value equality while leaving <code>==</code> to perform (default) referential equality. The <code>StringBuilder</code> class does exactly that:</p>
<pre data-type="programlisting">var sb1 = new StringBuilder ("foo");
var sb2 = new StringBuilder ("foo");
Console.WriteLine (sb1 == sb2);          // False <em>(referential equality)</em>
Console.WriteLine (sb1.Equals (sb2));    // True  <em>(value equality)</em></pre>
<p>Let’s now look at how to customize equality.<a contenteditable="false" data-primary="" data-startref="ch06.html1033" data-type="indexterm" id="id2935"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Equality and Custom Types" data-type="sect2"><div class="sect2" id="equality_and_custom_types">
<h2>Equality and Custom Types</h2>
<p><a contenteditable="false" data-primary="custom types" data-secondary="equality and" data-type="indexterm" id="ch06.html1035"/><a contenteditable="false" data-primary="equality comparison" data-secondary="equality and custom types" data-type="indexterm" id="ch06.html1036"/>Recall default equality comparison behavior:</p>
<ul>
<li><p>Value types use <em>value equality</em>.</p></li>
<li><p>Reference types use <em>referential equality</em> unless overridden (as is the case with anonymous types and records).</p></li>
</ul>
<p>Further:</p>
<ul>
<li><p>A struct’s <code>Equals</code> method applies <em>structural value equality</em> by default (i.e., it compares each field in the struct).</p></li>
</ul>
<p>Sometimes, it makes sense to override this behavior when writing a type. There are two cases for doing so:</p>
<ul>
<li><p>To change the meaning of equality</p></li>
<li><p>To speed up equality comparisons for structs</p></li>
</ul>
<section data-pdf-bookmark="Changing the meaning of equality" data-type="sect3"><div class="sect3" id="changing_the_meaning_of_equality">
<h3>Changing the meaning of equality</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="changing the meaning of equality" data-type="indexterm" id="id2936"/>Changing the meaning of equality makes sense when the default behavior of <code>==</code> and <code>Equals</code> is unnatural for your type and is <em>not what a consumer would expect</em>. An example is <code>DateTimeOffset</code>, a struct with two private fields: a UTC <code>DateTime</code> and a numeric integer offset. If you were writing this type, you’d probably want to ensure that equality comparisons considered only the UTC <code>DateTime</code> field and not the offset field. Another example is numeric types that support <code>NaN</code> values such as <code>float</code> and <code>double</code>. If you were implementing such types yourself, you’d want to ensure that <code>NaN</code>-comparison logic was supported in equality comparisons.</p>
<p>With classes, it’s sometimes more natural to offer <em>value equality</em> as the default instead of <em>referential equality</em>. This is often the case with small classes that hold a simple piece of data, such as <code>System.Uri</code> (or <code>System.String</code>).</p>
<p>With records, the compiler automatically implements structural equality (by comparing each field). Sometimes, however, this will include fields that you don’t want to compare, or objects that require special comparison logic, such as collections. The process of overriding equality with records is slightly different because records follow a special pattern that’s designed to play well with its rules for inheritance.</p>
</div></section>
<section data-pdf-bookmark="Speeding up equality comparisons with structs" data-type="sect3"><div class="sect3" id="speeding_up_equality_comparisons_with_s">
<h3>Speeding up equality comparisons with structs</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="speeding up with structs" data-type="indexterm" id="id2937"/><a contenteditable="false" data-primary="structs" data-secondary="speeding up equality comparison with" data-type="indexterm" id="id2938"/>The default <em>structural equality</em> comparison algorithm for structs is relatively slow. Taking over this process by overriding <code>Equals</code> can improve performance by a factor of five. Overloading the <code>==</code> operator and implementing <code>IEquatable&lt;T&gt;</code> allows unboxed equality comparisons, and this can speed things up by a factor of five again.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Overriding equality semantics for reference types doesn’t benefit performance. The default algorithm for referential equality comparison is already very fast because it simply compares two 32- or 64-bit references.</p>
</div>
<p>There’s another, rather peculiar case for customizing equality, and that’s to improve a struct’s hashing algorithm for better performance in a hashtable. This comes as a result of the fact that equality comparison and hashing are joined at the hip. We examine hashing in a moment.</p>
</div></section>
<section data-pdf-bookmark="How to override equality semantics" data-type="sect3"><div class="sect3" id="how_to_override_equality_semantics">
<h3>How to override equality semantics</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="overriding equality semantics" data-type="indexterm" id="id2939"/>To override equality with classes or structs, here are the steps:</p>
<ol>
<li><p>Override <code>GetHashCode()</code> and <code>Equals()</code>.</p></li>
<li><p>(Optionally) overload <code>!=</code> and <code>==</code>.</p></li>
<li><p>(Optionally) implement <code>IEquatable&lt;T&gt;</code>.</p></li>
</ol>
<p>The process is different (and simpler) with records because the compiler already overrides the equality methods and operators in line with its own special pattern. If you want to intervene, you must conform to this pattern, which means writing an <code>Equals</code> method with a signature like this:</p>
<pre data-type="programlisting">record Test (int X, int Y)
{
  <strong>public virtual bool Equals (Test t)</strong> =&gt; t != null &amp;&amp; t.X == X &amp;&amp; t.Y == Y;
}</pre>
<p>Notice that <code>Equals</code> is <code>virtual</code> (not <code>override</code>) and accepts the actual record type (<code>Test</code> in this case, and not <code>object</code>). The compiler will recognize that your method has the “correct” signature and will patch it in.</p>
<p>You must also override <code>GetHashCode()</code>, just as you would with classes or structs. You don’t need to (and shouldn’t) overload <code>!=</code> and <code>==</code>, or implement <code>IEquatable&lt;T&gt;</code>, because this is already done for you.</p>
</div></section>
<section data-pdf-bookmark="Overriding GetHashCode" data-type="sect3"><div class="sect3" id="overriding_gethashcode">
<h3>Overriding GetHashCode</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="overriding GetHashCode" data-type="indexterm" id="id2940"/><a contenteditable="false" data-primary="Get..." data-secondary="GetHashCode" data-type="indexterm" id="id2941"/><a contenteditable="false" data-primary="hashcode" data-type="indexterm" id="id2942"/><a contenteditable="false" data-primary="System..." data-secondary="System.Object" data-type="indexterm" id="id2943"/>It might seem odd that <code>System.Object</code>—with its small footprint of members—defines a method with a specialized and narrow purpose. <code>GetHashCode</code> is a virtual method in <code>Object</code> that fits this description; it exists primarily for the benefit of just the following two types:</p>
<pre data-type="programlisting">System.Collections.Hashtable
System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;</pre>
<p>These are <em>hashtables</em>—collections for which each element has a key used for storage and retrieval. A hashtable applies a very specific strategy for efficiently allocating elements based on their key. This requires that each key have an <code>Int32</code> number, or <em>hash code</em>. The hash code need not be unique for each key, but should be as varied as possible for good hashtable performance. Hashtables are considered important enough that <code>GetHashCode</code> is defined in <code>System.Object</code>—so that every type can emit a hash code.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We describe hashtables in detail in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>.</p>
</div>
<p>Both reference and value types have default implementations of <code>GetHashCode</code>, meaning that you don’t need to override this method—<em>unless you override</em> <code>Equals</code>. (And if you override <code>GetHashCode</code>, you will almost certainly want to also override <code>Equals</code>.)</p>
<p>Here are the other rules for overriding <code>object.GetHashCode</code>:</p>
<ul>
<li><p>It must return the same value on two objects for which <code>Equals</code> returns <code>true</code> (hence, <code>GetHashCode</code> and <code>Equals</code> are overridden together).</p></li>
<li><p>It must not throw exceptions.</p></li>
<li><p>It must return the same value if called repeatedly on the same object (unless the object has <em>changed</em>).</p></li>
</ul>
<p><a contenteditable="false" data-primary="hashtables" data-type="indexterm" id="id2944"/>For maximum performance in hashtables, you should write <code>GetHashCode</code> so as to minimize the likelihood of two different values returning the same hashcode. This gives rise to the third reason for overriding <code>Equals</code> and <code>GetHashCode</code> on structs, which is to provide a more efficient hashing algorithm than the default. The default implementation for structs is at the discretion of the runtime and can be based on every field in the struct.</p>
<p>In contrast, the default <code>GetHashCode</code> implementation for <em>classes</em> is based on an internal object token, which is unique for each instance in the CLR’s current <span class="keep-together">implementation</span>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If an object’s hashcode changes after it’s been added as a key to a dictionary, the object will no longer be accessible in the dictionary. You can preempt this by basing hashcode calculations on immutable fields.</p>
</div>
<p>We provide a complete example illustrating how to override <code>GetHashCode</code> shortly.</p>
</div></section>
<section data-pdf-bookmark="Overriding Equals" data-type="sect3"><div class="sect3" id="overriding_equals">
<h3>Overriding Equals</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="overriding Equals" data-type="indexterm" id="id2945"/><a contenteditable="false" data-primary="Object..." data-secondary="object.Equals static method" data-type="indexterm" id="id2946"/>The axioms for <code>object.Equals</code> are as follows:</p>
<ul>
<li><p>An object cannot equal <code>null</code> (unless it’s a nullable type).</p></li>
<li><p>Equality is <em>reflexive</em> (an object equals itself).</p></li>
<li><p>Equality is <em>commutative</em> (if <code>a.Equals(b)</code>, then <code>b.Equals(a)</code>).</p></li>
<li><p>Equality is <em>transitive</em> (if <code>a.Equals(b)</code> and <code>b.Equals(c)</code>, then <code>a.Equals(c)</code>).</p></li>
<li><p>Equality operations are repeatable and reliable (they don’t throw exceptions).</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Overloading == and !=" data-type="sect3"><div class="sect3" id="overloading_equalsequals_and_exclamatio">
<h3>Overloading == and !=</h3>
<p><a contenteditable="false" data-primary="!= (inequality operator)" data-type="indexterm" id="id2947"/><a contenteditable="false" data-primary="== (equality operator)" data-secondary="overloading" data-type="indexterm" id="id2948"/><a contenteditable="false" data-primary="equality comparison" data-secondary="overloading == and !=" data-type="indexterm" id="id2949"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="overloading" data-type="indexterm" id="id2950"/><a contenteditable="false" data-primary="inequality operator (!=)" data-type="indexterm" id="id2951"/><a contenteditable="false" data-primary="overloading" data-secondary="equality operator (==)" data-type="indexterm" id="id2952"/>In addition to overriding <code>Equals</code>, you can optionally overload the equality and inequality operators. This is nearly always done with structs because the consequence of not doing so is that the <code>==</code> and <code>!=</code> operators will simply not work on your type.</p>
<p>With classes, there are two ways to proceed:</p>
<ul>
<li><p>Leave <code>==</code> and <code>!=</code> alone—so that they apply referential equality.</p></li>
<li><p>Overload <code>==</code> and <code>!=</code> in line with <code>Equals</code>.</p></li>
</ul>
<p>The first approach is most common with custom types—especially <em>mutable</em> types. It ensures that your type follows the expectation that <code>==</code> and <code>!=</code> should exhibit referential equality with reference types, and this avoids confusing consumers. We saw an example earlier:</p>
<pre data-type="programlisting">var sb1 = new StringBuilder ("foo");
var sb2 = new StringBuilder ("foo");
Console.WriteLine (sb1 == sb2);          // False <em>(referential equality)</em>
Console.WriteLine (sb1.Equals (sb2));    // True  <em>(value equality)</em></pre>
<p>The second approach makes sense with types for which a consumer would never want referential equality. These are typically immutable—such as the <code>string</code> and <code>System.Uri</code> classes—and are sometimes good candidates for <code>struct</code>s.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although it’s possible to overload <code>!=</code> such that it means something other than <code>!(==)</code>, this is rarely done in practice. An example is with the types defined in the <code>System.Data.SqlTypes</code> namespace that represent native column types in SQL Server. These follow the null comparison logic of databases, whereby the <code>=</code> and <code>&lt;&gt;</code> operators (<code>==</code> and <code>!=</code> in C#) both return null if either operand is null.</p>
</div>
</div></section>
<section data-pdf-bookmark="Implementing IEquatable&lt;T&gt;" data-type="sect3"><div class="sect3" id="implementing_iequatableless_thantgreate">
<h3>Implementing IEquatable&lt;T&gt;</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="implementing IEquatable&lt;T&gt;" data-type="indexterm" id="id2953"/><a contenteditable="false" data-primary="IEquatable&lt;T&gt;" data-type="indexterm" id="id2954"/>For completeness, it’s also good to implement <code>IEquatable&lt;T&gt;</code> when overriding <code>Equals</code>. Its results should always match those of the overridden object’s <code>Equals</code> method. Implementing <code>IEquatable&lt;T&gt;</code> comes at no programming cost if you structure your <code>Equals</code> method implementation as in the example that follows in a moment.</p>
</div></section>
<section data-pdf-bookmark="An example: the Area struct" data-type="sect3"><div class="sect3" id="an_example_the_area_struct">
<h3>An example: the Area struct</h3>
<p>Imagine that we need a struct to represent an area whose width and height are interchangeable. In other words, 5 × 10 is equal to 10 × 5. (Such a type would be suitable in an algorithm that arranges rectangular shapes.)</p>
<p>Here’s the complete code:</p>
<pre data-type="programlisting">public struct Area : IEquatable &lt;Area&gt;
{
  public readonly int Measure1;
  public readonly int Measure2;

  public Area (int m1, int m2)
  {
    Measure1 = Math.Min (m1, m2);
    Measure2 = Math.Max (m1, m2);
  }

  public override bool Equals (object other)
    =&gt; other is Area a &amp;&amp; Equals (a);    // Calls method below

  public bool Equals (Area other)        // Implements IEquatable&lt;Area&gt;
    =&gt; Measure1 == other.Measure1 &amp;&amp; Measure2 == other.Measure2;

  public override int GetHashCode()
    =&gt; HashCode.Combine (Measure1, Measure2);

  // Note that we call the static Equals method in the object class: this
  // does null checking before calling our own (instance) Equals method.
  public static bool operator == (Area a1, Area a2) =&gt; Equals (a1, a2);

  public static bool operator != (Area a1, Area a2) =&gt; !(a1 == a2);
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From C# 10, you can shortcut the process with records. By declaring this as a <code>record struct</code>, you can remove all the code following the constructor.</p>
</div>
<p>In implementing <code>GetHashCode</code>, we used .NET’s <code>HashCode.Combine</code> function to produce a composite hashcode. (Before that function existed, a popular approach was to multiply each value by some prime number and then add them together.)</p>
<p>Here’s a demonstration of the <code>Area</code> struct:</p>
<pre data-type="programlisting">Area a1 = new Area (5, 10);
Area a2 = new Area (10, 5);
Console.WriteLine (a1.Equals (a2));    // True
Console.WriteLine (a1 == a2);          // True</pre>
</div></section>
<section data-pdf-bookmark="Pluggable equality comparers" data-type="sect3"><div class="sect3" id="pluggable_equality_comparers">
<h3>Pluggable equality comparers</h3>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="pluggable equality operators" data-type="indexterm" id="id2955"/><a contenteditable="false" data-primary="IEqualityComparer" data-type="indexterm" id="id2956"/>If you want a type to take on different equality semantics just for a specific scenario, you can use a pluggable <code>IEqualityComparer</code>. This is particularly useful in conjunction with the standard collection classes, and we describe it in the following chapter, in <a data-type="xref" href="ch07.html#plugging_in_equality_and_order">“Plugging in Equality and Order”</a>.<a contenteditable="false" data-primary="" data-startref="ch06.html1036" data-type="indexterm" id="id2957"/><a contenteditable="false" data-primary="" data-startref="ch06.html1035" data-type="indexterm" id="id2958"/><a contenteditable="false" data-primary="" data-startref="ch06.html1032" data-type="indexterm" id="id2959"/><a contenteditable="false" data-primary="" data-startref="ch06.html1031" data-type="indexterm" id="id2960"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Order Comparison" data-type="sect1"><div class="sect1" id="order_comparison">
<h1>Order Comparison</h1>
<p><a contenteditable="false" data-primary="order comparison" data-type="indexterm" id="ch06.html1037"/>As well as defining standard protocols for equality, C# and .NET define two standard protocols for determining the order of one object relative to another:</p>
<ul>
<li><p>The <code>IComparable</code> interfaces (<code>IComparable</code> and <code>IComparable&lt;T&gt;</code>)</p></li>
<li><p>The <code>&gt;</code> and <code>&lt;</code> operators</p></li>
</ul>
<p>The <code>IComparable</code> interfaces are used by general-purpose sorting algorithms. In the following example, the static <code>Array.Sort</code> method works because <code>System.String</code> implements the <code>IComparable</code> interfaces:</p>
<pre data-type="programlisting">string[] colors = { "Green", "Red", "Blue" };
<strong>Array.Sort (colors);</strong>
foreach (string c in colors) Console.Write (c + " ");   // Blue Green Red</pre>
<p><a contenteditable="false" data-primary="&lt; (comparison operator)" data-type="indexterm" id="id2961"/><a contenteditable="false" data-primary="&gt; (comparison operator)" data-type="indexterm" id="id2962"/><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="id2963"/>The <code>&lt;</code> and <code>&gt;</code> operators are more specialized, and they are intended mostly for numeric types. Because they are statically resolved, they can translate to highly efficient bytecode, suitable for computationally intensive algorithms.</p>
<p><a contenteditable="false" data-primary="IComparer" data-type="indexterm" id="id2964"/>.NET also provides pluggable ordering protocols, via the <code>IComparer</code> interfaces. We describe these in the final section of <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>.</p>
<section class="pagebreak-before" data-pdf-bookmark="IComparable" data-type="sect2"><div class="sect2" id="icomparable">
<h2 class="less_space">IComparable</h2>
<p><a contenteditable="false" data-primary="IComparable interface" data-type="indexterm" id="id2965"/><a contenteditable="false" data-primary="order comparison" data-secondary="IComparable interface" data-type="indexterm" id="id2966"/>The <code>IComparable</code> interfaces are defined as follows:</p>
<pre data-type="programlisting">public interface IComparable       { int CompareTo (object other); }
public interface IComparable&lt;in T&gt; { int CompareTo (T other);      }</pre>
<p>The two interfaces represent the same functionality. With value types, the generic type-safe interface is faster than the nongeneric interface. In both cases, the <code>CompareTo</code> method works as follows:</p>
<ul>
<li><p>If <code>a</code> comes after <code>b</code>, <code>a.CompareTo(b)</code> returns a positive number.</p></li>
<li><p>If <code>a</code> is the same as <code>b</code>, <code>a.CompareTo(b)</code> returns <code>0</code>.</p></li>
<li><p>If <code>a</code> comes before <code>b</code>, <code>a.CompareTo(b)</code> returns a negative number.</p></li>
</ul>
<p>For example:</p>
<pre data-type="programlisting">Console.WriteLine ("Beck".CompareTo ("Anne"));       // 1
Console.WriteLine ("Beck".CompareTo ("Beck"));       // 0
Console.WriteLine ("Beck".CompareTo ("Chris"));      // -1</pre>
<p>Most of the base types implement both <code>IComparable</code> interfaces. These interfaces are also sometimes implemented when writing custom types. We provide an example shortly.</p>
<section data-pdf-bookmark="IComparable versus Equals" data-type="sect3"><div class="sect3" id="icomparable_versus_equals">
<h3>IComparable versus Equals</h3>
<p><a contenteditable="false" data-primary="Equals method" data-secondary="IComparable versus" data-type="indexterm" id="id2967"/><a contenteditable="false" data-primary="IComparable interface" data-secondary="Equals versus" data-type="indexterm" id="id2968"/>Consider a type that both overrides <code>Equals</code> and implements the <code>IComparable</code> interfaces. You’d expect that when <code>Equals</code> returns <code>true</code>, <code>CompareTo</code> should return <code>0</code>. And you’d be right. But here’s the catch:</p>
<ul class="simplelist">
<li><p>When <code>Equals</code> returns <code>false</code>, <code>CompareTo</code> can return what it likes (as long as it’s internally consistent)!</p></li>
</ul>
<p>In other words, equality can be “fussier” than comparison, but not vice versa (violate this and sorting algorithms will break). So, <code>CompareTo</code> can say, “All objects are equal,” whereas <code>Equals</code> says, “But some are more equal than others!”</p>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.String" data-type="indexterm" id="id2969"/>A great example of this is <code>System.String</code>. <code>String</code>’s <code>Equals</code> method and <code>==</code> operator use <em>ordinal</em> comparison, which compares the Unicode point values of each character. Its <code>CompareTo</code> method, however, uses a <em>culture-dependent</em> comparison, which sometimes puts more than one character into the same sorting position.</p>
<p>In <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>, we discuss the pluggable ordering protocol, <code>IComparer</code>, which allows you to specify an alternative ordering algorithm when sorting or instantiating a sorted collection. A custom <code>IComparer</code> can further extend the gap between <code>CompareTo</code> and <code>Equals</code>—a case-insensitive string comparer, for instance, will return <code>0</code> when comparing <code>"A"</code> and <code>"a"</code>. The reverse rule still applies, however: <code>CompareTo</code> can never be fussier than <code>Equals</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When implementing the <code>IComparable</code> interfaces in a custom type, you can avoid running afoul of this rule by writing the first line of <code>CompareTo</code> as follows:</p>
<pre data-type="programlisting">if (Equals (other)) return 0;</pre>
<p>After that, it can return what it likes, as long as it’s consistent!</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="&lt; and &gt;" data-type="sect2"><div class="sect2" id="less_than_and_greater_than">
<h2>&lt; and &gt;</h2>
<p><a contenteditable="false" data-primary="&lt; (comparison operator)" data-type="indexterm" id="id2970"/><a contenteditable="false" data-primary="&gt; (comparison operator)" data-type="indexterm" id="id2971"/><a contenteditable="false" data-primary="order comparison" data-secondary="&lt;and&gt;" data-type="indexterm" id="id2972"/>Some types define <code>&lt;</code> and <code>&gt;</code> operators; for instance:</p>
<pre data-type="programlisting">bool after2010 = DateTime.Now &gt; new DateTime (2010, 1, 1);</pre>
<p>You can expect the <code>&lt;</code> and <code>&gt;</code> operators, when implemented, to be functionally consistent with the <code>IComparable</code> interfaces. This is standard practice across .NET.</p>
<p>It’s also standard practice to implement the <code>IComparable</code> interfaces whenever <code>&lt;</code> and <code>&gt;</code> are overloaded, although the reverse is not true. In fact, most .NET types that implement <code>IComparable</code> <em>do not</em> overload <code>&lt;</code> and <code>&gt;</code>. This differs from the situation with equality for which it’s normal to overload <code>==</code> when overriding <code>Equals</code>.</p>
<p>Typically, <code>&gt;</code> and <code>&lt;</code> are overloaded only when:</p>
<ul>
<li><p>A type has a strong intrinsic concept of “greater than” and “less than” (versus <code>IComparable</code>’s broader concepts of “comes before” and “comes after”).</p></li>
<li><p>There is only one way <em>or context</em> in which to perform the comparison.</p></li>
<li><p>The result is invariant across cultures.</p></li>
</ul>
<p><code>System.String</code> doesn’t satisfy the last point: the results of string comparisons can vary according to language. Hence, <code>string</code> doesn’t support the <code>&gt;</code> and <code>&lt;</code> operators:</p>
<pre data-type="programlisting">bool error = "Beck" &gt; "Anne";       // Compile-time error</pre>
</div></section>
<section data-pdf-bookmark="Implementing the IComparable Interfaces" data-type="sect2"><div class="sect2" id="implementing_the_icomparable_interfaces">
<h2>Implementing the IComparable Interfaces</h2>
<p><a contenteditable="false" data-primary="IComparable interface" data-secondary="implementing" data-type="indexterm" id="id2973"/><a contenteditable="false" data-primary="order comparison" data-secondary="implementing IComparable interfaces" data-type="indexterm" id="id2974"/>In the following struct representing a musical note, we implement the <code>IComparable</code> interfaces as well as overloading the <code>&lt;</code> and <code>&gt;</code> operators. For completeness, we also override <code>Equals</code>/<code>GetHashCode</code> and overload <code>==</code> and <code>!=</code>:<a contenteditable="false" data-primary="" data-startref="ch06.html1037" data-type="indexterm" id="id2975"/></p>
<pre data-type="programlisting">public struct Note : IComparable&lt;Note&gt;, IEquatable&lt;Note&gt;, IComparable
{
  int _semitonesFromA;
  public int SemitonesFromA { get { return _semitonesFromA; } }

  public Note (int semitonesFromA)
  {
    _semitonesFromA = semitonesFromA;
  }

  public int CompareTo (Note other)            // Generic IComparable&lt;T&gt;
  {
    if (Equals (other)) return 0;    // Fail-safe check
    return _semitonesFromA.CompareTo (other._semitonesFromA);
  }

  int IComparable.CompareTo (object other)     // Nongeneric IComparable
  {
    if (!(other is Note))
      throw new InvalidOperationException ("CompareTo: Not a note");
    return CompareTo ((Note) other);
  }

  public static bool operator &lt; (Note n1, Note n2)
     =&gt; n1.CompareTo (n2) &lt; 0;

  public static bool operator &gt; (Note n1, Note n2)
    =&gt; n1.CompareTo (n2) &gt; 0;

  public bool Equals (Note other)    // for IEquatable&lt;Note&gt;
    =&gt; _semitonesFromA == other._semitonesFromA;

  public override bool Equals (object other)
  {
    if (!(other is Note)) return false;
    return Equals ((Note) other);
  }

  public override int GetHashCode() =&gt; _semitonesFromA.GetHashCode();

  // Call the static Equals method to ensure nulls are properly handled:
  public static bool operator == (Note n1, Note n2) =&gt; Equals (n1, n2);

  public static bool operator != (Note n1, Note n2) =&gt; !(n1 == n2);
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Utility Classes" data-type="sect1"><div class="sect1" id="utility_classes">
<h1>Utility Classes</h1>
<section data-pdf-bookmark="Console" data-type="sect2"><div class="sect2" id="console">
<h2>Console</h2>
<p><a contenteditable="false" data-primary="Console class" data-type="indexterm" id="id2976"/><a contenteditable="false" data-primary="utility classes" data-secondary="Console" data-type="indexterm" id="id2977"/><a contenteditable="false" data-primary="utility classes" data-type="indexterm" id="ch06.html1038"/>The static <code>Console</code> class handles standard input/output for console-based applications. In a command-line (console) application, the input comes from the keyboard via <code>Read</code>, <code>ReadKey</code>, and <code>ReadLine</code>, and the output goes to the text window via <code>Write</code> and <code>WriteLine</code>. You can control the window’s position and dimensions with the properties <code>WindowLeft</code>, <code>WindowTop</code>, <code>WindowHeight</code>, and <code>WindowWidth</code>. You can also change the <code>BackgroundColor</code> and <code>ForegroundColor</code> properties and manipulate the cursor with the <code>CursorLeft</code>, <code>CursorTop</code>, and <code>CursorSize</code> properties:</p>
<pre data-type="programlisting">Console.WindowWidth = Console.LargestWindowWidth;
Console.ForegroundColor = ConsoleColor.Green;
Console.Write ("test... 50%");
Console.CursorLeft -= 3;
Console.Write ("90%");     // test... 90%</pre>
<p>The <code>Write</code> and <code>WriteLine</code> methods are overloaded to accept a composite format string (see <code>String.Format</code> in <a data-type="xref" href="#string_and_text_handling">“String and Text Handling”</a>). <span class="keep-together">However,</span> neither method accepts a format provider, so you’re stuck with <code>CultureInfo​.Cur⁠rentCulture</code>. (The workaround, of course, is to explicitly call <code>string.Format</code>.)</p>
<p>The <code>Console.Out</code> property returns a <code>TextWriter</code>. Passing <code>Console.Out</code> to a method that expects a <code>TextWriter</code> is a useful way to get that method to write to the <code>Console</code> for diagnostic purposes.</p>
<p>You can also redirect the <code>Console</code>’s input and output streams via the <code>SetIn</code> and <code>SetOut</code> methods:</p>
<pre data-type="programlisting">// First save existing output writer:
System.IO.TextWriter oldOut = Console.Out;

// Redirect the console's output to a file:
using (System.IO.TextWriter w = System.IO.File.CreateText
                                ("e:\\output.txt"))
{
  Console.SetOut (w);
  Console.WriteLine ("Hello world");
}

// Restore standard console output
Console.SetOut (oldOut);</pre>
<p>In <a data-type="xref" href="ch15.html#streams_and_isoliduso">Chapter 15</a>, we describe how streams and text writers work.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When running WPF or Windows Forms applications under Visual Studio, the <code>Console</code>’s output is automatically redirected to Visual Studio’s output window (in debug mode). This can make <code>Console.Write</code> useful for diagnostic purposes; although in most cases, the <code>Debug</code> and <code>Trace</code> classes in the <code>System.Diagnostics</code> namespace are more appropriate (see <a data-type="xref" href="ch13.html#diagnostic">Chapter 13</a>).</p>
</div>
</div></section>
<section data-pdf-bookmark="Environment" data-type="sect2"><div class="sect2" id="environment">
<h2>Environment</h2>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Environment class" data-type="indexterm" id="id2978"/><a contenteditable="false" data-primary="utility classes" data-secondary="Environment" data-type="indexterm" id="id2979"/>The static <code>System.Environment</code> class provides a range of useful properties:</p>
<dl>
<dt>Files and folders</dt>
<dd><code>CurrentDirectory</code>, <code>SystemDirectory</code>, <code>CommandLine</code></dd>
<dt>Computer and operating system</dt>
<dd><code>MachineName</code>, <code>ProcessorCount</code>, <code>OSVersion</code>,<code> NewLine</code></dd>
<dt>User logon</dt>
<dd><code>UserName</code>, <code>UserInteractive</code>, <code>UserDomainName</code></dd>
<dt>Diagnostics</dt>
<dd><code>TickCount</code>, <code>StackTrace</code>, <code>WorkingSet</code>, <code>Version</code></dd>
</dl>
<p>You can obtain additional folders by calling <code>GetFolderPath</code>; we describe this in <a data-type="xref" href="ch15.html#file_and_directory_operations">“File and Directory Operations”</a> in <a data-type="xref" href="ch15.html#streams_and_isoliduso">Chapter 15</a>.</p>
<p>You can access OS environment variables (what you see when you type “set” at the command prompt) with the following three methods: <code>GetEnvironmentVariable</code>, <code>GetEnvironmentVariables</code>, and <code>SetEnvironmentVariable</code>.</p>
<p>The <code>ExitCode</code> property lets you set the return code—for when your program is called from a command or batch file—and the <code>FailFast</code> method terminates a program immediately, without performing cleanup.</p>
<p>The <code>Environment</code> class available to Windows Store apps offers just a limited number of members (<code>ProcessorCount</code>, <code>NewLine</code>, and <code>FailFast</code>).</p>
</div></section>
<section data-pdf-bookmark="Process" data-type="sect2"><div class="sect2" id="process">
<h2>Process</h2>
<p><a contenteditable="false" data-primary="Process" data-type="indexterm" id="ch06.html1039"/><a contenteditable="false" data-primary="System..." data-secondary="System.Diagnostics" data-type="indexterm" id="ch06.html1040"/><a contenteditable="false" data-primary="utility classes" data-secondary="Process" data-type="indexterm" id="ch06.html1041"/>The <code>Process</code> class in <code>System.Diagnostics</code> allows you to launch a new process. (In <a data-type="xref" href="ch13.html#diagnostic">Chapter 13</a>, we describe how you can also use it to interact with other processes running on the computer).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>For security reasons, the <code>Process</code> class is not available to Windows Store apps, and you cannot start arbitrary processes. Instead, you must use the <code>Windows.System.Launcher</code> class to “launch” a URI or file to which you have access; for example:</p>
<pre data-type="programlisting">Launcher.LaunchUriAsync (new Uri ("http://albahari.com"));

var file = await KnownFolders.DocumentsLibrary
                             .GetFileAsync ("foo.txt");
Launcher.LaunchFileAsync (file);</pre>
<p>This opens the URI or file, using whatever program is associated with the URI scheme or file extension. Your program must be in the foreground for this to work.</p>
</div>
<p>The static <code>Process.Start</code> method has several overloads; the simplest accepts a simple filename with optional arguments:</p>
<pre data-type="programlisting">Process.Start ("notepad.exe");
Process.Start ("notepad.exe", "e:\\file.txt");</pre>
<p>The most flexible overload accepts a <code>ProcessStartInfo</code> instance. With this, you can capture and redirect the launched process’s input, output, and error output (if you leave <code>UseShellExecute</code> as <code>false</code>). The following captures the output of calling <code>ipconfig</code>:</p>
<pre data-type="programlisting">ProcessStartInfo psi = new ProcessStartInfo
{
  FileName = "cmd.exe",
  Arguments = "/c ipconfig /all",
  RedirectStandardOutput = true,
  UseShellExecute = false
};
Process p = Process.Start (psi);
string result = p.StandardOutput.ReadToEnd();
Console.WriteLine (result);</pre>
<p>If you don’t redirect output, <code>Process.Start</code> executes the program in parallel to the caller. If you want to wait for the new process to complete, you can call <code>WaitForExit</code> on the <code>Process</code> object, with an optional timeout.</p>
<section data-pdf-bookmark="Redirecting output and error streams" data-type="sect3"><div class="sect3" id="redirecting_output_and_error_streams">
<h3>Redirecting output and error streams</h3>
<p><a contenteditable="false" data-primary="Process" data-secondary="redirecting output and error streams" data-type="indexterm" id="id2980"/>With <code>UseShellExecute</code> false (the default in .NET), you can capture the standard input, output, and error streams and then write/read these streams via the <code>StandardInput</code>, <code>StandardOutput</code>, and <code>StandardError</code> properties.</p>
<p>A difficulty arises when you need to redirect both the standard output and standard error streams, in that you can’t usually know in which order to read data from each (because you don’t know in advance how the data will be interleaved). The solution is to read from both streams at once, which you can accomplish by reading from (at least) one of the streams <em>asynchronously</em>. Here’s how to do this:</p>
<ul>
<li><p>Handle the <code>OutputDataReceived</code> and/or <code>ErrorDataReceived</code> events. These events fire when output/error data is received.</p></li>
<li><p>Call <code>BeginOutputReadLine</code> and/or <code>BeginErrorReadLine</code>. This enables the aforementioned events.</p></li>
</ul>
<p>The following method runs an executable while capturing both the output and error streams:</p>
<pre data-type="programlisting">(string output, string errors) Run (string exePath, string args = "")
{
  using var p = Process.Start (new ProcessStartInfo (exePath, args)
  {
    RedirectStandardOutput = true,
    RedirectStandardError = true,
    UseShellExecute = false,    
  });
  
  var errors = new StringBuilder ();

  // Read from the error stream asynchronously...
  p.<strong>ErrorDataReceived</strong> += (sender, errorArgs) =&gt;
  {
    if (errorArgs.Data != null) <strong>errors.AppendLine (errorArgs.Data)</strong>;
  };
  p.BeginErrorReadLine ();
  
  // ...while we read from the output stream synchronously:
  string output = <strong>p.StandardOutput.ReadToEnd()</strong>;

  p.WaitForExit();
  return (output, errors.ToString());
}</pre>
</div></section>
<section data-pdf-bookmark="UseShellExecute" data-type="sect3"><div class="sect3" id="useshellexecute">
<h3>UseShellExecute</h3>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a contenteditable="false" data-primary="UseShellExecute" data-type="indexterm" id="id2981"/>In .NET 5+ (and .NET Core), the default for <code>UseShellExecute</code> is false, whereas in .NET Framework, it was true. Because this is a breaking change, it’s worth checking all calls to <code>Process.Start</code> when porting code from .NET Framework.</p>
</div>
<p>The <code>UseShellExecute</code> flag changes how the CLR starts the process. With <code>UseShellExecute</code> true, you can do the following:</p>
<ul>
<li><p>Specify a path to a file or document rather than an executable (resulting in the operating system opening the file or document with its associated application)</p></li>
<li><p>Specify a URL (resulting in the operating system navigating to that URL in the default web browser)</p></li>
<li><p>(Windows only) Specify a Verb (such as “runas”, to run the process with administrative elevation)</p></li>
</ul>
<p>The drawback is that you cannot redirect the input or output streams. Should you need to do so—while launching a file or document—a workaround is to set <code>UseShellExecute</code> to false and invoke the command-line process (cmd.exe) with the “/c” switch, as we did earlier when calling <em>ipconfig</em>.</p>
<p>Under Windows, <code>UseShellExecute</code> instructs the CLR to use the Windows <em>ShellExecute</em> function instead of the <em>CreateProcess</em> function. Under Linux, <code>UseShellExecute</code> instructs the CLR to call <em>xdg-open</em>, <em>gnome-open</em>, or <em>kfmclient</em>.<a contenteditable="false" data-primary="" data-startref="ch06.html1041" data-type="indexterm" id="id2982"/><a contenteditable="false" data-primary="" data-startref="ch06.html1040" data-type="indexterm" id="id2983"/><a contenteditable="false" data-primary="" data-startref="ch06.html1039" data-type="indexterm" id="id2984"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="AppContext" data-type="sect2"><div class="sect2" id="appcontext">
<h2>AppContext</h2>
<p><a contenteditable="false" data-primary="AppContext" data-type="indexterm" id="id2985"/><a contenteditable="false" data-primary="System..." data-secondary="System.AppContext" data-type="indexterm" id="id2986"/><a contenteditable="false" data-primary="utility classes" data-secondary="AppContext" data-type="indexterm" id="id2987"/>The static <code>System.AppContext</code> class exposes two useful properties:</p>
<ul>
<li><p><code>BaseDirectory</code> returns the folder in which the application started. This folder is important for resolving assemblies (finding and loading dependencies) and locating configuration files (such as <em>appsettings.json</em>).</p></li>
<li><p><code>TargetFrameworkName</code> tells you the name and version of the .NET runtime that the application targets (as specified in its <em>.runtimeconfig.json</em> file). This might be older than the runtime actually in use.</p></li>
</ul>
<p>In addition, the <code>AppContext</code> class manages a global string-keyed dictionary of Boolean values, intended to offer library writers a standard mechanism for allowing consumers to switch new features on or off. This untyped approach makes sense with experimental features that you want to keep undocumented to the majority of users.</p>
<p>The consumer of a library requests that you enable a feature as follows:</p>
<pre data-type="programlisting">AppContext.SetSwitch ("MyLibrary.SomeBreakingChange", true);</pre>
<p class="pagebreak-before">Code within that library can then check for that switch as follows:</p>
<pre data-type="programlisting">bool isDefined, switchValue;
isDefined = AppContext.TryGetSwitch ("MyLibrary.SomeBreakingChange",
                                      out switchValue);</pre>
<p><code>TryGetSwitch</code> returns false if the switch is undefined; this lets you distinguish an undefined switch from one whose value is set to false, should this be necessary.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Ironically, the design of <code>TryGetSwitch</code> illustrates how not to write APIs. The <code>out</code> parameter is unnecessary, and the method should instead return a nullable <code>bool</code> whose value is true, false, or null for undefined. This would then enable the following use:<a contenteditable="false" data-primary="" data-startref="ch06.html1038" data-type="indexterm" id="id2988"/><a contenteditable="false" data-primary="" data-startref="ch06.html100" data-type="indexterm" id="id2989"/></p>
<pre data-type="programlisting">bool switchValue = AppContext.GetSwitch ("...") ?? false;</pre>
</div>
</div></section>
</div></section>
</div></section></body></html>