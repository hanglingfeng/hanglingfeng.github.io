<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Cryptography</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Cryptography" data-pdf-bookmark="Chapter 20. Cryptography" data-type="chapter" epub:type="chapter"><div class="chapter" id="cryptography-id00013">
<h1><span class="label">Chapter 20. </span>Cryptography</h1>
<p><a contenteditable="false" data-primary="cryptography and encryption" data-type="indexterm" id="ch20.html0"/>In this chapter, we discuss the major cryptography APIs in .NET:</p>
<ul>
<li><p>Windows Data Protection API (DPAPI)</p></li>
<li><p>Hashing</p></li>
<li><p>Symmetric encryption</p></li>
<li><p>Public key encryption and signing</p></li>
</ul>
<p>The types covered in this chapter are defined in the following namespaces:</p>
<pre data-type="programlisting">System.Security;
System.Security.Cryptography;</pre>
<section data-pdf-bookmark="Overview" data-type="sect1"><div class="sect1" id="overview-id00067">
<h1>Overview</h1>
<p><a contenteditable="false" data-primary="cryptography and encryption" data-secondary="options in .NET" data-type="indexterm" id="id4286"/><a data-type="xref" href="#encryption_and_hashing_options_in_dotne">Table 20-1</a> summarizes the cryptography options in .NET. In the remaining sections, we explore each of these.</p>
<table class="border" id="encryption_and_hashing_options_in_dotne">
<caption><span class="label">Table 20-1. </span>Encryption and hashing options in .NET</caption>
<thead>
<tr>
<th>Option</th>
<th>Keys to manage</th>
<th>Speed</th>
<th>Strength</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>File.Encrypt</code></td>
<td>0</td>
<td>Fast</td>
<td>Depends on user’s password</td>
<td>Protects files transparently with filesystem support. A key is derived implicitly from the logged-in user’s credentials. Windows only.</td>
</tr>
<tr>
<td>Windows Data Protection</td>
<td>0</td>
<td>Fast</td>
<td>Depends on user’s password</td>
<td>Encrypts and decrypts byte arrays using an implicitly derived key.</td>
</tr>
<tr>
<td>Hashing</td>
<td>0</td>
<td>Fast</td>
<td>High</td>
<td>One-way (irreversible) transformation. Used for storing passwords, comparing files, and checking for data corruption.</td>
</tr>
<tr>
<td>Symmetric Encryption</td>
<td>1</td>
<td>Fast</td>
<td>High</td>
<td>For general-purpose encryption/decryption. The same key encrypts and decrypts. Can be used to secure messages in transit.</td>
</tr>
<tr>
<td>Public Key Encryption</td>
<td>2</td>
<td>Slow</td>
<td>High</td>
<td>Encryption and decryption use different keys. Used for exchanging a symmetric key in message transmission and for digitally signing files.</td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Security.Cryptography.X509Certificates" data-type="indexterm" id="id4287"/><a contenteditable="false" data-primary="System..." data-secondary="System.Security.Cryptography.Xml" data-type="indexterm" id="id4288"/>.NET also provides more specialized support for creating and validating XML-based signatures in <code>System.Security.Cryptography.Xml</code> and types for working with digital certificates in <code>System.Security.Cryptography.X509Certificates</code>.</p>
</div></section>
<section data-pdf-bookmark="Windows Data Protection" data-type="sect1"><div class="sect1" id="windows_data_protection">
<h1>Windows Data Protection</h1>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="cryptography and encryption" data-secondary="Windows Data Protection" data-type="indexterm" id="id4289"/>Windows Data Protection is available on Windows only, and throws a <code>PlatformNotSupportedException</code> on other operating systems.</p>
</div>
<p>In the section <a data-type="xref" href="ch15.html#file_and_directory_operations">“File and Directory Operations”</a>, we described how you could use <code>File.Encrypt</code> to request that the operating system transparently encrypt a file:</p>
<pre data-type="programlisting">File.WriteAllText ("myfile.txt", "");
File.Encrypt ("myfile.txt");
File.AppendAllText ("myfile.txt", "sensitive data");</pre>
<p>The encryption in this case uses a key derived from the logged-in user’s password. <a contenteditable="false" data-primary="DPAPI (Windows Data Protection API)" data-type="indexterm" id="id4290"/><a contenteditable="false" data-primary="Windows Data Protection API (DPAPI)" data-type="indexterm" id="id4291"/>You can use this same implicitly derived key to encrypt a byte array with the Windows Data Protection API (DPAPI). The DPAPI is exposed through the <span class="keep-together"><code>ProtectedData</code></span> class—a simple type with two static methods:</p>
<pre data-type="programlisting">public static byte[] Protect
  (byte[] userData, byte[] optionalEntropy, DataProtectionScope scope);

public static byte[] Unprotect
  (byte[] encryptedData, byte[] optionalEntropy, DataProtectionScope scope);</pre>
<p>Whatever you include in <code>optionalEntropy</code> is added to the key, thereby increasing its security. The <code>DataProtectionScope</code> enum argument allows two options: <code>Curren⁠t​User</code> or <code>LocalMachine</code>. With <code>CurrentUser</code>, a key is derived from the logged-in user’s credentials; with <code>LocalMachine</code>, a machine-wide key is used, common to all users. This means that with the <code>CurrentUser</code> scope, data encrypted by one user cannot be decrypted by another. A <code>LocalMachine</code> key provides less protection but works under a Windows Service or a program needing to operate under a variety of accounts.</p>
<p class="pagebreak-before">Here’s a simple encryption and decryption demonstration:</p>
<pre data-type="programlisting">byte[] original = {1, 2, 3, 4, 5};
DataProtectionScope scope = DataProtectionScope.CurrentUser;

byte[] encrypted = ProtectedData.Protect (original, null, scope);
byte[] decrypted = ProtectedData.Unprotect (encrypted, null, scope);
// decrypted is now {1, 2, 3, 4, 5}</pre>
<p>Windows Data Protection provides moderate security against an attacker with full access to the computer, depending on the strength of the user’s password. With <code>LocalMachine</code> scope, it’s effective only against those with restricted physical and electronic access.</p>
</div></section>
<section data-pdf-bookmark="Hashing" data-type="sect1"><div class="sect1" id="hashing">
<h1>Hashing</h1>
<p><a contenteditable="false" data-primary="hashcode" data-type="indexterm" id="id4292"/><a contenteditable="false" data-primary="hashing algorithm" data-type="indexterm" id="id4293"/>A <a contenteditable="false" data-primary="cryptography and encryption" data-secondary="hashing" data-type="indexterm" id="ch20.html1"/><a contenteditable="false" data-primary="hashing" data-type="indexterm" id="ch20.html2"/><em>hashing algorithm</em> distills a potentially large number of bytes into a small fixed-length <em>hashcode</em>. Hashing algorithms are designed such that a single-bit change anywhere in the source data results in a significantly different hashcode. This makes it suitable for comparing files or detecting accidental (or malicious) corruption to a file or data stream.</p>
<p>Hashing also acts as one-way encryption, because it’s difficult to impossible to convert a hashcode back into the original data. This makes it ideal for storing passwords in a database, because should your database become compromised, you don’t want the attacker to gain access to plain-text passwords. To authenticate, you simply hash what the user types in and compare it to the hash that’s stored in the database.</p>
<p>To hash, you call <code>ComputeHash</code> on one of the <code>HashAlgorithm</code> subclasses, such as <code>SHA1</code> or <code>SHA256</code>:</p>
<pre data-type="programlisting">byte[] hash;
using (Stream fs = File.OpenRead ("checkme.doc"))
  hash = <strong>SHA1.Create().ComputeHash</strong> (fs);   // SHA1 hash is 20 bytes long</pre>
<p>The <code>ComputeHash</code> method also accepts a byte array, which is convenient for hashing passwords (we describe a more secure technique in <a data-type="xref" href="#hashing_passwords">“Hashing Passwords”</a>):</p>
<pre data-type="programlisting">byte[] data = System.Text.Encoding.UTF8.GetBytes ("stRhong%pword");
byte[] hash = SHA256.Create().ComputeHash (data);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>GetBytes</code> method on an <code>Encoding</code> object converts a string to a byte array; the <code>GetString</code> method converts it back. An <code>Encoding</code> object cannot, however, convert an encrypted or hashed byte array to a string, because scrambled data usually violates text encoding rules. Instead, use <span class="keep-together"><code>Convert.ToBase64String</code></span> and <code>Convert.FromBase64String</code>: these convert between any byte array and a legal (and XML- or JSON-friendly) string.</p>
</div>
<section data-pdf-bookmark="Hash Algorithms in .NET" data-type="sect2"><div class="sect2" id="hash_algorithms_in_dotnet">
<h2>Hash Algorithms in .NET</h2>
<p><a contenteditable="false" data-primary="hashing" data-secondary="hash algorithms in .NET" data-type="indexterm" id="id4294"/><code>SHA1</code> and <code>SHA256</code> are two of the <code>HashAlgorithm</code> subtypes provided by .NET. Here are the major algorithms, in ascending order of security:</p>

<table>
<thead>
  <tr>
    <th>Class</th>
    <th>Algorithm</th>
    <th>Hash length in bytes</th>
    <th>Strength</th>
  </tr>
  </thead>
  <tr>
    <td><code>MD5</code></td>
    <td>MD5</td>
    <td>16</td>
    <td>Very poor</td>
  </tr>
    <tr>
    <td><code>SHA1</code></td>
    <td>SHA-1</td>
    <td>20</td>
    <td>Poor</td>
  </tr>
    <tr>
    <td><code>SHA256</code></td>
    <td>SHA-2</td>
    <td>32</td>
    <td>Good</td>
  </tr>
    <tr>
    <td><code>SHA384</code></td>
    <td>SHA-2</td>
    <td>48</td>
    <td>Good</td>
  </tr>
    <tr>
    <td><code>SHA512</code></td>
    <td>SHA-2</td>
    <td>64</td>
    <td>Good</td>
  </tr>
</table>

<p>All five algorithms execute at roughly similar speeds in their current implementations, with the exception of SHA256, which is 2-3 times faster (this may vary with hardware and operating system). To give a ballpark figure, you can expect at least 500 MB per second on a 2024-era desktop or server with all algorithms. The longer hashes decrease the possibility of <em>collision</em> (two distinct files yielding the same hash)<a contenteditable="false" data-primary="collision" data-type="indexterm" id="id4295"/>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Use <em>at least</em> <code>SHA256</code> when hashing passwords or other security-sensitive data. <code>MD5</code> and <code>SHA1</code> are considered insecure for this purpose and are suitable to protect only against accidental corruption, not deliberate tampering.</p>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6><p>.NET 8 and above also support the latest SHA-3 hashing note via the <code>SHA3_256</code>, <code>SHA3_384</code>, and <code>SHA3_512</code> classes. The SHA-3 algorithms are considered even more secure (and slower) than the previously listed algorithms, but require Windows Build 25324+ or Linux with OpenSSL 1.1.1+. You can test whether OS support is available via the static <code>IsSupported</code> property on these classes.</p></div>
</div></section>
<section data-pdf-bookmark="Hashing Passwords" data-type="sect2"><div class="sect2" id="hashing_passwords">
<h2>Hashing Passwords</h2>
<p><a contenteditable="false" data-primary="dictionary attack" data-type="indexterm" id="id4296"/><a contenteditable="false" data-primary="hashing" data-secondary="passwords" data-type="indexterm" id="id4297"/><a contenteditable="false" data-primary="passwords" data-secondary="hashing" data-type="indexterm" id="id4298"/>The longer SHA algorithms are suitable as a basis for password hashing, if you enforce a strong password policy to mitigate a <em>dictionary attack</em>—a strategy whereby an attacker builds a password lookup table by hashing every word in a dictionary.</p>
<p>A standard technique, when hashing passwords, is to incorporate “salt”—a long series of bytes that you initially obtain via a random number generator and then combine with each password before hashing. This frustrates hackers in two ways:</p>
<ul>
<li><p>They must also know the salt bytes.</p></li>
<li><p><a contenteditable="false" data-primary="rainbow tables" data-type="indexterm" id="id4299"/>They cannot use <em>rainbow tables</em> (publicly available <em>precomputed</em> databases of passwords and their hashcodes), although a dictionary attack might still be possible with sufficient computing power.</p></li>
</ul>
<p>You can further strengthen security by “stretching” your password hashes—repeatedly rehashing to obtain more computationally intensive byte sequences. If you rehash 100 times, a dictionary attack that might otherwise take one month would take eight years. The <code>KeyDerivation</code>, <code>Rfc2898DeriveBytes</code>, and <code>PasswordDeriveBytes</code> classes perform exactly this kind of stretching while also allowing for convenient salting. Of these, <code>KeyDerivation.Pbkdf2</code> offers the best hashing:</p>
<pre data-type="programlisting">byte[] encrypted = KeyDerivation.Pbkdf2 (
    password: "stRhong%pword",
    salt: Encoding.UTF8.GetBytes ("j78Y#p)/saREN!y3@"),
    prf: KeyDerivationPrf.HMACSHA512,
    iterationCount: 100,
    numBytesRequested: 64);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>KeyDerivation.Pbkdf2</code> requires the NuGet package <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code>. Though it’s in the ASP.NET Core namespace, any .NET application can use it.<a contenteditable="false" data-primary="" data-startref="ch20.html2" data-type="indexterm" id="id4300"/><a contenteditable="false" data-primary="" data-startref="ch20.html1" data-type="indexterm" id="id4301"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Symmetric Encryption" data-type="sect1"><div class="sect1" id="symmetric_encryption">
<h1>Symmetric Encryption</h1>
<p><a contenteditable="false" data-primary="cryptography and encryption" data-secondary="symmetric encryption" data-type="indexterm" id="ch20.html3"/><a contenteditable="false" data-primary="symmetric encryption" data-type="indexterm" id="ch20.html4"/>Symmetric encryption uses the same key for encryption as for decryption. The .NET BCL provides four symmetric algorithms, of which Rijndael (pronounced “Rhine Dahl” or “Rain Doll”) is the premium; the other algorithms are intended mainly for compatibility with older applications. Rijndael is both fast and secure and has two implementations:</p>
<ul>
<li><p>The <code>Rijndael</code> class</p></li>
<li><p>The <code>Aes</code> class</p></li>
</ul>
<p><a contenteditable="false" data-primary="Aes class" data-type="indexterm" id="ch20.html5"/>The two are almost identical, except that <code>Aes</code> does not let you weaken the cipher by changing the block size. <code>Aes</code> is recommended by the CLR’s security team.</p>
<p><a contenteditable="false" data-primary="Rijndael class" data-type="indexterm" id="id4302"/><code>Rijndael</code> and <code>Aes</code> allow symmetric keys of length 16, 24, or 32 bytes: all are currently considered secure. Here’s how to encrypt a series of bytes as they’re written to a file, using a 16-byte key:</p>
<pre data-type="programlisting">byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};
byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};

byte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.

using (SymmetricAlgorithm algorithm = Aes.Create())
using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))
using (Stream f = File.Create ("encrypted.bin"))
using (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))
  c.Write (data, 0, data.Length);</pre>
<p class="pagebreak-before">The following code decrypts the file:</p>
<pre data-type="programlisting">byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};
byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};

byte[] decrypted = new byte[5];

using (SymmetricAlgorithm algorithm = Aes.Create())
using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))
using (Stream f = File.OpenRead ("encrypted.bin"))
using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))
  for (int b; (b = c.ReadByte()) &gt; -1;)
    Console.Write (b + " ");                            // 1 2 3 4 5</pre>
<p>In this example, we made up a key of 16 randomly chosen bytes. <a contenteditable="false" data-primary="CryptoStream" data-type="indexterm" id="id4303"/>If the wrong key was used in decryption, <code>CryptoStream</code> would throw a <code>CryptographicException</code>. Catching this exception is the only way to test whether a key is correct.</p>
<p><a contenteditable="false" data-primary="Initialization Vector (IV)" data-type="indexterm" id="id4304"/><a contenteditable="false" data-primary="IV (Initialization Vector)" data-type="indexterm" id="id4305"/>As well as a key, we made up an IV, or <em>Initialization Vector</em>. This 16-byte sequence forms part of the cipher—much like the key—but is not considered <em>secret</em>. If you’re transmitting an encrypted message, you would send the IV in plain text (perhaps in a message header) and then <em>change it with every message</em>. This would render each encrypted message unrecognizable from any previous one—even if their unencrypted versions were similar or identical.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you don’t need—or want—the protection of an IV, you can defeat it by using the same 16-byte value for both the key and the IV. Sending multiple messages with the same IV, though, weakens the cipher and might even make it possible to crack.</p>
</div>
<p>The cryptography work is divided among the classes. <code>Aes</code> is the mathematician; it applies the cipher algorithm, along with its <code>encryptor</code> and <code>decryptor</code> transforms. <code>CryptoStream</code> is the plumber; it takes care of stream plumbing. You can replace <code>Aes</code> with a different symmetric algorithm yet still use <code>CryptoStream</code>.</p>
<p><code>CryptoStream</code> is <em>bidirectional</em>, meaning you can read or write to the stream depending on whether you choose <code>CryptoStreamMode.Read</code> or <code>CryptoStreamMode.Write</code>. Both encryptors and decryptors are read <em>and</em> write savvy, yielding four combinations—the choice can have you staring at a blank screen for a while! It can be helpful to model reading as “pulling” and writing as “pushing.” If in doubt, start with <code>Write</code> for encryption and <code>Read</code> for decryption; this is often the most natural.</p>
<p>To generate a random key or IV, use <code>RandomNumberGenerator</code> in <code>System.Cryptography</code>. The numbers it produces are genuinely unpredictable, or <em>cryptographically strong</em> (the <code>System.Random</code> class does not offer the same guarantee). Here’s an <span class="keep-together">example</span>:</p>
<pre data-type="programlisting">byte[] key = new byte [16];
byte[] iv  = new byte [16];
RandomNumberGenerator rand = RandomNumberGenerator.Create();
rand.GetBytes (key);
rand.GetBytes (iv);</pre>

<p>Or, from .NET 6:</p>

<pre data-type="programlisting">byte[] key = RandomNumberGenerator.GetBytes (16);
byte[] iv = RandomNumberGenerator.GetBytes (16);</pre>
    
<p>If you don’t specify a key and IV, cryptographically strong random values are generated automatically. You can query these through the <code>Aes</code> object’s <code>Key</code> and <code>IV</code> <span class="keep-together">properties</span>.</p>
<section data-pdf-bookmark="Encrypting in Memory" data-type="sect2"><div class="sect2" id="encrypting_in_memory">
<h2>Encrypting in Memory</h2>
<p><a contenteditable="false" data-primary="MemoryStream" data-type="indexterm" id="id4306"/><a contenteditable="false" data-primary="symmetric encryption" data-secondary="encrypting in memory" data-type="indexterm" id="id4307"/>From .NET 6, you can utilize the <code>EncryptCbc</code> and <code>DecryptCbc</code> methods to shortcut the process of encrypting and decrypting byte arrays:</p>

<pre data-type="programlisting">public static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)
{
  using Aes algorithm = Aes.Create();
  algorithm.Key = key;
  return algorithm.EncryptCbc (data, iv);
}

public static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)
{
  using Aes algorithm = Aes.Create();
  algorithm.Key = key;
  return algorithm.DecryptCbc (data, iv);
}</pre>

<p>Here’s an equivalent that works in all.NET versions:</p>

<pre data-type="programlisting">public static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)
{
  using (Aes algorithm = Aes.Create())
  using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))
    return Crypt (data, encryptor);
}

public static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)
{
  using (Aes algorithm = Aes.Create())
  using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))
    return Crypt (data, decryptor);
}

static byte[] Crypt (byte[] data, ICryptoTransform cryptor)
{
  MemoryStream m = new MemoryStream();
  using (Stream c = new CryptoStream (m, cryptor, CryptoStreamMode.Write))
    c.Write (data, 0, data.Length);
  return m.ToArray();
}</pre>
<p>Here, <code>CryptoStreamMode.Write</code> works best for both encryption and decryption, since in both cases we’re “pushing” into a fresh memory stream.</p>
<p class="pagebreak-before">Here are overloads that accept and return strings:</p>
<pre data-type="programlisting">public static string Encrypt (string data, byte[] key, byte[] iv)
{
  return Convert.ToBase64String (
    Encrypt (Encoding.UTF8.GetBytes (data), key, iv));
}

public static string Decrypt (string data, byte[] key, byte[] iv)
{
  return Encoding.UTF8.GetString (
    Decrypt (Convert.FromBase64String (data), key, iv));
}</pre>
<p>The following demonstrates their use:</p>
<pre data-type="programlisting">byte[] key = new byte[16];
byte[] iv = new byte[16];

var cryptoRng = RandomNumberGenerator.Create();
cryptoRng.GetBytes (key);
cryptoRng.GetBytes (iv);

string encrypted = Encrypt ("Yeah!", key, iv);
Console.WriteLine (encrypted);                 // R1/5gYvcxyR2vzPjnT7yaQ==

string decrypted = Decrypt (encrypted, key, iv);
Console.WriteLine (decrypted);                 // Yeah!</pre>
</div></section>
<section data-pdf-bookmark="Chaining Encryption Streams" data-type="sect2"><div class="sect2" id="chaining_encryption_streams">
<h2>Chaining Encryption Streams</h2>
<p><a contenteditable="false" data-primary="chaining" data-secondary="encryption streams" data-type="indexterm" id="id4308"/><a contenteditable="false" data-primary="symmetric encryption" data-secondary="chaining encryption streams" data-type="indexterm" id="id4309"/><code>CryptoStream</code> is a decorator, meaning that you can chain it with other streams. In the following example, we write compressed encrypted text to a file and then read it back:</p>
<pre data-type="programlisting">byte[] key = new byte [16];
byte[] iv = new byte [16];

var cryptoRng = RandomNumberGenerator.Create();
cryptoRng.GetBytes (key);
cryptoRng.GetBytes (iv);

using (Aes algorithm = Aes.Create())
{
  using (ICryptoTransform encryptor = algorithm.CreateEncryptor(key, iv))
  using (Stream f = File.Create ("serious.bin"))
  using (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))
  using (Stream d = new DeflateStream (c, CompressionMode.Compress))
  using (StreamWriter w = new StreamWriter (d))
    await w.WriteLineAsync ("Small and secure!");

  using (ICryptoTransform decryptor = algorithm.CreateDecryptor(key, iv))
  using (Stream f = File.OpenRead ("serious.bin"))
  using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))
  using (Stream d = new DeflateStream (c, CompressionMode.Decompress))
  using (StreamReader r = new StreamReader (d))
    Console.WriteLine (await r.ReadLineAsync());     // Small and secure!
}</pre>
<p>(As a final touch, we make our program asynchronous by calling <code>WriteLineAsync</code> and <code>ReadLineAsync</code> and awaiting the result.)</p>
<p>In this example, all one-letter variables form part of a chain. The mathematicians—<code>algorithm</code>, <code>encryptor</code>, and <code>decryptor</code>—are there to assist <code>CryptoStream</code> in the cipher work, as illustrated in <a data-type="xref" href="#chaining_encryption_and_compression_str">Figure 20-1</a>.</p>

<p>Chaining streams in this manner demands little memory, regardless of the ultimate stream sizes.</p>

<figure><div class="figure" id="chaining_encryption_and_compression_str">
<img alt="Chaining encryption and compression streams" src="assets/cn10_2001.png"/>
<h6><span class="label">Figure 20-1. </span>Chaining encryption and compression streams</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Disposing Encryption Objects" data-type="sect2"><div class="sect2" id="disposing_encryption_objects">
<h2>Disposing Encryption Objects</h2>
<p><a contenteditable="false" data-primary="disposal" data-secondary="encryption objects" data-type="indexterm" id="id4310"/><a contenteditable="false" data-primary="symmetric encryption" data-secondary="disposing encryption objects" data-type="indexterm" id="id4311"/>Disposing a <code>CryptoStream</code> ensures that its internal cache of data is flushed to the underlying stream. Internal caching is necessary for encryption algorithms because they process data in blocks, rather than one byte at a time.</p>
<p><code>CryptoStream</code> is unusual in that its <code>Flush</code> method does nothing. To flush a stream (without disposing it) you must call <code>FlushFinalBlock</code>. In contrast to <code>Flush</code>, you can call <code>FlushFinalBlock</code> only once, and then no further data can be written.</p>
<p>We also disposed the mathematicians—the <code>Aes</code> algorithm and <code>ICryptoTransform</code> objects (<code>encryptor</code> and <code>decryptor</code>). <a contenteditable="false" data-primary="Rijndael class" data-type="indexterm" id="id4312"/>When the Rijndael transforms are disposed, they wipe the symmetric key and related data from memory, preventing subsequent discovery by other software running on the computer (we’re talking malware). You can’t rely on the garbage collector for this job, because it merely flags sections of memory as available; it doesn’t write zeros over every byte.</p>
<p>The easiest way to dispose an <code>Aes</code> object outside of a <code>using</code> statement is to call <code>Clear</code>. Its <code>Dispose</code> method is hidden via explicit implementation (to signal its unusual disposal semantics, whereby it clears memory rather than releasing unmanaged resources).<a contenteditable="false" data-primary="" data-startref="ch20.html5" data-type="indexterm" id="id4313"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can further reduce your application’s vulnerability to leaking secrets via released memory by doing the following:</p>
<ul>
<li><p>Avoiding strings for security information (being immutable, a string’s value can never be cleared once created)</p></li>
<li><p>Overwriting buffers as soon as they’re no longer needed (for instance, by calling <code>Array.Clear</code> on a byte array)</p></li>
</ul>
</div>
</div></section>
<section data-pdf-bookmark="Key Management" data-type="sect2"><div class="sect2" id="key_management">
<h2>Key Management</h2>
<p><a contenteditable="false" data-primary="key management" data-type="indexterm" id="id4314"/><a contenteditable="false" data-primary="symmetric encryption" data-secondary="key management" data-type="indexterm" id="id4315"/>Key management is a critical element of security: if your keys are exposed, so is your data. You need to consider who should have access to keys and how to back them up in case of hardware failure while storing them in a manner that prevents unauthorized access.</p>
<p>It is inadvisable to hardcode encryption keys because popular tools exist to decompile assemblies with little expertise required. A better option (on Windows) is to manufacture a random key for each installation, storing it securely with Windows Data Protection.</p>
<p><a contenteditable="false" data-primary="Amazon Web Services (AWS)" data-type="indexterm" id="id4316"/><a contenteditable="false" data-primary="AWS (Amazon Web Services)" data-type="indexterm" id="id4317"/><a contenteditable="false" data-primary="Microsoft Azure" data-type="indexterm" id="id4318"/>For applications deployed to the cloud, Microsoft Azure and Amazon Web Services (AWS) offer key-management systems with additional features that can be useful in an enterprise environment, such as audit trails. If you’re encrypting a message stream, public-key encryption still provides the best option.<a contenteditable="false" data-primary="" data-startref="ch20.html4" data-type="indexterm" id="id4319"/><a contenteditable="false" data-primary="" data-startref="ch20.html3" data-type="indexterm" id="id4320"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Public-Key Encryption and Signing" data-type="sect1"><div class="sect1" id="public_key_encryption_and_signing">
<h1>Public-Key Encryption and Signing</h1>
<p><a contenteditable="false" data-primary="cryptography and encryption" data-secondary="public-key encryption/signing" data-type="indexterm" id="ch20.html6"/><a contenteditable="false" data-primary="public-key encryption/signing" data-type="indexterm" id="ch20.html7"/>Public-key cryptography is <em>asymmetric</em>, meaning that encryption and decryption use different keys.</p>
<p>Unlike symmetric encryption, for which any arbitrary series of bytes of appropriate length can serve as a key, asymmetric cryptography requires specially crafted key pairs. <a contenteditable="false" data-primary="private key" data-type="indexterm" id="id4321"/><a contenteditable="false" data-primary="public key" data-type="indexterm" id="id4322"/>A key pair contains a <em>public key</em> and <em>private key</em> component that work together as follows:</p>
<ul>
<li><p>The public key encrypts messages.</p></li>
<li><p>The private key decrypts messages.</p></li>
</ul>
<p>The party “crafting” a key pair keeps the private key secret while distributing the public key freely. A special feature of this type of cryptography is that you cannot calculate a private key from a public key. So, if the private key is lost, encrypted data cannot be recovered; conversely, if a private key is leaked, the encryption system becomes useless.</p>
<p>A public key handshake allows two computers to communicate securely over a public network, with no prior contact and no existing shared secret. To see how this works, suppose that computer <em>Origin</em> wants to send a confidential message to computer <em>Target</em>:</p>
<ol>
<li><p><em>Target</em> generates a public/private key pair and then sends its public key to <span class="keep-together"><em>Origin</em></span>.</p></li>
<li><p><em>Origin</em> encrypts the confidential message using <em>Target</em>’s public key and then sends it to <em>Target</em>.</p></li>
<li><p><em>Target</em> decrypts the confidential message using its private key.</p></li>
</ol>
<p>An eavesdropper will see the following:</p>
<ul>
<li><p><em>Target</em>’s public key</p></li>
<li><p>The secret message, encrypted with <em>Target</em>’s public key</p></li>
</ul>
<p>But without <em>Target</em>’s private key, the message cannot be decrypted.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="man-in-the-middle attack" data-type="indexterm" id="id4323"/>This doesn’t prevent against a man-in-the-middle attack: in other words, <em>Origin</em> cannot know that <em>Target</em> isn’t some malicious party. To authenticate the recipient, the originator needs to already know the recipient’s public key or be able to validate its key through a <em>digital site certificate</em>.</p>
</div>
<p>Because public key encryption is relatively slow and its message size limited, the secret message sent from <em>Origin</em> to <em>Target</em> typically contains a fresh key for subsequent <em>symmetric</em> encryption. This allows public key encryption to be abandoned for the remainder of the session, in favor of a symmetric algorithm capable of handling larger messages. This protocol is particularly secure if a fresh public/private key pair is generated for each session because no keys then need to be stored on either <span class="keep-together">computer</span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The public key encryption algorithms rely on the message being smaller than the key. This makes them suitable for encrypting only small amounts of data, such as a key for subsequent symmetric encryption. If you try to encrypt a message much larger than half the key size, the provider will throw an exception.</p>
</div>
<section data-pdf-bookmark="The RSA Class" data-type="sect2"><div class="sect2" id="the_rsa_class">
<h2>The RSA Class</h2>
<p><a contenteditable="false" data-primary="public-key encryption/signing" data-secondary="RSA class" data-type="indexterm" id="id4324"/><a contenteditable="false" data-primary="RSA encryption algorithm" data-type="indexterm" id="id4325"/>.NET provides a number of asymmetric algorithms, of which RSA is the most popular. Here’s how to encrypt and decrypt with RSA:</p>
<pre data-type="programlisting">byte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.

using (var rsa = new RSACryptoServiceProvider())
{
  byte[] encrypted = rsa.Encrypt (data, true);
  byte[] decrypted = rsa.Decrypt (encrypted, true);
}</pre>
<p>Because we didn’t specify a public or private key, the cryptographic provider automatically generated a key pair, using the default length of 1,024 bits; you can request longer keys in increments of eight bytes, through the constructor. For security-critical applications, it’s prudent to request 2,048 bits:</p>
<pre data-type="programlisting">var rsa = new RSACryptoServiceProvider (2048);</pre>
<p>Generating a key pair is computationally intensive—taking perhaps 10 ms. For this reason, the RSA implementation delays this until a key is actually needed, such as when calling <code>Encrypt</code>. This gives you the chance to load in an existing key—or key pair, should it exist.</p>
<p>The methods <code>ImportCspBlob</code> and <code>ExportCspBlob</code> load and save keys in byte array format. <code>FromXmlString</code> and <code>ToXmlString</code> do the same job in a string format, the string containing an XML fragment. A <code>bool</code> flag lets you indicate whether to include the private key when saving. Here’s how to manufacture a key pair and save it to disk:</p>
<pre data-type="programlisting">using (var rsa = new RSACryptoServiceProvider())
{
  File.WriteAllText ("PublicKeyOnly.xml", rsa.ToXmlString (false));
  File.WriteAllText ("PublicPrivate.xml", rsa.ToXmlString (true));
}</pre>
<p>Because we didn’t provide existing keys, <code>ToXmlString</code> forced the manufacture of a fresh key pair (on the first call). In the next example, we read back these keys and use them to encrypt and decrypt a message:</p>
<pre data-type="programlisting">byte[] data = Encoding.UTF8.GetBytes ("Message to encrypt");

string publicKeyOnly = File.ReadAllText ("PublicKeyOnly.xml");
string publicPrivate = File.ReadAllText ("PublicPrivate.xml");

byte[] encrypted, decrypted;

using (var rsaPublicOnly = new RSACryptoServiceProvider())
{
  rsaPublicOnly.FromXmlString (publicKeyOnly);
  encrypted = rsaPublicOnly.Encrypt (data, true);


  // The next line would throw an exception because you need the private
  // key in order to decrypt:
  // decrypted = rsaPublicOnly.Decrypt (encrypted, true);
}

using (var rsaPublicPrivate = new RSACryptoServiceProvider())
{
  // With the private key we can successfully decrypt:
  rsaPublicPrivate.FromXmlString (publicPrivate);
  decrypted = rsaPublicPrivate.Decrypt (encrypted, true);
}</pre>
</div></section>
<section data-pdf-bookmark="Digital Signing" data-type="sect2"><div class="sect2" id="digital_signing">
<h2>Digital Signing</h2>
<p><a contenteditable="false" data-primary="digital signing" data-type="indexterm" id="id4326"/><a contenteditable="false" data-primary="public-key encryption/signing" data-secondary="digital signing" data-type="indexterm" id="id4327"/><a contenteditable="false" data-primary="signing, digital" data-type="indexterm" id="id4328"/>You also can use public key algorithms to digitally sign messages or documents. A signature is like a hash, except that its production requires a private key and so cannot be forged. The public key is used to verify the signature. Here’s an example:</p>
<pre data-type="programlisting">byte[] data = Encoding.UTF8.GetBytes ("Message to sign");
byte[] publicKey;
byte[] signature;
object hasher = SHA1.Create();         // Our chosen hashing algorithm.

// Generate a new key pair, then sign the data with it:
using (var publicPrivate = new RSACryptoServiceProvider())
{
  signature = publicPrivate.SignData (data, hasher);
  publicKey = publicPrivate.ExportCspBlob (false);    // get public key
}

// Create a fresh RSA using just the public key, then test the signature.
using (var publicOnly = new RSACryptoServiceProvider())
{
  publicOnly.ImportCspBlob (publicKey);
  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // True

  // Let's now tamper with the data and recheck the signature:
  data[0] = 0;
  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // False

  // The following throws an exception as we're lacking a private key:
  signature = publicOnly.SignData (data, hasher);
}</pre>
<p>Signing works by first hashing the data and then applying the asymmetric algorithm to the resultant hash. Because hashes are of a small fixed size, large documents can be signed relatively quickly (public key encryption is much more CPU-intensive than hashing). If you want, you can do the hashing yourself and then call <code>SignHash</code> instead of <code>SignData</code>:</p>
<pre data-type="programlisting">using (var rsa = new RSACryptoServiceProvider())
{
  byte[] hash = SHA1.Create().ComputeHash (data);
  signature = rsa.SignHash (hash, CryptoConfig.MapNameToOID ("SHA1"));
  ...
}</pre>
<p><code>SignHash</code> still needs to know what hash algorithm you used; <code>CryptoConfig.Map​Na⁠meToOID</code> provides this information in the correct format from a friendly name such as “SHA1”.</p>
<p><code>RSACryptoServiceProvider</code> produces signatures whose size matches that of the key. Currently, no mainstream algorithm produces secure signatures significantly smaller than 128 bytes (suitable for product activation codes, for instance).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For signing to be effective, the recipient must know, and trust, the sender’s public key. This can happen via prior communication, preconfiguration, or a site certificate. A site certificate is an electronic record of the originator’s public key and name—itself signed by an independent trusted authority. The namespace <a contenteditable="false" data-primary="System..." data-secondary="System.Security.Cryptography.X509Certificates" data-type="indexterm" id="id4329"/><code>System.Security.Cryptography.X509Certificates</code> defines the types for working with certificates<a contenteditable="false" data-primary="" data-startref="ch20.html7" data-type="indexterm" id="id4330"/><a contenteditable="false" data-primary="" data-startref="ch20.html6" data-type="indexterm" id="id4331"/>.<a contenteditable="false" data-primary="" data-startref="ch20.html0" data-type="indexterm" id="id4332"/></p>
</div>
</div></section>
</div></section>
</div></section></body></html>