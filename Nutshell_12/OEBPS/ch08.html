<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>LINQ Queries</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="LINQ Queries" data-pdf-bookmark="Chapter 8. LINQ Queries" data-type="chapter" epub:type="chapter"><div class="chapter" id="linq_queries">
<h1><span class="label">Chapter 8. </span>LINQ Queries</h1>

<p><a contenteditable="false" data-primary="LINQ queries" data-type="indexterm" id="ch08.html0"/>LINQ, or Language Integrated Query, is a set of language and runtime features for writing structured type-safe queries over local object collections and remote data sources.</p>

<p>LINQ enables you to query any collection implementing <code>IEnumerable&lt;T&gt;</code>, whether an array, list, or XML Document Object Model (DOM), as well as remote data sources, such as tables in an SQL Server database. LINQ offers the benefits of both compile-time type checking and dynamic query composition.</p>

<p>This chapter describes the LINQ architecture and the fundamentals of writing queries. All core types are defined in the <code>System.Linq</code> and <code>System.Linq.Expressions</code> namespaces.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The examples in this and the following two chapters are preloaded into an interactive querying tool called LINQPad. You can download LINQPad from <a href="http://www.linqpad.net"><em>http://www.linqpad.net</em></a>.</p>
</div>

<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="getting_started">
<h1>Getting Started</h1>

<p><a contenteditable="false" data-primary="elements" data-type="indexterm" id="id3112"/><a contenteditable="false" data-primary="sequences" data-type="indexterm" id="id3113"/>The <a contenteditable="false" data-primary="LINQ queries" data-secondary="basics" data-type="indexterm" id="ch08.html1"/>basic units of data in LINQ are <em>sequences</em> and <em>elements</em>. A sequence is any object that implements <code>IEnumerable&lt;T&gt;</code>, and an element is each item in the sequence. In the following example, <code>names</code> is a sequence, and <code>"Tom"</code>, <code>"Dick"</code>, and <code>"Harry"</code> are <span class="keep-together">elements</span>:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry" };</pre>

<p><a contenteditable="false" data-primary="local sequences" data-type="indexterm" id="id3114"/>We call this a <em>local sequence</em> because it represents a local collection of objects in memory.</p>

<p><a contenteditable="false" data-primary="query operators" data-secondary="LINQ" data-type="indexterm" id="id3115"/>A <em>query operator</em> is a method that transforms a sequence. A typical query operator accepts an <em>input sequence</em> and emits a transformed <em>output sequence</em>. In the <code>Enumerable</code> class in <code>System.Linq</code>, there are around 40 query operators—all implemented as static extension methods. These are called <em>standard query operators</em>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="LINQ-to-objects queries" data-type="indexterm" id="id3116"/>Queries that operate over local sequences are called <em>local</em> queries or <em>LINQ-to-objects</em> queries.</p>

<p>LINQ also supports sequences that can be dynamically fed from a remote data source such as an SQL Server database. These sequences additionally implement the <code>IQueryable&lt;T&gt;</code> interface and are supported through a matching set of standard query operators in the <code>Queryable</code> class. We discuss this further in <a data-type="xref" href="#interpreted_queries">“Interpreted Queries”</a>.</p>
</div>

<p>A query is an expression that, when enumerated, transforms sequences with query operators. The simplest query comprises one input sequence and one operator. For instance, we can apply the <code>Where</code> operator on a simple array to extract those strings whose length is at least four characters, as follows:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry" };
<strong>IEnumerable&lt;string&gt; filteredNames = System.Linq.Enumerable.Where</strong>
<strong>                                    (names, n =&gt; n.Length &gt;= 4);</strong>
foreach (string n in filteredNames)
  Console.WriteLine (n);

<em>Dick</em>
<em>Harry</em></pre>

<p>Because the standard query operators are implemented as extension methods, we can call <code>Where</code> directly on <code>names</code>, as though it were an instance method:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; filteredNames = <strong>names.Where</strong> (n =&gt; n.Length &gt;= 4);</pre>

<p>For this to compile, you must import the <code>System.Linq</code> namespace. Here’s a complete example:</p>

<pre data-type="programlisting">
using System;
using System.Collections.Generic;
using System.Linq;

string[] names = { "Tom", "Dick", "Harry" };

<strong>IEnumerable&lt;string&gt; filteredNames = names.Where (n =&gt; n.Length &gt;= 4);</strong>
foreach (string name in filteredNames) Console.WriteLine (name);

<em>Dick</em>
<em>Harry</em></pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We could further shorten our code by implicitly typing <code>filteredNames</code>:</p>

<pre data-type="programlisting">
<strong>var</strong> filteredNames = names.Where (n =&gt; n.Length &gt;= 4);</pre>

<p>This can hinder readability, however, outside of an IDE, where there are no tool tips to help. For this reason, we make less use of implicit typing in this chapter than you might in your own projects.</p>
</div>

<p>Most query operators accept a lambda expression as an argument. The lambda expression helps guide and shape the query. In our example, the lambda expression is as follows:</p>

<pre data-type="programlisting">
n =&gt; n.Length &gt;= 4</pre>

<p>The input argument corresponds to an input element. In this case, the input argument <code>n</code> represents each name in the array and is of type <code>string</code>. The <code>Where</code> operator requires that the lambda expression return a <code>bool</code> value, which if <code>true</code>, indicates that the element should be included in the output sequence. Here’s its signature:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<strong>bool</strong>&gt; predicate)</pre>

<p>The following query extracts all names that contain the letter “a”:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; filteredNames = names.Where (<strong>n =&gt; n.Contains ("a")</strong>);

foreach (string name in filteredNames)
  Console.WriteLine (name);             // Harry</pre>

<p>So far, we’ve built queries using extension methods and lambda expressions. As you’ll see shortly, this strategy is highly composable in that it allows the chaining of query operators. In this book, we refer to this as <em>fluent syntax</em>.<sup><a data-type="noteref" href="ch08.html#ch01fn7" id="ch01fn7-marker">1</a></sup> C# also provides another syntax for writing queries, called <em>query expression</em> syntax. Here’s our preceding query written as a query expression:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; filteredNames = from n in names
                                    where n.Contains ("a")
                                    select n;</pre>

<p>Fluent syntax and query syntax are complementary. In the following two sections, we explore each in more detail.<a contenteditable="false" data-primary="" data-startref="ch08.html1" data-type="indexterm" id="id3117"/></p>
</div></section>

<section data-pdf-bookmark="Fluent Syntax" data-type="sect1"><div class="sect1" id="fluent_syntax">
<h1>Fluent Syntax</h1>

<p><a contenteditable="false" data-primary="fluent syntax" data-type="indexterm" id="ch08.html2"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="fluent syntax" data-type="indexterm" id="ch08.html3"/>Fluent syntax is the most flexible and fundamental. In this section, we describe how to chain query operators to form more complex queries—and show why extension methods are important to this process. We also describe how to formulate lambda expressions for a query operator and introduce several new query operators.</p>

<section data-pdf-bookmark="Chaining Query Operators" data-type="sect2"><div class="sect2" id="chaining_query_operator">
<h2>Chaining Query Operators</h2>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="chaining query operators" data-type="indexterm" id="ch08.html4"/><a contenteditable="false" data-primary="query operators" data-secondary="chaining" data-type="indexterm" id="ch08.html5"/>In the preceding section, we showed two simple queries, each comprising a single query operator. To build more complex queries, you append additional query operators to the expression, creating a chain. To illustrate, the following query extracts all strings containing the letter “a,” sorts them by length, and then converts the results to uppercase:</p>

<pre data-type="programlisting">
using System;
using System.Collections.Generic;
using System.Linq;

string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;string&gt; query = names
  .Where   (n =&gt; n.Contains ("a"))
  .OrderBy (n =&gt; n.Length)
  .Select  (n =&gt; n.ToUpper());

foreach (string name in query) Console.WriteLine (name);

<em>JAY</em>
<em>MARY</em>
<em>HARRY</em></pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The variable, <code>n</code>, in our example, is privately scoped to each of the lambda expressions. We can reuse the identifier <code>n</code> for the same reason that we can reuse the identifier <code>c</code> in the following method:</p>

<pre data-type="programlisting">
void Test()
{
  foreach (char c in "string1") Console.Write (c);
  foreach (char c in "string2") Console.Write (c);
  foreach (char c in "string3") Console.Write (c);
}</pre>
</div>

<p><code>Where</code>, <code>OrderBy</code>, and <code>Select</code> are standard query operators that resolve to extension methods in the <code>Enumerable</code> class (if you import the <code>System.Linq</code> namespace).</p>

<p>We already introduced the <code>Where</code> operator, which emits a filtered version of the input sequence. The <code>OrderBy</code> operator emits a sorted version of its input sequence; the <code>Select</code> method emits a sequence in which each input element is transformed or <em>projected</em> with a given lambda expression (<code>n.ToUpper()</code>, in this case). Data flows from left to right through the chain of operators, so the data is first filtered, then sorted, and then projected.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A query operator never alters the input sequence; instead, it returns a new sequence. This is consistent with the <em>functional programming</em> paradigm from which LINQ was inspired.</p>
</div>

<p>Here are the signatures of each of these extension methods (with the <code>OrderBy</code> signature slightly simplified):</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)

public static IEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector)

public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)</pre>

<p>When query operators are chained as in this example, the output sequence of one operator is the input sequence of the next. The complete query resembles a production line of conveyor belts, as illustrated in <a data-type="xref" href="#chaining_query_operators">Figure 8-1</a>.</p>

<figure><div class="figure" id="chaining_query_operators"><img alt="Chaining query operators" src="assets/cn10_0801.png"/>
<h6><span class="label">Figure 8-1. </span>Chaining query operators</h6>
</div></figure>

<p>We can construct the identical query <em>progressively</em>, as follows:</p>

<pre data-type="programlisting">
// You must import the System.Linq namespace for this to compile:

IEnumerable&lt;string&gt; filtered   = names   .Where   (n =&gt; n.Contains ("a"));
IEnumerable&lt;string&gt; sorted     = filtered.OrderBy (n =&gt; n.Length);
IEnumerable&lt;string&gt; finalQuery = sorted  .Select  (n =&gt; n.ToUpper());</pre>

<p><code>finalQuery</code> is compositionally identical to the <code>query</code> we constructed previously. Further, each intermediate step also comprises a valid query that we can execute:</p>

<pre data-type="programlisting">
foreach (string name in filtered)
  Console.Write (name + "|");        // Harry|Mary|Jay|

Console.WriteLine();
foreach (string name in sorted)
  Console.Write (name + "|");        // Jay|Mary|Harry|

Console.WriteLine();
foreach (string name in finalQuery)
  Console.Write (name + "|");        // JAY|MARY|HARRY|</pre>

<section data-pdf-bookmark="Why extension methods are important" data-type="sect3"><div class="sect3" id="why_extension_methods_are_important">
<h3>Why extension methods are important</h3>

<p><a contenteditable="false" data-primary="extension methods" data-type="indexterm" id="id3118"/><a contenteditable="false" data-primary="fluent syntax" data-secondary="importance of extension methods" data-type="indexterm" id="id3119"/>Instead of using extension method syntax, you can use conventional static method syntax to call the query operators:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; filtered = Enumerable.Where (names,
                                                 n =&gt; n.Contains ("a"));
IEnumerable&lt;string&gt; sorted = Enumerable.OrderBy (filtered, n =&gt; n.Length);
IEnumerable&lt;string&gt; finalQuery = Enumerable.Select (sorted,
                                                    n =&gt; n.ToUpper());</pre>

<p>This is, in fact, how the compiler translates extension method calls. Shunning extension methods comes at a cost, however, if you want to write a query in a single statement as we did earlier. Let’s revisit the single-statement query—first in extension method syntax:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names.Where   (n =&gt; n.Contains ("a"))
                                 .OrderBy (n =&gt; n.Length)
                                 .Select  (n =&gt; n.ToUpper());</pre>

<p>Its natural linear shape reflects the left-to-right flow of data and also keeps lambda expressions alongside their query operators (<em>infix</em> notation). Without extension methods, the query loses its <em>fluency</em>:<a contenteditable="false" data-primary="" data-startref="ch08.html5" data-type="indexterm" id="id3120"/><a contenteditable="false" data-primary="" data-startref="ch08.html4" data-type="indexterm" id="id3121"/></p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  Enumerable.Select (
    Enumerable.OrderBy (
      Enumerable.Where (
        names, n =&gt; n.Contains ("a")
      ), n =&gt; n.Length
    ), n =&gt; n.ToUpper()
  );</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Composing Lambda Expressions" data-type="sect2"><div class="sect2" id="composing_lambda_expressions">
<h2>Composing Lambda Expressions</h2>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="composing lambda expressions" data-type="indexterm" id="ch08.html6"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="composing" data-type="indexterm" id="ch08.html7"/>In previous examples, we fed the following lambda expression to the <code>Where</code> <span class="keep-together">operator</span>:</p>

<pre data-type="programlisting">
n =&gt; n.Contains ("a")      // Input type = string, return type = bool.</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="predicate" data-type="indexterm" id="id3122"/>A lambda expression that takes a value and returns a <code>bool</code> is called a <em>predicate</em>.</p>
</div>

<p>The purpose of the lambda expression depends on the particular query operator. With the <code>Where</code> operator, it indicates whether an element should be included in the output sequence. In the case of the <code>OrderBy</code> operator, the lambda expression maps each element in the input sequence to its sorting key. With the <code>Select</code> operator, the lambda expression determines how each element in the input sequence is transformed before being fed to the output sequence.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A lambda expression in a query operator always works on individual elements in the input sequence—not the sequence as a whole.</p>
</div>

<p>The query operator evaluates your lambda expression upon demand, typically once per element in the input sequence. Lambda expressions allow you to feed your own logic into the query operators. This makes the query operators versatile as well as being simple under the hood. Here’s a complete implementation of <code>Enumerable.Where</code>, exception handling aside:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)
{
  foreach (TSource element in source)
    if (predicate (element))
      yield return element;
}</pre>

<section data-pdf-bookmark="Lambda expressions and Func signatures" data-type="sect3"><div class="sect3" id="lambda_expressions_and_func_signatures">
<h3>Lambda expressions and Func signatures</h3>

<p><a contenteditable="false" data-primary="Func delegate" data-type="indexterm" id="id3123"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="Func signatures and" data-type="indexterm" id="id3124"/>The standard query operators utilize generic <code>Func</code> delegates. <code>Func</code> is a family of general-purpose generic delegates in the <code>System</code> namespace, defined with the following intent:</p>

<blockquote>
<p>The type arguments in <code>Func</code> appear in the same order as they do in lambda expressions.</p>
</blockquote>

<p>Hence, <code>Func&lt;TSource,bool&gt;</code> matches a <code>TSource=&gt;bool</code> lambda expression: one that accepts a <code>TSource</code> argument and returns a <code>bool</code> value.</p>

<p>Similarly, <code>Func&lt;TSource,TResult&gt;</code> matches a <code>TSource=&gt;TResult</code> lambda <span class="keep-together">expression</span>.</p>

<p>The <code>Func</code> delegates are listed in <a data-type="xref" href="ch04.html#lambda_expressions">“Lambda Expressions”</a>.</p>
</div></section>

<section data-pdf-bookmark="Lambda expressions and element typing" data-type="sect3"><div class="sect3" id="lambda_expressions_and_element_typing">
<h3>Lambda expressions and element typing</h3>

<p><a contenteditable="false" data-primary="element typing" data-type="indexterm" id="id3125"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="element typing and" data-type="indexterm" id="id3126"/>The standard query operators use the following type parameter names:</p>

<table class="border">
  <thead>
    <tr>
      <th>Generic type letter</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>TSource</code></td>
      <td>Element type for the input sequence</td>
    </tr>
    <tr>
      <td><code>TResult</code></td>
      <td>Element type for the output sequence (if different from <code>TSource</code>)</td>
    </tr>
    <tr>
      <td><code>TKey</code></td>
      <td>Element type for the <em>key</em> used in sorting, grouping, or joining</td>
    </tr>
  </tbody>
</table>

<p><code>TSource</code> is determined by the input sequence. <code>TResult</code> and <code>TKey</code> are typically <em>inferred from your lambda expression</em>.</p>

<p>For example, consider the signature of the <code>Select</code> query operator:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;
  (this IEnumerable&lt;TSource&gt; source, <strong>Func&lt;TSource,TResult&gt;</strong> selector)</pre>

<p><code>Func&lt;TSource,TResult&gt;</code> matches a <code>TSource=&gt;TResult</code> lambda expression: one that maps an <em>input element</em> to an <em>output element</em>. <code>TSource</code> and <code>TResult</code> can be different types, so the lambda expression can change the type of each element. Further, the lambda expression <em>determines the output sequence type</em>. The following query uses <code>Select</code> to transform string type elements to integer type elements:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
IEnumerable&lt;int&gt; query = names.Select (n =&gt; n.Length);

foreach (int length in query)
  Console.Write (length + "|");    // 3|4|5|4|3|</pre>

<p>The compiler can <em>infer</em> the type of <code>TResult</code> from the return value of the lambda expression. In this case, <code>n.Length</code> returns an <code>int</code> value, so <code>TResult</code> is inferred to be <code>int</code>.</p>

<p>The <code>Where</code> query operator is simpler and requires no type inference for the output because input and output elements are of the same type. This makes sense because the operator merely filters elements; it does not <em>transform</em> them:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
  (this IEnumerable&lt;TSource&gt; source, <strong>Func&lt;TSource,bool&gt;</strong> predicate)</pre>

<p>Finally, consider the signature of the <code>OrderBy</code> operator:</p>

<pre data-type="programlisting">
// Slightly simplified:
public static IEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt;
  (this IEnumerable&lt;TSource&gt; source, <strong>Func&lt;TSource,TKey&gt;</strong> keySelector)</pre>

<p><code>Func&lt;TSource,TKey&gt;</code> maps an input element to a <em>sorting key</em>. <code>TKey</code> is inferred from your lambda expression and is separate from the input and output element types. For instance, we could choose to sort a list of names by length (<code>int</code> key) or alphabetically (<code>string</code> key):</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
IEnumerable&lt;string&gt; sortedByLength, sortedAlphabetically;
sortedByLength       = names.OrderBy (n =&gt; n.Length);   // <strong>int</strong> key
sortedAlphabetically = names.OrderBy (n =&gt; n);          // <strong>string</strong> key</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can call the query operators in <code>Enumerable</code> with traditional delegates that refer to methods instead of lambda expressions. This approach is effective in simplifying certain kinds of local queries—particularly with LINQ to XML—and is demonstrated in <a data-type="xref" href="ch10.html#linq_to_xml">Chapter 10</a>. It doesn’t work with <code>IQueryable&lt;T&gt;</code>-based sequences, however (e.g., when querying a database), because the operators in <code>Queryable</code> require lambda expressions in order to emit expression trees. We discuss this later in <a data-type="xref" href="#interpreted_queries">“Interpreted Queries”</a>.<a contenteditable="false" data-primary="" data-startref="ch08.html7" data-type="indexterm" id="id3127"/><a contenteditable="false" data-primary="" data-startref="ch08.html6" data-type="indexterm" id="id3128"/></p>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Natural Ordering" data-type="sect2"><div class="sect2" id="natural_ordering">
<h2>Natural Ordering</h2>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="natural ordering" data-type="indexterm" id="id3129"/>The original ordering of elements within an input sequence is significant in LINQ. Some query operators rely on this ordering, such as <code>Take</code>, <code>Skip</code>, and <code>Reverse</code>.</p>

<p>The <code>Take</code> operator outputs the first <code>x</code> elements, discarding the rest:</p>

<pre data-type="programlisting">
int[] numbers  = { 10, 9, 8, 7, 6 };
IEnumerable&lt;int&gt; firstThree = numbers.Take (3);     // { 10, 9, 8 }</pre>

<p>The <code>Skip</code> operator ignores the first <code>x</code> elements and outputs the rest:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt; lastTwo    = numbers.Skip (3);     // { 7, 6 }</pre>

<p><code>Reverse</code> does exactly as it says:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt; reversed   = numbers.Reverse();    // { 6, 7, 8, 9, 10 }</pre>

<p>With local queries (LINQ-to-objects), operators such as <code>Where</code> and <code>Select</code> preserve the original ordering of the input sequence (as do all other query operators, except for those that specifically change the ordering).</p>
</div></section>

<section data-pdf-bookmark="Other Operators" data-type="sect2"><div class="sect2" id="other_operators">
<h2>Other Operators</h2>

<p><a contenteditable="false" data-primary="element operators" data-type="indexterm" id="id3130"/>Not all query operators return a sequence. The <em>element</em> operators extract one element from the input sequence; examples are <code>First</code>, <code>Last</code>, and <code>ElementAt</code>:</p>

<pre data-type="programlisting">
int[] numbers    = { 10, 9, 8, 7, 6 };
int firstNumber  = numbers.First();                        // 10
int lastNumber   = numbers.Last();                         // 6
int secondNumber = numbers.ElementAt(1);                   // 9
int secondLowest = numbers.OrderBy(n=&gt;n).Skip(1).First();  // 7</pre>

<p>Because these operators return a single element, you don’t usually call further query operators on their result unless that element itself is a collection.</p>

<p><a contenteditable="false" data-primary="aggregation operators" data-type="indexterm" id="id3131"/>The <em>aggregation</em> operators return a scalar value, usually of numeric type:</p>

<pre data-type="programlisting">
int count = numbers.Count();          // 5;
int min = numbers.Min();              // 6;</pre>

<p><a contenteditable="false" data-primary="quantifiers" data-type="indexterm" id="id3132"/>The <em>quantifiers</em> return a <code>bool</code> value:</p>

<pre data-type="programlisting">
bool hasTheNumberNine = numbers.Contains (9);          // true
bool hasMoreThanZeroElements = numbers.Any();          // true
bool hasAnOddElement = numbers.Any (n =&gt; n % 2 != 0);  // true</pre>

<p>Some query operators accept two input sequences. Examples are <code>Concat</code>, which appends one sequence to another, and <code>Union</code>, which does the same but with duplicates removed:</p>

<pre data-type="programlisting">
int[] seq1 = { 1, 2, 3 };
int[] seq2 = { 3, 4, 5 };
IEnumerable&lt;int&gt; concat = seq1.Concat (seq2);    //  { 1, 2, 3, 3, 4, 5 }
IEnumerable&lt;int&gt; union  = seq1.Union (seq2);     //  { 1, 2, 3, 4, 5 }</pre>

<p>The joining operators also fall into this category. <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a> covers all of the query operators in detail.<a contenteditable="false" data-primary="" data-startref="ch08.html3" data-type="indexterm" id="id3133"/><a contenteditable="false" data-primary="" data-startref="ch08.html2" data-type="indexterm" id="id3134"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Query Expressions" data-type="sect1"><div class="sect1" id="query_expressions">
<h1>Query Expressions</h1>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="query expressions" data-type="indexterm" id="ch08.html8"/>C# provides a syntactic shortcut for writing LINQ queries, called <a contenteditable="false" data-primary="query expressions" data-secondary="about" data-type="indexterm" id="ch08.html9"/><em>query expressions</em>. Contrary to popular belief, a query expression is not a means of embedding SQL into C#. In fact, the design of query expressions was inspired primarily by <em>list comprehensions</em> from functional programming languages such as LISP and Haskell, although SQL had a cosmetic influence.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this book, we refer to query expression syntax simply as <em>query syntax</em>.</p>
</div>

<p class="pagebreak-before">In the preceding section, we wrote a fluent-syntax query to extract strings containing the letter “a,” sorted by length and converted to uppercase. Here’s the same thing in query syntax:</p>

<pre data-type="programlisting">
using System;
using System.Collections.Generic;
using System.Linq;

string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;string&gt; query =
<strong>  from    n in names</strong>
<strong>  where   n.Contains ("a")     // Filter elements</strong>
<strong>  orderby n.Length             // Sort elements</strong>
<strong>  select  n.ToUpper();         // Translate each element (project)</strong>

foreach (string name in query) Console.WriteLine (name);

<em>JAY</em>
<em>MARY</em>
<em>HARRY</em></pre>

<p>Query expressions always start with a <code>from</code> clause and end with either a <code>select</code> or <code>group</code> clause. The <code>from</code> clause declares a <em>range variable</em> (in this case, <code>n</code>), which you can think of as traversing the input sequence—rather like <code>foreach</code>. <a data-type="xref" href="#query_syntax-id00091">Figure 8-2</a> illustrates the complete syntax as a railroad diagram.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To read this diagram, start at the left and then proceed along the track as if you were a train. For instance, after the mandatory <code>from</code> clause, you can optionally include an <code>orderby</code>, <code>where</code>, <code>let</code>, or <code>join</code> clause. After that, you can either continue with a <code>select</code> or <code>group</code> clause, or go back and include another <code>from</code>, <code>orderby</code>, <code>where</code>, <code>let</code>, or <code>join</code> clause.</p>
</div>

<figure><div class="figure" id="query_syntax-id00091"><img alt="Query syntax" src="assets/cn10_0802.png"/>
<h6><span class="label">Figure 8-2. </span>Query syntax</h6>
</div></figure>

<p>The compiler processes a query expression by translating it into fluent syntax. It does this in a fairly mechanical fashion—much like it translates <code>foreach</code> statements into calls to <code>GetEnumerator</code> and <code>MoveNext</code>. This means that anything you can write in query syntax you can also write in fluent syntax. The compiler (initially) translates our example query into the following:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names.Where   (n =&gt; n.Contains ("a"))
                                 .OrderBy (n =&gt; n.Length)
                                 .Select  (n =&gt; n.ToUpper());</pre>

<p>The <code>Where</code>, <code>OrderBy</code>, and <code>Select</code> operators then resolve using the same rules that would apply if the query were written in fluent syntax. In this case, they bind to extension methods in the <code>Enumerable</code> class because the <code>System.Linq</code> namespace is imported and <code>names</code> implements <code>IEnumerable&lt;string&gt;</code>. The compiler doesn’t specifically favor the <code>Enumerable</code> class, however, when translating query expressions. You can think of the compiler as mechanically injecting the words “Where,” “OrderBy,” and “Select” into the statement and then compiling it as though you had typed the method names yourself. This offers flexibility in how they resolve. The operators in the database queries that we write in later sections, for instance, will bind instead to extension methods in <code>Queryable</code>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If we remove the <code>using System.Linq</code> directive from our program, the query would not compile, since the <code>Where</code>, <code>OrderBy</code>, and <code>Select</code> methods would have nowhere to bind. Query expressions cannot compile unless you import <code>System.Linq</code> or another namespace with an implementation of these query methods.<a contenteditable="false" data-primary="" data-startref="ch08.html9" data-type="indexterm" id="id3135"/></p>
</div>

<section data-pdf-bookmark="Range Variables" data-type="sect2"><div class="sect2" id="range_variables">
<h2>Range Variables</h2>

<p><a contenteditable="false" data-primary="query expressions" data-secondary="range variables" data-type="indexterm" id="id3136"/><a contenteditable="false" data-primary="range variables" data-type="indexterm" id="id3137"/>The identifier immediately following the <code>from</code> keyword syntax is called the <em>range variable</em>. A range variable refers to the current element in the sequence on which the operation is to be performed.</p>

<p>In our examples, the range variable <code>n</code> appears in every clause in the query. And yet, the variable actually enumerates over a <em>different</em> sequence with each clause:</p>

<pre data-type="programlisting">
from    n in names           // n is our range variable
where   n.Contains ("a")     // n = directly from the array
orderby n.Length             // n = subsequent to being filtered
select  n.ToUpper()          // n = subsequent to being sorted</pre>

<p>This becomes clear when we examine the compiler’s mechanical translation to fluent syntax:</p>

<pre data-type="programlisting">
names.Where   (n =&gt; n.Contains ("a"))      // Locally scoped n
     .OrderBy (n =&gt; n.Length)              // Locally scoped n
     .Select  (n =&gt; n.ToUpper())           // Locally scoped n</pre>

<p>As you can see, each instance of <code>n</code> is scoped privately to its own lambda expression.</p>

<p>Query expressions also let you introduce new range variables via the following <span class="keep-together">clauses</span>:</p>

<ul>
  <li>
  <p><code>let</code></p>
  </li>
  <li>
  <p><code>into</code></p>
  </li>
  <li>
  <p>An additional <code>from</code> clause</p>
  </li>
  <li>
  <p><code>join</code></p>
  </li>
</ul>

<p>We cover these later in this chapter in <a data-type="xref" href="#composition_strategies">“Composition Strategies”</a> as well as in <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a>, in <a data-type="xref" href="ch09.html#projecting-id00076">“Projecting”</a> and <a data-type="xref" href="ch09.html#joining">“Joining”</a>.</p>
</div></section>

<section data-pdf-bookmark="Query Syntax Versus SQL Syntax" data-type="sect2"><div class="sect2" id="query_syntax_versus_sql_syntax">
<h2>Query Syntax Versus SQL Syntax</h2>

<p><a contenteditable="false" data-primary="query expressions" data-secondary="query syntax versus SQL syntax" data-type="indexterm" id="id3138"/>Query expressions look superficially like SQL, yet the two are very different. A LINQ query boils down to a C# expression, and so follows standard C# rules. For example, with LINQ, you cannot use a variable before you declare it. In SQL, you can reference a table alias in the <code>SELECT</code> clause before defining it in a <code>FROM</code> clause.</p>

<p>A subquery in LINQ is just another C# expression and so requires no special syntax. Subqueries in SQL are subject to special rules.</p>

<p>With LINQ, data logically flows from left to right through the query. With SQL, the order is less well structured with regard to data flow.</p>

<p>A LINQ query comprises a conveyor belt or <em>pipeline</em> of operators that accept and emit sequences whose element order can matter. An SQL query comprises a <em>network</em> of clauses that work mostly with <em>unordered sets</em>.</p>
</div></section>

<section data-pdf-bookmark="Query Syntax Versus Fluent Syntax" data-type="sect2"><div class="sect2" id="query_syntax_versus_fluent_syntax">
<h2>Query Syntax Versus Fluent Syntax</h2>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="query syntax versus" data-type="indexterm" id="id3139"/><a contenteditable="false" data-primary="query expressions" data-secondary="query syntax versus fluent syntax" data-type="indexterm" id="id3140"/>Query and fluent syntax each have advantages.</p>

<p>Query syntax is simpler for queries that involve any of the following:</p>

<ul>
  <li>
  <p>A <code>let</code> clause for introducing a new variable alongside the range variable</p>
  </li>
  <li>
  <p><code>SelectMany</code>, <code>Join</code>, or <code>GroupJoin</code>, followed by an outer range variable reference</p>
  </li>
</ul>

<p>(We describe the <code>let</code> clause in <a data-type="xref" href="#composition_strategies">“Composition Strategies”</a>; we describe <code>SelectMany</code>, <code>Join</code>, and <code>GroupJoin</code> in <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a>.)</p>

<p>The middle ground is queries that involve the simple use of <code>Where</code>, <code>OrderBy</code>, and <code>Select</code>. Either syntax works well; the choice here is largely personal.</p>

<p>For queries that comprise a single operator, fluent syntax is shorter and less <span class="keep-together">cluttered</span>.</p>

<p>Finally, there are many operators that have no keyword in query syntax. These require that you use fluent syntax—at least in part. This means any operator outside of the following:</p>

<pre data-type="programlisting">
Where, Select, SelectMany
OrderBy, ThenBy, OrderByDescending, ThenByDescending
GroupBy, Join, GroupJoin</pre>
</div></section>

<section data-pdf-bookmark="Mixed-Syntax Queries" data-type="sect2"><div class="sect2" id="mixed_syntax_queries">
<h2>Mixed-Syntax Queries</h2>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="mixed-syntax queries" data-type="indexterm" id="id3141"/><a contenteditable="false" data-primary="query expressions" data-secondary="mixed-syntax queries" data-type="indexterm" id="id3142"/>If a query operator has no query-syntax support, you can mix query syntax and fluent syntax. The only restriction is that each query-syntax component must be complete (i.e., start with a <code>from</code> clause and end with a <code>select</code> or <code>group</code> clause).</p>

<p>Assuming this array declaration</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };</pre>

<p>the following example counts the number of names containing the letter “a”:</p>

<pre data-type="programlisting">
int matches = (from n in names where n.Contains ("a") select n).Count();
// 3</pre>

<p>The next query obtains the first name in alphabetical order:</p>

<pre data-type="programlisting">
string first = (from n in names orderby n select n).First();   // Dick</pre>

<p>The mixed-syntax approach is sometimes beneficial in more complex queries. With these simple examples, however, we could stick to fluent syntax throughout without penalty:</p>

<pre data-type="programlisting">
int matches = names.Where (n =&gt; n.Contains ("a")).Count();   // 3
string first = names.OrderBy (n =&gt; n).First();               // Dick</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are times when mixed-syntax queries offer by far the highest “bang for the buck” in terms of function and simplicity. It’s important not to unilaterally favor either query or fluent syntax; otherwise, you’ll be unable to write mixed-syntax queries when they are the best option.</p>
</div>

<p>Where applicable, the remainder of this chapter shows key concepts in both fluent and query syntax.<a contenteditable="false" data-primary="" data-startref="ch08.html8" data-type="indexterm" id="id3143"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Deferred Execution" data-type="sect1"><div class="sect1" id="deferred_executio">
<h1>Deferred Execution</h1>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="LINQ queries" data-type="indexterm" id="ch08.html10"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="deferred execution" data-type="indexterm" id="ch08.html11"/>An important feature of most query operators is that they execute not when constructed but when <em>enumerated</em> (in other words, when <code>MoveNext</code> is called on its enumerator). Consider the following query:</p>

<pre data-type="programlisting">
var numbers = new List&lt;int&gt; { 1 };

IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10);    // Build query

numbers.Add (2);                    // Sneak in an extra element

foreach (int n in query)
  Console.Write (n + "|");          // 10|20|</pre>

<p>The extra number that we sneaked into the list <em>after</em> constructing the query is included in the result because it’s not until the <code>foreach</code> statement runs that any filtering or sorting takes place. This is called <em>deferred</em> or <em>lazy</em> execution and is the same as what happens with delegates:</p>

<pre data-type="programlisting">
Action a = () =&gt; Console.WriteLine ("Foo");
// We’ve not written anything to the Console yet. Now let’s run it:
a();  // Deferred execution!</pre>

<p>All standard query operators provide deferred execution, with the following <span class="keep-together">exceptions</span>:</p>

<ul>
  <li>
  <p>Operators that return a single element or scalar value, such as <code>First</code> or <code>Count</code></p>
  </li>
  <li>
  <p>The following <em>conversion operators</em>:</p>
  <pre data-type="programlisting">
ToArray, ToList, ToDictionary, ToLookup, ToHashSet</pre>
  </li>
</ul>

<p>These operators cause immediate query execution because their result types have no mechanism to provide deferred execution. The <code>Count</code> method, for instance, returns a simple integer, which doesn’t then get enumerated. The following query is executed immediately:</p>

<pre data-type="programlisting">
int matches = numbers.Where (n =&gt; n &lt;= 2).Count();    // 1</pre>

<p>Deferred execution is important because it decouples query <em>construction</em> from query <em>execution</em>. This allows you to construct a query in several steps and also makes database queries possible.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Subqueries provide another level of indirection. Everything in a subquery is subject to deferred execution, including aggregation and conversion methods. We describe this in <a data-type="xref" href="#subqueries">“Subqueries”</a>.</p>
</div>

<section data-pdf-bookmark="Reevaluation" data-type="sect2"><div class="sect2" id="reevaluation">
<h2>Reevaluation</h2>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="reevaluation" data-type="indexterm" id="id3144"/>Deferred execution has another consequence: a deferred execution query is reevaluated when you reenumerate:</p>

<pre data-type="programlisting">
var numbers = new List&lt;int&gt;() { 1, 2 };

IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10);
foreach (int n in query) Console.Write (n + "|");   // 10|20|

numbers.Clear();
foreach (int n in query) Console.Write (n + "|");   // &lt;nothing&gt;</pre>

<p>There are a couple of reasons why reevaluation is sometimes disadvantageous:</p>

<ul>
  <li>
  <p>Sometimes, you want to “freeze” or cache the results at a certain point in time.</p>
  </li>
  <li>
  <p>Some queries are computationally intensive (or rely on querying a remote database), so you don’t want to unnecessarily repeat them.</p>
  </li>
</ul>

<p>You can defeat reevaluation by calling a conversion operator such as <code>ToArray</code> or <code>ToList</code>. <code>ToArray</code> copies the output of a query to an array; <code>ToList</code> copies to a generic <code>List&lt;T&gt;</code>:</p>

<pre data-type="programlisting">
var numbers = new List&lt;int&gt;() { 1, 2 };

List&lt;int&gt; timesTen = numbers
  .Select (n =&gt; n * 10)

<strong>  .ToList();                // Executes immediately into a List&lt;int&gt;</strong>

numbers.Clear();
Console.WriteLine (timesTen.Count);      // Still 2</pre>
</div></section>

<section data-pdf-bookmark="Captured Variables" data-type="sect2"><div class="sect2" id="captured_variables">
<h2>Captured Variables</h2>

<p><a contenteditable="false" data-primary="captured variables" data-type="indexterm" id="id3145"/><a contenteditable="false" data-primary="deferred execution" data-secondary="captured variables" data-type="indexterm" id="id3146"/>If your query’s lambda expressions <em>capture</em> outer variables, the query will honor the value of those variables at the time the query <em>runs</em>:</p>

<pre data-type="programlisting">
int[] numbers = { 1, 2 };

int factor = 10;
IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * <strong>factor</strong>);
<strong>factor = 20;</strong>
foreach (int n in query) Console.Write (n + "|");   // <strong>20|40|</strong></pre>

<p>This can be a trap when building up a query within a <code>for</code> loop. For example, suppose that we want to remove all vowels from a string. The following, although inefficient, gives the correct result:</p>

<pre data-type="programlisting">
IEnumerable&lt;char&gt; query = "Not what you might expect";

query = query.Where (c =&gt; c != 'a');
query = query.Where (c =&gt; c != 'e');
query = query.Where (c =&gt; c != 'i');
query = query.Where (c =&gt; c != 'o');
query = query.Where (c =&gt; c != 'u');

foreach (char c in query) Console.Write (c);  // Nt wht y mght xpct</pre>

<p>Now watch what happens when we refactor this with a <code>for</code> loop:</p>

<pre data-type="programlisting">
IEnumerable&lt;char&gt; query = "Not what you might expect";
string vowels = "aeiou";

for (int i = 0; i &lt; vowels.Length; i++)
  query = query.Where (c =&gt; c != vowels[i]);

foreach (char c in query) Console.Write (c);</pre>

<p>An <code>IndexOutOfRangeException</code> is thrown upon enumerating the query because, as we saw in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a> (see <a data-type="xref" href="ch04.html#capturing_outer_variables">“Capturing Outer Variables”</a>), the compiler scopes the iteration variable in the <code>for</code> loop as if it were declared <em>outside</em> the loop. Hence, each closure captures the <em>same</em> variable (<code>i</code>) whose value is 5 when the query is actually enumerated. To solve this, you must assign the loop variable to another variable declared <em>inside</em> the statement block:</p>

<pre data-type="programlisting">
for (int i = 0; i &lt; vowels.Length; i++)
{
  char vowel = vowels[i];
  query = query.Where (c =&gt; c != vowel);
}</pre>

<p>This forces a fresh local variable to be captured on each loop iteration.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another way to solve the problem is to replace the <code>for</code> loop with a <code>foreach</code> loop:</p>

<pre data-type="programlisting">
foreach (char vowel in vowels)
  query = query.Where (c =&gt; c != vowel);</pre>
</div>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="How Deferred Execution Works" data-type="sect2"><div class="sect2" id="how_deferred_execution_works">
<h2 class="less_space">How Deferred Execution Works</h2>

<p><a contenteditable="false" data-primary="decorator sequence" data-type="indexterm" id="id3147"/><a contenteditable="false" data-primary="deferred execution" data-secondary="mechanism of operation" data-type="indexterm" id="id3148"/>Query operators provide deferred execution by returning <em>decorator</em> sequences.</p>

<p>Unlike a traditional collection class such as an array or linked list, a decorator sequence (in general) has no backing structure of its own to store elements. Instead, it wraps another sequence that you supply at runtime, to which it maintains a permanent dependency. Whenever you request data from a decorator, it in turn must request data from the wrapped input sequence.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The query operator’s transformation constitutes the “decoration.” If the output sequence performed no transformation, it would be a <em>proxy</em> rather than a decorator.</p>
</div>

<p>Calling <code>Where</code> merely constructs the decorator wrapper sequence, which holds a reference to the input sequence, the lambda expression, and any other arguments supplied. The input sequence is enumerated only when the decorator is enumerated.</p>

<p><a data-type="xref" href="#decorator_sequence">Figure 8-3</a> illustrates the composition of the following query:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt; lessThanTen = new int[] { 5, 12, 3 }.Where (n =&gt; n &lt; 10);</pre>

<figure><div class="figure" id="decorator_sequence"><img alt="Decorator sequence" src="assets/cn10_0803.png"/>
<h6><span class="label">Figure 8-3. </span>Decorator sequence</h6>
</div></figure>

<p>When you enumerate <code>lessThanTen</code>, you are, in effect, querying the array through the <code>Where</code> decorator.</p>

<p>The good news—should you ever want to write your own query operator—is that implementing a decorator sequence is easy with a C# iterator. Here’s how you can write your own <code>Select</code> method:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TResult&gt; MySelect&lt;TSource,TResult&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)
{
  foreach (TSource element in source)
    yield return selector (element);
}</pre>

<p>This method is an iterator by virtue of the <code>yield return</code> statement. Functionally, it’s a shortcut for the following:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TResult&gt; MySelect&lt;TSource,TResult&gt;
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)
{
  return new <em>SelectSequence</em> (source, selector);
}</pre>

<p>where <code><em>SelectSequence</em></code> is a (compiler-written) class whose enumerator encapsulates the logic in the iterator method.</p>

<p>Hence, when you call an operator such as <code>Select</code> or <code>Where</code>, you’re doing nothing more than instantiating an enumerable class that decorates the input sequence.</p>
</div></section>

<section data-pdf-bookmark="Chaining Decorators" data-type="sect2"><div class="sect2" id="chaining_decorators">
<h2>Chaining Decorators</h2>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="chaining decorators" data-type="indexterm" id="id3149"/>Chaining query operators creates a layering of decorators. Consider the following query:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt; query = new int[] { 5, 12, 3 }.Where   (n =&gt; n &lt; 10)
                                               .OrderBy (n =&gt; n)
                                               .Select  (n =&gt; n * 10);</pre>

<p>Each query operator instantiates a new decorator that wraps the previous sequence (rather like a Russian nesting doll). <a data-type="xref" href="#layered_decorator_sequences">Figure 8-4</a> illustrates the object model of this query. Note that this object model is fully constructed prior to any enumeration.</p>

<figure><div class="figure" id="layered_decorator_sequences"><img alt="Layered decorator sequences" src="assets/cn10_0804.png"/>
<h6><span class="label">Figure 8-4. </span>Layered decorator sequences</h6>
</div></figure>

<p>When you enumerate <code>query</code>, you’re querying the original array, transformed through a layering or chain of decorators.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Adding <code>ToList</code> onto the end of this query would cause the preceding operators to execute immediately, collapsing the whole object model into a single list.</p>
</div>

<p><a data-type="xref" href="#uml_decorator_composition">Figure 8-5</a> shows the same object composition in Unified Modeling Language (UML) syntax. <code>Select</code>’s decorator references the <code>OrderBy</code> decorator, which references <code>Where</code>’s decorator, which references the array. A feature of deferred execution is that you build the identical object model if you compose the query progressively:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt;
  source    = new int[] { 5, 12, 3 },
  filtered  = source   .Where   (n =&gt; n &lt; 10),
  sorted    = filtered .OrderBy (n =&gt; n),
  query     = sorted   .Select  (n =&gt; n * 10);</pre>
  
  <figure><div class="figure" id="uml_decorator_composition"><img alt="UML decorator composition" src="assets/cn10_0805.png"/>
<h6><span class="label">Figure 8-5. </span>UML decorator composition</h6>
</div></figure>
</div></section>

<section data-pdf-bookmark="How Queries Are Executed" data-type="sect2"><div class="sect2" id="how_queries_are_executed">
<h2>How Queries Are Executed</h2>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="how queries are executed" data-type="indexterm" id="id3150"/>Here are the results of enumerating the preceding query:</p>

<pre data-type="programlisting">
foreach (int n in query) Console.WriteLine (n);

<em>30</em>
<em>50</em></pre>

<p>Behind the scenes, the <code>foreach</code> calls <code>GetEnumerator</code> on <code>Select</code>’s decorator (the last or outermost operator), which kicks off everything. The result is a chain of enumerators that structurally mirrors the chain of decorator sequences. <a data-type="xref" href="#execution_of_a_local_query">Figure 8-6</a> illustrates the flow of execution as enumeration proceeds.</p>

<figure><div class="figure" id="execution_of_a_local_query"><img alt="Execution of a local query" src="assets/cn10_0806.png"/>
<h6><span class="label">Figure 8-6. </span>Execution of a local query</h6>
</div></figure>

<p>In the first section of this chapter, we depicted a query as a production line of conveyor belts. Extending this analogy, we can say a LINQ query is a lazy production line, where the conveyor belts roll elements only upon <em>demand</em>. Constructing a query constructs a production line—with everything in place—but with nothing rolling. Then, when the consumer requests an element (enumerates over the query), the rightmost conveyor belt activates; this in turn triggers the others to roll—as and when input sequence elements are needed. LINQ follows a demand-driven <em>pull</em> model, rather than a supply-driven <em>push</em> model. This is important—as you’ll see later—in allowing LINQ to scale to querying SQL databases.<a contenteditable="false" data-primary="" data-startref="ch08.html11" data-type="indexterm" id="id3151"/><a contenteditable="false" data-primary="" data-startref="ch08.html10" data-type="indexterm" id="id3152"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Subqueries" data-type="sect1"><div class="sect1" id="subqueries">
<h1>Subqueries</h1>

<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="subqueries" data-type="indexterm" id="ch08.html12"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="subqueries" data-type="indexterm" id="ch08.html13"/><a contenteditable="false" data-primary="subqueries" data-type="indexterm" id="ch08.html14"/>A <em>subquery</em> is a query contained within another query’s lambda expression. The following example uses a subquery to sort musicians by their last name:</p>

<pre data-type="programlisting">
string[] musos = 
  { "David Gilmour", "Roger Waters", "Rick Wright", "Nick Mason" };

IEnumerable&lt;string&gt; query = musos.OrderBy (m =&gt; <strong>m.Split().Last()</strong>);</pre>

<p><code>m.Split</code> converts each string into a collection of words, upon which we then call the <code>Last</code> query operator. <code>m.Split().Last</code> is the subquery; <code>query</code> references the <em>outer query</em>.</p>

<p class="pagebreak-before">Subqueries are permitted because you can put any valid C# expression on the righthand side of a lambda. A subquery is simply another C# expression. This means that the rules for subqueries are a consequence of the rules for lambda expressions (and the behavior of query operators in general).</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The term <em>subquery</em>, in the general sense, has a broader meaning. For the purpose of describing LINQ, we use the term only for a query referenced from within the lambda expression of another query. In a query expression, a subquery amounts to a query referenced from an expression in any clause except the <code>from</code> clause.</p>
</div>

<p>A subquery is privately scoped to the enclosing expression and can reference parameters in the outer lambda expression (or range variables in a query <span class="keep-together">expression</span>).</p>

<p><code>m.Split().Last</code> is a very simple subquery. The next query retrieves all strings in an array whose length matches that of the shortest string:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;string&gt; outerQuery = names
  .Where (n =&gt; n.Length == <strong>names.OrderBy (n2 =&gt; n2.Length)</strong>
<strong>                                .Select  (n2 =&gt; n2.Length).First()</strong>);

<em>// Tom, Jay</em></pre>

<p>Here’s the same thing as a query expression:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; outerQuery =
  from   n in names
  where  n.Length ==
           <strong>(from n2 in names orderby n2.Length select n2.Length).First()</strong>
  select n;</pre>

<p>Because the outer range variable (<code>n</code>) is in scope for a subquery, we cannot reuse <code>n</code> as the subquery’s range variable.</p>

<p>A subquery is executed whenever the enclosing lambda expression is evaluated. This means that a subquery is executed upon demand, at the discretion of the outer query. You could say that execution proceeds from the <em>outside in</em>. Local queries follow this model literally; interpreted queries (e.g., database queries) follow this model <em>conceptually</em>.</p>

<p class="pagebreak-before">The subquery executes as and when required, to feed the outer query. As Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#subquery_composition">8-7</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#uml_subquery_composition">8-8</a> illustrate, the subquery in our example (the top conveyor belt in <a data-type="xref" href="#subquery_composition">Figure 8-7</a>) executes once for every outer loop iteration.</p>

<figure><div class="figure" id="subquery_composition"><img alt="Subquery composition" src="assets/cn10_0807.png"/>
<h6><span class="label">Figure 8-7. </span>Subquery composition</h6>
</div></figure>



<p>We can express our preceding subquery more succinctly as follows:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from   n in names
  where  n.Length == names.OrderBy (n2 =&gt; n2.Length).First().Length
  select n;</pre>

<p>With the <code>Min</code> aggregation function, we can simplify the query further:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from   n in names
  where  n.Length == names.Min (n2 =&gt; n2.Length)
  select n;</pre>

<p>In <a data-type="xref" href="#interpreted_queries">“Interpreted Queries”</a>, we describe how remote sources such as SQL tables can be queried. Our example makes an ideal database query because it would be processed as a unit, requiring only one round trip to the database server. This query, however, is inefficient for a local collection because the subquery is recalculated on each outer loop iteration. We can avoid this inefficiency by running the subquery separately (so that it’s no longer a subquery):</p>

<pre data-type="programlisting">
int shortest = names.Min (n =&gt; n.Length);

IEnumerable&lt;string&gt; query = from   n in names
                            where  n.Length == shortest
                            select n;</pre>

<figure><div class="figure" id="uml_subquery_composition"><img alt="UML subquery composition" src="assets/cn10_0808.png"/>
<h6><span class="label">Figure 8-8. </span>UML subquery composition</h6>
</div></figure>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Factoring out subqueries in this manner is nearly always desirable when querying local collections. An exception is when the subquery is <em>correlated</em>, meaning that it references the outer range variable. We explore correlated subqueries in <a data-type="xref" href="ch09.html#projecting-id00076">“Projecting”</a>.</p>
</div>

<section data-pdf-bookmark="Subqueries and Deferred Execution" data-type="sect2"><div class="sect2" id="subqueries_and_deferred_execution">
<h2>Subqueries and Deferred Execution</h2>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="subqueries and" data-type="indexterm" id="id3153"/><a contenteditable="false" data-primary="subqueries" data-secondary="deferred execution and" data-type="indexterm" id="id3154"/>An element or aggregation operator such as <code>First</code> or <code>Count</code> in a subquery doesn’t force the <em>outer</em> query into immediate execution—deferred execution still holds for the outer query. This is because subqueries are called <em>indirectly</em>—through a delegate in the case of a local query, or through an expression tree in the case of an interpreted query.</p>

<p>An interesting case arises when you include a subquery within a <code>Select</code> expression. In the case of a local query, you’re actually <em>projecting a sequence of queries</em>—each itself subject to deferred execution. The effect is generally transparent, and it serves to further improve efficiency. We revisit <code>Select</code> subqueries in some detail in <span class="keep-together"><a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a></span>.<a contenteditable="false" data-primary="" data-startref="ch08.html14" data-type="indexterm" id="id3155"/><a contenteditable="false" data-primary="" data-startref="ch08.html13" data-type="indexterm" id="id3156"/><a contenteditable="false" data-primary="" data-startref="ch08.html12" data-type="indexterm" id="id3157"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Composition Strategies" data-type="sect1"><div class="sect1" id="composition_strategies">
<h1>Composition Strategies</h1>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="composition strategies" data-type="indexterm" id="ch08.html15"/>In this section, we describe three strategies for building more complex queries:</p>

<ul>
  <li>
  <p>Progressive query construction</p>
  </li>
  <li>
  <p>Using the <code>into</code> keyword</p>
  </li>
  <li>
  <p>Wrapping queries</p>
  </li>
</ul>

<p>All are <em>chaining</em> strategies and produce identical runtime queries.</p>

<section data-pdf-bookmark="Progressive Query Building" data-type="sect2"><div class="sect2" id="progressive_query_building">
<h2>Progressive Query Building</h2>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="progressive query building" data-type="indexterm" id="ch08.html16"/>At the start of the chapter, we demonstrated how you could build a fluent query progressively:</p>

<pre data-type="programlisting">
var filtered   = names    .Where   (n =&gt; n.Contains ("a"));
var sorted     = filtered .OrderBy (n =&gt; n);
var query      = sorted   .Select  (n =&gt; n.ToUpper());</pre>

<p>Because each of the participating query operators returns a decorator sequence, the resultant query is the same chain or layering of decorators that you would get from a single-expression query. There are a couple of potential benefits, however, to building queries progressively:</p>

<ul>
  <li>
  <p>It can make queries easier to write.</p>
  </li>
  <li>
  <p>You can add query operators <em>conditionally</em>. For example,</p>


<pre data-type="programlisting">
if (includeFilter) query = query.Where (...)</pre>

<p>is more efficient than</p>

<pre data-type="programlisting">
query = query.Where (n =&gt; !includeFilter || <em>&lt;expression&gt;</em>)</pre>

<p>because it avoids adding an extra query operator if <code>includeFilter</code> is false.</p> </li>
</ul>

<p>A progressive approach is often useful in query comprehensions. Imagine that we want to remove all vowels from a list of names and then present in alphabetical order those whose length is still more than two characters. In fluent syntax, we could write this query as a single expression—by projecting <em>before</em> we filter:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names
  .Select  (n =&gt; n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                  .Replace ("o", "").Replace ("u", ""))
  .Where   (n =&gt; n.Length &gt; 2)
  .OrderBy (n =&gt; n);

<em>// Dck</em>
<em>// Hrry</em>
<em>// Mry</em></pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Rather than calling <code>string</code>’s <code>Replace</code> method five times, we could remove vowels from a string more efficiently with a regular expression:</p>

<pre data-type="programlisting">
n =&gt; Regex.Replace (n, "[aeiou]", "")</pre>

<p><code>string</code>’s <code>Replace</code> method has the advantage, though, of also working in database queries.</p>
</div>

<p>Translating this directly into a query expression is troublesome because the <code>select</code> clause must come after the <code>where</code> and <code>orderby</code> clauses. And if we rearrange the query so as to project last, the result would be different:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from    n in names
  where   n.Length &gt; 2
  orderby n
  select  n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
           .Replace ("o", "").Replace ("u", "");

<em>// Dck</em>
<em>// Hrry</em>
<em>// Jy</em>
<em>// Mry</em>
<em>// Tm</em></pre>

<p>Fortunately, there are a number of ways to get the original result in query syntax. The first is by querying progressively:<a contenteditable="false" data-primary="" data-startref="ch08.html16" data-type="indexterm" id="id3158"/></p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from   n in names
  select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
          .Replace ("o", "").Replace ("u", "");

query = from n in query where n.Length &gt; 2 orderby n select n;

<em>// Dck</em>
<em>// Hrry</em>
<em>// Mry</em></pre>
</div></section>

<section data-pdf-bookmark="The into Keyword" data-type="sect2"><div class="sect2" id="the_into_keyword">
<h2>The into Keyword</h2>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="into keyword" data-type="indexterm" id="id3159"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="into keyword" data-type="indexterm" id="id3160"/>The <code>into</code> keyword is interpreted in two very different ways by query expressions, depending on context. <a contenteditable="false" data-primary="query continuation" data-type="indexterm" id="id3161"/>The meaning we’re describing now is for signaling <em>query continuation</em> (the other is for signaling a <code>GroupJoin</code>).</p> 
</div>

<p>The <code>into</code> keyword lets you “continue” a query after a projection and is a shortcut for progressively querying. With <code>into</code>, we can rewrite the preceding query as follows:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from   n in names
  select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
          .Replace ("o", "").Replace ("u", "")
  <strong>into noVowel</strong>
    where noVowel.Length &gt; 2 orderby noVowel select noVowel;</pre>

<p>The only place you can use <code>into</code> is after a <code>select</code> or <code>group</code> clause. <code>into</code> “restarts” a query, allowing you to introduce fresh <code>where</code>, <code>orderby</code>, and <code>select</code> clauses.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although it’s easiest to think of <code>into</code> as restarting a query from the perspective of a query expression, it’s <em>all one query</em> when translated to its final fluent form. Hence, there’s no intrinsic performance hit with <code>into</code>. Nor do you lose any points for its use!</p>
</div>

<p>The equivalent of <code>into</code> in fluent syntax is simply a longer chain of operators.</p>

<section data-pdf-bookmark="Scoping rules" data-type="sect3"><div class="sect3" id="scoping_rules">
<h3>Scoping rules</h3>

<p>All range variables are out of scope following an <code>into</code> keyword. The following will not compile:</p>

<pre data-type="programlisting">
var query =
  from n1 in names
  select n1.ToUpper()
  into n2                              // Only n2 is visible from here on.
    <strong>where n1.Contains ("x")            // Illegal: n1 is not in scope.</strong>
    select n2;</pre>

<p>To see why, consider how this maps to fluent syntax:</p>

<pre data-type="programlisting">
var query = names
  .Select (n1 =&gt; n1.ToUpper())
  <strong>.Where  (n2 =&gt; n1.Contains ("x"));     // Error: n1 no longer in scope</strong></pre>

<p>The original name (<code>n1</code>) is lost by the time the <code>Where</code> filter runs. <code>Where</code>’s input sequence contains only uppercase names, so it cannot filter based on <code>n1</code>.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Wrapping Queries" data-type="sect2"><div class="sect2" id="wrapping_queries">
<h2>Wrapping Queries</h2>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="wrapping queries" data-type="indexterm" id="id3162"/>A query built progressively can be formulated into a single statement by wrapping one query around another. In general terms,</p>

<pre data-type="programlisting">
var tempQuery = <em>tempQueryExpr</em>
var finalQuery = from <em>...</em> in tempQuery <em>...</em></pre>

<p>can be reformulated as:</p>

<pre data-type="programlisting">
var finalQuery = from <em>...</em> in (<em>tempQueryExpr</em>)</pre>

<p>Wrapping is semantically identical to progressive query building or using the <code>into</code> keyword (without the intermediate variable). The end result in all cases is a linear chain of query operators. For example, consider the following query:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from   n in names
  select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
          .Replace ("o", "").Replace ("u", "");

query = from n in query where n.Length &gt; 2 orderby n select n;</pre>

<p>Reformulated in wrapped form, it’s the following:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from n1 in
  (
    from   n2 in names
    select n2.Replace ("a", "").Replace ("e", "").Replace ("i", "")
             .Replace ("o", "").Replace ("u", "")
  )
  where n1.Length &gt; 2 orderby n1 select n1;</pre>

<p>When converted to fluent syntax, the result is the same linear chain of operators as in previous examples:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names
  .Select  (n =&gt; n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                  .Replace ("o", "").Replace ("u", ""))
  .Where   (n =&gt; n.Length &gt; 2)
  .OrderBy (n =&gt; n);</pre>

<p>(The compiler does not emit the final <code>.Select (n =&gt; n)</code>, because it’s redundant.)</p>

<p>Wrapped queries can be confusing because they resemble the <em>subqueries</em> we wrote earlier. Both have the concept of an inner and outer query. When converted to fluent syntax, however, you can see that wrapping is simply a strategy for sequentially chaining operators. The end result bears no resemblance to a subquery, which embeds an inner query within the <em>lambda expression</em> of another.</p>

<p>Returning to a previous analogy: when wrapping, the “inner” query amounts to the <em>preceding conveyor belts</em>. In contrast, a subquery rides above a conveyor belt and is activated upon demand through the conveyor belt’s lambda worker (as illustrated in <a data-type="xref" href="#subquery_composition">Figure 8-7</a>).<a contenteditable="false" data-primary="" data-startref="ch08.html15" data-type="indexterm" id="id3163"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Projection Strategies" data-type="sect1"><div class="sect1" id="projection_strategies">
<h1>Projection Strategies</h1>

<section data-pdf-bookmark="Object Initializers" data-type="sect2"><div class="sect2" id="object_initializer">
<h2>Object Initializers</h2>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="object initializers" data-type="indexterm" id="id3164"/><a contenteditable="false" data-primary="object initializers" data-secondary="LINQ queries and" data-type="indexterm" id="id3165"/>So <a contenteditable="false" data-primary="LINQ queries" data-secondary="projection strategies" data-type="indexterm" id="ch08.html17"/>far, all of our <code>select</code> clauses have projected scalar element types. With C# object initializers, you can project into more complex types. For example, suppose, as a first step in a query, we want to strip vowels from a list of names while still retaining the original versions alongside, for the benefit of subsequent queries. We can write the following class to assist:</p>

<pre data-type="programlisting">
class TempProjectionItem
{
  public string Original;    // Original name
  public string Vowelless;   // Vowel-stripped name
}</pre>

<p class="pagebreak-before">We then can project into it with object initializers:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;TempProjectionItem&gt; temp =
  from n in names
  select new TempProjectionItem
 <strong> {</strong>
 <strong>   Original  = n,</strong>
    <strong>Vowelless = n.Replace ("a", "").Replace ("e", "").Replace ("i", "")</strong>
<strong>                 .Replace ("o", "").Replace ("u", "")</strong>
  };</pre>

<p>The result is of type <code>IEnumerable&lt;TempProjectionItem&gt;</code>, which we can subsequently query:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = from   item in temp
                            where  item.Vowelless.Length &gt; 2
                            select item.Original;
<em>// Dick</em>
<em>// Harry</em>
<em>// Mary</em></pre>
</div></section>

<section data-pdf-bookmark="Anonymous Types" data-type="sect2"><div class="sect2" id="anonymous_type">
<h2>Anonymous Types</h2>

<p><a contenteditable="false" data-primary="anonymous types" data-type="indexterm" id="id3166"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="anonymous types" data-type="indexterm" id="id3167"/>Anonymous types allow you to structure your intermediate results without writing special classes. We can eliminate the <code>TempProjectionItem</code> class in our previous example with anonymous types:</p>

<pre data-type="programlisting">
var intermediate = from n in names

  <strong>select new</strong>
  <strong>{</strong>
    <strong>Original = n,</strong>
    <strong>Vowelless = n.Replace ("a", "").Replace ("e", "").Replace ("i", "")</strong>
<strong>                 .Replace ("o", "").Replace ("u", "")</strong>
  <strong>};</strong>

IEnumerable&lt;string&gt; query = from   item in intermediate
                            where  item.Vowelless.Length &gt; 2
                            select item.Original;</pre>

<p>This gives the same result as the previous example, but without needing to write a one-off class. The compiler does the job instead, generating a temporary class with fields that match the structure of our projection. This means, however, that the <code>intermediate</code> query has the following type:</p>

<pre data-type="programlisting">
IEnumerable &lt;<em>random-compiler-generated-name</em>&gt;</pre>

<p>The only way we can declare a variable of this type is with the <code>var</code> keyword. In this case, <code>var</code> is more than just a clutter reduction device; it’s a necessity.</p>

<p class="pagebreak-after">We can write the entire query more succinctly with the <code>into</code> keyword:</p>

<pre data-type="programlisting">
var query = from n in names
  select new
  {
     Original = n,
     Vowelless = n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                  .Replace ("o", "").Replace ("u", "")
  }
  into temp
  where temp.Vowelless.Length &gt; 2
  select temp.Original;</pre>

<p>Query expressions provide a shortcut for writing this kind of query: the <code>let</code> <span class="keep-together">keyword</span>.</p>
</div></section>

<section data-pdf-bookmark="The let Keyword" data-type="sect2"><div class="sect2" id="the_let_keyword">
<h2>The let Keyword</h2>

<p><a contenteditable="false" data-primary="let keyword" data-type="indexterm" id="id3168"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="let keyword" data-type="indexterm" id="id3169"/>The <code>let</code> keyword introduces a new variable alongside the range variable.</p>

<p>With <code>let</code>, we can write a query extracting strings whose length, excluding vowels, exceeds two characters, as follows:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;string&gt; query =
  from n in names
  <strong>let vowelless = n.Replace ("a", "").Replace ("e", "").Replace ("i", "")</strong>
<strong>                   .Replace ("o", "").Replace ("u", "")</strong>
<strong>  where vowelless.Length &gt; 2</strong>
  orderby vowelless
  select n;       // Thanks to let, n is still in scope.</pre>

<p>The compiler resolves a <code>let</code> clause by projecting into a temporary anonymous type that contains both the range variable and the new expression variable. In other words, the compiler translates this query into the preceding example.</p>

<p><code>let</code> accomplishes two things:</p>

<ul>
  <li>
  <p>It projects new elements alongside existing elements.</p>
  </li>
  <li>
  <p>It allows an expression to be used repeatedly in a query without being <span class="keep-together">rewritten</span>.</p>
  </li>
</ul>

<p>The <code>let</code> approach is particularly advantageous in this example because it allows the <code>select</code> clause to project either the original name (<code>n</code>) or its vowel-removed version (<code>vowelless</code>).</p>

<p>You can have any number of <code>let</code> statements before or after a <code>where</code> statement (see <a data-type="xref" href="#query_syntax-id00091">Figure 8-2</a>). A <code>let</code> statement can reference variables introduced in earlier <code>let</code> statements (subject to the boundaries imposed by an <code>into</code> clause). <code>let</code> <em>reprojects</em> all existing variables transparently.</p>

<p>A <code>let</code> expression need not evaluate to a scalar type: sometimes it’s useful to have it evaluate to a subsequence, for instance.<a contenteditable="false" data-primary="" data-startref="ch08.html17" data-type="indexterm" id="id3170"/></p>
</div></section>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Interpreted Queries" data-type="sect1"><div class="sect1" id="interpreted_queries">
<h1 class="less_space">Interpreted Queries</h1>

<p><a contenteditable="false" data-primary="interpreted queries" data-type="indexterm" id="ch08.html18"/><a contenteditable="false" data-primary="LINQ queries" data-secondary="interpreted queries" data-type="indexterm" id="ch08.html19"/>LINQ provides two parallel architectures: <em>local</em> queries for local object collections and <em>interpreted</em> queries for remote data sources. So far, we’ve examined the architecture of local queries, which operate over collections implementing <code>IEnumerable&lt;T&gt;</code>. Local queries resolve to query operators in the <code>Enumerable</code> class (by default), which in turn resolve to chains of decorator sequences. The delegates that they accept—whether expressed in query syntax, fluent syntax, or traditional delegates—are fully local to Intermediate Language (IL) code, just like any other C# method.</p>

<p>By contrast, interpreted queries are <em>descriptive</em>. They operate over sequences that implement <a contenteditable="false" data-primary="IQueryable&lt;T&gt;" data-type="indexterm" id="ch08.html20"/><code>IQueryable&lt;T&gt;</code>, and they resolve to the query operators in the <code>Queryable</code> class, which emit <em>expression trees</em> that are interpreted at runtime. These expression trees can be translated, for instance, to SQL queries, allowing you to use LINQ to query a database.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The query operators in <code>Enumerable</code> can actually work with <code>IQueryable&lt;T&gt;</code> sequences. The difficulty is that the resultant queries always execute locally on the client. This is why a second set of query operators is provided in the <code>Queryable</code> class.</p>
</div>

<p>To write interpreted queries, you need to start with an API that exposes sequences of type <code>IQueryable&lt;T&gt;</code>. An example is Microsoft’s <em>Entity Framework Core</em> (EF Core), which allows you to query a variety of databases, including SQL Server, Oracle, MySQL, PostgreSQL, and SQLite.</p>

<p>It’s also possible to generate an <code>IQueryable&lt;T&gt;</code> wrapper around an ordinary enumerable collection by calling the <code>AsQueryable</code> method. We describe <code>AsQueryable</code> in <a data-type="xref" href="#building_query_expressions">“Building Query Expressions”</a>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>IQueryable&lt;T&gt;</code> is an extension of <code>IEnumerable&lt;T&gt;</code> with additional methods for constructing expression trees. Most of the time you can ignore the details of these methods; they’re called indirectly by the runtime. <a data-type="xref" href="#building_query_expressions">“Building Query Expressions”</a> covers <code>IQueryable&lt;T&gt;</code> in more detail.</p>
</div>

<p>To illustrate, let’s create a simple customer table in SQL Server and populate it with a few names using the following SQL script:</p>

<pre data-type="programlisting">
create table Customer
(
  ID int not null primary key,
  Name varchar(30)
)
insert Customer values (1, 'Tom')
insert Customer values (2, 'Dick')
insert Customer values (3, 'Harry')
insert Customer values (4, 'Mary')
insert Customer values (5, 'Jay')</pre>

<p>With this table in place, we can write an interpreted LINQ query in C# that uses EF Core to retrieve customers whose name contains the letter “a,” as follows:</p>

<pre data-type="programlisting">
using System;
using System.Linq;
using Microsoft.EntityFrameworkCore;

using var dbContext = new NutshellContext();

<strong>IQueryable&lt;string&gt; query = from c in dbContext.Customers</strong>
<strong>  where   c.Name.Contains ("a")</strong>
<strong>  orderby c.Name.Length</strong>
<strong>  select  c.Name.ToUpper();</strong>

foreach (string name in query) Console.WriteLine (name);

public class Customer
{
  public int ID { get; set; }
  public string Name { get; set; }
}

// We’ll explain the following class in more detail in the next section.
public class NutshellContext : DbContext
{
  public virtual DbSet&lt;Customer&gt; Customers { get; set; }

  protected override void OnConfiguring (DbContextOptionsBuilder builder)
    =&gt; builder.UseSqlServer ("...connection string...");

  protected override void OnModelCreating (ModelBuilder modelBuilder)
    =&gt; modelBuilder.Entity&lt;Customer&gt;().ToTable ("Customer")
                                      .HasKey (c =&gt; c.ID);
}</pre>

<p>EF Core translates this query into the following SQL:</p>

<pre data-type="programlisting">
SELECT UPPER([c].[Name])
FROM [Customers] AS [c]
WHERE CHARINDEX(N'a', [c].[Name]) &gt; 0
ORDER BY CAST(LEN([c].[Name]) AS int)</pre>

<p>Here’s the end result:</p>

<pre data-type="programlisting">
<em>// JAY</em>
<em>// MARY</em>
<em>// HARRY</em></pre>

<section class="pagebreak-before" data-pdf-bookmark="How Interpreted Queries Work" data-type="sect2"><div class="sect2" id="how_interpreted_queries_work">
<h2 class="less_space">How Interpreted Queries Work</h2>

<p><a contenteditable="false" data-primary="interpreted queries" data-secondary="mechanism of operation" data-type="indexterm" id="id3171"/>Let’s examine how the preceding query is processed.</p>

<p>First, the compiler converts query syntax to fluent syntax. This is done exactly as with local queries:</p>

<pre data-type="programlisting">
IQueryable&lt;string&gt; query = dbContext.customers
                                    .Where   (n =&gt; n.Name.Contains ("a"))
                                    .OrderBy (n =&gt; n.Name.Length)
                                    .Select  (n =&gt; n.Name.ToUpper());</pre>

<p>Next, the compiler resolves the query operator methods. Here’s where local and interpreted queries differ—interpreted queries resolve to query operators in the <code>Queryable</code> class instead of the <code>Enumerable</code> class.</p>

<p>To see why, we need to look at the <code>dbContext.Customers</code> variable, the source upon which the entire query builds. <code>dbContext.Customers</code> is of type <code>DbSet&lt;T&gt;</code>, which implements <code>IQueryable&lt;T&gt;</code> (a subtype of <code>IEnumerable&lt;T&gt;</code>). This means that the compiler has a choice in resolving <code>Where</code>: it could call the extension method in <code>Enumerable</code> or the following extension method in <code>Queryable</code>:</p>

<pre data-type="programlisting">
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this
  IQueryable&lt;TSource&gt; source, Expression &lt;Func&lt;TSource,bool&gt;&gt; predicate)</pre>

<p>The compiler chooses <code>Queryable.Where</code> because its signature is a <em>more specific match</em>.</p>

<p><code>Queryable.Where</code> accepts a predicate wrapped in an <code>Expression&lt;TDelegate&gt;</code> type. This instructs the compiler to translate the supplied lambda expression—in other words, <code>n=&gt;n.Name.Contains("a")</code>—to an <em>expression tree</em> rather than a compiled delegate. An expression tree is an object model based on the types in <code>System.Linq.Expressions</code> that can be inspected at runtime (so that EF Core can later translate it to an SQL statement).</p>

<p>Because <code>Queryable.Where</code> also returns <code>IQueryable&lt;T&gt;</code>, the same process follows with the <code>OrderBy</code> and <code>Select</code> operators. <a data-type="xref" href="#interpreted_query_composition">Figure 8-9</a> illustrates the end result. In the shaded box, there is an <em>expression tree</em> describing the entire query, which can be traversed at runtime.</p>

<figure><div class="figure" id="interpreted_query_composition"><img alt="Interpreted query composition" src="assets/cn10_0809.png"/>
<h6><span class="label">Figure 8-9. </span>Interpreted query composition</h6>
</div></figure>

<section data-pdf-bookmark="Execution" data-type="sect3"><div class="sect3" id="execution">
<h3>Execution</h3>

<p><a contenteditable="false" data-primary="interpreted queries" data-secondary="execution" data-type="indexterm" id="id3172"/>Interpreted queries follow a deferred execution model—just like local queries. This means that the SQL statement is not generated until you start enumerating the query. Further, enumerating the same query twice results in the database being queried twice.</p>

<p>Under the hood, interpreted queries differ from local queries in how they execute. When you enumerate over an interpreted query, the outermost sequence runs a program that traverses the entire expression tree, processing it as a unit. In our example, EF Core translates the expression tree to an SQL statement, which it then executes, yielding the results as a sequence.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To work, EF Core needs to understand the schema of the database. It does this by leveraging conventions, code attributes, and a fluent configuration API. We’ll explore this in detail later in the chapter.</p>
</div>

<p>We said previously that a LINQ query is like a production line. However, when you enumerate an <code>IQueryable</code> conveyor belt, it doesn’t start up the whole production line, like with a local query. Instead, just the <code>IQueryable</code> belt starts up, with a special enumerator that calls upon a production manager. The manager reviews the entire production line—which consists not of compiled code but of <em>dummies</em> (method call expressions) with instructions pasted to their <em>foreheads</em> (expression trees). The manager then traverses all the expressions, in this case transcribing them to a single piece of paper (an SQL statement), which it then executes, feeding the results back to the consumer. Only one belt turns; the rest of the production line is a network of empty shells, existing just to describe what needs to be done.</p>

<p>This has some practical implications. For instance, with local queries, you can write your own query methods (fairly easily, with iterators) and then use them to supplement the predefined set. With remote queries, this is difficult and even undesirable. If you wrote a <code>MyWhere</code> extension method accepting <code>IQueryable&lt;T&gt;</code>, it would be like putting your own dummy into the production line. The production manager wouldn’t know what to do with your dummy. Even if you intervened at this stage, your solution would be hardwired to a particular provider, such as EF Core, and would not work with other <code>IQueryable</code> implementations. Part of the benefit of having a standard set of methods in <code>Queryable</code> is that they define a <em>standard vocabulary</em> for querying <em>any</em> remote collection. As soon as you try to extend the vocabulary, you’re no longer interoperable.</p>

<p>Another consequence of this model is that an <code>IQueryable</code> provider might be unable to cope with some queries—even if you stick to the standard methods. EF Core is limited by the capabilities of the database server; some LINQ queries have no SQL translation. If you’re familiar with SQL, you’ll have a good intuition for what these are, although at times you’ll need to experiment to see what causes a runtime error; it can be surprising what <em>does</em> work!<a contenteditable="false" data-primary="" data-startref="ch08.html20" data-type="indexterm" id="id3173"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Combining Interpreted and Local Queries" data-type="sect2"><div class="sect2" id="combining_interpreted_and_local_queries">
<h2>Combining Interpreted and Local Queries</h2>

<p><a contenteditable="false" data-primary="interpreted queries" data-secondary="combining local queries with" data-type="indexterm" id="id3174"/><a contenteditable="false" data-primary="local queries" data-type="indexterm" id="id3175"/>A query can include both interpreted and local operators. A typical pattern is to have the local operators on the <em>outside</em> and the interpreted components on the <em>inside</em>; in other words, the interpreted queries feed the local queries. This pattern works well when querying a database.</p>

<p>For instance, suppose that we write a custom extension method to pair up strings in a collection:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;string&gt; Pair (this IEnumerable&lt;string&gt; source)
{
  string firstHalf = null;
  foreach (string element in source)
    if (firstHalf == null)
      firstHalf = element;
    else
    {
      yield return firstHalf + ", " + element;
      firstHalf = null;
    }
}</pre>

<p>We can use this extension method in a query that mixes EF Core and local <span class="keep-together">operators</span>:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext ();
IEnumerable&lt;string&gt; q = dbContext.Customers
  .Select (c =&gt; c.Name.ToUpper())
  .OrderBy (n =&gt; n)
<strong>  .Pair()                         // Local from this point on.</strong>
  <strong>.Select ((n, i) =&gt; "Pair " + i.ToString() + " = " + n);</strong>

foreach (string element in q) Console.WriteLine (element);

<em>// Pair 0 = DICK, HARRY</em>
<em>// Pair 1 = JAY, MARY</em></pre>

<p>Because <code>dbContext.Customers</code> is of a type implementing <code>IQueryable&lt;T&gt;</code>, the <code>Select</code> operator resolves to <code>Queryable.Select</code>. This returns an output sequence also of type <code>IQueryable&lt;T&gt;</code>, so the <code>OrderBy</code> operator similarly resolves to <span class="keep-together"><code>Queryable.OrderBy</code></span>. But the next query operator, <code>Pair</code>, has no overload accepting <code>IQueryable&lt;T&gt;</code>—only the less specific <code>IEnumerable&lt;T&gt;</code>. So, it resolves to our local <code>Pair</code> method—wrapping the interpreted query in a local query. <code>Pair</code> also returns <span class="keep-together"><code>IEnumerable</code></span>, so the <code>Select</code> that follows resolves to another local operator.</p>

<p>On the EF Core side, the resulting SQL statement is equivalent to this:</p>

<pre data-type="programlisting">
SELECT UPPER([c].[Name]) FROM [Customers] AS [c] ORDER BY UPPER([c].[Name])</pre>

<p>The remaining work is done locally. In effect, we end up with a local query (on the outside) whose source is an interpreted query (the inside).</p>
</div></section>

<section data-pdf-bookmark="AsEnumerable" data-type="sect2"><div class="sect2" id="asenumerable">
<h2>AsEnumerable</h2>

<p><a contenteditable="false" data-primary="AsEnumerable operator" data-type="indexterm" id="id3176"/><a contenteditable="false" data-primary="Enumerable..." data-secondary="Enumerable.AsEnumerable operator" data-type="indexterm" id="id3177"/><a contenteditable="false" data-primary="interpreted queries" data-secondary="AsEnumerable operator" data-type="indexterm" id="id3178"/><code>Enumerable.AsEnumerable</code> is the simplest of all query operators. Here’s its complete definition:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt;
              (this IEnumerable&lt;TSource&gt; source)
{
    return source;
}</pre>

<p>Its purpose is to cast an <code>IQueryable&lt;T&gt;</code> sequence to <code>IEnumerable&lt;T&gt;</code>, forcing subsequent query operators to bind to <code>Enumerable</code> operators instead of <code>Queryable</code> operators. This causes the remainder of the query to execute locally.</p>

<p>To illustrate, suppose that we had a <code>MedicalArticles</code> table in SQL Server and wanted to use EF Core to retrieve all articles on influenza whose abstract contained fewer than 100 words. For the latter predicate, we need a regular expression:</p>

<pre data-type="programlisting">
Regex wordCounter = new Regex (@"\b(\w|[-'])+\b");

using var dbContext = new NutshellContext ();

var query = dbContext.MedicalArticles
  .Where (article =&gt; article.Topic == "influenza" &amp;&amp;
                     <strong>wordCounter.Matches (article.Abstract).Count</strong> &lt; 100);</pre>

<p>The problem is that SQL Server doesn’t support regular expressions, so EF Core will throw an exception, complaining that the query cannot be translated to SQL. We can solve this by querying in two steps: first retrieving all articles on influenza through an EF Core query, and then filtering <em>locally</em> for abstracts of fewer than 100 words:</p>

<pre data-type="programlisting">
Regex wordCounter = new Regex (@"\b(\w|[-'])+\b");

using var dbContext = new NutshellContext ();

<strong>IEnumerable&lt;MedicalArticle&gt;</strong> efQuery = dbContext.MedicalArticles
  .Where (article =&gt; article.Topic == "influenza");

IEnumerable&lt;MedicalArticle&gt; localQuery = efQuery
  .Where (article =&gt; wordCounter.Matches (article.Abstract).Count &lt; 100);</pre>

<p>Because <code>efQuery</code> is of type <code>IEnumerable&lt;MedicalArticle&gt;</code>, the second query binds to the local query operators, forcing that part of the filtering to run on the client.</p>

<p>With <code>AsEnumerable</code>, we can do the same in a single query:</p>

<pre data-type="programlisting">
Regex wordCounter = new Regex (@"\b(\w|[-'])+\b");

using var dbContext = new NutshellContext ();

var query = dbContext.MedicalArticles
  .Where (article =&gt; article.Topic == "influenza")

<strong>  .AsEnumerable()</strong>
  .Where (article =&gt; wordCounter.Matches (article.Abstract).Count &lt; 100);</pre>

<p>An alternative to calling <code>AsEnumerable</code> is to call <code>ToArray</code> or <code>ToList</code>. The advantage of <code>AsEnumerable</code> is that it doesn’t force immediate query execution, nor does it create any storage structure.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Moving query processing from the database server to the client can hurt performance, especially if it means retrieving more rows. A more efficient (though more complex) way to solve our example would be to use SQL CLR integration to expose a function on the database that implemented the regular expression.</p>
</div>

<p>We further demonstrate combined interpreted and local queries in <a data-type="xref" href="ch10.html#linq_to_xml">Chapter 10</a>.<a contenteditable="false" data-primary="" data-startref="ch08.html19" data-type="indexterm" id="id3179"/><a contenteditable="false" data-primary="" data-startref="ch08.html18" data-type="indexterm" id="id3180"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="EF Core" data-type="sect1"><div class="sect1" id="ef_core">
<h1>EF Core</h1>

<p><a contenteditable="false" data-primary="EF Core" data-type="indexterm" id="ch08.html21"/>Throughout this and <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a>, we use EF Core to demonstrate interpreted queries. Let’s now examine the key features of this technology.</p>

<section data-pdf-bookmark="EF Core Entity Classes" data-type="sect2"><div class="sect2" id="ef_core_entity_classes">
<h2>EF Core Entity Classes</h2>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="entity classes" data-type="indexterm" id="id3181"/>EF Core lets you use any class to represent data, as long as it contains a public property for each column that you want to query.</p>

<p>For instance, we could define the following entity class to query and update a <span class="keep-together"><em>Customers</em></span> table in the database:</p>

<pre data-type="programlisting">
public class Customer
{
  public int ID { get; set; } 
  public string Name { get; set; }
}</pre>
</div></section>

<section data-pdf-bookmark="DbContext" data-type="sect2"><div class="sect2" id="dbcontext">
<h2>DbContext</h2>

<p><a contenteditable="false" data-primary="DbContext" data-type="indexterm" id="ch08.html22"/><a contenteditable="false" data-primary="EF Core" data-secondary="DbContext" data-type="indexterm" id="ch08.html23"/>After defining entity classes, the next step is to subclass <code>DbContext</code>. An instance of that class represents your sessions working with the database. Typically, your <code>DbContext</code> subclass will contain one <code>DbSet&lt;T&gt;</code> property for each entity in your model:</p>

<pre data-type="programlisting">
public class NutshellContext <strong>: DbContext</strong>
{
  public <strong>DbSet&lt;Customer&gt;</strong> Customers { get; set; }
  ... properties for other tables ...

}</pre>

<p>A <code>DbContext</code> object does three things:</p>

<ul>
  <li>
  <p>It acts as a factory for generating <code>DbSet&lt;&gt;</code> objects that you can query.</p>
  </li>
  <li>
  <p>It keeps track of any changes that you make to your entities so that you can write them back (see <a data-type="xref" href="#change_tracking">“Change Tracking”</a>).</p>
  </li>
  <li>
  <p>It provides virtual methods that you can override to configure the connection and model.</p>
  </li>
</ul>

<section data-pdf-bookmark="Configuring the connection" data-type="sect3"><div class="sect3" id="configuring_the_connection">
<h3>Configuring the connection</h3>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="configuring the connection" data-type="indexterm" id="id3182"/>By overriding the <code>OnConfiguring</code> method, you can specify the database provider and connection string:</p>

<pre data-type="programlisting">
public class NutshellContext : DbContext
{
  ...
  protected override void OnConfiguring (DbContextOptionsBuilder 
                                         optionsBuilder) =&gt;
    optionsBuilder.<strong>UseSqlServer</strong> 
      (@"<strong>Server=(local);Database=Nutshell;Trusted_Connection=True</strong>");
}</pre>

<p>In this example, the connection string is specified as a string literal. Production applications would typically retrieve it from a configuration file such as <span class="keep-together"><em>appsettings.json</em></span>.</p>

<p><code>UseSqlServer</code> is an extension method defined in an assembly that’s part of the <em>Microsoft.EntityFramework.SqlServer</em> NuGet package. Packages are available for other database providers, including Oracle, MySQL, PostgreSQL, and SQLite.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re using ASP.NET, you can allow its dependency injection framework to preconfigure <code>optionsBuilder</code>; in most cases, this lets you avoid overriding <code>OnConfiguring</code> altogether. To enable this, define a constructor on <code>DbContext</code> as follows:</p>

<pre data-type="programlisting">
public NutshellContext (DbContextOptions&lt;NutshellContext&gt;
                        options)
  : base(options) { }</pre>

<p>If you do choose to override <code>OnConfiguring</code> (perhaps to provide a configuration if your <code>DbContext</code> is used in another scenario), you can check whether options have already been configured as follows:</p>

<pre data-type="programlisting">
protected override void OnConfiguring (
  DbContextOptionsBuilder optionsBuilder)
{
  if <strong>(!optionsBuilder.IsConfigured)</strong>
  {
    ...
  }
}</pre>
</div>

<p>In the <code>OnConfiguring</code> method, you can enable other options, including lazy loading (see <a data-type="xref" href="#lazy_loading">“Lazy loading”</a>).</p>
</div></section>

<section data-pdf-bookmark="Configuring the model" data-type="sect3"><div class="sect3" id="configuring_the_model">
<h3>Configuring the model</h3>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="configuring the model" data-type="indexterm" id="id3183"/>By default, EF Core is <em>convention based</em>, meaning that it infers the database schema from your class and property names.</p>

<p>You can override the defaults using the <em>fluent api</em> by overriding <code>OnModelCreating</code> and calling extension methods on the <code>ModelBuilder</code> parameter. For example, we can explicitly specify the database table name for our <code>Customer</code> entity as follows:</p>

<pre data-type="programlisting">
protected override void OnModelCreating (ModelBuilder modelBuilder) =&gt;
  modelBuilder.Entity&lt;Customer&gt;()
    .ToTable ("Customer");   // Table is called 'Customer'</pre>

<p>Without this code, EF Core would map this entity to a table named “Customers” rather than “Customer”, because we have a <code>DbSet&lt;Customer&gt;</code> property in our <span class="keep-together"><code>DbContext</code></span> called <code>Customers</code>:</p>

<pre data-type="programlisting">
public DbSet&lt;Customer&gt; <strong>Customers</strong> { get; set; }</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The following code maps all of your entities to table names that match the entity <em>class name</em> (which is typically singular) rather than the <code>DbSet&lt;T&gt;</code> <em>property name</em> (which is typically plural):</p>

<pre data-type="programlisting">
protected override void OnModelCreating (ModelBuilder
                                        modelBuilder)
{
  foreach (IMutableEntityType entityType in
           modelBuilder.Model.GetEntityTypes())
  {
    modelBuilder.Entity (entityType.Name)
      .ToTable (entityType.ClrType.Name);
  }
}</pre>
</div>

<p>The fluent API offers an expanded syntax for configuring columns. In the next example, we use two popular methods:</p>

<ul>
  <li>
  <p><code>HasColumnName</code>, which maps a property to a differently named column</p>
  </li>
  <li>
  <p><code>IsRequired</code>, which indicates that a column is not nullable</p>
  </li>
</ul>

<pre data-type="programlisting">
protected override void OnModelCreating (ModelBuilder modelBuilder) =&gt;
  modelBuilder.Entity&lt;Customer&gt; (entity =&gt;
  {
      entity.ToTable ("Customer");
      entity.Property (e =&gt; e.Name)
<strong>            .HasColumnName ("Full Name")</strong>  // Column name is 'Full Name'
<strong>            .IsRequired()</strong>;                // Column is not nullable
  });</pre>

<p><a data-type="xref" href="#fluent_api_model_configuration_methods">Table 8-1</a> lists some of the most important methods in the fluent API.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Instead of using the fluent API, you can configure your model by applying special attributes to your entity classes and properties (“data annotations”). This approach is less flexible in that the configuration must be fixed at compile-time, and is less powerful in that there are some options that can be configured only via the fluent API.</p>
</div>

<table class="border" id="fluent_api_model_configuration_methods">
  <caption><span class="label">Table 8-1. </span>Fluent API model configuration methods</caption>
  <thead>
    <tr>
      <th>Method</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ToTable</code></td>
      <td>Specify the database table name for a given entity</td>
      <td>
      <pre data-type="programlisting">
builder
  .Entity&lt;Customer&gt;()
  .ToTable("Customer");</pre>
      </td>
    </tr>
    <tr>
      <td><span class="keep-together"><code>HasColumnName</code></span></td>
      <td>Specify the column name for a given property</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .Property(c =&gt; c.Name)
  .HasColumnName("Full Name");</pre>
      </td>
    </tr>
    <tr>
      <td><code>HasKey</code></td>
      <td>Specify a key (usually that deviates from convention)</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .HasKey(c =&gt; c.CustomerNr);</pre>
      </td>
    </tr>
    <tr>
      <td><span class="keep-together"><code>IsRequired</code></span></td>
      <td>Specify that the property requires a value (is not nullable)</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .Property(c =&gt; c.Name)
  .IsRequired();</pre>
      </td>
    </tr>
    <tr>
      <td><span class="keep-together"><code>HasMaxLength</code></span></td>
      <td>Specify the maximum length of a variable-length type (usually a string) whose width can vary</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .Property(c =&gt; c.Name)
  .HasMaxLength(60);</pre>
      </td>
    </tr>
    <tr>
      <td><span class="keep-together"><code>HasColumnType</code></span></td>
      <td>Specify the database data type for a column</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Purchase&gt;()
  .Property(p =&gt; p.Description)
  .HasColumnType("varchar(80)");</pre>
      </td>
    </tr>
    <tr>
      <td><code>Ignore</code></td>
      <td>Ignore a type</td>
      <td>
      <pre data-type="programlisting">
builder.Ignore&lt;Products&gt;();</pre>
      </td>
    </tr>
    <tr>
      <td><code>Ignore</code></td>
      <td>Ignore a property of a type</td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .Ignore(c =&gt; c.ChatName);</pre>
      </td>
    </tr>
    <tr>
      <td><code>HasIndex</code></td>
      <td>Specify a property (or combination of properties) should serve in the database as an index</td>
      <td>
      <pre data-type="programlisting">
// Compound index:
builder.Entity&lt;Purchase&gt;()
  .HasIndex(p =&gt;
     new { p.Date, p.Price });

// Unique index on one property
builder
  .Entity&lt;MedicalArticle&gt;()
  .HasIndex(a =&gt; a.Topic)
  .IsUnique();</pre>
      </td>
    </tr>
    <tr>
      <td><code>HasOne</code></td>
      <td>See <a data-type="xref" href="#navigation_properties">“Navigation Properties”</a></td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Purchase&gt;()
  .HasOne(p =&gt; p.Customer)
  .WithMany(c =&gt; c.Purchases);</pre>
      </td>
    </tr>
    <tr>
      <td><code>HasMany</code></td>
      <td>See <a data-type="xref" href="#navigation_properties">“Navigation Properties”</a></td>
      <td>
      <pre data-type="programlisting">
builder.Entity&lt;Customer&gt;()
  .HasMany(c =&gt; c.Purchases)
  .WithOne(p =&gt; p.Customer);</pre>
      </td>
    </tr>
  </tbody>
</table>
</div></section>

<section data-pdf-bookmark="Creating the database" data-type="sect3"><div class="sect3" id="creating_the_database">
<h3>Creating the database</h3>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="creating the database" data-type="indexterm" id="id3184"/>EF Core supports a <em>code-first</em> approach, which means that you can start by defining entity classes and then ask EF Core to create the database. The easiest way to do the latter is to call the following method on a <code>DbContext</code> instance:</p>

<pre data-type="programlisting">
dbContext.Database.EnsureCreated();</pre>

<p>A better approach, however, is to use EF Core’s <em>migrations</em> feature, which not only creates the database but configures it such that EF Core can automatically update the schema in the future when your entity classes change. You can enable migrations in Visual Studio’s Package Manager Console and ask it to create the database with the following commands:</p>

<pre data-type="programlisting">
Install-Package Microsoft.EntityFrameworkCore.Tools
Add-Migration InitialCreate
Update-Database</pre>

<p>The first command installs tools to manage EF Core from within Visual Studio. The second command generates a special C# class known as a code migration that contains instructions to create the database. The final command runs those instructions against the database connection string specified in the project’s application configuration file.</p>
</div></section>

<section data-pdf-bookmark="Using DbContext" data-type="sect3"><div class="sect3" id="using_dbcontext">
<h3>Using DbContext</h3>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="using" data-type="indexterm" id="id3185"/>After you’ve defined Entity classes and subclassed <code>DbContext</code>, you can instantiate your <code>DbContext</code> and query the database, as follows:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext();
Console.WriteLine (dbContext.Customers.Count());
// Executes "SELECT COUNT(*) FROM [Customer] AS [c]"</pre>

<p>You can also use your <code>DbContext</code> instance to write to the database. The following code inserts a row into the Customer table:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext();
Customer cust = new Customer()
{
  Name = "Sara Wells"
};
dbContext.<strong>Customers.Add (cust)</strong>;
dbContext.<strong>SaveChanges()</strong>;    // Writes changes back to database</pre>

<p>The following queries the database for the customer that was just inserted:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext();
Customer cust = dbContext.Customers
  .Single (c =&gt; c.Name == "Sara Wells")</pre>

<p>The following updates that customer’s name and writes the change to the database:</p>

<pre data-type="programlisting">
cust.Name = "Dr. Sara Wells";
dbContext.<strong>SaveChanges()</strong>;</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>Single</code> operator is ideal for retrieving a row by primary key. Unlike <code>First</code>, it throws an exception if more than one element is returned.</p>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Object Tracking" data-type="sect2"><div class="sect2" id="object_tracking">
<h2>Object Tracking</h2>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="object tracking" data-type="indexterm" id="id3186"/><a contenteditable="false" data-primary="EF Core" data-secondary="object tracking" data-type="indexterm" id="id3187"/><a contenteditable="false" data-primary="object tracking" data-type="indexterm" id="id3188"/>A <code>DbContext</code> instance keeps track of all the entities it instantiates, so it can feed the same ones back to you whenever you request the same rows in a table. In other words, a context in its lifetime will never emit two separate entities that refer to the same row in a table (where a row is identified by primary key). This capability is called <em>object tracking</em>.</p>

<p>To illustrate, suppose the customer whose name is alphabetically first also has the lowest ID. In the following example, <code>a</code> and <code>b</code> will reference the same object:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext ();

Customer a = dbContext.Customers.OrderBy (c =&gt; c.Name).First();
Customer b = dbContext.Customers.OrderBy (c =&gt; c.ID).First();</pre>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="disposing_dbcontext">
<h1>Disposing DbContext</h1>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="disposing" data-type="indexterm" id="id3189"/>Although <code>DbContext</code> implements <code>IDisposable</code>, you can (in general) get away with not disposing instances. Disposing forces the context’s connection to dispose—but this is usually unnecessary because EF Core closes connections automatically whenever you finish retrieving results from a query.</p>

<p>Disposing a context prematurely can actually be problematic because of lazy evaluation. Consider the following:</p>

<pre data-type="programlisting">
IQueryable&lt;Customer&gt; GetCustomers (string prefix)
{
  using (var dbContext = new NutshellContext ())
    return dbContext.Customers
                    .Where (c =&gt; c.Name.StartsWith (prefix));
}
...
foreach (Customer c in GetCustomers ("a"))
  Console.WriteLine (c.Name);</pre>

<p>This will fail because the query is evaluated when we enumerate it—which is <em>after</em> disposing its <code>DbContext</code>.</p>

<p>There are some caveats, though, on not disposing contexts:</p>

<ul>
  <li>
  <p>It relies on the connection object releasing all unmanaged resources on the <code>Close</code> method. Even though this holds true with <code>SqlConnection</code>, it’s theoretically possible for a third-party connection to keep resources open if you call <code>Close</code> but not <code>Dispose</code> (though this would arguably violate the contract defined by <code>IDbConnection.Close</code>).</p>
  </li>
  <li>
  <p>If you manually call <code>GetEnumerator</code> on a query (instead of using <code>foreach</code>) and then fail to either dispose the enumerator or consume the sequence, the connection will remain open. Disposing the <code>DbContext</code> provides a backup in such scenarios.</p>
  </li>
  <li>
  <p>Some people feel that it’s tidier to dispose contexts (and all objects that implement <code>IDisposable</code>).</p>
  </li>
</ul>

<p>If you want to explicitly dispose contexts, you must pass a <code>DbContext</code> instance into methods such as <code>GetCustomers</code> to avoid the problem described. In scenarios such as ASP.NET Core MVC where the context instance is provided via dependency injection (DI), the DI infrastructure will manage the context lifetime. It will be created when a unit of work (such as an HTTP request processed in the controller) begins and disposed when that unit of work ends.</p>
</div></aside>

<p>Consider what happens when EF Core encounters the second query. It starts by querying the database—and obtaining a single row. It then reads the primary key of this row and performs a lookup in the context’s entity cache. Seeing a match, it returns the existing object <em>without updating any values</em>. So, if another user had just updated that customer’s <code>Name</code> in the database, the new value would be ignored. This is essential for avoiding unexpected side effects (the <code>Customer</code> object could be in use elsewhere) and also for managing concurrency. If you had altered properties on the <code>Customer</code> object and not yet called <code>SaveChanges</code>, you wouldn’t want your properties automatically overwritten.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can disable object tracking by chaining the <code>AsNoTracking</code> extension method to your query or by setting <code>ChangeTracker.QueryTrackingBehavior</code> on the context to <code>QueryTrackingBehavior.NoTracking</code>. No-tracking queries are useful when data is used read-only as it improves performance and reduces memory use.</p>
</div>

<p>To get fresh information from the database, you must either instantiate a new context or call the <code>Reload</code> method, as follows:</p>

<pre data-type="programlisting">
dbContext.Entry (myCustomer).Reload();</pre>

<p>The best practice is to use a fresh <code>DbContext</code> instance per unit of work so that the need to manually reload an entity is rare.<a contenteditable="false" data-primary="" data-startref="ch08.html23" data-type="indexterm" id="id3190"/><a contenteditable="false" data-primary="" data-startref="ch08.html22" data-type="indexterm" id="id3191"/></p>
</div></section>

<section data-pdf-bookmark="Change Tracking" data-type="sect2"><div class="sect2" id="change_tracking">
<h2>Change Tracking</h2>

<p><a contenteditable="false" data-primary="DbContext" data-secondary="change tracking" data-type="indexterm" id="id3192"/><a contenteditable="false" data-primary="EF Core" data-secondary="change tracking" data-type="indexterm" id="id3193"/>When you change a property value in an entity loaded via <code>DbContext</code>, EF Core recognizes the change and updates the database accordingly upon calling <code>SaveChanges</code>. To do that, it creates a snapshot of the state of entities loaded through your <code>DbContext</code> subclass and compares the current state to the original one when <code>SaveChanges</code> is called (or when you manually query change tracking, as you’ll see in a moment). You can enumerate the tracked changes in a <code>DbContext</code> as follows:</p>

<pre data-type="programlisting">
foreach (var e in dbContext.ChangeTracker.Entries())
{
  Console.WriteLine ($"{e.Entity.GetType().FullName} is {e.State}");
  foreach (var m in e.Members)
    Console.WriteLine (
      $"  {m.Metadata.Name}: '{m.CurrentValue}' modified: {m.IsModified}");
}</pre>

<p>When you call <code>SaveChanges</code>, EF Core uses the information in the <code>ChangeTracker</code> to construct SQL statements that will update the database to match the changes in your objects, issuing insert statements to add new rows, update statements to modify data, and delete statements to remove rows that were removed from the object graph in your <code>DbContext</code> subclass. Any <code>TransactionScope</code> is honored; if none is present, it wraps all statements in a new transaction.</p> 

<p><a contenteditable="false" data-primary="INotifyPropertyChanged interface" data-type="indexterm" id="id3194"/><a contenteditable="false" data-primary="INotifyPropertyChanging interface" data-type="indexterm" id="id3195"/>You can optimize change tracking by implementing <code>INotifyPropertyChanged</code> and, optionally, <code>INotifyPropertyChanging</code> in your entities. The former allows EF Core to avoid the overhead of comparing modified with original entities; the latter allows EF Core to avoid storing the original values altogether. After implementing these interfaces, call the <code>HasChangeTrackingStrategy</code> method on the <code>ModelBuilder</code> when configuring the model in order to activate the optimized change tracking.</p>
</div></section>

<section data-pdf-bookmark="Navigation Properties" data-type="sect2"><div class="sect2" id="navigation_properties">
<h2>Navigation Properties</h2>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="navigation properties" data-type="indexterm" id="ch08.html24"/><a contenteditable="false" data-primary="navigation properties" data-type="indexterm" id="ch08.html25"/>Navigation properties allow you to do the following:</p>

<ul>
  <li>
  <p>Query related tables without having to manually join</p>
  </li>
  <li>
  <p>Insert, remove, and update related rows without explicitly updating foreign keys</p>
  </li>
</ul>

<p>For example, suppose that a customer can have a number of purchases. We can represent a one-to-many relationship between <em>Customer</em> and <em>Purchase</em> with the following entities:</p>

<pre data-type="programlisting">
public class Customer
{
  <strong>public int ID { get; set; }</strong>
  public string Name { get; set; }

  // Child navigation property, which must be of type ICollection&lt;T&gt;:
  <strong>public virtual List&lt;Purchase&gt; Purchases {get;set;} = new List&lt;Purchase&gt;();</strong>
}

public class Purchase
{        
  public int ID { get; set; }
  public DateTime Date { get; set; }
  public string Description { get; set; }
  public decimal Price { get; set; }
  <strong>public int CustomerID? { get; set; }</strong>     // Foreign key field

  <strong>public Customer Customer { get; set; }</strong>   // Parent navigation property
}</pre>

<p>EF Core is able to infer from these entities that <code>CustomerID</code> is a foreign key to the <em>Customer</em> table, because the name “CustomerID” follows a popular naming convention. If we were to ask EF Core to create a database from these entities, it would create a foreign key constraint between <code>Purchase.CustomerID</code> and <code>Customer.ID</code>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If EF Core is unable to infer the relationship, you can configure it explicitly in the <code>OnModelCreating</code> method as follows:</p>

<pre data-type="programlisting">
modelBuilder.Entity&lt;Purchase&gt;()
  .HasOne (e =&gt; e.Customer)
  .WithMany (e =&gt; e.Purchases)
  .HasForeignKey (e =&gt; e.CustomerID);</pre>
</div>

<p>With these navigation properties set up, we can write queries such as this:</p>

<pre data-type="programlisting">
var customersWithPurchases = Customers.Where (c =&gt; c.Purchases.Any());</pre>

<p>We cover how to write such queries in detail in <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a>.</p>

<section data-pdf-bookmark="Adding and removing entities from navigation collections" data-type="sect3"><div class="sect3" id="adding_and_removing_entities_from_navig">
<h3>Adding and removing entities from navigation collections</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="adding and removing entities from navigation collections" data-type="indexterm" id="id3196"/><a contenteditable="false" data-primary="navigation properties" data-secondary="adding and removing entities from navigation collections" data-type="indexterm" id="id3197"/>When you add new entities to a collection navigation property, EF Core automatically populates the foreign keys upon calling <code>SaveChanges</code>:</p>

<pre data-type="programlisting">
Customer cust = dbContext.Customers.Single (c =&gt; c.ID == 1);

Purchase p1 = new Purchase { Description="Bike",  Price=500 };
Purchase p2 = new Purchase { Description="Tools", Price=100 };

cust.Purchases.Add (p1);
cust.Purchases.Add (p2);

dbContext.SaveChanges();</pre>

<p>In this example, EF Core automatically writes 1 into the <code>CustomerID</code> column of each of the new purchases and writes the database-generated ID for each purchase to <code>Purchase</code>.<code>ID</code>.</p>

<p>When you remove an entity from a collection navigation property and call <code>SaveChanges</code>, EF Core will either clear the foreign key field or delete the corresponding row from the database, depending on how the relationship has been configured or inferred. In this case, we’ve defined <code>Purchase.CustomerID</code> as a nullable integer (so that we can represent purchases without a customer, or cash transactions), so removing a purchase from a customer would clear its foreign key field rather than deleting it from the database.</p>
</div></section>

<section data-pdf-bookmark="Loading navigation properties" data-type="sect3"><div class="sect3" id="loading_navigation_properties">
<h3>Loading navigation properties</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="loading navigation properties" data-type="indexterm" id="id3198"/><a contenteditable="false" data-primary="navigation properties" data-secondary="loading" data-type="indexterm" id="id3199"/>When EF Core populates an entity, it does not (by default) populate its navigation properties:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext();
var cust = dbContext.Customers.First();
Console.WriteLine (cust.Purchases.Count);    // Always 0</pre>

<p>One solution is to use the <code>Include</code> extension method, which instructs EF Core to <em>eagerly</em> load navigation properties:</p>

<pre data-type="programlisting">
var cust = dbContext.Customers 
  <strong>.Include (c =&gt; c.Purchases)</strong>
  .Where (c =&gt; c.ID == 2).First();</pre>

<p>Another solution is to use a projection. This technique is particularly useful when you need to work with only some of the entity properties, because it reduces data transfer:</p>

<pre data-type="programlisting">
var custInfo = dbContext.Customers 
  .Where (c =&gt; c.ID == 2)
<strong>  .Select (c =&gt; new</strong>
<strong>    {</strong>
<strong>      Name = c.Name,</strong>
<strong>      Purchases = c.Purchases.Select (p =&gt; new { p.Description, p.Price })</strong>
<strong>    })</strong>
  .First();</pre>

<p>Both of these techniques inform EF Core what data you require so that it can be fetched in a single database query. It’s also possible to manually instruct EF Core to populate a navigation property as needed:</p>

<pre data-type="programlisting">
dbContext<strong>.Entry (cust).Collection (b =&gt; b.Purchases).Load()</strong>;
// cust.Purchases is now populated.</pre>

<p><a contenteditable="false" data-primary="explicit loading" data-type="indexterm" id="id3200"/>This is called <em>explicit loading</em>. Unlike the preceding approaches, this generates an extra round trip to the database.</p>
</div></section>

<section data-pdf-bookmark="Lazy loading" data-type="sect3"><div class="sect3" id="lazy_loading">
<h3>Lazy loading</h3>

<p><a contenteditable="false" data-primary="navigation properties" data-secondary="lazy loading" data-type="indexterm" id="id3201"/>Another approach for loading navigation properties is called <em>lazy loading</em>. When enabled, EF Core populates navigation properties on demand by generating a proxy class for each of your entity classes that intercepts attempts to access unloaded navigation properties. For this to work, each navigation property must be virtual, and the class it’s defined in must be inheritable (not sealed). Also, the context must not have been disposed when the lazy load occurs, so that an additional database request can be performed.</p>

<p>You can enable lazy loading in the <code>OnConfiguring</code> method of your <code>DbContext</code> subclass, as follows:</p>

<pre data-type="programlisting">
protected override void OnConfiguring (DbContextOptionsBuilder 
                                       optionsBuilder)
{
  optionsBuilder
    <strong>.UseLazyLoadingProxies()</strong>
    ...
}</pre>

<p>(You will also need to add a reference to the <code>Microsoft.EntityFrameworkCore.Proxies</code> NuGet package.)</p>

<p>The cost of lazy loading is that EF Core must make an additional request to the database each time you access an unloaded navigation property. If you make many such requests, performance can suffer as a result of excessive round-tripping.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>With lazy loading enabled, the runtime type of your classes is a proxy derived from your entity class. For example:<a contenteditable="false" data-primary="" data-startref="ch08.html25" data-type="indexterm" id="id3202"/><a contenteditable="false" data-primary="" data-startref="ch08.html24" data-type="indexterm" id="id3203"/></p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext();
var cust = dbContext.Customers.First();  
Console.WriteLine (cust.GetType());
// Castle.Proxies.CustomerProxy</pre>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Deferred Execution" data-type="sect2"><div class="sect2" id="deferred_execution">
<h2>Deferred Execution</h2>

<p><a contenteditable="false" data-primary="deferred execution" data-secondary="EF Core queries" data-type="indexterm" id="id3204"/><a contenteditable="false" data-primary="EF Core" data-secondary="deferred execution" data-type="indexterm" id="id3205"/>EF Core queries are subject to deferred execution, just like local queries. This allows you to build queries progressively. There is one aspect, however, in which EF Core has special deferred execution semantics, and that is when a subquery appears within a <code>Select</code> expression.</p>

<p>With local queries, you get double-deferred execution, because from a functional perspective, you’re selecting a sequence of <em>queries</em>. So, if you enumerate the outer result sequence but never enumerate the inner sequences, the subquery will never execute.</p>

<p>With EF Core, the subquery is executed at the same time as the main outer query. This prevents excessive round-tripping.</p>

<p>For example, the following query executes in a single round trip upon reaching the first <code>foreach</code> statement:</p>

<pre data-type="programlisting">
using var dbContext = new NutshellContext ();

var query = from c in dbContext.Customers
            select
               from p in c.Purchases
               select new { c.Name, p.Price };

foreach (var customerPurchaseResults in query)
  foreach (var namePrice in customerPurchaseResults)
    Console.WriteLine ($"{ namePrice.Name} spent { namePrice.Price}");</pre>

<p>Any navigation properties that you explicitly project are fully populated in a single round trip:</p>

<pre data-type="programlisting">
var query = from c in dbContext.Customers
            select new { c.Name, <strong>c.Purchases</strong> };

<strong>foreach (var row in query)</strong>
<strong>  foreach (Purchase p in row.Purchases)   // No extra round-tripping</strong>
    Console.WriteLine (row.Name + " spent " + p.Price);</pre>

<p>But if we enumerate a navigation property without first having either eagerly loaded or projected, deferred execution rules apply. In the following example, EF Core executes another <code>Purchases</code> query on each loop iteration (assuming lazy loading is enabled):</p>

<pre data-type="programlisting">
foreach (Customer c in <strong>dbContext.Customers.ToArray()</strong>)
  foreach (Purchase p in c.Purchases)    // Another SQL round-trip
    Console.WriteLine (c.Name + " spent " + p.Price);</pre>

<p>This model is advantageous when you want to <em>selectively</em> execute the inner loop, based on a test that can be performed only on the client:</p>

<pre data-type="programlisting">
foreach (Customer c in dbContext.Customers.ToArray())
  if (<em>myWebService.HasBadCreditHistory (c.ID)</em>)
    foreach (Purchase p in c.Purchases)   // Another SQL round trip
      Console.WriteLine (c.Name + " spent " + p.Price);</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note the use of <code>ToArray</code> in the previous two queries. By default, SQL Server cannot initiate a new query while the results of the current query are still being processed. Calling <code>ToArray</code> materializes the customers so that additional queries can be issued to retrieve purchases per customer. It is possible to configure SQL Server to allow multiple active result sets (MARS) by appending <a contenteditable="false" data-primary="MARS (MultipleActiveResultSets)" data-type="indexterm" id="id3206"/><a contenteditable="false" data-primary="MultipleActiveResultSets (MARS)" data-type="indexterm" id="id3207"/><code>;MultipleActiveResultSets=True</code> to the database connection string. Use MARS with caution as it can mask a chatty database design that could be improved by eager loading and/or projecting the required data.</p>
</div>

<p>(In <a data-type="xref" href="ch09.html#linq_operators">Chapter 9</a>, we explore <code>Select</code> subqueries in more detail, in <a data-type="xref" href="ch09.html#projecting-id00076">“Projecting”</a>.)<a contenteditable="false" data-primary="" data-startref="ch08.html21" data-type="indexterm" id="id3208"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Building Query Expressions" data-type="sect1"><div class="sect1" id="building_query_expressions">
<h1>Building Query Expressions</h1>

<p><a contenteditable="false" data-primary="query expressions" data-secondary="building" data-type="indexterm" id="ch08.html26"/>So far in this chapter, when we’ve needed to dynamically compose queries, we’ve done so by conditionally chaining query operators. Although this is adequate in many scenarios, sometimes you need to work at a more granular level and dynamically compose the lambda expressions that feed the operators.</p>

<p>In this section, we assume the following <code>Product</code> class:</p>

<pre data-type="programlisting">
public class Product
{
  public int ID { get; set; }
  public string Description { get; set; }
  public bool Discontinued { get; set; }
  public DateTime LastSale { get; set; }
}</pre>

<section data-pdf-bookmark="Delegates Versus Expression Trees" data-type="sect2"><div class="sect2" id="delegates_versus_expression_trees">
<h2>Delegates Versus Expression Trees</h2>

<p><a contenteditable="false" data-primary="expression trees" data-secondary="delegates versus" data-type="indexterm" id="ch08.html27"/><a contenteditable="false" data-primary="query expressions" data-secondary="delegates versus expression trees" data-type="indexterm" id="ch08.html28"/>Recall that:</p>

<ul>
  <li>
  <p>Local queries, which use <code>Enumerable</code> operators, take delegates.</p>
  </li>
  <li>
  <p>Interpreted queries, which use <code>Queryable</code> operators, take expression trees.</p>
  </li>
</ul>

<p>We can see this by comparing the signature of the <code>Where</code> operator in <code>Enumerable</code> and <code>Queryable</code>:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this
  <strong>IEnumerable</strong>&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)

public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this
  <strong>IQueryable</strong>&lt;TSource&gt; source, <strong>Expression</strong>&lt;Func&lt;TSource,bool&gt;<strong>&gt;</strong> predicate)</pre>

<p>When embedded within a query, a lambda expression looks identical whether it binds to <code>Enumerable</code>’s operators or <code>Queryable</code>’s operators:</p>

<pre data-type="programlisting">
IEnumerable&lt;Product&gt; q1 = localProducts.Where (<strong>p =&gt; !p.Discontinued</strong>);
IQueryable&lt;Product&gt;  q2 = sqlProducts.Where   (<strong>p =&gt; !p.Discontinued</strong>);</pre>

<p>When you assign a lambda expression to an intermediate variable, however, you must be explicit about whether to resolve to a delegate (i.e., <code>Func&lt;&gt;</code>) or an expression tree (i.e., <code>Expression&lt;Func&lt;&gt;&gt;</code>). In the following example, <code>predicate1</code> and <code>predicate2</code> are not interchangeable:</p>

<pre data-type="programlisting">
Func &lt;Product, bool&gt; predicate1 = p =&gt; !p.Discontinued;
IEnumerable&lt;Product&gt; q1 = localProducts.Where (predicate1);

Expression &lt;Func &lt;Product, bool&gt;&gt; predicate2 = p =&gt; !p.Discontinued;
IQueryable&lt;Product&gt; q2 = sqlProducts.Where (predicate2);</pre>

<section data-pdf-bookmark="Compiling expression trees" data-type="sect3"><div class="sect3" id="compiling_expression_trees">
<h3>Compiling expression trees</h3>

<p><a contenteditable="false" data-primary="expression trees" data-secondary="compiling" data-type="indexterm" id="id3209"/>You can convert an expression tree to a delegate by calling <code>Compile</code>. This is of particular value when writing methods that return reusable expressions. To illustrate, let’s add a static method to the <code>Product</code> class that returns a predicate evaluating to <code>true</code> if a product is not discontinued and has sold in the past 30 days:</p>

<pre data-type="programlisting">
public class Product
{
  public static Expression&lt;Func&lt;Product, bool&gt;&gt; IsSelling()
  {
    return p =&gt; !p.Discontinued &amp;&amp; p.LastSale &gt; DateTime.Now.AddDays (-30);
  }
}</pre>

<p>The method just written can be used both in interpreted and local queries, as <span class="keep-together">follows</span>:</p>

<pre data-type="programlisting">
void Test()
{
  var dbContext = new NutshellContext();
  Product[] localProducts = dbContext.Products.ToArray();

  IQueryable&lt;Product&gt; sqlQuery =
    dbContext.Products.Where (Product.<strong>IsSelling()</strong>);

  IEnumerable&lt;Product&gt; localQuery =
    localProducts.Where (<strong>Product.IsSelling().Compile()</strong>);
}</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>.NET does not provide an API to convert in the reverse direction, from a delegate to an expression tree. This makes expression trees more versatile.</p>
</div>
</div></section>

<section data-pdf-bookmark="AsQueryable" data-type="sect3"><div class="sect3" id="asqueryable">
<h3>AsQueryable</h3>

<p><a contenteditable="false" data-primary="AsQueryable operator" data-type="indexterm" id="id3210"/>The <code>AsQueryable</code> operator lets you write whole <em>queries</em> that can run over either local or remote sequences:</p>

<pre data-type="programlisting">
IQueryable&lt;Product&gt; FilterSortProducts (IQueryable&lt;Product&gt; input)
{
  return from p in input
         where ...
         orderby ...
         select p;
}

void Test()
{
  var dbContext = new NutshellContext();
  Product[] localProducts = dbContext.Products.ToArray();

  var sqlQuery   = FilterSortProducts (dbContext.Products);
  var localQuery = FilterSortProducts (localProducts<strong>.AsQueryable()</strong>);
  ...
}</pre>

<p><code>AsQueryable</code> wraps <code>IQueryable&lt;T&gt;</code> clothing around a local sequence so that subsequent query operators resolve to expression trees. When you later enumerate over the result, the expression trees are implicitly compiled (at a small performance cost), and the local sequence enumerates as it would ordinarily.<a contenteditable="false" data-primary="" data-startref="ch08.html28" data-type="indexterm" id="id3211"/><a contenteditable="false" data-primary="" data-startref="ch08.html27" data-type="indexterm" id="id3212"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Expression Trees" data-type="sect2"><div class="sect2" id="expression_trees">
<h2>Expression Trees</h2>

<p><a contenteditable="false" data-primary="expression trees" data-type="indexterm" id="ch08.html29"/><a contenteditable="false" data-primary="query expressions" data-secondary="expression trees" data-type="indexterm" id="ch08.html30"/>We said previously that an implicit conversion from a lambda expression to <code>Expression&lt;TDelegate&gt;</code> causes the C# compiler to emit code that builds an expression tree. With some programming effort, you can do the same thing manually at runtime—in other words, dynamically build an expression tree from scratch. The result can be cast to an <code>Expression&lt;TDelegate&gt;</code> and used in EF Core queries or compiled into an ordinary delegate by calling <code>Compile</code>.</p>

<section data-pdf-bookmark="The Expression DOM" data-type="sect3"><div class="sect3" id="the_expression_dom">
<h3>The Expression DOM</h3>

<p><a contenteditable="false" data-primary="DOM (document object model)" data-secondary="expression DOM" data-type="indexterm" id="id3213"/><a contenteditable="false" data-primary="expression DOM" data-type="indexterm" id="id3214"/><a contenteditable="false" data-primary="query expressions" data-secondary="expression DOM" data-type="indexterm" id="id3215"/>An expression tree is a miniature code DOM. Each node in the tree is represented by a type in the <code>System.Linq.Expressions</code> namespace. <a data-type="xref" href="#expression_types">Figure 8-10</a> illustrates these types.</p>

<figure><div class="figure" id="expression_types"><img alt="Expression types" src="assets/cn10_0810.png"/>
<h6><span class="label">Figure 8-10. </span>Expression types</h6>
</div></figure>

<p>The base class for all nodes is the (nongeneric) <code>Expression</code> class. The generic <code>Expression&lt;TDelegate&gt;</code> class actually means “typed lambda expression” and might have been named <code>LambdaExpression&lt;TDelegate&gt;</code> if it wasn’t for the clumsiness of this:</p>

<pre data-type="programlisting">
LambdaExpression&lt;Func&lt;Customer,bool&gt;&gt; f = ...</pre>

<p><code>Expression&lt;T&gt;</code>’s base type is the (nongeneric) <code>LambdaExpression</code> class. <code>Lamdba​Ex⁠pression</code> provides type unification for lambda expression trees: any typed <span class="keep-together"><code>Expression&lt;T&gt;</code></span> can be cast to a <code>LambdaExpression</code>.</p>

<p>The thing that distinguishes <code>LambdaExpression</code>s from ordinary <code>Expression</code>s is that lambda expressions have <em>parameters</em>.</p>

<p>To create an expression tree, don’t instantiate node types directly; rather, call static methods provided on the <code>Expression</code> class, such as <code>Add</code>, <code>And</code>, <code>Call</code>, <code>Constant</code>, <code>LessThan</code>, and so on.</p>

<p><a data-type="xref" href="#expression_tree">Figure 8-11</a> shows the expression tree that the following assignment creates:</p>

<pre data-type="programlisting">
Expression&lt;Func&lt;string, bool&gt;&gt; f = s =&gt; s.Length &lt; 5;</pre>

<figure><div class="figure" id="expression_tree"><img alt="Expression tree" src="assets/cn10_0811.png"/>
<h6><span class="label">Figure 8-11. </span>Expression tree</h6>
</div></figure>

<p>We can demonstrate this as follows:</p>

<pre data-type="programlisting">
Console.WriteLine (f.Body.NodeType);                     // LessThan
Console.WriteLine (((BinaryExpression) f.Body).Right);   // 5</pre>

<p>Let’s now build this expression from scratch. The principle is that you start from the bottom of the tree and work your way up. The bottommost thing in our tree is a <code>ParameterExpression</code>, the lambda expression parameter called “s” of type <code>string</code>:</p>

<pre data-type="programlisting">
ParameterExpression p = Expression.Parameter (typeof (string), "s");</pre>

<p>The next step is to build the <code>MemberExpression</code> and <code>ConstantExpression</code>. In the former case, we need to access the <code>Length</code> <em>property</em> of our parameter, “s”:</p>

<pre data-type="programlisting">
MemberExpression stringLength = Expression.Property (p, "Length");
ConstantExpression five = Expression.Constant (5);</pre>

<p>Next is the <code>LessThan</code> comparison:</p>

<pre data-type="programlisting">
BinaryExpression comparison = Expression.LessThan (stringLength, five);</pre>

<p>The final step is to construct the lambda expression, which links an expression <code>Body</code> to a collection of parameters:</p>

<pre data-type="programlisting">
Expression&lt;Func&lt;string, bool&gt;&gt; lambda
  = Expression.Lambda&lt;Func&lt;string, bool&gt;&gt; (comparison, p);</pre>

<p>A convenient way to test our lambda is by compiling it to a delegate:</p>

<pre data-type="programlisting">
Func&lt;string, bool&gt; runnable = lambda.Compile();

Console.WriteLine (runnable ("kangaroo"));           // False
Console.WriteLine (runnable ("dog"));                // True</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The easiest way to determine which expression type to use is to examine an existing lambda expression in the Visual Studio debugger.</p>
</div>

<p>We continue this discussion<a contenteditable="false" data-primary="" data-startref="ch08.html30" data-type="indexterm" id="id3216"/> online,<a contenteditable="false" data-primary="" data-startref="ch08.html29" data-type="indexterm" id="id3217"/><a contenteditable="false" data-primary="" data-startref="ch08.html26" data-type="indexterm" id="id3218"/> at <a contenteditable="false" data-primary="" data-startref="ch08.html0" data-type="indexterm" id="id3219"/><a href="http://www.albahari.com/expressions"><em class="hyperlink">http://www.albahari.com/expressions</em></a>.</p>
</div></section>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn7"><sup><a href="ch08.html#ch01fn7-marker">1</a></sup> The term is based on Eric Evans and Martin Fowler’s work on fluent interfaces.</p></div></div></section></body></html>