<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">

<head>
    <title>Introducing C# and .NET</title>
    <link href="epub.css" rel="stylesheet" type="text/css" />
    <meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource" />
</head>

<body data-type="book">
    <section class="pagenumrestart" data-nutshell-tab="Introducing C# and .NET"
        data-pdf-bookmark="Chapter 1. Introducing C# and .NET" data-type="chapter" epub:type="chapter">
        <div class="chapter" id="introducing_chash_and_dotnet">
            <h1><span class="label">Chapter 1. </span>Introducing C# and .NET</h1>
            <p>C# is a general-purpose, type-safe, object-oriented programming language. The goal of the language is
                programmer productivity. To this end, C# balances simplicity, expressiveness, and performance. The chief
                architect of the language since its first version is Anders Hejlsberg (creator of Turbo Pascal and
                architect of Delphi). The C# language is platform neutral and works with a range of platform-specific
                runtimes.</p>
            <section data-pdf-bookmark="Object Orientation" data-type="sect1">
                <div class="sect1" id="object_orientation">
                    <h1>Object Orientation</h1>
                    <p><a contenteditable="false" data-primary="C# (generally)" data-secondary="object orientation"
                            data-type="indexterm" id="id1520" />C# is a rich implementation of the object-orientation
                        paradigm, which includes <em>encapsulation</em>, <em>inheritance</em>, and
                        <em>polymorphism</em>. Encapsulation means creating a boundary around an <em>object</em> to
                        separate its external (public) behavior from its internal (private) implementation details.
                        Following are the distinctive features of C# from an object-oriented perspective:</p>
                    <dl>
                        <dt>Unified type system</dt>
                        <dd>The fundamental building block in C# is an encapsulated unit of data and functions called a
                            <em>type</em>. C# has a <em>unified type system</em> in which all types ultimately share a
                            common base type. This means that all types, whether they represent business objects or are
                            primitive types such as numbers, share the same basic functionality. For example, an
                            instance of any type can be converted to a string by calling its <code>ToString</code>
                            method.</dd>
                        <dt>Classes and interfaces</dt>
                        <dd><a contenteditable="false" data-primary="interface" data-secondary="defined"
                                data-type="indexterm" id="id1521" />In a traditional object-oriented paradigm, the only
                            kind of type is a class. In C#, there are several other kinds of types, one of which is an
                            <em>interface</em>. An interface is like a class that cannot hold data. This means that it
                            can define only <em>behavior</em> (and not <em>state</em>), which allows for multiple
                            inheritance as well as a separation between specification and implementation.</dd>
                        <dt>Properties, methods, and events</dt>
                        <dd>In the pure object-oriented paradigm, all functions are <em>methods</em>. In C#, methods are
                            only one kind of <em>function member</em>, which also includes <em>properties</em> and
                            <em>events</em> (there are others, too). Properties are function members that encapsulate a
                            piece of an object’s state such as a button’s color or a label’s text. Events are function
                            members that simplify acting on object state changes.</dd>
                    </dl>
                    <p>Although C# is primarily an object-oriented language, it also borrows from the <em>functional
                            programming</em> paradigm, specifically:</p>
                    <dl>
                        <dt>Functions can be treated as values</dt>
                        <dd>Using <em>delegates</em>, C# allows functions to be passed as values to and from other
                            functions.</dd>
                        <dt>C# supports patterns for purity</dt>
                        <dd>Core to functional programming is avoiding the use of variables whose values change, in
                            favor of declarative patterns. C# has key features to help with those patterns, including
                            the ability to write unnamed functions on the fly that “capture” variables (<em>lambda
                                expressions</em>), and the ability to perform list or reactive programming via <em>query
                                expressions</em>. C# also provides <em>records</em>, which make it easy to write
                            <em>immutable</em> (read-only) types.</dd>
                    </dl>
                </div>
            </section>
            <section data-pdf-bookmark="Type Safety" data-type="sect1">
                <div class="sect1" id="type_safety">
                    <h1>Type Safety</h1>
                    <p><a contenteditable="false" data-primary="C# (generally)" data-secondary="type safety"
                            data-type="indexterm" id="id1522" /><a contenteditable="false" data-primary="type safety"
                            data-type="indexterm" id="id1523" />C# is primarily a <em>type-safe</em> language, meaning
                        that instances of types can interact only through protocols they define, thereby ensuring each
                        type’s internal consistency. For instance, C# prevents you from interacting with a
                        <em>string</em> type as though it were an <em>integer</em> type.</p>
                    <p><a contenteditable="false" data-primary="static typing" data-type="indexterm" id="id1524" />More
                        specifically, C# supports <em>static typing</em>, meaning that the language enforces type safety
                        at <em>compile time</em>. This is in addition to type safety being enforced at <em>runtime</em>.
                    </p>
                    <p>Static typing eliminates a large class of errors before a program is even run. It shifts the
                        burden away from runtime unit tests onto the compiler to verify that all the types in a program
                        fit together correctly. This makes large programs much easier to manage, more predictable, and
                        more robust. Furthermore, static typing allows tools such as IntelliSense in Visual Studio to
                        help you write a program because it knows for a given variable what type it is, and hence what
                        methods you can call on that variable. Such tools can also identify everywhere in your program
                        that a variable, type, or method is used, allowing for reliable refactoring.</p>
                    <div data-type="note" epub:type="note">
                        <h6>Note</h6>
                        <p>C# also allows parts of your code to be dynamically typed via the <code>dynamic</code>
                            keyword. However, C# remains a predominantly statically typed language.</p>
                    </div>
                    <p class="pagebreak-before">C# is also called a <em>strongly typed language</em> because its type
                        rules are strictly enforced (whether statically or at runtime). For instance, you cannot call a
                        function that’s designed to accept an integer with a floating-point number, unless you first
                        <em>explicitly</em> convert the floating-point number to an integer. This helps prevent
                        mistakes.</p>
                </div>
            </section>
            <section data-pdf-bookmark="Memory Management" data-type="sect1">
                <div class="sect1" id="memory_management">
                    <h1>Memory Management</h1>
                    <p><a contenteditable="false" data-primary="C# (generally)" data-secondary="memory management"
                            data-seealso="garbage collection[GC]" data-type="indexterm" id="id1525" />C# relies on the
                        runtime to perform automatic memory management. The Common Language Runtime has a garbage
                        collector that executes as part of your program, reclaiming memory for objects that are no
                        longer referenced. This frees programmers from explicitly deallocating the memory for an object,
                        eliminating the problem of incorrect pointers encountered in languages such as C++.</p>
                    <p>C# does not eliminate pointers: it merely makes them unnecessary for most programming tasks. For
                        performance-critical hotspots and interoperability, pointers and explicit memory allocation is
                        permitted in blocks that are marked <code>unsafe</code>.</p>
                </div>
            </section>
            <section data-pdf-bookmark="Platform Support" data-type="sect1">
                <div class="sect1" id="platform_support">
                    <h1>Platform Support</h1>
                    <p><a contenteditable="false" data-primary="C# (generally)" data-secondary="platform support"
                            data-type="indexterm" id="id1526" />C# has runtimes that support the following platforms:
                    </p>
                    <ul>
                        <li>
                            <p>Windows 7+ Desktop (for rich-client, web, server, and command-line <span
                                    class="keep-together">applications</span>)</p>
                        </li>
                        <li>
                            <p>macOS (for web and command-line applications—and rich-client applications via Mac
                                Catalyst)</p>
                        </li>
                        <li>
                            <p>Linux (for web and command-line applications)</p>
                        </li>
                        <li>
                            <p>Android and iOS (for mobile applications)</p>
                        </li>
                        <li>
                            <p>Windows 10 devices (Xbox, Surface Hub, and HoloLens) via UWP</p>
                        </li>
                    </ul>
                    <p>There is also a technology called <em>Blazor</em> that can compile C# to web assembly that runs
                        in a browser.</p>
                </div>
            </section>
            <section data-pdf-bookmark="CLRs, BCLs, and Runtimes" data-type="sect1">
                <div class="sect1" id="clrscomma_bclscomma_and_runtimes">
                    <h1>CLRs, BCLs, and Runtimes</h1>
                    <p>Runtime support for C# programs consists of a <em>Common Language Runtime</em> and a <em>Base
                            Class Library</em>. A runtime can also include a higher-level <em>application layer</em>
                        that contains libraries for developing rich-client, mobile, or web applications (see <a
                            data-type="xref" href="#runtime_architecture">Figure 1-1</a>). Different runtimes exist to
                        allow for different kinds of applications, as well as different platforms.</p>
                    <figure>
                        <div class="figure" id="runtime_architecture">
                            <img alt="Runtime architecture" src="assets/cn10_0101.png" />
                            <h6><span class="label">Figure 1-1. </span>Runtime architecture</h6>
                        </div>
                    </figure>
                    <section data-pdf-bookmark="Common Language Runtime" data-type="sect2">
                        <div class="sect2" id="common_language_runtime">
                            <h2>Common Language Runtime</h2>
                            <p><a contenteditable="false" data-primary="CLR (Common Language Runtime)"
                                    data-type="indexterm" id="id1527" />A <em>Common Language Runtime</em> (CLR)
                                provides essential runtime services such as automatic memory management and exception
                                handling. (The word “common” refers to the fact that the same runtime can be shared by
                                other <em>managed</em> programming languages, such as F#, Visual Basic, and Managed
                                C++.)</p>
                            <p><a contenteditable="false" data-primary="IL (intermediate language)"
                                    data-secondary="CLR and" data-type="indexterm" id="id1528" />C# is called a
                                <em>managed language</em> because it compiles source code into managed code, which is
                                represented in <em>Intermediate Language</em> (IL). <a contenteditable="false"
                                    data-primary="C# (generally)" data-secondary="memory management"
                                    data-type="indexterm" id="id1529" /><a contenteditable="false"
                                    data-primary="JIT (Just-in-Time) compilation" data-type="indexterm" id="id1530" /><a
                                    contenteditable="false" data-primary="Just-in-Time (JIT) compilation"
                                    data-type="indexterm" id="id1531" /><a contenteditable="false"
                                    data-primary="memory management" data-type="indexterm" id="id1532" />The CLR
                                converts the IL into the native code of the machine, such as X64 or X86, usually just
                                prior to execution. This is referred to as Just-In-Time (JIT) compilation. Ahead-of-time
                                compilation is also available to improve startup time with large assemblies or
                                resource-constrained devices (and to satisfy iOS app store rules when developing mobile
                                apps).</p>
                            <p><a contenteditable="false" data-primary="assemblies" data-secondary="defined"
                                    data-type="indexterm" id="id1533" />The container for managed code is called an
                                <em>assembly</em>. An assembly contains not only IL but also type information
                                (<em>metadata</em>). The presence of metadata allows assemblies to reference types in
                                other assemblies without needing additional files.</p>
                            <div data-type="note" epub:type="note">
                                <h6>Note</h6>
                                <p><a contenteditable="false" data-primary="ildasm tool" data-type="indexterm"
                                        id="id1534" />You can examine and disassemble the contents of an assembly with
                                    Microsoft’s <em>ildasm</em> tool. And with tools such as ILSpy or JetBrain’s
                                    dotPeek, you can go further and decompile the IL to C#. Because IL is higher level
                                    than native machine code, the decompiler can do quite a good job of reconstructing
                                    the original C#.</p>
                            </div>
                            <p>A program can query its own metadata (<em>reflection</em>) and even generate new IL at
                                runtime (<em>reflection.emit</em>).</p>
                        </div>
                    </section>
                    <section class="pagebreak-before" data-pdf-bookmark="Base Class Library" data-type="sect2">
                        <div class="sect2" id="base_class_library">
                            <h2 class="less_space">Base Class Library</h2>
                            <p><a contenteditable="false" data-primary="base class library (BCL)" data-type="indexterm"
                                    id="id1535" /><a contenteditable="false" data-primary="BCL (base class library)"
                                    data-type="indexterm" id="id1536" />A CLR always ships with a set of assemblies
                                called a <em>Base Class Library</em> (BCL). A BCL provides core functionality to
                                programmers, such as collections, input/output, text processing, XML/JSON handling,
                                networking, encryption, interop, concurrency, and parallel programming.</p>
                            <p>A BCL also implements types that the C# language itself requires (for features such as
                                enumeration, querying, and asynchrony) and lets you explicitly access features of the
                                CLR, such as Reflection and memory management.</p>
                        </div>
                    </section>
                    <section data-pdf-bookmark="Runtimes" data-type="sect2">
                        <div class="sect2" id="runtimes">
                            <h2>Runtimes</h2>
                            <p><a contenteditable="false" data-primary="frameworks" data-seealso="runtimes"
                                    data-type="indexterm" id="id1537" /><a contenteditable="false"
                                    data-primary="runtimes" data-secondary="defined" data-type="indexterm"
                                    id="id1538" />A <em>runtime</em> (also called a <em>framework</em>) is a deployable
                                unit that you download and install. A runtime consists of a CLR (with its BCL), plus an
                                optional <em>application layer</em> specific to the kind of application that you’re
                                writing—web, mobile, rich client, etc. (If you’re writing a command-line console
                                application or a non-UI library, you don’t need an application layer.)</p>
                            <p>When writing an application, you <em>target</em> a particular runtime, which means that
                                your application uses and depends on the functionality that the runtime provides. Your
                                choice of runtime also determines which platforms your application will support.</p>
                            <p>The following table lists the major runtime options:</p>
                            <table class="border">
                                <thead>
                                    <tr>
                                        <th>Application layer</th>
                                        <th>CLR/BCL</th>
                                        <th>Program type</th>
                                        <th>Runs on...</th>
                                        <th />
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>ASP.NET</td>
                                        <td>.NET 8</td>
                                        <td>Web</td>
                                        <td>Windows, Linux, macOS</td>
                                        <td />
                                    </tr>
                                    <tr>
                                        <td>Windows Desktop</td>
                                        <td>.NET 8</td>
                                        <td>Windows</td>
                                        <td>Windows 10+</td>
                                        <td />
                                    </tr>
                                    <tr>
                                        <td>WinUI 3</td>
                                        <td>.NET 8</td>
                                        <td>Windows</td>
                                        <td colspan="2">Windows 10+</td>
                                    </tr>
                                    <tr>
                                        <td>MAUI</td>
                                        <td>.NET 8</td>
                                        <td>Mobile, desktop</td>
                                        <td>iOS, Android, macOS, Windows 10+</td>
                                        <td />
                                    </tr>
                                    <tr>
                                        <td>.NET Framework</td>
                                        <td>.NET Framework</td>
                                        <td>Web, Windows</td>
                                        <td>Windows 7+</td>
                                        <td />
                                    </tr>
                                </tbody>
                            </table>
                            <p><a data-type="xref" href="#runtimes_for_chash">Figure 1-2</a> shows this information
                                graphically and also serves as a guide to what’s covered in the book.</p>
                            <figure>
                                <div class="figure" id="runtimes_for_chash">
                                    <img alt="Runtimes for C#" src="assets/cn10_0102.png" />
                                    <h6><span class="label">Figure 1-2. </span>Runtimes for C#</h6>
                                </div>
                            </figure>
                            <section data-pdf-bookmark=".NET 8" data-type="sect3">
                                <div class="sect3" id="dotnet_eight">
                                    <h3>.NET 8</h3>
                                    <p>.NET 8 is Microsoft’s flagship open-source runtime. You can write web and console
                                        applications that run on Windows, Linux, and macOS; rich-client applications
                                        that run on Windows 10+ and macOS; and mobile apps that run on iOS and Android.
                                        This book focuses on the .NET 8 CLR and BCL.</p>
                                    <p>Unlike .NET Framework, .NET 8 is not preinstalled on Windows machines. If you try
                                        to run a .NET 8 application without the correct runtime being present, a message
                                        will appear directing you to a web page where you can download the runtime. You
                                        can avoid this by creating a <em>self-contained</em> deployment, which includes
                                        the parts of the runtime required by the application.</p>
                                    <div data-type="note" epub:type="note">
                                        <h6>Note</h6>
                                        <p>.NET’s update history runs as follows: .NET Core 1.x → <span
                                                class="keep-together">NET Core 2.x →</span> .NET Core 3.x → .NET 5 →
                                            .NET 6 → .NET 7 → .NET 8. After .NET Core 3, Microsoft removed “Core” from
                                            the name and skipped version 4 to avoid confusion with <em>.NET
                                                Framework</em> 4.x, which precedes all of the preceding runtimes but is
                                            still supported and in popular use.</p>
                                        <p>This means that assemblies compiled under .NET Core 1.x → .NET 7 will, in
                                            most cases, run without modification under .NET 8. In contrast, assemblies
                                            compiled under (any version of) .NET Framework are usually incompatible with
                                            .NET 8.</p>
                                    </div>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Windows Desktop and WinUI 3" data-type="sect3">
                                <div class="sect3" id="windows_desktop_and_winui_three">
                                    <h3>Windows Desktop and WinUI 3</h3>
                                    <p><a contenteditable="false" data-primary="Windows Desktop application layer"
                                            data-type="indexterm" id="id1539" /><a contenteditable="false"
                                            data-primary="WinUI 3" data-type="indexterm" id="id1540" />For writing
                                        rich-client applications that run on Windows 10 and above, you can choose
                                        between the classic Windows Desktop APIs (Windows Forms and WPF) and WinUI 3.
                                        The Windows Desktop APIs are part of the .NET Desktop runtime, whereas WinUI 3
                                        is part of the <em>Windows App SDK</em> (a separate download).</p>
                                    <p>The classic Windows Desktop APIs have existed since 2006 and enjoy terrific
                                        third-party library support, as well as offering a wealth of answered questions
                                        on sites such as StackOverflow. <em>WinUI 3</em> was released in 2022 and is
                                        intended for writing modern immersive applications that feature the latest
                                        Windows 10+ controls. It is a successor to the <em>Universal Windows
                                            Platform</em> (UWP).</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="MAUI" data-type="sect3">
                                <div class="sect3" id="maui-id00027">
                                    <h3>MAUI</h3>
                                    <p><a contenteditable="false" data-primary="MAUI" data-type="indexterm"
                                            id="id1541" /><em>MAUI</em> (Multi-platform App UI) is designed primarily
                                        for creating mobile apps for iOS and Android, although it can also be used for
                                        desktop apps that run on macOS and Windows via Mac Catalyst and WinUI 3. MAUI is
                                        an evolution of Xamarin and allows a single project to target multiple
                                        platforms.</p>
                                    <div data-type="note" epub:type="note">
                                        <h6>Note</h6>
                                        <p><a contenteditable="false" data-primary="Avalonia" data-type="indexterm"
                                                id="id1542" />For cross-platform desktop applications, a third-party
                                            library called Avalonia offers an alternative to MAUI. Avalonia also runs on
                                            Linux and is architecturally simpler than MAUI (as it operates without the
                                            Catalyst/WinUI indirection layer). Avalonia has an API similar to WPF, and
                                            it also offers a commercial add-on called XPF that provides almost complete
                                            WPF compatibility.</p>
                                    </div>
                                </div>
                            </section>
                            <section data-pdf-bookmark=".NET Framework" data-type="sect3">
                                <div class="sect3" id="dotnet_framework">
                                    <h3>.NET Framework</h3>
                                    <p><em><a contenteditable="false" data-primary=".NET Framework"
                                                data-primary-sortas="NET Framework" data-secondary="about"
                                                data-type="indexterm" id="id1543" />.NET Framework</em> is Microsoft’s
                                        original Windows-only runtime for writing web and rich-client applications that
                                        run (only) on Windows desktop/server. No major new releases are planned,
                                        although Microsoft will continue to support and maintain the current 4.8 release
                                        due to the wealth of existing applications.</p>
                                    <p>With the .NET Framework, the CLR/BCL is integrated with the application layer.
                                        Applications written in .NET Framework can be recompiled under .NET 8, although
                                        they usually require some modification. Some features of .NET Framework are not
                                        present in .NET 8 (and vice versa).</p>
                                    <p>.NET Framework is preinstalled with Windows and is automatically patched via
                                        Windows Update. When you target .NET Framework 4.8, you can use the features of
                                        C# 7.3 and earlier. (You can override this by specifying a newer language
                                        version in the project file—this unlocks all of the latest language features
                                        except for those that require support from a newer runtime.)</p>
                                    <div data-type="note" epub:type="note">
                                        <h6>Note</h6>
                                        <p>The word “.NET” has long been used as an umbrella term for any technology
                                            that includes the word “.NET” (.NET Framework, .NET Core, .NET Standard, and
                                            so on).</p>
                                        <p>This means that Microsoft’s renaming of .NET Core to .NET has created an
                                            unfortunate ambiguity. In this book, we’ll refer to the new .NET as <em>.NET
                                                5+</em> when an ambiguity arises. And to refer to .NET Core and its
                                            successors, we’ll use the phrase “.NET Core and .NET 5+.”</p>
                                        <p>To add to the confusion, .NET (5+) is a framework, yet it’s very different
                                            from the <em>.NET Framework</em>. Hence, we’ll use the term <em>runtime</em>
                                            in preference to <em>framework</em>, where possible.</p>
                                    </div>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="Niche Runtimes" data-type="sect2">
                        <div class="sect2" id="niche_runtimes">
                            <h2>Niche Runtimes</h2>
                            <p><a contenteditable="false" data-primary="C# (generally)" data-secondary="niche runtimes"
                                    data-type="indexterm" id="id1544" /><a contenteditable="false"
                                    data-primary="niche runtimes" data-type="indexterm" id="id1545" /><a
                                    contenteditable="false" data-primary="runtimes" data-secondary="niche"
                                    data-type="indexterm" id="id1546" />There are also the following niche runtimes:</p>
                            <ul>
                                <li>
                                    <p><a contenteditable="false" data-primary=".NET Micro Framework"
                                            data-primary-sortas="NET Micro Framework" data-type="indexterm"
                                            id="id1547" /><a contenteditable="false" data-primary="Unity"
                                            data-type="indexterm" id="id1548" />Unity is a game development platform
                                        that allows game logic to be scripted with C#.</p>
                                </li>
                                <li>
                                    <p><a contenteditable="false" data-primary="UWP (Universal Windows Platform)"
                                            data-secondary="about" data-type="indexterm" id="id1549" /><em>Universal
                                            Windows Platform</em> (UWP) was designed for writing touch-first
                                        applications that run on Windows 10+ desktop and devices, including Xbox,
                                        Surface Hub, and HoloLens. UWP apps are sandboxed and ship via the Windows
                                        Store. UWP uses a version of the .NET Core 2.2 CLR/BCL, and it’s unlikely that
                                        this dependency will be updated; instead, Microsoft has recommended that users
                                        switch to its modern replacement, WinUI 3. But because WinUI 3 only supports
                                        Windows desktop, UWP still has a niche application for targeting Xbox, Surface
                                        Hub, and HoloLens.</p>
                                </li>
                                <li>
                                    <p>The .NET Micro Framework is for running .NET code on highly resource-constrained
                                        embedded devices (under one megabyte).</p>
                                </li>
                            </ul>
                            <p><a contenteditable="false" data-primary="SQL Server" data-type="indexterm"
                                    id="id1550" />It’s also possible to run managed code within SQL Server. With SQL
                                Server CLR integration, you can write custom functions, stored procedures, and
                                aggregations in C# and then call them from SQL. This works in conjunction with .NET
                                Framework and a special “hosted” CLR that enforces a sandbox to protect the integrity of
                                the SQL Server process.</p>
                        </div>
                    </section>
                </div>
            </section>
            <section data-pdf-bookmark="A Brief History of C#" data-type="sect1">
                <div class="sect1" id="a_brief_history_of_chash">
                    <h1>A Brief History of C#</h1>
                    <p><a contenteditable="false" data-primary="C# (generally)"
                            data-secondary="brief history of features introduced from C# 2.0 through C# 9.0"
                            data-type="indexterm" id="ch01.html100" />The following is a reverse chronology of the new
                        features in each C# version, for the benefit of readers who are already familiar with an older
                        version of the language.</p>
                    <section data-pdf-bookmark="What’s New in C# 12" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_onetwo">
                            <h2>What’s New in C# 12</h2>
                            <p><a contenteditable="false" data-primary="C# 12" data-secondary="new features"
                                    data-type="indexterm" id="ch01.html101" />C# 12 ships with Visual Studio 2022, and
                                is used when you target .NET 8.</p>
                            <section class="pagebreak-before" data-pdf-bookmark="Collection expressions"
                                data-type="sect3">
                                <div class="sect3" id="collection_expressions">
                                    <h3 class="less_space">Collection expressions</h3>
                                    <p>Rather than initializing an array as follows:</p>
                                    <pre data-type="programlisting">char[] vowels = {'a','e','i','o','u'};</pre>
                                    <p>you can now use square brackets (a <em>collection expression</em>):</p>
                                    <pre
                                        data-type="programlisting">char[] vowels = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;</pre>
                                    <p>Collection expressions have two major advantages. First, the same syntax also
                                        works with other collection types, such as lists and sets (and even the
                                        low-level span types):</p>
                                    <pre data-type="programlisting"><strong>List&lt;char&gt;</strong> list         = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;
<strong>HashSet&lt;char&gt;</strong> set       = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;
<strong>ReadOnlySpan&lt;char&gt;</strong> span = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;</pre>
                                    <p>Second, they are <em>target-typed</em>, which means that you can omit the type in
                                        other scenarios where the compiler can infer it, such as when calling methods:
                                    </p>
                                    <pre data-type="programlisting">Foo (['a','e','i','o','u']);

void Foo (char[] letters) { ... }</pre>
                                    <p>See <a data-type="xref"
                                            href="ch04.html#collection_initializers_and_collection">“Collection
                                            Initializers and Collection Expressions”</a> for more details.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Primary constructors in classes and structs" data-type="sect3">
                                <div class="sect3" id="primary_constructors_in_classes_and_str">
                                    <h3>Primary constructors in classes and structs</h3>
                                    <p>From C# 12, you can include a parameter list directly after a class (or struct)
                                        declaration:</p>
                                    <pre data-type="programlisting">class Person (<strong>string firstName, string lastName</strong>)
{
  public void Print() =&gt; Console.WriteLine (<strong>firstName</strong> + " " + <strong>lastName</strong>);
}</pre>
                                    <p>This instructs the compiler to automatically build a <em>primary
                                            constructor</em>, allowing the following:</p>
                                    <pre data-type="programlisting">Person p = <strong>new Person ("Alice", "Jones")</strong>;
p.Print();    // Alice Jones</pre>
                                    <p>This feature has existed since C# 9 with records—where they behave slightly
                                        differently. With records, the compiler generates (by default) a public
                                        init-only property for each primary constructor parameter. This is not the case
                                        with classes and structs; to achieve the same result, you must define those
                                        properties explicitly:</p>
                                    <pre data-type="programlisting">class Person (string firstName, string lastName)
{
  <strong>public string FirstName { get; set; } = firstName;</strong>
  <strong>public string LastName { get; set; } = lastName;</strong>
}</pre>
                                    <p>Primary constructors work well in simple scenarios. We describe their nuances and
                                        limitations in <a data-type="xref"
                                            href="ch03.html#primary_constructors_left_parenthesisch">“Primary
                                            Constructors (C# 12)”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Default lambda parameters" data-type="sect3">
                                <div class="sect3" id="default_lambda_parameters">
                                    <h3>Default lambda parameters</h3>
                                    <p>Just as ordinary methods can define parameters with default values:</p>
                                    <pre
                                        data-type="programlisting">void Print (string <strong>message = ""</strong>) =&gt; Console.WriteLine (message);</pre>
                                    <p>so, too, can lambda expressions:</p>
                                    <pre data-type="programlisting">var print = (string <strong>message = ""</strong>) =&gt; Console.WriteLine (message);

print ("Hello");
print ();</pre>
                                    <p>This feature is useful with libraries such as ASP.NET Minimal API.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Alias any type" data-type="sect3">
                                <div class="sect3" id="alias_any_type">
                                    <h3>Alias any type</h3>
                                    <p>C# has always allowed you to alias a simple or generic type via the
                                        <code>using</code> directive:</p>
                                    <pre data-type="programlisting">using ListOfInt = System.Collections.Generic.List&lt;int&gt;;

var list = new ListOfInt();</pre>
                                    <p>From C# 12, this approach works with other kinds of types, too, such as arrays
                                        and tuples:</p>
                                    <pre data-type="programlisting">using NumberList = double[];
using Point = (int X, int Y);

NumberList numbers = { 2.5, 3.5 };
Point p = (3, 4);</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Other new features" data-type="sect3">
                                <div class="sect3" id="other_new_features-id00031">
                                    <h3>Other new features</h3>
                                    <p>C# 12 also supports <em>inline arrays</em>, via the
                                        <code>[System.Runtime.CompilerServices.InlineArray]</code> attribute. This
                                        allows for the creation of fixed-size arrays in a struct without requiring an
                                        unsafe context, and is intended for use primarily within the runtime APIs. <a
                                            contenteditable="false" data-primary="" data-startref="ch01.html101"
                                            data-type="indexterm" id="id1551" /></p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 11" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_oneone">
                            <h2>What’s New in C# 11</h2>
                            <p><a contenteditable="false" data-primary="C# 11" data-secondary="new features"
                                    data-type="indexterm" id="ch01.html102" />C# 11 shipped with Visual Studio 2022, and
                                is used by default when you target .NET 7.</p>
                            <section data-pdf-bookmark="Raw string literals" data-type="sect3">
                                <div class="sect3" id="raw_string_literals">
                                    <h3>Raw string literals</h3>
                                    <p>Wrapping a string in three or more quote characters creates a <em>raw string
                                            literal</em>, which can contain almost any character sequence without
                                        escaping or doubling up. This makes it easy to represent JSON, XML, and HTML
                                        literals, as well as regular expressions and source code:</p>
                                    <pre
                                        data-type="programlisting">string raw = <strong>"""</strong>&lt;file path="c:\temp\test.txt"&gt;&lt;/file&gt;<strong>"""</strong>;</pre>
                                    <p>Raw string literals can be multiline and permit interpolation via the
                                        <code>$</code> prefix:</p>
                                    <pre data-type="programlisting">string multiLineRaw = <strong>$"""</strong>
  Line 1
  Line 2
  The date and time is <strong>{DateTime.Now}</strong>
  <strong>"""</strong>;</pre>
                                    <p>Using two (or more) <code>$</code> characters in a raw string literal prefix
                                        changes the interpolation sequence from one brace to two (or more) braces,
                                        allowing you to include braces in the string itself:</p>
                                    <pre data-type="programlisting">Console.WriteLine ($$"""{ "TimeStamp": "<strong>{{</strong>DateTime.Now<strong>}}</strong>" }""");
// Output: <em>{ "TimeStamp": "01/01/2024 12:13:25 PM" }</em></pre>
                                    <p>We cover the nuances of this feature in <a data-type="xref"
                                            href="ch02.html#raw_string_literals_left_parenthesischa">“Raw string
                                            literals (C# 11)”</a> and <a data-type="xref"
                                            href="ch02.html#string_interpolation">“String interpolation”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="UTF-8 strings" data-type="sect3">
                                <div class="sect3" id="utf_eight_strings-id00050">
                                    <h3>UTF-8 strings</h3>
                                    <p>With the <code>u8</code> suffix, you create string literals encoded in UTF-8
                                        rather than UTF-16. This feature is intended for advanced scenarios such as the
                                        low-level handling of JSON text in performance hotspots:</p>
                                    <pre data-type="programlisting">ReadOnlySpan&lt;byte&gt; utf8 = "ab→cd"<strong>u8</strong>;  // Arrow symbol consumes 3 bytes
Console.WriteLine (utf8.Length);      // 7</pre>
                                    <p>The underlying type is <code>ReadOnlySpan&lt;byte&gt;</code> (<a data-type="xref"
                                            href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>),
                                        which you can convert to a byte array by calling its <code>ToArray()</code>
                                        method.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="List patterns" data-type="sect3">
                                <div class="sect3" id="list_patterns-id00025">
                                    <h3>List patterns</h3>
                                    <p>List patterns match a series of elements in square brackets, and work with any
                                        collection type that is countable (with a <code>Count</code> or
                                        <code>Length</code> property) and indexable (with an indexer of type
                                        <code>int</code> or <code>System.Index</code>):</p>
                                    <pre data-type="programlisting">int[] numbers = { 0, 1, 2, 3, 4 };
Console.WriteLine (<strong>numbers is [0, 1, 2, 3, 4]</strong>);   // True</pre>
                                    <p>An underscore matches a single element of any value, and two dots match zero or
                                        more elements (a <em>slice</em>):</p>
                                    <pre
                                        data-type="programlisting">Console.WriteLine (<strong>numbers is [_, 1, .., 4]</strong>);     // True</pre>
                                    <p>A slice can be followed by the <code>var</code> pattern—see <a data-type="xref"
                                            href="ch04.html#list_patterns-id00076">“List Patterns”</a> for details.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Required members" data-type="sect3">
                                <div class="sect3" id="required_members">
                                    <h3>Required members</h3>
                                    <p>Applying the <code>required</code> modifier to a field or property forces
                                        consumers of that class or struct to populate that member via an object
                                        initializer when constructing it:</p>
                                    <pre data-type="programlisting">Asset a1 = new Asset { Name = "House" };  // OK
Asset a2 = new Asset();                   // Error: will not compile!

class Asset { public <strong>required</strong> string Name; }</pre>
                                    <p>With this feature, you can avoid writing constructors with long parameter lists,
                                        which can simplify subclassing. Should you also wish to write a constructor, you
                                        can apply the <code>[SetsRequiredMembers]</code> attribute to bypass the
                                        required member restriction for that constructor—see <a data-type="xref"
                                            href="ch03.html#required_members_left_parenthesischash">“Required members
                                            (C# 11)”</a> for details.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Static virtual/abstract interface members" data-type="sect3">
                                <div class="sect3" id="static_virtualsolidusabstract-id00040">
                                    <h3>Static virtual/abstract interface members</h3>
                                    <p>From C# 11, interfaces can declare members as <code>static virtual</code> or
                                        <code>static abstract</code>:</p>
                                    <pre data-type="programlisting">public interface IParsable&lt;TSelf&gt;
{
   <strong>static abstract</strong> TSelf Parse (string s);
}</pre>
                                    <p>These members are implemented as static functions in classes or structs, and can
                                        be called polymorphically via a constrained type parameter:</p>
                                    <pre
                                        data-type="programlisting">T ParseAny&lt;T&gt; (string s) <strong>where T : IParsable&lt;T&gt;</strong> =&gt; T.Parse (s);</pre>
                                    <p>Operator functions can also be declared as <code>static virtual</code> or
                                        <code>static abstract</code>.</p>
                                    <p>For details, see <a data-type="xref"
                                            href="ch03.html#static_virtualsolidusabstract-id00091">“Static
                                            virtual/abstract interface members”</a> and <a data-type="xref"
                                            href="ch04.html#static_polymorphism">“Static Polymorphism”</a>. We also
                                        describe how to call static abstract members via reflection in <a
                                            data-type="xref"
                                            href="ch18.html#calling_static_virtualsolidusabstract_i">“Calling Static
                                            Virtual/Abstract Interface Members”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Generic math" data-type="sect3">
                                <div class="sect3" id="generic_math-id00018">
                                    <h3>Generic math</h3>
                                    <p>The <code>System.Numerics.INumber&lt;TSelf&gt;</code> interface (new to .NET 7)
                                        unifies arithmetic operations across all numeric types, allowing generic methods
                                        such as the following to be written:</p>
                                    <pre data-type="programlisting">T Sum&lt;T&gt; (T[] numbers) <strong>where T : INumber&lt;T&gt;</strong>
{
  T total = <strong>T.Zero</strong>;
  foreach (T n in numbers)
    total <strong>+=</strong> n;      // Invokes addition operator for any numeric type
  return total;
}

int intSum = Sum (3, 5, 7);
double doubleSum = Sum (3.2, 5.3, 7.1);
decimal decimalSum = Sum (3.2m, 5.3m, 7.1m);</pre>
                                    <p><code>INumber&lt;TSelf&gt;</code> is implemented by all real and integral numeric
                                        types in .NET (as well as <code>char</code>), and comprises several interfaces
                                        that include static abstract operator definitions such as the following:</p>
                                    <pre
                                        data-type="programlisting">static abstract TResult operator + (TSelf left, TOther right);</pre>
                                    <p>We cover this in <a data-type="xref"
                                            href="ch04.html#polymorphic_operators">“Polymorphic Operators”</a> and <a
                                            data-type="xref" href="ch04.html#generic_math-id00069">“Generic Math”</a>.
                                    </p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Other new features" data-type="sect3">
                                <div class="sect3" id="other_new_features-id00082">
                                    <h3>Other new features</h3>
                                    <p>A type with the <code>file</code> accessibility modifier can be accessed only
                                        from within the same file, and is intended for use within source generators:</p>
                                    <pre data-type="programlisting"><strong>file</strong> class Foo { ... }</pre>
                                    <p>C# 11 also introduced checked operators (see <a data-type="xref"
                                            href="ch04.html#checked_operators">“Checked operators”</a>), for defining
                                        operator functions to be called inside <code>checked</code> blocks (this was
                                        required for a full implementation of generic math). C# 11 also relaxed the
                                        requirement to populate every field in a struct’s constructor (see <a
                                            data-type="xref" href="ch03.html#struct_construction_semantics">“Struct
                                            Construction Semantics”</a>).</p>
                                    <p>Finally, the <code>nint</code> and <code>nuint</code> native-sized integers types
                                        that were introduced in C# 9 to match the address space of the process at
                                        runtime (32 or 64 bits) were enhanced in C# 11 when targeting .NET 7 or later.
                                        Specifically, the compile-time distinction between these types and their
                                        underlying runtime types (<code>IntPtr</code> and <code>UIntPtr</code>) has
                                        melted away when targeting .NET 7+. See <a data-type="xref"
                                            href="ch04.html#native_sized_integers">“Native-Sized Integers”</a> for a
                                        full discussion.</p><a contenteditable="false" data-primary=""
                                        data-startref="ch01.html102" data-type="indexterm" id="id1552" />
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 10" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_onezero">
                            <h2>What’s New in C# 10</h2>
                            <p><a contenteditable="false" data-primary="C# 10" data-secondary="new features"
                                    data-type="indexterm" id="ch01.html103" />C# 10 shipped with Visual Studio 2022, and
                                is used when you target .NET 6.</p>
                            <section data-pdf-bookmark="File-scoped namespaces" data-type="sect3">
                                <div class="sect3" id="file_scoped_namespaces-id00017">
                                    <h3>File-scoped namespaces</h3>
                                    <p>In the common case that all types in a file are defined in a single namespace, a
                                        <em>file-scoped namespace</em> declaration in C# 10 reduces clutter and
                                        eliminates an unnecessary level of indentation:</p>
                                    <pre data-type="programlisting"><strong>namespace MyNamespace;</strong>  // Applies to everything that follows in the file.

class Class1 {}         // inside MyNamespace
class Class2 {}         // inside MyNamespace</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="The global using directive" data-type="sect3">
                                <div class="sect3" id="the_global_using_directive-id00044">
                                    <h3>The global using directive</h3>
                                    <p>When you prefix a <code>using</code> directive with the <code>global</code>
                                        keyword, it applies the directive to all files in the project:</p>
                                    <pre data-type="programlisting"><strong>global</strong> using System;
<strong>global</strong> using System.Collection.Generic;</pre>
                                    <p>This lets you avoid repeating the same directives in every file.
                                        <code>global using</code> directives work with <code>using static</code>.</p>
                                    <p>Additionally, .NET 6 projects now support <em>implicit global using
                                            directives</em>: if the <code>ImplicitUsings</code> element is set to true
                                        in the project file, the most commonly used namespaces are automatically
                                        imported (based on the SDK project type). See <a data-type="xref"
                                            href="ch02.html#the_global_using_directive-id00095">“The global using
                                            Directive”</a> for more detail.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Nondestructive mutation for anonymous types" data-type="sect3">
                                <div class="sect3" id="nondestructive_mutation_for_anonymous_t">
                                    <h3>Nondestructive mutation for anonymous types</h3>
                                    <p>C# 9 introduced the <code>with</code> keyword, to perform nondestructive mutation
                                        on records. In C# 10, the <code>with</code> keyword also works with anonymous
                                        types:</p>
                                    <pre data-type="programlisting">var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 <strong>with { E = 10 }</strong>; 
Console.WriteLine (a2);      // { A = 1, B = 2, C = 3, D = 4, E = 10 }</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="New deconstruction syntax" data-type="sect3">
                                <div class="sect3" id="new_deconstruction_syntax">
                                    <h3>New deconstruction syntax</h3>
                                    <p>C# 7 introduced the deconstruction syntax for tuples (or any type with a <span
                                            class="keep-together"><code>Deconstruct</code></span> method). C# 10 takes
                                        this syntax further, letting you mix assignment and declaration in the same
                                        deconstruction:</p>
                                    <pre data-type="programlisting">var point = (3, 4);
double x = 0;
(x, double y) = point;</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Field initializers and parameterless constructors in structs"
                                data-type="sect3">
                                <div class="sect3" id="field_initializers_and_parameterless_co">
                                    <h3>Field initializers and parameterless constructors in structs</h3>
                                    <p>From C# 10, you can include field initializers and parameterless constructors in
                                        structs (see <a data-type="xref" href="ch03.html#structs">“Structs”</a>). These
                                        execute only when the constructor is called explicitly, and so can easily be
                                        bypassed—for instance, via the <code>default</code> keyword. This feature was
                                        introduced primarily for the benefit of struct records.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Record structs" data-type="sect3">
                                <div class="sect3" id="record_structs">
                                    <h3>Record structs</h3>
                                    <p>Records were first introduced in C# 9, where they acted as a compiled-enhanced
                                        class. In C# 10, records can also be structs:</p>
                                    <pre
                                        data-type="programlisting">record <strong>struct</strong> Point (int X, int Y);</pre>
                                    <p>The rules are otherwise similar: <em>record structs</em> have much the same
                                        features as <em>class structs</em> (see <a data-type="xref"
                                            href="ch04.html#records-id00087">“Records”</a>). An exception is that the
                                        compiler-generated properties on record structs are writable, unless you prefix
                                        the record declaration with the <code>readonly</code> keyword.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Lambda expression enhancements" data-type="sect3">
                                <div class="sect3" id="lambda_expression_enhancements">
                                    <h3>Lambda expression enhancements</h3>
                                    <p>The syntax around lambda expressions has been enhanced in a number of ways.
                                        First, implicit typing (<code>var</code>) is permitted:</p>
                                    <pre
                                        data-type="programlisting"><strong>var</strong> greeter = () =&gt; "Hello, world";</pre>
                                    <p>The implicit type for a lambda expression is an <code>Action</code> or
                                        <code>Func</code> delegate, so <code>greeter</code>, in this case, is of type
                                        <code>Func&lt;string&gt;</code>. You must explicitly state any parameter types:
                                    </p>
                                    <pre
                                        data-type="programlisting">var square = (<strong>int</strong> x) =&gt; x * x;</pre>
                                    <p>Second, a lambda expression can specify a return type:</p>
                                    <pre
                                        data-type="programlisting">var sqr = <strong>int</strong> (int x) =&gt; x;</pre>
                                    <p>This is primarily to improve compiler performance with complex nested lambdas.
                                    </p>
                                    <p>Third, you can pass a lambda expression into a method parameter of type
                                        <code>object</code>, <code>Delegate,</code> or <code>Expression</code>:</p>
                                    <pre data-type="programlisting">M1 (() =&gt; "test");   // Implicitly typed to Func&lt;string&gt;
M2 (() =&gt; "test");   // Implicitly typed to Func&lt;string&gt;
M3 (() =&gt; "test");   // Implicitly typed to Expression&lt;Func&lt;string&gt;&gt;

void M1 (object x) {}
void M2 (Delegate x) {}
void M3 (Expression x) {}</pre>
                                    <p>Finally, you can apply attributes to a lambda expression’s compile-generated
                                        target method (as well as its parameters and return value):</p>
                                    <pre
                                        data-type="programlisting">Action a = <strong>[Description("test")]</strong> () =&gt; { };</pre>
                                    <p>See <a data-type="xref"
                                            href="ch04.html#applying_attributes_to_lambda_expressio">“Applying
                                            Attributes to Lambda Expressions”</a> for more detail.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Nested property patterns" data-type="sect3">
                                <div class="sect3" id="nested_property_patterns">
                                    <h3>Nested property patterns</h3>
                                    <p>The following simplified syntax is legal in C# 10 for nested property pattern
                                        matching (see <a data-type="xref" href="ch04.html#property_patterns">“Property
                                            Patterns”</a>):</p>
                                    <pre data-type="programlisting">var obj = new Uri ("https://www.linqpad.net");
if (obj is Uri { <strong>Scheme.Length</strong>: 5 }) ...</pre>
                                    <p>This is equivalent to:</p>
                                    <pre
                                        data-type="programlisting">if (obj is Uri { <strong>Scheme: { Length: 5 }}</strong>) ...</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="CallerArgumentExpression" data-type="sect3">
                                <div class="sect3" id="callerargumentexpression-id00003">
                                    <h3>CallerArgumentExpression</h3>
                                    <p>A method parameter to which you apply the <code>[CallerArgumentExpression]</code>
                                        attribute captures an argument expression from the call site:</p>
                                    <pre data-type="programlisting">Print (<strong>Math.PI * 2</strong>);

void Print (double number,
           [<strong>CallerArgumentExpression("number")</strong>] string expr = null)
  =&gt; Console.WriteLine (expr);

// Output: Math.PI * 2</pre>
                                    <p>This feature is intended primarily for validation and assertion libraries (see <a
                                            data-type="xref"
                                            href="ch04.html#callerargumentexpression-id00054">“CallerArgumentExpression”</a>).
                                    </p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Other new features" data-type="sect3">
                                <div class="sect3" id="other_new_features-id000104">
                                    <h3>Other new features</h3>
                                    <p>The <code>#line</code> directive has been enhanced in C# 10 to allow a column and
                                        range to be specified.</p>
                                    <p>Interpolated strings in C# 10 can be constants, as long as the interpolated
                                        values are constants.</p>
                                    <p>Records can seal the <code>ToString()</code> method in C# 10.</p>
                                    <p>C#’s definite assignment analysis has been improved so that expressions such as
                                        the following work:</p>
                                    <pre data-type="programlisting">if (foo?.TryParse ("123", out var number) ?? false)
  Console.WriteLine (number);</pre>
                                    <p>(Prior to C# 10, the compiler would generate an error: “Use of unassigned local
                                        variable ‘number’.”) <a contenteditable="false" data-primary=""
                                            data-startref="ch01.html103" data-type="indexterm" id="id1553" /></p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 9.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_ninedotzer">
                            <h2>What’s New in C# 9.0</h2>
                            <p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09"
                                    data-secondary="new features" data-type="indexterm" id="ch01.html0" />C# 9.0 shipped
                                with <em>Visual Studio 2019</em>, and is used when you target .NET 5.</p>
                            <section data-pdf-bookmark="Top-level statements" data-type="sect3">
                                <div class="sect3" id="top_level_statements-id00047">
                                    <h3>Top-level statements</h3>
                                    <p>With <em>top-level statements</em> (see <a data-type="xref"
                                            href="ch02.html#top_level_statements-id00098">“Top-Level Statements”</a>),
                                        you can write a program without the baggage of a <code>Main</code> method and
                                        <code>Program</code> class:</p>
                                    <pre data-type="programlisting">using System;
Console.WriteLine ("Hello, world");</pre>
                                    <p>Top-level statements can include methods (which act as local methods). You can
                                        also access command-line arguments via the “magic” <code>args</code> variable,
                                        and return a value to the caller. Top-level statements can be followed by type
                                        and namespace declarations.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Init-only setters" data-type="sect3">
                                <div class="sect3" id="init_only_setters-id00023">
                                    <h3>Init-only setters</h3>
                                    <p>An <em>init-only setter</em> (see <a data-type="xref"
                                            href="ch03.html#init_only_setters-id00074">“Init-only setters”</a>) in a
                                        property declaration uses the <code>init</code> keyword instead of the
                                        <code>set</code> keyword:</p>
                                    <pre
                                        data-type="programlisting">class Foo { public int ID { get; <strong>init;</strong> } }</pre>
                                    <p>This behaves like a read-only property, except that it can also be set via an
                                        object initializer:</p>
                                    <pre
                                        data-type="programlisting">var foo = new Foo <strong>{ ID = 123 }</strong>;</pre>
                                    <p>This makes it possible to create immutable (read-only) types that can be
                                        populated via an object initializer instead of a constructor, and helps to avoid
                                        the antipattern of constructors that accept a large number of optional
                                        parameters. Init-only setters also allow for <em>nondestructive mutation</em>
                                        when used in <em>records</em>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Records" data-type="sect3">
                                <div class="sect3" id="records-id00036">
                                    <h3>Records</h3>
                                    <p>A <em>record</em> (see <a data-type="xref"
                                            href="ch04.html#records-id00087">“Records”</a>) is a special kind of class
                                        that’s designed to work well with immutable data. Its most special feature is
                                        that it supports <em>nondestructive mutation</em> via a new keyword
                                        (<code>with</code>):</p>
                                    <pre data-type="programlisting">Point p1 = new Point (2, 3);
Point p2 = p1 <strong>with { Y = 4 }</strong>;   // p2 is a copy of p1, but with Y set to 4
Console.WriteLine (p2);         // Point { X = 2, Y = 4 }

<strong>record</strong> Point
{
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    
}</pre>
                                    <p>In simple cases, a record can also eliminate the boilerplate code of defining
                                        properties and writing a constructor and deconstructor. We can replace our
                                        <code>Point</code> record definition with the following, without loss of
                                        functionality:</p>
                                    <pre data-type="programlisting">record Point (double X, double Y);</pre>
                                    <p>Like tuples, records exhibit structural equality by default. Records can subclass
                                        other records, and can include the same constructs that classes can include. The
                                        compiler implements records as classes at runtime.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Pattern-matching improvements" data-type="sect3">
                                <div class="sect3" id="pattern_matching_improvements">
                                    <h3>Pattern-matching improvements</h3>
                                    <p>The <em>relational pattern</em> (see <a data-type="xref"
                                            href="ch04.html#patterns">“Patterns”</a>) allows the <code>&lt;</code>,
                                        <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators to
                                        appear in patterns:</p>
                                    <pre data-type="programlisting">string GetWeightCategory (decimal bmi) =&gt; bmi switch {
  <strong>&lt;</strong> 18.5m =&gt; "underweight",
  <strong>&lt;</strong> 25m =&gt; "normal",
  <strong>&lt;</strong> 30m =&gt; "overweight",
  _ =&gt; "obese" };</pre>
                                    <p>With <em>pattern combinators</em>, you can combine patterns via three new
                                        keywords (<code>and</code>, <code>or</code>, and <code>not</code>):</p>
                                    <pre data-type="programlisting">bool IsVowel (char c) =&gt; c is <strong>'a' or 'e' or 'i' or 'o' or 'u'</strong>;

bool IsLetter (char c) =&gt; c is <strong>&gt;= 'a' and &lt;= 'z'</strong>
                            <strong>or &gt;= 'A' and &lt;= 'Z'</strong>;</pre>
                                    <p>As with the <code>&amp;&amp;</code> and <code>||</code> operators,
                                        <code>and</code> has higher precedence than <code>or</code>. You can override
                                        this with parentheses.</p>
                                    <p>The <code>not</code> combinator can be used with the <em>type pattern</em> to
                                        test whether an object is (not) a type:</p>
                                    <pre data-type="programlisting">if (obj is <strong>not string</strong>) ...</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Target-typed new expressions" data-type="sect3">
                                <div class="sect3" id="target_typed_new_expressions-id00043">
                                    <h3>Target-typed new expressions</h3>
                                    <p>When constructing an object, C# 9 lets you omit the type name when the compiler
                                        can infer it unambiguously:</p>
                                    <pre data-type="programlisting">System.Text.StringBuilder sb1 = <strong>new()</strong>;
System.Text.StringBuilder sb2 = <strong>new ("Test")</strong>;</pre>
                                    <p>This is particularly useful when the variable declaration and initialization are
                                        in different parts of your code:</p>
                                    <pre data-type="programlisting">class Foo
{
  <strong>System.Text.StringBuilder</strong> sb;
  public Foo (string initialValue) =&gt; sb = <strong>new (initialValue)</strong>;
}</pre>
                                    <p>And in the following scenario:</p>
                                    <pre data-type="programlisting">MyMethod (<strong>new ("test")</strong>);
void MyMethod (System.Text.StringBuilder sb) { ... }</pre>
                                    <p>See <a data-type="xref"
                                            href="ch02.html#target_typed_new_expressions-id00094">“Target-Typed new
                                            Expressions”</a> for more information.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Interop improvements" data-type="sect3">
                                <div class="sect3" id="interop_improvements">
                                    <h3>Interop improvements</h3>
                                    <p>C# 9 introduces <em>function pointers</em> (see <a data-type="xref"
                                            href="ch04.html#function_pointers">“Function Pointers”</a> and <a
                                            data-type="xref"
                                            href="ch24.html#callbacks_with_function_pointers_left_p">“Callbacks with
                                            Function Pointers”</a>). Their main purpose is to allow unmanaged code to
                                        call static methods in C# without the overhead of a delegate instance, with the
                                        ability to bypass the P/Invoke layer when the arguments and return types are
                                        <em>blittable</em> (represented identically on each side).</p>
                                    <p>C# 9 also introduces the <code>nint</code> and <code>nuint</code> native-sized
                                        integer types (see <a data-type="xref"
                                            href="ch04.html#native_sized_integers">“Native-Sized Integers”</a>), which
                                        map at runtime to <code>System.IntPtr</code> and <code>System.UIntPtr</code>. At
                                        compile time, they behave like numeric types with support for arithmetic
                                        operations.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Other new features" data-type="sect3">
                                <div class="sect3" id="other_new_features">
                                    <h3>Other new features</h3>
                                    <p>Additionally, C# 9 now lets you:</p>
                                    <ul>
                                        <li>
                                            <p>Override a method or read-only property such that it returns a more
                                                derived type (see <a data-type="xref"
                                                    href="ch03.html#covariant_return_types">“Covariant return
                                                    types”</a>).</p>
                                        </li>
                                        <li>
                                            <p>Apply attributes to local functions (see <a data-type="xref"
                                                    href="ch04.html#attributes">“Attributes”</a>).</p>
                                        </li>
                                        <li>
                                            <p>Apply the <code>static</code> keyword to lambda expressions or local
                                                functions to ensure that you don’t accidentally capture local or
                                                instance variables (see <a data-type="xref"
                                                    href="ch04.html#static_lambdas">“Static lambdas”</a>).</p>
                                        </li>
                                        <li>
                                            <p>Make any type work with the <code>foreach</code> statement, by writing a
                                                <code>GetEnumerator</code> extension method.</p>
                                        </li>
                                        <li>
                                            <p>Define a <em>module initializer</em> method that executes once when an
                                                assembly is first loaded, by applying the
                                                <code>[ModuleInitializer]</code> attribute to a (static void
                                                parameterless) method.</p>
                                        </li>
                                        <li>
                                            <p>Use a “discard” (underscore symbol) as a lambda expression argument.</p>
                                        </li>
                                        <li class="pagebreak-before">
                                            <p>Write <em>extended partial methods</em> that are mandatory to
                                                implement—enabling scenarios such as Roslyn’s new <em>source
                                                    generators</em> (see <a data-type="xref"
                                                    href="ch03.html#extended_partial_methods">“Extended partial
                                                    methods”</a>).</p>
                                        </li>
                                        <li>
                                            <p>Apply an attribute to methods, types, or modules to prevent local
                                                variables from being initialized by the runtime (see <a data-type="xref"
                                                    href="ch04.html#left_square_bracketskiplocalsinitright">“[SkipLocalsInit]”</a>)<a
                                                    contenteditable="false" data-primary="" data-startref="ch01.html0"
                                                    data-type="indexterm" id="id1554" />.</p>
                                        </li>
                                    </ul>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 8.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_eightdotze">
                            <h2>What’s New in C# 8.0</h2>
                            <p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08"
                                    data-secondary="new features" data-type="indexterm" id="ch01.html1" />C# 8.0 first
                                shipped with <em>Visual Studio 2019</em>, and is still used today when you target .NET
                                Core 3 or .NET Standard 2.1.</p>
                            <section data-pdf-bookmark="Indices and ranges" data-type="sect3">
                                <div class="sect3" id="indices_and_ranges-id00022">
                                    <h3>Indices and ranges</h3>
                                    <p><em>Indices and ranges</em> simplify working with elements or portions of an
                                        array (or the low-level types <code>Span&lt;T&gt;</code> and
                                        <code>ReadOnlySpan&lt;T&gt;</code>).</p>
                                    <p>Indices let you refer to elements relative to the <em>end</em> of an array by
                                        using the <code>^</code> operator. <code>^1</code> refers to the last element,
                                        <code>^2</code> refers to the second-to-last element, and so on:</p>
                                    <pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [<strong>^1</strong>];   // 'u'
char secondToLast = vowels [<strong>^2</strong>];   // 'o'</pre>
                                    <p>Ranges let you “slice” an array by using the <code>..</code> operator:</p>
                                    <pre data-type="programlisting">char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3]    // 'i'
char[] lastTwo =   vowels [^2..];   // 'o', 'u'</pre>
                                    <p>C# implements indexes and ranges with the help of the <code>Index</code> and
                                        <code>Range</code> types:</p>
                                    <pre data-type="programlisting"><strong>Index</strong> last = <strong>^1</strong>;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'</pre>
                                    <p>You can support indices and ranges in your own classes by defining an indexer
                                        with a parameter type of <code>Index</code> or <code>Range</code>:</p>
                                    <pre data-type="programlisting">class Sentence
{
  string[] words = "The quick brown fox".Split();

  public string this   [Index index] =&gt; words [index];
  public string[] this [Range range] =&gt; words [range];
}</pre>
                                    <p>For more information, see <a data-type="xref"
                                            href="ch02.html#indices_and_ranges-id00073">“Indices and Ranges”</a>.</p>
                                </div>
                            </section>
                            <section class="pagebreak-before" data-pdf-bookmark="Null-coalescing assignment"
                                data-type="sect3">
                                <div class="sect3" id="null_coalescing_assignment">
                                    <h3 class="less_space">Null-coalescing assignment</h3>
                                    <p>The <code>??=</code> operator assigns a variable only if it’s null. Instead of
                                    </p>
                                    <pre data-type="programlisting">if (s == null) s = "Hello, world";</pre>
                                    <p>you can now write this:</p>
                                    <pre data-type="programlisting">s <strong>??=</strong> "Hello, world";</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Using declarations" data-type="sect3">
                                <div class="sect3" id="using_declarations-id00049">
                                    <h3>Using declarations</h3>
                                    <p>If you omit the brackets and statement block following a <code>using</code>
                                        statement, it becomes a <em>using declaration</em>. The resource is then
                                        disposed when execution falls outside the <em>enclosing</em> statement block:
                                    </p>
                                    <pre data-type="programlisting">if (File.Exists ("file.txt"))
<strong>{</strong>
  <strong>using var reader = File.OpenText ("file.txt");</strong>
  Console.WriteLine (reader.ReadLine());
  ...
<strong>}</strong></pre>
                                    <p>In this case, <code>reader</code> will be disposed when execution falls outside
                                        the <code>if</code> statement block.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Read-only members" data-type="sect3">
                                <div class="sect3" id="read_only_members">
                                    <h3>Read-only members</h3>
                                    <p>C# 8 lets you apply the <code>readonly</code> modifier to a struct’s
                                        <em>functions</em>, ensuring that if the function attempts to modify any field,
                                        a compile-time error is generated:</p>
                                    <pre data-type="programlisting">struct Point
{
  public int X, Y;
  public <strong>readonly</strong> void ResetX() =&gt; X = 0;  // Error!
}</pre>
                                    <p>If a <code>readonly</code> function calls a non-<code>readonly</code> function,
                                        the compiler generates a warning (and defensively copies the struct to avoid the
                                        possibility of a mutation).</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Static local methods" data-type="sect3">
                                <div class="sect3" id="static_local_methods-id00039">
                                    <h3>Static local methods</h3>
                                    <p>Adding the <code>static</code> modifier to a local method prevents it from seeing
                                        the local variables and parameters of the enclosing method. This helps to reduce
                                        coupling and enables the local method to declare variables as it pleases,
                                        without risk of colliding with those in the containing method.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Default interface members" data-type="sect3">
                                <div class="sect3" id="default_interface_members-id00010">
                                    <h3>Default interface members</h3>
                                    <p>C# 8 lets you add a default implementation to an interface member, making it
                                        optional to implement:</p>
                                    <pre class="pagebreak-before" data-type="programlisting">interface ILogger
{
  void Log (string text) <strong>=&gt; Console.WriteLine (text);</strong>
}</pre>
                                    <p>This means that you can add a member to an interface without breaking
                                        implementations. Default implementations must be called explicitly through the
                                        interface:</p>
                                    <pre
                                        data-type="programlisting">(<strong>(ILogger)</strong>new Logger()).Log ("message");</pre>
                                    <p>Interfaces can also define static members (including fields), which can be
                                        accessed from code inside default implementations:</p>
                                    <pre data-type="programlisting">interface ILogger
{
  void Log (string text) =&gt; Console.WriteLine (<strong>Prefix</strong> + text);
  <strong>static string Prefix</strong> = ""; 
}</pre>
                                    <p>Or from outside the interface unless restricted via an accessibility modifier on
                                        the static interface member (such as <code>private</code>,
                                        <code>protected</code>, or <code>internal</code>):</p>
                                    <pre
                                        data-type="programlisting"><strong>ILogger.Prefix</strong> = "File log: ";</pre>
                                    <p>Instance fields are prohibited. For more details, see <a data-type="xref"
                                            href="ch03.html#default_interface_members-id00061">“Default Interface
                                            Members”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Switch expressions" data-type="sect3">
                                <div class="sect3" id="switch_expressions-id00042">
                                    <h3>Switch expressions</h3>
                                    <p>From C# 8, you can use <code>switch</code> in the context of an
                                        <em>expression</em>:</p>
                                    <pre data-type="programlisting">string cardName = cardNumber <strong>switch</strong>    // assuming cardNumber is an int
{
  13 <strong>=&gt;</strong> "King"<strong>,</strong>
  12 <strong>=&gt;</strong> "Queen"<strong>,</strong>
  11 <strong>=&gt;</strong> "Jack"<strong>,</strong>
  <strong>_ =&gt;</strong> "Pip card"   // equivalent to 'default'
};</pre>
                                    <p>For more examples, see <a data-type="xref"
                                            href="ch02.html#switch_expressions-id00093">“Switch expressions”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Tuple, positional, and property patterns" data-type="sect3">
                                <div class="sect3" id="tuplecomma_positionalcomma_and_property">
                                    <h3>Tuple, positional, and property patterns</h3>
                                    <p>C# 8 supports three new patterns, mostly for the benefit of switch
                                        statements/expressions (see <a data-type="xref"
                                            href="ch04.html#patterns">“Patterns”</a>). <em>Tuple patterns</em> let you
                                        switch on multiple values:</p>
                                    <pre data-type="programlisting">int cardNumber = 12; string suite = "spades";
string cardName = <strong>(cardNumber, suite)</strong> switch
{
  <strong>(13, "spades")</strong> =&gt; "King of spades",
  <strong>(13, "clubs")</strong> =&gt; "King of clubs",
  ...
};</pre>
                                    <p><em>Positional patterns</em> allow a similar syntax for objects that expose a
                                        deconstructor, and <em>property patterns</em> let you match on an object’s
                                        properties. You can use all of the patterns both in switches and with the
                                        <code>is</code> operator. The following example uses a <em>property pattern</em>
                                        to test whether <code>obj</code> is a string with a length of 4:</p>
                                    <pre
                                        data-type="programlisting">if (obj is <strong>string { Length:4 }</strong>) ...</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Nullable reference types" data-type="sect3">
                                <div class="sect3" id="nullable_reference_types-id00030">
                                    <h3>Nullable reference types</h3>
                                    <p>Whereas <em>nullable value types</em> bring nullability to value types,
                                        <em>nullable reference types</em> do the opposite and bring (a degree of)
                                        <em>non-nullability</em> to reference types, with the purpose of helping to
                                        avoid <code>NullReferenceException</code>s. Nullable reference types introduce a
                                        level of safety that’s enforced purely by the compiler in the form of warnings
                                        or errors when it detects code that’s at risk of generating a
                                        <code>NullReferenceException</code>.</p>
                                    <p>Nullable reference types can be enabled either at the project level (via the
                                        <code>Nullable</code> element in the <em>.csproj</em> project file) or in code
                                        (via the <code>#nullable</code> directive). After it’s enabled, the compiler
                                        makes non-nullability the default: if you want a reference type to accept nulls,
                                        you must apply the <code>?</code> suffix to indicate a <em>nullable reference
                                            type</em>:</p>
                                    <pre data-type="programlisting">#nullable enable    // Enable nullable reference types from this point on

string s1 = null;   // Generates a compiler warning! (s1 is non-nullable)
<strong>string?</strong> s2 = null;  // OK: s2 is <em>nullable reference type</em></pre>
                                    <p>Uninitialized fields also generate a warning (if the type is not marked as
                                        nullable), as does dereferencing a nullable reference type, if the compiler
                                        thinks a <code>NullReferenceException</code> might occur:</p>
                                    <pre
                                        data-type="programlisting">void Foo (<strong>string?</strong> s) =&gt; Console.Write (<strong>s.Length</strong>);  // Warning (.Length)</pre>
                                    <p>To remove the warning, you can use the <em>null-forgiving operator</em>
                                        (<code>!</code>):</p>
                                    <pre
                                        data-type="programlisting">void Foo (string? s) =&gt; Console.Write (<strong>s!.Length</strong>);</pre>
                                    <p>For a full discussion, see <a data-type="xref"
                                            href="ch04.html#nullable_reference_types-id00081">“Nullable Reference
                                            Types”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Asynchronous streams" data-type="sect3">
                                <div class="sect3" id="asynchronous_streams">
                                    <h3>Asynchronous streams</h3>
                                    <p>Prior to C# 8, you could use <code>yield return</code> to write an
                                        <em>iterator</em>, or <code>await</code> to write an <em>asynchronous
                                            function</em>. But you couldn’t do both and write an iterator that awaits,
                                        yielding elements asynchronously. C# 8 fixes this through the introduction of
                                        <em>asynchronous streams</em>:</p>
                                    <pre data-type="programlisting">async <strong>IAsyncEnumerable&lt;int&gt;</strong> RangeAsync (
  int start, int count, int delay)
{
  for (int i = start; i &lt; start + count; i++)
  {
    <strong>await</strong> Task.Delay (delay);
    <strong>yield return</strong> i;
  }
}</pre>
                                    <p>The <code>await foreach</code> statement consumes an asynchronous stream:</p>
                                    <pre data-type="programlisting"><strong>await foreach</strong> (var number in RangeAsync (0, 10, 100))
  Console.WriteLine (number);</pre>
                                    <p>For more information, see <a data-type="xref"
                                            href="ch14.html#asynchronous_stream">“Asynchronous Streams”</a>.<a
                                            contenteditable="false" data-primary="" data-startref="ch01.html1"
                                            data-type="indexterm" id="id1555" /></p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 7.x" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_sevendotx">
                            <h2>What’s New in C# 7.x</h2>
                            <p>C# 7.x was first shipped with Visual Studio 2017. C# 7.3 is still used today by Visual
                                Studio 2019 when you target .NET Core 2, .NET Framework 4.6 to 4.8, or .NET Standard
                                2.0.</p>
                            <section data-pdf-bookmark="C# 7.3" data-type="sect3">
                                <div class="sect3" id="chash_sevendotthree">
                                    <h3>C# 7.3</h3>
                                    <p>C# 7.3 made minor improvements to existing features, such as enabling the use of
                                        the equality operators with tuples, improved overload resolution, and the
                                        ability to apply attributes to the backing fields of automatic properties:</p>
                                    <pre data-type="programlisting">[<strong>field:</strong>NonSerialized]
public int MyProperty { get; set; }</pre>
                                    <p>C# 7.3 also built on C# 7.2’s advanced low-allocation programming features, with
                                        the ability to reassign <em>ref locals</em>, no requirement to pin when indexing
                                        <code>fixed</code> fields, and field initializer support with
                                        <code>stackalloc</code>:</p>
                                    <pre data-type="programlisting">int* pointer  = stackalloc int[] <strong>{1, 2, 3}</strong>;
Span&lt;int&gt; arr = stackalloc []    <strong>{1, 2, 3}</strong>;</pre>
                                    <p>Notice that stack-allocated memory can be assigned directly to a
                                        <code>Span&lt;T&gt;</code>. We describe spans—and why you would use them—in <a
                                            data-type="xref"
                                            href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="C# 7.2" data-type="sect3">
                                <div class="sect3" id="chash_sevendottwo">
                                    <h3>C# 7.2</h3>
                                    <p>C# 7.2 added a new <code>private protected</code> modifier (the
                                        <em>intersection</em> of <code>internal</code> and <code>protected</code>), the
                                        ability to follow named arguments with positional ones when calling methods, and
                                        <code>readonly</code> structs. A <code>readonly</code> struct enforces that all
                                        fields are <code>readonly</code>, to aid in declaring intent and to allow the
                                        compiler more optimization freedom:</p>
                                    <pre data-type="programlisting"><strong>readonly</strong> struct Point
{
  public readonly int X, Y;   // X and Y must be readonly
}</pre>
                                    <p>C# 7.2 also added specialized features to help with micro-optimization and
                                        low-allocation programming: see <a data-type="xref"
                                            href="ch02.html#the_in_modifier">“The in modifier”</a>, <a data-type="xref"
                                            href="ch02.html#ref_locals">“Ref Locals”</a>, <a data-type="xref"
                                            href="ch02.html#ref_returns">“Ref Returns”</a>, and <a data-type="xref"
                                            href="ch03.html#ref_structs">“Ref Structs”</a>.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="C# 7.1" data-type="sect3">
                                <div class="sect3" id="chash_sevendotone">
                                    <h3>C# 7.1</h3>
                                    <p>From C# 7.1, you can omit the type when using the <code>default</code> keyword,
                                        if the type can be inferred:</p>
                                    <pre
                                        data-type="programlisting">decimal number = <strong>default</strong>;   // number is decimal</pre>
                                    <p>C# 7.1 also relaxed the rules for switch statements (so that you can
                                        pattern-match on generic type parameters), allowed a program’s <code>Main</code>
                                        method to be asynchronous, and allowed tuple element names to be inferred:</p>
                                    <pre data-type="programlisting">var now = DateTime.Now;
var tuple = (now.Hour, now.Minute, now.Second);</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Numeric literal improvements" data-type="sect3">
                                <div class="sect3" id="numeric_literal_improvements">
                                    <h3>Numeric literal improvements</h3>
                                    <p>Numeric literals in C# 7 can include underscores to improve readability. These
                                        are called <em>digit separators</em> and are ignored by the compiler:</p>
                                    <pre data-type="programlisting">int million = <strong>1_000_000</strong>;</pre>
                                    <p><em>Binary literals</em> can be specified with the <code>0b</code> prefix:</p>
                                    <pre
                                        data-type="programlisting">var b = <strong>0b</strong>1010_1011_1100_1101_1110_1111;</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Out variables and discards" data-type="sect3">
                                <div class="sect3" id="out_variables_and_discards-id00032">
                                    <h3>Out variables and discards</h3>
                                    <p>C# 7 makes it easier to call methods that contain <code>out</code> parameters.
                                        First, you can now declare <em>out variables</em> on the fly (see <a
                                            data-type="xref" href="ch02.html#out_variables_and_discards-id00083">“Out
                                            variables and discards”</a>):</p>
                                    <pre data-type="programlisting">bool successful = int.TryParse ("123", <strong>out int result</strong>);
Console.WriteLine (result);</pre>
                                    <p>And when calling a method with multiple <code>out</code> parameters, you can
                                        <em>discard</em> ones you’re uninterested in with the underscore character:</p>
                                    <pre data-type="programlisting">SomeBigMethod (<strong>out _, out _, out _,</strong> out int x<strong>, out _, out _, out _</strong>);
Console.WriteLine (x);</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Type patterns and pattern variables" data-type="sect3">
                                <div class="sect3" id="type_patterns_and_pattern_variables">
                                    <h3>Type patterns and pattern variables</h3>
                                    <p>You can also introduce variables on the fly with the <code>is</code> operator.
                                        These are called <em>pattern variables</em> (see <a data-type="xref"
                                            href="ch03.html#introducing_a_pattern_variable">“Introducing a pattern
                                            variable”</a>):</p>
                                    <pre data-type="programlisting">void Foo (object x)
{
  if (x <strong>is string s</strong>)
    Console.WriteLine (<strong>s</strong>.Length);
}</pre>
                                    <p>The <code>switch</code> statement also supports type patterns, so you can switch
                                        on <em>type</em> as well as constants (see <a data-type="xref"
                                            href="ch02.html#switching_on_types">“Switching on types”</a>). You can
                                        specify conditions with a <code>when</code> clause and also switch on the
                                        <code>null</code> value:</p>
                                    <pre class="pagebreak-before" data-type="programlisting">switch (x)
{
  case <strong>int i</strong>:
    Console.WriteLine ("It's an int!");
    break;
  case <strong>string s</strong>:
    Console.WriteLine (<strong>s</strong>.Length);    // We can use the <strong>s</strong> variable
    break;
  case <strong>bool b when b == true</strong>:        // Matches only when b is true
    Console.WriteLine ("True");
    break;
  case <strong>null:</strong>
    Console.WriteLine ("Nothing");
    break;
}</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Local methods" data-type="sect3">
                                <div class="sect3" id="local_methods-id00026">
                                    <h3>Local methods</h3>
                                    <p>A <em>local method</em> is a method declared within another function (see <a
                                            data-type="xref" href="ch03.html#local_methods-id00077">“Local
                                            methods”</a>):</p>
                                    <pre data-type="programlisting">void WriteCubes()
{
  Console.WriteLine (Cube (3));
  Console.WriteLine (Cube (4));
  Console.WriteLine (Cube (5));

  <strong>int Cube (int value) =&gt; value * value * value;</strong>
}</pre>
                                    <p>Local methods are visible only to the containing function and can capture local
                                        variables in the same way that lambda expressions do.</p>
                                </div>
                            </section>
                            <section data-pdf-bookmark="More expression-bodied members" data-type="sect3">
                                <div class="sect3" id="more_expression_bodied_members">
                                    <h3>More expression-bodied members</h3>
                                    <p>C# 6 introduced the expression-bodied “fat-arrow” syntax for methods, read-only
                                        properties, operators, and indexers. C# 7 extends this to constructors,
                                        read/write properties, and finalizers:</p>
                                    <pre data-type="programlisting">public class Person
{
  string name;

  <strong>public Person (string name) =&gt; Name = name;</strong>

  public string Name
  {
    <strong>get =&gt; name;</strong>
    <strong>set =&gt; name = value ?? "";</strong>
  }

  <strong>~Person () =&gt; Console.WriteLine ("finalize");</strong>
}</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Deconstructors" data-type="sect3">
                                <div class="sect3" id="deconstructors-id00009">
                                    <h3>Deconstructors</h3>
                                    <p>C# 7 introduces the <em>deconstructor</em> pattern (see <a data-type="xref"
                                            href="ch03.html#deconstructors-id00060">“Deconstructors”</a>). Whereas a
                                        constructor typically takes a set of values (as parameters) and assigns them to
                                        fields, a <em>deconstructor</em> does the reverse and assigns fields back to a
                                        set of variables. We could write a deconstructor for the <code>Person</code>
                                        class in the preceding example as follows (exception handling aside):</p>
                                    <pre data-type="programlisting">public void <strong>Deconstruct</strong> (out string firstName, out string lastName)
{
  int spacePos = name.IndexOf (' ');
  firstName = name.Substring (0, spacePos);
  lastName = name.Substring (spacePos + 1);
}</pre>
                                    <p>Deconstructors are called with the following special syntax:</p>
                                    <pre data-type="programlisting">var joe = new Person ("Joe Bloggs");
<strong>var (first, last) = joe;          // Deconstruction</strong>
Console.WriteLine (first);        // Joe
Console.WriteLine (last);         // Bloggs</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="Tuples" data-type="sect3">
                                <div class="sect3" id="tuples-id00048">
                                    <h3>Tuples</h3>
                                    <p>Perhaps the most notable improvement to C# 7 is explicit <em>tuple</em> support
                                        (see <a data-type="xref" href="ch04.html#tuples-id00099">“Tuples”</a>). Tuples
                                        provide a simple way to store a set of related values:</p>
                                    <pre data-type="programlisting">var bob = <strong>("Bob", 23)</strong>;
Console.WriteLine (bob.Item1);   // Bob
Console.WriteLine (bob.Item2);   // 23</pre>
                                    <p>C#’s new tuples are syntactic sugar for using the
                                        <code>System.ValueTuple&lt;…&gt;</code> generic structs. But thanks to compiler
                                        magic, tuple elements can be named:</p>
                                    <pre data-type="programlisting">var tuple = (<strong>name:</strong>"Bob", <strong>age:</strong>23);
Console.WriteLine (tuple.<strong>name</strong>);     // Bob
Console.WriteLine (tuple.<strong>age</strong>);      // 23</pre>
                                    <p>With tuples, functions can return multiple values without resorting to
                                        <code>out</code> parameters or extra type baggage:</p>
                                    <pre data-type="programlisting">static <strong>(int row, int column)</strong> GetFilePosition() =&gt; <strong>(3, 10)</strong>;

static void Main()
{
  var pos = GetFilePosition();
  Console.WriteLine (pos<strong>.row</strong>);      // 3
  Console.WriteLine (pos<strong>.column</strong>);   // 10
}</pre>
                                    <p>Tuples implicitly support the deconstruction pattern, so you can easily
                                        <em>deconstruct</em> them into individual variables:</p>
                                    <pre class="pagebreak-before" data-type="programlisting">static void Main()
{
  <strong>(int row, int column)</strong> = GetFilePosition();   // Creates 2 local variables
  Console.WriteLine (row);      // 3 
  Console.WriteLine (column);   // 10
}</pre>
                                </div>
                            </section>
                            <section data-pdf-bookmark="throw expressions" data-type="sect3">
                                <div class="sect3" id="throw_expressions-id00045">
                                    <h3>throw expressions</h3>
                                    <p>Prior to C# 7, <code>throw</code> was always a statement. Now it can also appear
                                        as an expression in expression-bodied functions:</p>
                                    <pre
                                        data-type="programlisting">public string Foo() =&gt; <strong>throw new NotImplementedException()</strong>;</pre>
                                    <p>A <code>throw</code> expression can also appear in a ternary conditional
                                        expression:</p>
                                    <pre data-type="programlisting">string Capitalize (string value) =&gt;
  value == null ? <strong>throw new ArgumentException ("value")</strong> :
  value == "" ? "" :
  char.ToUpper (value[0]) + value.Substring (1);</pre>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 6.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_sixdotzero">
                            <h2>What’s New in C# 6.0</h2>
                            <p>C# 6.0, which shipped with <em>Visual Studio 2015</em>, features a new-generation
                                compiler, completely written in C#. Known as project “Roslyn,” the new compiler exposes
                                the entire compilation pipeline via libraries, allowing you to perform code analysis on
                                arbitrary source code. The compiler itself is open source, and the source code is
                                available at <a
                                    href="https://github.com/dotnet/roslyn"><em>https://github.com/dotnet/roslyn</em></a>.
                            </p>
                            <p>In addition, C# 6.0 features several minor but significant enhancements, aimed primarily
                                at reducing code clutter.</p>
                            <p>The <em>null-conditional</em> (“Elvis”) operator (see <a data-type="xref"
                                    href="ch02.html#null_operators">“Null Operators”</a>) avoids having to explicitly
                                check for null before calling a method or accessing a type member. In the following
                                example, <code>result</code> evaluates to null instead of throwing a
                                <code>NullReferenceException</code>:</p>
                            <pre data-type="programlisting">System.Text.StringBuilder sb = null;
string result = sb<strong>?.</strong>ToString();      // result is null</pre>
                            <p><em>Expression-bodied functions</em> (see <a data-type="xref"
                                    href="ch03.html#methods">“Methods”</a>) allow methods, properties, operators, and
                                indexers that comprise a single expression to be written more tersely, in the style of a
                                lambda expression:</p>
                            <pre data-type="programlisting">public int TimesTwo (int x) =&gt; x * 2;
public string SomeProperty =&gt; "Property value";</pre>
                            <p><em>Property initializers</em> (<a data-type="xref"
                                    href="ch03.html#creating_types_in_chash">Chapter 3</a>) let you assign an initial
                                value to an automatic property:</p>
                            <pre
                                data-type="programlisting">public DateTime TimeCreated { get; set; } = DateTime.Now;</pre>
                            <p>Initialized properties can also be read-only:</p>
                            <pre data-type="programlisting">public DateTime TimeCreated { get; } = DateTime.Now;</pre>
                            <p>Read-only properties can also be set in the constructor, making it easier to create
                                immutable (read-only) types.</p>
                            <p><em>Index initializers</em> (<a data-type="xref"
                                    href="ch04.html#advanced_chash">Chapter 4</a>) allow single-step initialization of
                                any type that exposes an indexer:</p>
                            <pre data-type="programlisting">var dict = new Dictionary&lt;int,string&gt;()
{
  [3] = "three",
  [10] = "ten"
};</pre>
                            <p><em>String interpolation</em> (see <a data-type="xref"
                                    href="ch02.html#string_type">“String Type”</a>) offers a succinct alternative to
                                <code>string.Format</code>:</p>
                            <pre
                                data-type="programlisting">string s = <strong>$</strong>"It is <strong>{</strong>DateTime.Now.DayOfWeek<strong>}</strong> today";</pre>
                            <p><em>Exception filters</em> (see <a data-type="xref"
                                    href="ch04.html#try_statements_and_exceptions">“try Statements and Exceptions”</a>)
                                let you apply a condition to a catch block:</p>
                            <pre data-type="programlisting">string html;
try
{
  html = await new HttpClient().GetStringAsync ("http://asef");
}
catch (WebException ex) <strong>when (ex.Status == WebExceptionStatus.Timeout)</strong>
{
  ...
}</pre>
                            <p>The <code>using static</code> (see <a data-type="xref"
                                    href="ch02.html#namespaces-id00029">“Namespaces”</a>) directive lets you import all
                                the static members of a type so that you can use those members unqualified:</p>
                            <pre data-type="programlisting"><strong>using static</strong> System.Console;
...
<strong>WriteLine</strong> ("Hello, world");  // WriteLine instead of Console.WriteLine</pre>
                            <p>The <code>nameof</code> (<a data-type="xref"
                                    href="ch03.html#creating_types_in_chash">Chapter 3</a>) operator returns the name of
                                a variable, type, or other symbol as a string. This avoids breaking code when you rename
                                a symbol in Visual Studio:</p>
                            <pre data-type="programlisting">int capacity = 123;
string x = nameof (capacity);   // x is "capacity"
string y = nameof (Uri.Host);   // y is "Host"</pre>
                            <p>And finally, you’re now allowed to <code>await</code> inside <code>catch</code> and
                                <code>finally</code> blocks.</p>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 5.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_fivedotzer">
                            <h2>What’s New in C# 5.0</h2>
                            <p>C# 5.0’s big new feature was support for <em>asynchronous functions</em> via two new
                                keywords, <code>async</code> and <code>await</code>. Asynchronous functions enable
                                <em>asynchronous continuations</em>, which make it easier to write responsive and
                                thread-safe rich-client applications. They also make it easy to write highly concurrent
                                and efficient I/O-bound applications that don’t tie up a thread resource per operation.
                                We cover asynchronous functions in detail in <a data-type="xref"
                                    href="ch14.html#concurrency_and_asynchron">Chapter 14</a>.</p>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 4.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_fourdotzer">
                            <h2>What’s New in C# 4.0</h2>
                            <p>C# 4.0 introduced four major enhancements:</p>
                            <p><em>Dynamic binding</em> (Chapters <a data-type="xref"
                                    data-xrefstyle="select:labelnumber" href="ch04.html#advanced_chash">4</a> and <a
                                    data-type="xref" data-xrefstyle="select:labelnumber"
                                    href="ch19.html#dynamic_programming">19</a>) defers <em>binding</em>—the process of
                                resolving types and members—from compile time to runtime and is useful in scenarios that
                                would otherwise require complicated reflection code. Dynamic binding is also useful when
                                interoperating with dynamic languages and COM components.</p>
                            <p><em>Optional parameters</em> (<a data-type="xref"
                                    href="ch02.html#chash_language_basics">Chapter 2</a>) allow functions to specify
                                default parameter values so that callers can omit arguments, and <em>named
                                    arguments</em> allow a function caller to identify an argument by name rather than
                                position.</p>
                            <p><em>Type variance</em> rules were relaxed in C# 4.0 (Chapters <a data-type="xref"
                                    data-xrefstyle="select:labelnumber" href="ch03.html#creating_types_in_chash">3</a>
                                and <a data-type="xref" data-xrefstyle="select:labelnumber"
                                    href="ch04.html#advanced_chash">4</a>), such that type parameters in generic
                                interfaces and generic delegates can be marked as <em>covariant</em> or
                                <em>contravariant</em>, allowing more natural type conversions.</p>
                            <p><em>COM interoperability</em> (<a data-type="xref"
                                    href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>) was enhanced in C#
                                4.0 in three ways. First, arguments can be passed by reference without the
                                <code>ref</code> keyword (particularly useful in conjunction with optional parameters).
                                Second, assemblies that contain COM interop types can be <em>linked</em> rather than
                                <em>referenced</em>. Linked interop types support type equivalence, avoiding the need
                                for <em>Primary Interop Assemblies</em> and putting an end to versioning and deployment
                                headaches. Third, functions that return COM Variant types from linked interop types are
                                mapped to <code>dynamic</code> rather than <code>object</code>, eliminating the need for
                                casting.</p>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 3.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_threedotze">
                            <h2>What’s New in C# 3.0</h2>
                            <p>The features added to C# 3.0 were mostly centered on <em>Language-Integrated Query</em>
                                (LINQ) capabilities. LINQ enables queries to be written directly within a C# program and
                                checked <em>statically</em> for correctness, and query both local collections (such as
                                lists or XML documents) or remote data sources (such as a database). The C# 3.0 features
                                added to support LINQ comprised implicitly typed local variables, anonymous types,
                                object initializers, lambda expressions, extension methods, query expressions, and
                                expression trees.</p>
                            <p><em>Implicitly typed local variables</em> (<code>var</code> keyword, <a data-type="xref"
                                    href="ch02.html#chash_language_basics">Chapter 2</a>) let you omit the variable type
                                in a declaration statement, allowing the compiler to infer it. This reduces clutter as
                                well as allowing <em>anonymous types</em> (<a data-type="xref"
                                    href="ch04.html#advanced_chash">Chapter 4</a>), which are simple classes created on
                                the fly that are commonly used in the final output of LINQ queries. You can also
                                implicitly type arrays (<a data-type="xref"
                                    href="ch02.html#chash_language_basics">Chapter 2</a>).</p>
                            <p><em>Object initializers</em> (<a data-type="xref"
                                    href="ch03.html#creating_types_in_chash">Chapter 3</a>) simplify object construction
                                by allowing you to set properties inline after the constructor call. Object initializers
                                work with both named and anonymous types.</p>
                            <p><em>Lambda expressions</em> (<a data-type="xref"
                                    href="ch04.html#advanced_chash">Chapter 4</a>) are miniature functions created by
                                the compiler on the fly; they are particularly useful in “fluent” LINQ queries (<a
                                    data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>).</p>
                            <p><em>Extension methods</em> (<a data-type="xref"
                                    href="ch04.html#advanced_chash">Chapter 4</a>) extend an existing type with new
                                methods (without altering the type’s definition), making static methods feel like
                                instance methods. LINQ’s query operators are implemented as extension methods.</p>
                            <p><em>Query expressions</em> (<a data-type="xref"
                                    href="ch08.html#linq_queries">Chapter 8</a>) provide a higher-level syntax for
                                writing LINQ queries that can be substantially simpler when working with multiple
                                sequences or range variables.</p>
                            <p><em>Expression trees</em> (<a data-type="xref"
                                    href="ch08.html#linq_queries">Chapter 8</a>) are miniature code Document Object
                                Models (DOMs) that describe lambda expressions assigned to the special type
                                <code>Expression&lt;TDelegate&gt;</code>. Expression trees make it possible for LINQ
                                queries to execute remotely (e.g., on a database server) because they can be
                                introspected and translated at runtime (e.g., into an SQL statement).</p>
                            <p>C# 3.0 also added automatic properties and partial methods.</p>
                            <p><em>Automatic properties</em> (<a data-type="xref"
                                    href="ch03.html#creating_types_in_chash">Chapter 3</a>) cut the work in writing
                                properties that simply <code>get</code>/<code>set</code> a private backing field by
                                having the compiler do that work automatically. <em>Partial methods</em> (<a
                                    data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>) let an
                                autogenerated partial class provide customizable hooks for manual authoring that “melt
                                away” if unused.</p>
                        </div>
                    </section>
                    <section data-pdf-bookmark="What’s New in C# 2.0" data-type="sect2">
                        <div class="sect2" id="whatapostrophes_new_in_chash_twodotzero">
                            <h2>What’s New in C# 2.0</h2>
                            <p>The big new features in C# 2 were generics (<a data-type="xref"
                                    href="ch03.html#creating_types_in_chash">Chapter 3</a>), nullable value types (<a
                                    data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), iterators (<a
                                    data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), and anonymous
                                methods (the predecessor to lambda expressions). These features paved the way for the
                                introduction of LINQ in C# 3.</p>
                            <p>C# 2 also added support for partial classes, static classes, and a host of minor and
                                miscellaneous features such as the namespace alias qualifier, friend assemblies, and
                                fixed-size buffers.</p>
                            <p>The introduction of generics required a new CLR (CLR 2.0), because generics maintain full
                                type fidelity at runtime. <a contenteditable="false" data-primary=""
                                    data-startref="ch01.html100" data-type="indexterm" id="id1556" /><a
                                    contenteditable="false" data-primary=".NET Core" data-primary-sortas="NET Core"
                                    data-secondary="collections" data-see="collections" data-type="indexterm"
                                    id="id1557" /><a contenteditable="false"
                                    data-primary="&quot;Elvis&quot; (null-conditional) operator"
                                    data-primary-sortas="Elvis" data-see="null-conditional operator"
                                    data-type="indexterm" id="id1558" /><a contenteditable="false" data-primary="ALC"
                                    data-see="assembly load context" data-type="indexterm" id="id1559" /><a
                                    contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09"
                                    data-secondary="records" data-see="records" data-type="indexterm" id="id1560" /><a
                                    contenteditable="false" data-primary="classes" data-secondary="inheritance"
                                    data-see="inheritance" data-type="indexterm" id="id1561" /><a
                                    contenteditable="false" data-primary="Common Language Runtime" data-see="CLR"
                                    data-type="indexterm" id="id1562" /><a contenteditable="false"
                                    data-primary="Component Object Model" data-see="COM" data-type="indexterm"
                                    id="id1563" /><a contenteditable="false" data-primary="document object model"
                                    data-see="DOM" data-type="indexterm" id="id1564" /><a contenteditable="false"
                                    data-primary="Dynamic Link Library (DLL)" data-see="DLL" data-type="indexterm"
                                    id="id1565" /><a contenteditable="false" data-primary="encryption"
                                    data-see="cryptography and encryption" data-type="indexterm" id="id1566" /><a
                                    contenteditable="false" data-primary="Hypertext Transfer Protocol" data-see="HTTP"
                                    data-type="indexterm" id="id1567" /><a contenteditable="false"
                                    data-primary="initialization" data-secondary="lazy" data-see="lazy initialization"
                                    data-type="indexterm" id="id1568" /><a contenteditable="false"
                                    data-primary="intermediate language" data-see="IL" data-type="indexterm"
                                    id="id1569" /><a contenteditable="false"
                                    data-primary="Language-Integrated Query (LINQ)" data-see="LINQ entries"
                                    data-type="indexterm" id="id1570" /><a contenteditable="false"
                                    data-primary="lazy execution" data-see="deferred execution" data-type="indexterm"
                                    id="id1571" /><a contenteditable="false" data-primary="LINQ to XML"
                                    data-secondary="X-DOM" data-see="XML DOM" data-type="indexterm" id="id1572" /><a
                                    contenteditable="false" data-primary="locking" data-secondary="exclusive"
                                    data-see="exclusive locking" data-type="indexterm" id="id1573" /><a
                                    contenteditable="false" data-primary="locking" data-secondary="nonexclusive"
                                    data-see="nonexclusive locking" data-type="indexterm" id="id1574" /><a
                                    contenteditable="false" data-primary="multithreading"
                                    data-see="parallel programming" data-type="indexterm" id="id1575" /><a
                                    contenteditable="false" data-primary="overloading" data-secondary="operator"
                                    data-see="operator overloading" data-type="indexterm" id="id1576" /><a
                                    contenteditable="false" data-primary="Parallel LINQ" data-see="PLINQ"
                                    data-type="indexterm" id="id1577" /><a contenteditable="false"
                                    data-primary="parallel programming" data-secondary="PLINQ" data-see="PLINQ"
                                    data-type="indexterm" id="id1578" /><a contenteditable="false" data-primary="PFX"
                                    data-see="Parallel Framework" data-type="indexterm" id="id1579" /><a
                                    contenteditable="false" data-primary="security"
                                    data-see="cryptography and encryption" data-type="indexterm" id="id1580" /><a
                                    contenteditable="false" data-primary="Trace class"
                                    data-see="Debug and Trace classes" data-type="indexterm" id="id1581" /><a
                                    contenteditable="false" data-primary="Transmission and Control Protcol"
                                    data-see="TCP" data-type="indexterm" id="id1582" /><a contenteditable="false"
                                    data-primary="type system, C#" data-secondary="inheritance" data-see="inheritance"
                                    data-type="indexterm" id="id1583" /><a contenteditable="false"
                                    data-primary="Universal Windows Platform (UWP)" data-see="UWP" data-type="indexterm"
                                    id="id1584" /><a contenteditable="false" data-primary="wait handles"
                                    data-see="event wait handles" data-type="indexterm" id="id1585" /><a
                                    contenteditable="false" data-primary="X-DOM" data-see="XML DOM"
                                    data-type="indexterm" id="id1586" /></p>
                        </div>
                    </section>
                </div>
            </section>
        </div>
    </section>
</body>

</html>