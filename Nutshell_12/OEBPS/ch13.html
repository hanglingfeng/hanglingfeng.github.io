<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Diagnostics</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Diagnostics" data-pdf-bookmark="Chapter 13. Diagnostics" data-type="chapter" epub:type="chapter"><div class="chapter" id="diagnostic">
<h1><span class="label">Chapter 13. </span>Diagnostics</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-type="indexterm" id="ch13.html0"/>When things go wrong, it’s important that information is available to aid in diagnosing the problem. An Integrated Development Environment (IDE) or debugger can assist greatly to this effect—but it is usually available only during development. After an application ships, the application itself must gather and record diagnostic information. To meet this requirement, .NET provides a set of facilities to log diagnostic information, monitor application behavior, detect runtime errors, and integrate with debugging tools if available.</p>
<p>Some diagnostic tools and APIs are Windows specific because they rely on features of the Windows operating system. In an effort to prevent platform-specific APIs from cluttering the .NET BCL, Microsoft has shipped them in separate NuGet <span class="keep-together">packages</span> that you can optionally reference. There are more than a dozen Windows-specific packages, which you can reference all at once with the <em>Microsoft.Windows.Compatibility</em> “master” package.</p>
<p>The types in this chapter are defined primarily in the <code>System.Diagnostics</code> <span class="keep-together">namespace</span>.</p>
<section data-pdf-bookmark="Conditional Compilation" data-type="sect1"><div class="sect1" id="conditional_compilation">
<h1>Conditional Compilation</h1>
<p><a contenteditable="false" data-primary="conditional compilation" data-type="indexterm" id="ch13.html1"/><a contenteditable="false" data-primary="diagnostics" data-secondary="conditional compilation" data-type="indexterm" id="ch13.html2"/>You can conditionally compile any section of code in C# with <em>preprocessor directives</em>. <a contenteditable="false" data-primary="# (hash)" data-type="indexterm" id="id3570"/><a contenteditable="false" data-primary="hash (#)" data-type="indexterm" id="id3571"/>Preprocessor directives are special instructions to the compiler that begin with the <code>#</code> symbol (and, unlike other C# constructs, must appear on a line of their own). Logically, they execute before the main compilation takes place (although in practice, the compiler processes them during the lexical parsing phase). The preprocessor directives for conditional compilation are <code>#if</code>, <code>#else</code>, <code>#endif</code>, and <code>#elif</code>.</p>
<p><a contenteditable="false" data-primary="#if directive" data-primary-sortas="if directive" data-type="indexterm" id="id3572"/>The <code>#if</code> directive instructs the compiler to ignore a section of code unless a specified <em>symbol</em> has been defined. <a contenteditable="false" data-primary="#define directive" data-primary-sortas="define directive" data-type="indexterm" id="id3573"/><a contenteditable="false" data-primary="#endif directive" data-primary-sortas="endif directive" data-type="indexterm" id="id3574"/>You can define a symbol in source code by using the <code>#define</code> directive (in which case the symbol applies to just that file), or in the <em>.csproj</em> file by using a <code>&lt;DefineConstants&gt;</code> element (in which case the symbol applies to whole assembly):</p>
<pre data-type="programlisting"><strong>#define TESTMODE</strong>            // #define directives must be at top of file
                            // Symbol names are uppercase by convention.
using System;

class Program
{
  static void Main()
  {
<strong>#if TESTMODE</strong>
    Console.WriteLine ("in test mode!");     // OUTPUT: in test mode!
<strong>#endif</strong>
  }
}</pre>
<p>If we deleted the first line, the program would compile with the <code>Console.WriteLine</code> statement completely eliminated from the executable, as though it were commented out.</p>
<p><a contenteditable="false" data-primary="#elif directive" data-primary-sortas="elif directive" data-type="indexterm" id="id3575"/><a contenteditable="false" data-primary="#elif statement" data-primary-sortas="elif statement" data-type="indexterm" id="id3576"/><a contenteditable="false" data-primary="#else directive" data-primary-sortas="else directive" data-type="indexterm" id="id3577"/><a contenteditable="false" data-primary="#else statement" data-primary-sortas="else statement" data-type="indexterm" id="id3578"/>The <code>#else</code> statement is analogous to C#’s <code>else</code> statement, and <code>#elif</code> is equivalent to <code>#else</code> followed by <code>#if</code>. <a contenteditable="false" data-primary="! (logical negation operator)" data-type="indexterm" id="id3579"/><a contenteditable="false" data-primary="&amp;&amp; (conditional and operator)" data-type="indexterm" id="id3580"/><a contenteditable="false" data-primary="|| (conditional or operator)" data-type="indexterm" id="id3581"/><a contenteditable="false" data-primary="conditional and operator (&amp;&amp;)" data-type="indexterm" id="id3582"/><a contenteditable="false" data-primary="conditional or operator (||)" data-type="indexterm" id="id3583"/><a contenteditable="false" data-primary="logical negation operator (!)" data-type="indexterm" id="id3584"/>The <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code> operators perform <em>or</em>, <em>and</em>, and <em>not</em> <span class="keep-together">operations</span>:</p>
<pre data-type="programlisting">#if TESTMODE &amp;&amp; !PLAYMODE      // if TESTMODE and not PLAYMODE
  ...</pre>
<p>Keep in mind, however, that you’re not building an ordinary C# expression, and the symbols upon which you operate have absolutely no connection to <em>variables</em>—static or otherwise.</p>
<p>You can define symbols that apply to every file in an assembly by editing the <em>.csproj</em> file (or in Visual Studio, by going to the Build tab in the Project Properties window). The following defines two constants, <code>TESTMODE</code> and <code>PLAYMODE</code>:</p>
<pre data-type="programlisting">&lt;PropertyGroup&gt;
  &lt;DefineConstants&gt;<strong>TESTMODE;PLAYMODE</strong>&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;</pre>
<p><a contenteditable="false" data-primary="#undef directive" data-primary-sortas="undef directive" data-type="indexterm" id="id3585"/>If you’ve defined a symbol at the assembly level and then want to “undefine” it for a particular file, you can do so by using the <code>#undef</code> directive.</p>
<section data-pdf-bookmark="Conditional Compilation Versus Static Variable Flags" data-type="sect2"><div class="sect2" id="conditional_compilation_versus_static_v">
<h2>Conditional Compilation Versus Static Variable Flags</h2>
<p><a contenteditable="false" data-primary="conditional compilation" data-secondary="static variable flags versus" data-type="indexterm" id="id3586"/><a contenteditable="false" data-primary="static variable flags" data-type="indexterm" id="id3587"/>You could instead implement the preceding example with a simple static field:</p>
<pre data-type="programlisting">static internal bool TestMode = true;

static void Main()
{
  if (TestMode) Console.WriteLine ("in test mode!");
}</pre>
<p>This has the advantage of allowing runtime configuration. So, why choose conditional compilation? The reason is that conditional compilation can take you places variable flags cannot, such as the following:</p>
<ul>
<li><p>Conditionally including an attribute</p></li>
<li><p>Changing the declared type of variable</p></li>
<li><p>Switching between different namespaces or type aliases in a <code>using</code> directive; for example:</p>
 <pre data-type="programlisting">using TestType =
  #if V2
     MyCompany.Widgets.GadgetV2;
  #else
     MyCompany.Widgets.Gadget;
  #endif</pre>
</li>
</ul>

<p>You can even perform major refactoring under a conditional compilation directive, so you can instantly switch between old and new versions, and write libraries that can compile against multiple runtime versions, leveraging the latest features where available.</p>
<p>Another advantage of conditional compilation is that debugging code can refer to types in assemblies that are not included in deployment.</p>
</div></section>
<section data-pdf-bookmark="The Conditional Attribute" data-type="sect2"><div class="sect2" id="the_conditional_attribute">
<h2>The Conditional Attribute</h2>
<p><a contenteditable="false" data-primary="Conditional attribute" data-type="indexterm" id="ch13.html3"/><a contenteditable="false" data-primary="conditional compilation" data-secondary="Conditional attribute" data-type="indexterm" id="ch13.html4"/>The <code>Conditional</code> attribute instructs the compiler to ignore any calls to a particular class or method, if the specified symbol has not been defined.</p>
<p>To see how this is useful, suppose that you write a method for logging status information as follows:</p>
<pre data-type="programlisting">static void LogStatus (string msg)
{
  string logFilePath = ...
  System.IO.File.AppendAllText (logFilePath, msg + "\r\n");
}</pre>
<p>Now imagine that you want this to execute only if the <code>LOGGINGMODE</code> symbol is defined. The first solution is to wrap all calls to <code>LogStatus</code> around an <code>#if</code> directive:</p>
<pre data-type="programlisting"><strong>#if LOGGINGMODE</strong>
LogStatus ("Message Headers: " + GetMsgHeaders());
<strong>#endif</strong></pre>
<p>This gives an ideal result, but it is tedious. The second solution is to put the <code>#if</code> directive inside the <code>LogStatus</code> method. This, however, is problematic should <span class="keep-together"><code>LogStatus</code></span> be called as follows:</p>
<pre data-type="programlisting">LogStatus ("Message Headers: " + GetComplexMessageHeaders());</pre>
<p><code>GetComplexMessageHeaders</code> would always be called—which might incur a performance hit.</p>
<p>We can combine the functionality of the first solution with the convenience of the second by attaching the <code>Conditional</code> attribute (defined in <code>System.Diagnostics</code>) to the <code>LogStatus</code> method:</p>
<pre data-type="programlisting"><strong>[Conditional ("LOGGINGMODE")]</strong>
static void LogStatus (string msg)
{
  ...
}</pre>
<p>This instructs the compiler to treat calls to <code>LogStatus</code> as though they were wrapped in an <code>#if LOGGINGMODE</code> directive. If the symbol is not defined, any calls to <code>Log​Sta⁠tus</code> are eliminated entirely in compilation—including their argument evaluation expressions. (Hence any side-effecting expressions will be bypassed.) This works even if <code>LogStatus</code> and the caller are in different assemblies.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another benefit of <code>[Conditional]</code> is that the conditionality check is performed when the <em>caller</em> is compiled, rather than when the <em>called method</em> is compiled. This is beneficial because it allows you to write a library containing methods such as <code>LogStatus</code>—and build just one version of that library.</p>
</div>
<p>The <code>Conditional</code> attribute is ignored at runtime—it’s purely an instruction to the compiler.</p>
<section data-pdf-bookmark="Alternatives to the Conditional attribute" data-type="sect3"><div class="sect3" id="alternatives_to_the_conditional_attribu">
<h3>Alternatives to the Conditional attribute</h3>
<p>The <code>Conditional</code> attribute is useless if you need to dynamically enable or disable functionality at runtime: instead, you must use a variable-based approach. This leaves the question of how to elegantly circumvent the evaluation of arguments when calling conditional logging methods. A functional approach solves this<a contenteditable="false" data-primary="" data-startref="ch13.html4" data-type="indexterm" id="id3588"/><a contenteditable="false" data-primary="" data-startref="ch13.html3" data-type="indexterm" id="id3589"/>:<a contenteditable="false" data-primary="" data-startref="ch13.html2" data-type="indexterm" id="id3590"/><a contenteditable="false" data-primary="" data-startref="ch13.html1" data-type="indexterm" id="id3591"/></p>
<pre data-type="programlisting">using System;
using System.Linq;

class Program
{
  public static bool EnableLogging;

  static void LogStatus (Func&lt;string&gt; message)
  {
    string logFilePath = ...
    if (EnableLogging)
      System.IO.File.AppendAllText (logFilePath, message() + "\r\n");
  }
}</pre>
<p>A lambda expression lets you call this method without syntax bloat:</p>
<pre data-type="programlisting">LogStatus ( () =&gt; "Message Headers: " + GetComplexMessageHeaders() );</pre>
<p>If <code>EnableLogging</code> is <code>false</code>, <code>GetComplexMessageHeaders</code> is never evaluated.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Debug and Trace Classes" data-type="sect1"><div class="sect1" id="debug_and_trace_classes">
<h1>Debug and Trace Classes</h1>
<p><a contenteditable="false" data-primary="Debug and Trace classes" data-type="indexterm" id="ch13.html5"/><a contenteditable="false" data-primary="diagnostics" data-secondary="Debug and Trace classes" data-type="indexterm" id="ch13.html6"/><code>Debug</code> and <code>Trace</code> are static classes that provide basic logging and assertion capabilities. The two classes are very similar; the main differentiator is their intended use. The <code>Debug</code> class is intended for debug builds; the <code>Trace</code> class is intended for both debug and release builds. To this effect:</p>
<pre data-type="programlisting">All methods of the Debug class are defined with [Conditional("DEBUG")].
All methods of the Trace class are defined with [Conditional("TRACE")].</pre>
<p>This means that all calls that you make to <code>Debug</code> or <code>Trace</code> are eliminated by the compiler unless you define <code>DEBUG</code> or <code>TRACE</code> symbols. (Visual Studio provides checkboxes for defining these symbols in the Build tab of Project Properties, and enables the TRACE symbol by default with new projects.)</p>
<p>Both the <code>Debug</code> and <code>Trace</code> classes provide <code>Write</code>, <code>WriteLine</code>, and <code>WriteIf</code> methods. By default, these send messages to the debugger’s output window:</p>
<pre data-type="programlisting">Debug.Write     ("Data");
Debug.WriteLine (23 * 34);
int x = 5, y = 3;
Debug.WriteIf   (x &gt; y, "x is greater than y");</pre>
<p>The <code>Trace</code> class also provides the methods <code>TraceInformation</code>, <code>TraceWarning</code>, and <code>TraceError</code>. The difference in behavior between these and the <code>Write</code> methods depends on the active <code>TraceListener</code>s (we cover this in <a data-type="xref" href="#tracelistener">“TraceListener”</a>).</p>
<section data-pdf-bookmark="Fail and Assert" data-type="sect2"><div class="sect2" id="fail_and_assert">
<h2>Fail and Assert</h2>
<p><a contenteditable="false" data-primary="Assert method" data-type="indexterm" id="id3592"/><a contenteditable="false" data-primary="Debug and Trace classes" data-secondary="Fail and Assert methods" data-type="indexterm" id="id3593"/><a contenteditable="false" data-primary="Fail method" data-type="indexterm" id="id3594"/>The <code>Debug</code> and <code>Trace</code> classes both provide <code>Fail</code> and <code>Assert</code> methods. <code>Fail</code> sends the message to each <code>TraceListener</code> in the <code>Debug</code> or <code>Trace</code> class’s <code>Listeners</code> collection (see the following section), which by default writes the message to the debug output:</p>
<pre data-type="programlisting">Debug.Fail ("File data.txt does not exist!");</pre>
<p><code>Assert</code> simply calls <code>Fail</code> if the <code>bool</code> argument is <code>false</code>—this is called <em>making an assertion</em> and indicates a bug in the code if violated. Specifying a failure message is optional:</p>
<pre data-type="programlisting">Debug.Assert (File.Exists ("data.txt"), "File data.txt does not exist!");
var result = ...
Debug.Assert (result != null);</pre>
<p>The <code>Write</code>, <code>Fail</code>, and <code>Assert</code> methods are also overloaded to accept a <code>string</code> category in addition to the message, which can be useful in processing the output.</p>
<p>An alternative to assertion is to throw an exception if the opposite condition is true. This is a common practice when validating method arguments:</p>
<pre class="pagebreak-before" data-type="programlisting">public void ShowMessage (string message)
{
  if (message == null) throw new ArgumentNullException ("message");
  ...
}</pre>
<p>Such “assertions” are compiled unconditionally and are less flexible in that you can’t control the outcome of a failed assertion via <code>TraceListener</code>s. And technically, they’re not assertions. An assertion is something that, if violated, indicates a bug in the current method’s code. Throwing an exception based on argument validation indicates a bug in the <em>caller</em>’s code.</p>
</div></section>
<section data-pdf-bookmark="TraceListener" data-type="sect2"><div class="sect2" id="tracelistener">
<h2>TraceListener</h2>
<p><a contenteditable="false" data-primary="Debug and Trace classes" data-secondary="TraceListener" data-type="indexterm" id="id3595"/><a contenteditable="false" data-primary="TraceListener" data-type="indexterm" id="id3596"/>The <code>Trace</code> class has a static <code>Listeners</code> property that returns a collection of <code>TraceListener</code> instances. These are responsible for processing the content emitted by the <code>Write</code>, <code>Fail</code>, and <code>Trace</code> methods.</p>
<p><a contenteditable="false" data-primary="Listeners" data-type="indexterm" id="ch13.html7"/>By default, the <code>Listeners</code> collection of each includes a single listener (<code>Default​Tra⁠ceListener</code>). The default listener has two key features:</p>
<ul>
<li><p>When connected to a debugger such as Visual Studio, messages are written to the debug output window; otherwise, message content is ignored.</p></li>
<li><p>When the <code>Fail</code> method is called (or an assertion fails), the application is <span class="keep-together">terminated</span>.</p></li>
</ul>
<p>You can change this behavior by (optionally) removing the default listener and then adding one or more of your own. You can write trace listeners from scratch (by subclassing <code>TraceListener</code>) or use one of the predefined types:</p>
<ul>
<li><p><code>TextWriterTraceListener</code> writes to a <code>Stream</code> or <code>TextWriter</code> or appends to a file.</p></li>
<li><p><code>EventLogTraceListener</code> writes to the Windows event log (Windows only).</p></li>
<li><p><code>EventProviderTraceListener</code> writes to the Event Tracing for Windows (ETW) subsystem (cross-platform support).</p></li>
</ul>
<p><code>TextWriterTraceListener</code> is further subclassed to <code>ConsoleTraceListener</code>, <span class="keep-together"><code>DelimitedListTraceListener</code></span>, <code>XmlWriterTraceListener</code>, and <code>EventSchemaTraceListener</code>.</p>
<p>The following example clears <code>Trace</code>’s default listener and then adds three listeners—one that appends to a file, one that writes to the console, and one that writes to the Windows event log:</p>
<pre data-type="programlisting">// Clear the default listener:
Trace.Listeners.Clear();

// Add a writer that appends to the trace.txt file:
Trace.Listeners.Add (new TextWriterTraceListener ("trace.txt"));

// Obtain the Console's output stream, then add that as a listener:
System.IO.TextWriter tw = Console.Out;
Trace.Listeners.Add (new TextWriterTraceListener (tw));

// Set up a Windows Event log source and then create/add listener.
// CreateEventSource requires administrative elevation, so this would
// typically be done in application setup.
if (!EventLog.SourceExists ("DemoApp"))
  EventLog.CreateEventSource ("DemoApp", "Application");

Trace.Listeners.Add (new EventLogTraceListener ("DemoApp"));</pre>
<p>In the case of the Windows event log, messages that you write with the <code>Write</code>, <code>Fail</code>, or <code>Assert</code> method always display as “Information” messages in the Windows event viewer. Messages that you write via the <code>TraceWarning</code> and <code>TraceError</code> methods, however, show up as warnings or errors.</p>
<p><a contenteditable="false" data-primary="TraceFilter" data-type="indexterm" id="id3597"/><code>TraceListener</code> also has a <code>Filter</code> of type <code>TraceFilter</code> that you can set to control whether a message gets written to that listener. To do this, you either instantiate one of the predefined subclasses (<code>EventTypeFilter</code> or <code>SourceFilter</code>), or subclass <code>TraceFilter</code> and override the <code>ShouldTrace</code> method. You could use this to filter by category, for instance.</p>
<p><code>TraceListener</code> also defines <code>IndentLevel</code> and <code>IndentSize</code> properties for controlling indentation, and the <code>TraceOutputOptions</code> property for writing extra data:</p>
<pre data-type="programlisting">TextWriterTraceListener tl = new TextWriterTraceListener (Console.Out);
tl.TraceOutputOptions = TraceOptions.DateTime | TraceOptions.Callstack;</pre>
<p><code>TraceOutputOptions</code> are applied when using the <code>Trace</code> methods:</p>
<pre data-type="programlisting">Trace.TraceWarning ("Orange alert");

<em>DiagTest.vshost.exe Warning: 0 : Orange alert</em>
<em>     DateTime=2007-03-08T05:57:13.6250000Z</em>
<em>     Callstack=   at System.Environment.GetStackTrace(Exception e, Boolean</em>
<em>needFileInfo)</em>
<em>     at System.Environment.get_StackTrace()     at ...</em></pre>
</div></section>
<section data-pdf-bookmark="Flushing and Closing Listeners" data-type="sect2"><div class="sect2" id="flushing_and_closing_listeners">
<h2>Flushing and Closing Listeners</h2>
<p><a contenteditable="false" data-primary="Debug and Trace classes" data-secondary="flushing and closing listeners" data-type="indexterm" id="id3598"/>Some listeners, such as <code>TextWriterTraceListener</code>, ultimately write to a stream that is subject to caching. This has two implications:</p>
<ul>
<li><p>A message might not appear in the output stream or file immediately.</p></li>
<li><p>You must close—or at least flush—the listener before your application ends; otherwise, you lose what’s in the cache (up to 4 KB, by default, if you’re writing to a file).</p></li>
</ul>
<p>The <code>Trace</code> and <code>Debug</code> classes provide static <code>Close</code> and <code>Flush</code> methods that call <code>Close</code> or <code>Flush</code> on all listeners (which in turn calls <code>Close</code> or <code>Flush</code> on any underlying <span class="keep-together">writers</span> and streams). <code>Close</code> implicitly calls <code>Flush</code>, closes file handles, and prevents further data from being written.</p>
<p>As a general rule, call <code>Close</code> before an application ends, and call <code>Flush</code> anytime you want to ensure that current message data is written. This applies if you’re using stream- or file-based listeners.</p>
<p><code>Trace</code> and <code>Debug</code> also provide an <code>AutoFlush</code> property, which, if <code>true</code>, forces a <code>Flush</code> after every message.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s a good policy to set <code>AutoFlush</code> to <code>true</code> on <code>Debug</code> and <code>Trace</code> if you’re using any file- or stream-based listeners. Otherwise, if an unhandled exception or critical error occurs, the last 4 KB of diagnostic information can be lost<a contenteditable="false" data-primary="" data-startref="ch13.html7" data-type="indexterm" id="id3599"/>.<a contenteditable="false" data-primary="" data-startref="ch13.html6" data-type="indexterm" id="id3600"/><a contenteditable="false" data-primary="" data-startref="ch13.html5" data-type="indexterm" id="id3601"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Debugger Integration" data-type="sect1"><div class="sect1" id="debugger_integration">
<h1>Debugger Integration</h1>
<p><a contenteditable="false" data-primary="Debugger class" data-type="indexterm" id="id3602"/><a contenteditable="false" data-primary="diagnostics" data-secondary="debugger integration" data-type="indexterm" id="id3603"/>Sometimes, it’s useful for an application to interact with a debugger if one is available. During development, the debugger is usually your IDE (e.g., Visual Studio); in deployment, the debugger is more likely to be one of the lower-level debugging tools, such as WinDbg, Cordbg, or MDbg.</p>
<section data-pdf-bookmark="Attaching and Breaking" data-type="sect2"><div class="sect2" id="attaching_and_breaking">
<h2>Attaching and Breaking</h2>
<p><a contenteditable="false" data-primary="Debugger class" data-secondary="attaching and breaking" data-type="indexterm" id="id3604"/><a contenteditable="false" data-primary="System..." data-secondary="System.Diagnostics" data-type="indexterm" id="id3605"/>The static <code>Debugger</code> class in <code>System.Diagnostics</code> provides basic functions for interacting with a debugger—namely <code>Break</code>, <code>Launch</code>, <code>Log</code>, and <code>IsAttached</code>.</p>
<p>A debugger must first attach to an application in order to debug it. If you start an application from within an IDE, this happens automatically, unless you request otherwise (by choosing “Start without debugging”). Sometimes, though, it’s inconvenient or impossible to start an application in debug mode within the IDE. An example is a Windows Service application or (ironically) a Visual Studio designer. One solution is to start the application normally and then, in your IDE, choose Debug Process. This doesn’t allow you to set breakpoints early in the program’s execution, however.</p>
<p>The workaround is to call <code>Debugger.Break</code> from within your application. This method launches a debugger, attaches to it, and suspends execution at that point. (<code>Launch</code> does the same, but without suspending execution.) After it’s attached, you can log messages directly to the debugger’s output window with the <code>Log</code> method. You can verify whether you’re attached to a debugger by checking the <code>IsAttached</code> property.</p>
</div></section>
<section data-pdf-bookmark="Debugger Attributes" data-type="sect2"><div class="sect2" id="debugger_attributes">
<h2>Debugger Attributes</h2>
<p><a contenteditable="false" data-primary="Debugger class" data-secondary="attributes" data-type="indexterm" id="id3606"/><a contenteditable="false" data-primary="DebuggerHidden attribute" data-type="indexterm" id="id3607"/><a contenteditable="false" data-primary="DebuggerStepThrough attribute" data-type="indexterm" id="id3608"/>The <code>DebuggerStepThrough</code> and <code>DebuggerHidden</code> attributes provide suggestions to the debugger on how to handle single-stepping for a particular method, constructor, or class.</p>
<p><code>DebuggerStepThrough</code> requests that the debugger step through a function without any user interaction. This attribute is useful in automatically generated methods and in proxy methods that forward the real work to a method somewhere else. In the latter case, the debugger will still show the proxy method in the call stack if a breakpoint is set within the “real” method—unless you also add the <code>DebuggerHidden</code> attribute. You can combine these two attributes on proxies to help the user focus on debugging the application logic rather than the plumbing:</p>
<pre data-type="programlisting">[DebuggerStepThrough, DebuggerHidden]
void DoWorkProxy()
{
  // setup...
  DoWork();
  // teardown...
}

void DoWork() {...}   // Real method...</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Processes and Process Threads" data-type="sect1"><div class="sect1" id="processes_and_process_threads">
<h1>Processes and Process Threads</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="processes and process threads" data-type="indexterm" id="id3609"/><a contenteditable="false" data-primary="Process" data-type="indexterm" id="id3610"/>We described in the last section of <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a> how to use <code>Process.Start</code> to launch a new process. The <code>Process</code> class also allows you to query and interact with other processes running on the same or another computer. The <code>Process</code> class is part of .NET Standard 2.0, although its features are restricted for the UWP platform.</p>
<section data-pdf-bookmark="Examining Running Processes" data-type="sect2"><div class="sect2" id="examining_running_processes">
<h2>Examining Running Processes</h2>
<p><a contenteditable="false" data-primary="Process" data-secondary="examining running processes" data-type="indexterm" id="id3611"/>The <code>Process.GetProcess<em>XXX</em></code> methods retrieve a specific process by name or process ID, or all processes running on the current or nominated computer. This includes both managed and unmanaged processes. Each <code>Process</code> instance has a wealth of properties mapping statistics such as name, ID, priority, memory and processor utilization, window handles, and so on. The following sample enumerates all the running processes on the current computer:</p>
<pre data-type="programlisting">foreach (Process p in Process.GetProcesses())
using (p)
{
  Console.WriteLine (p.ProcessName);
  Console.WriteLine ("   PID:      " + p.Id);
  Console.WriteLine ("   Memory:   " + p.WorkingSet64);
  Console.WriteLine ("   Threads:  " + p.Threads.Count);
}</pre>
<p><code>Process.GetCurrentProcess</code> returns the current process.</p>
<p>You can terminate a process by calling its <code>Kill</code> method.</p>
</div></section>
<section data-pdf-bookmark="Examining Threads in a Process" data-type="sect2"><div class="sect2" id="examining_threads_in_a_process">
<h2>Examining Threads in a Process</h2>
<p><a contenteditable="false" data-primary="Process" data-secondary="examining threads in a process" data-type="indexterm" id="id3612"/><a contenteditable="false" data-primary="Process.Threads property" data-type="indexterm" id="id3613"/><a contenteditable="false" data-primary="threads" data-secondary="examining threads in a process" data-type="indexterm" id="id3614"/>You can also enumerate over the threads of other processes with the <code>Pro⁠cess​.Threads</code> property. The objects that you get, however, are not <code>System.Thread⁠ing​.Thread</code> objects; they’re <code>ProcessThread</code> objects and are intended for administrative rather than synchronization tasks. A <code>ProcessThread</code> object provides diagnostic information about the underlying thread and allows you to control some aspects of it, such as its priority and processor affinity:</p>
<pre data-type="programlisting">public void EnumerateThreads (Process p)
{
  foreach (ProcessThread pt in p.Threads)
  {
    Console.WriteLine (pt.Id);
    Console.WriteLine ("   State:    " + pt.ThreadState);
    Console.WriteLine ("   Priority: " + pt.PriorityLevel);
    Console.WriteLine ("   Started:  " + pt.StartTime);
    Console.WriteLine ("   CPU time: " + pt.TotalProcessorTime);
  }
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="StackTrace and StackFrame" data-type="sect1"><div class="sect1" id="stacktrace_and_stackframe">
<h1>StackTrace and StackFrame</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="StackTrace and StackFrame" data-type="indexterm" id="ch13.html8"/><a contenteditable="false" data-primary="StackFrame class" data-type="indexterm" id="ch13.html9"/><a contenteditable="false" data-primary="StackTrace class" data-type="indexterm" id="ch13.html10"/>The <code>StackTrace</code> and <code>StackFrame</code> classes provide a read-only view of an execution call stack. You can obtain stack traces for the current thread or an <code>Exception</code> object. Such information is useful mostly for diagnostic purposes, though you also can use it in programming (hacks). <code>StackTrace</code> represents a complete call stack; <code>StackFrame</code> represents a single method call within that stack.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you just need to know the name and line number of the calling method, caller info attributes can provide an easier and faster alternative. We cover this topic in <a data-type="xref" href="ch04.html#caller_info_attributes">“Caller Info Attributes”</a>.</p>
</div>
<p>If you instantiate a <code>StackTrace</code> object with no arguments—or with a <code>bool</code> argument—you get a snapshot of the current thread’s call stack. The <code>bool</code> argument, if <code>true</code>, instructs <code>StackTrace</code> to read the assembly <em>.pdb</em> (project debug) files if they are present, giving you access to filename, line number, and column offset data. Project debug files are generated when you compile with the <code>/debug</code> switch. (Visual Studio compiles with this switch unless you request otherwise via <em>Advanced Build Settings</em>.)</p>
<p>After you’ve obtained a <code>StackTrace</code>, you can examine a particular frame by calling <code>GetFrame</code>—or obtain the whole lot by using <code>GetFrames</code>:</p>
<pre data-type="programlisting">static void Main() { A (); }
static void A()    { B (); }
static void B()    { C (); }
static void C()
{
  StackTrace s = new StackTrace (true);

  Console.WriteLine ("Total frames:   " + s.FrameCount);
  Console.WriteLine ("Current method: " + s.GetFrame(0).GetMethod().Name);
  Console.WriteLine ("Calling method: " + s.GetFrame(1).GetMethod().Name);
  Console.WriteLine ("Entry method:   " + s.GetFrame
                                       (s.FrameCount-1).GetMethod().Name);
  Console.WriteLine ("Call Stack:");
  foreach (StackFrame f in s.GetFrames())
    Console.WriteLine (
      "  File: "   + f.GetFileName() +
      "  Line: "   + f.GetFileLineNumber() +
      "  Col: "    + f.GetFileColumnNumber() +
      "  Offset: " + f.GetILOffset() +
      "  Method: " + f.GetMethod().Name);
}</pre>
<p>Here’s the output:</p>
<pre data-type="programlisting">Total frames:   4
Current method: C
Calling method: B
Entry method: Main
Call stack:
  File: C:\Test\Program.cs  Line: 15  Col: 4  Offset: 7  Method: C
  File: C:\Test\Program.cs  Line: 12  Col: 22  Offset: 6  Method: B
  File: C:\Test\Program.cs  Line: 11  Col: 22  Offset: 6  Method: A
  File: C:\Test\Program.cs  Line: 10  Col: 25  Offset: 6  Method: Main</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Intermediate Language (IL) offset indicates the offset of the instruction that will execute <em>next</em>—not the instruction that’s currently executing. Peculiarly, though, the line and column number (if a <em>.pdb</em> file is present) usually indicate the actual execution point.</p>
<p>This happens because the CLR does its best to <em>infer</em> the actual execution point when calculating the line and column from the IL offset. The compiler emits IL in such a way as to make this possible—including inserting <code>nop</code> (no-operation) instructions into the IL stream.</p>
<p>Compiling with optimizations enabled, however, disables the insertion of <code>nop</code> instructions, and so the stack trace might show the line and column number of the next statement to execute. Obtaining a useful stack trace is further hampered by the fact that optimization can pull other tricks, including collapsing entire methods.</p>
</div>
<p>A shortcut to obtaining the essential information for an entire <code>StackTrace</code> is to call <code>ToString</code> on it. Here’s what the result looks like:</p>
<pre data-type="programlisting">   at DebugTest.Program.C() in C:\Test\Program.cs:line 16
   at DebugTest.Program.B() in C:\Test\Program.cs:line 12
   at DebugTest.Program.A() in C:\Test\Program.cs:line 11
   at DebugTest.Program.Main() in C:\Test\Program.cs:line 10</pre>
<p>You can also obtain the stack trace for an <code>Exception</code> object (showing what led up to the exception being thrown) by passing the <code>Exception</code> into <code>StackTrace</code>’s <span class="keep-together">constructor</span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Exception</code> already has a <code>StackTrace</code> property; however, this property returns a simple string—not a <code>StackTrace</code> object. A <code>StackTrace</code> object is far more useful in logging exceptions that occur after deployment—where no <em>.pdb</em> files are available—because you can log the <em>IL offset</em> in lieu of line and column numbers. With an IL offset and <em>ildasm</em>, you can pinpoint where within a method an error occurred.<a contenteditable="false" data-primary="" data-startref="ch13.html10" data-type="indexterm" id="id3615"/><a contenteditable="false" data-primary="" data-startref="ch13.html9" data-type="indexterm" id="id3616"/><a contenteditable="false" data-primary="" data-startref="ch13.html8" data-type="indexterm" id="id3617"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Windows Event Logs" data-type="sect1"><div class="sect1" id="windows_event_logs">
<h1>Windows Event Logs</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="Windows event logs" data-type="indexterm" id="ch13.html11"/><a contenteditable="false" data-primary="EventLog class" data-type="indexterm" id="ch13.html12"/><a contenteditable="false" data-primary="Windows event logs" data-type="indexterm" id="ch13.html13"/>The Win32 platform provides a centralized logging mechanism, in the form of the Windows event logs.</p>
<p>The <code>Debug</code> and <code>Trace</code> classes we used earlier write to a Windows event log if you register an <code>EventLogTraceListener</code>. With the <code>EventLog</code> class, however, you can write directly to a Windows event log without using <code>Trace</code> or <code>Debug</code>. You can also use this class to read and monitor event data.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Writing to the Windows event log makes sense in a Windows Service application, because if something goes wrong, you can’t pop up a user interface directing the user to some special file where diagnostic information has been written. Also, because it’s common practice for services to write to the Windows event log, this is the first place an administrator is likely to look if your service falls over.</p>
</div>
<p>There are three standard Windows event logs, identified by these names:</p>
<ul>
<li><p>Application</p></li>
<li><p>System</p></li>
<li><p>Security</p></li>
</ul>
<p>The Application log is where most applications normally write.</p>
<section data-pdf-bookmark="Writing to the Event Log" data-type="sect2"><div class="sect2" id="writing_to_the_event_log">
<h2>Writing to the Event Log</h2>
<p><a contenteditable="false" data-primary="Windows event logs" data-secondary="writing to" data-type="indexterm" id="id3618"/>To write to a Windows event log:</p>
<ol>
<li><p>Choose one of the three event logs (usually <em>Application</em>).</p></li>
<li><p>Decide on a <em>source name</em> and create it if necessary (create requires administrative permissions).</p></li>
<li><p>Call <code>EventLog.WriteEntry</code> with the log name, source name, and message data.</p></li>
</ol>
<p>The <em>source name</em> is an easily identifiable name for your application. You must register a source name before you use it—the <code>CreateEventSource</code> method performs this function. You can then call <code>WriteEntry</code>:</p>
<pre data-type="programlisting">const string SourceName = "MyCompany.WidgetServer";

// CreateEventSource requires administrative permissions, so this would
// typically be done in application setup.
if (!EventLog.SourceExists (SourceName))
  EventLog.CreateEventSource (SourceName, "Application");

EventLog.WriteEntry (SourceName,
  "Service started; using configuration file=...",
  EventLogEntryType.Information);</pre>
<p><code>EventLogEntryType</code> can be <code>Information</code>, <code>Warning</code>, <code>Error</code>, <code>SuccessAudit</code>, or <span class="keep-together"><code>FailureAudit</code></span>. Each displays with a different icon in the Windows event viewer. You can also optionally specify a category and event ID (each is a number of your own choosing) and provide optional binary data.</p>
<p><code>CreateEventSource</code> also allows you to specify a machine name: this is to write to another computer’s event log, if you have sufficient permissions.</p>
</div></section>
<section data-pdf-bookmark="Reading the Event Log" data-type="sect2"><div class="sect2" id="reading_the_event_log">
<h2>Reading the Event Log</h2>
<p><a contenteditable="false" data-primary="Windows event logs" data-secondary="reading" data-type="indexterm" id="id3619"/>To read an event log, instantiate the <code>EventLog</code> class with the name of the log that you want to access and optionally the name of another computer on which the log resides. Each log entry can then be read via the <code>Entries</code> collection property:</p>
<pre data-type="programlisting">EventLog log = new EventLog ("Application");

Console.WriteLine ("Total entries: " + log.Entries.Count);

EventLogEntry last = log.Entries [log.Entries.Count - 1];
Console.WriteLine ("Index:   " + last.Index);
Console.WriteLine ("Source:  " + last.Source);
Console.WriteLine ("Type:    " + last.EntryType);
Console.WriteLine ("Time:    " + last.TimeWritten);
Console.WriteLine ("Message: " + last.Message);</pre>
<p>You can enumerate over all logs for the current (or another) computer via the static method <code>EventLog.GetEventLogs</code> (this requires administrative privileges for full access):</p>
<pre data-type="programlisting">foreach (EventLog log in EventLog.GetEventLogs())
  Console.WriteLine (log.LogDisplayName);</pre>
<p>This normally prints, at a minimum, <em>Application</em>, <em>Security</em>, and <em>System</em>.</p>
</div></section>
<section data-pdf-bookmark="Monitoring the Event Log" data-type="sect2"><div class="sect2" id="monitoring_the_event_log">
<h2>Monitoring the Event Log</h2>
<p><a contenteditable="false" data-primary="Windows event logs" data-secondary="monitoring" data-type="indexterm" id="id3620"/>You can be alerted whenever an entry is written to a Windows event log, via the <code>EntryWritten</code> event. This works for event logs on the local computer, and it fires regardless of what application logged the event.</p>
<p class="pagebreak-before">To enable log monitoring:</p>
<ol>
<li><p>Instantiate an <code>EventLog</code> and set its <code>EnableRaisingEvents</code> property to <code>true</code>.</p></li>
<li><p>Handle the <code>EntryWritten</code> event.</p></li>
</ol>
<p>For example:<a contenteditable="false" data-primary="" data-startref="ch13.html13" data-type="indexterm" id="id3621"/><a contenteditable="false" data-primary="" data-startref="ch13.html12" data-type="indexterm" id="id3622"/><a contenteditable="false" data-primary="" data-startref="ch13.html11" data-type="indexterm" id="id3623"/></p>
<pre data-type="programlisting">using (var log = new EventLog ("Application"))
{
  log.EnableRaisingEvents = true;
  log.EntryWritten += DisplayEntry;
  Console.ReadLine();
}

void DisplayEntry (object sender, EntryWrittenEventArgs e)
{
  EventLogEntry entry = e.Entry;
  Console.WriteLine (entry.Message);
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Performance Counters" data-type="sect1"><div class="sect1" id="performance_counters">
<h1>Performance Counters</h1>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="performance counters" data-type="indexterm" id="ch13.html14"/><a contenteditable="false" data-primary="performance counters" data-type="indexterm" id="ch13.html15"/>Performance Counters are a Windows-only feature and require the <a contenteditable="false" data-primary="System..." data-secondary="System.Diagnostics.PerformanceCounter" data-type="indexterm" id="id3624"/>NuGet package <code>System.Diagnostics​.Per⁠formance​Counter</code>. If you’re targeting Linux or macOS, see <a data-type="xref" href="#cross_platform_diagnostics_tools">“Cross-Platform Diagnostic Tools”</a> for <span class="keep-together">alternatives</span>.</p>
</div>
<p>The logging mechanisms we’ve discussed to date are useful for capturing information for future analysis. However, to gain insight into the current state of an application (or the system as a whole), a more real-time approach is needed. The Win32 solution to this need is the performance-monitoring infrastructure, which consists of a set of performance counters that the system and applications expose, and the Microsoft Management Console (MMC) snap-ins used to monitor these counters in real time.</p>
<p>Performance counters are grouped into categories such as “System,” “Processor,” “.NET CLR Memory,” and so on. These categories are sometimes also referred to as “performance objects” by the graphical user interface (GUI) tools. Each category groups a related set of performance counters that monitor one aspect of the system or application. Examples of performance counters in the “.NET CLR Memory” category include “% Time in GC,” “# Bytes in All Heaps,” and “Allocated bytes/sec.”</p>
<p>Each category can optionally have one or more instances that can be monitored independently. For example, this is useful in the “% Processor Time” performance counter in the “Processor” category, which allows one to monitor CPU utilization. On a multiprocessor machine, this counter supports an instance for each CPU, allowing you to monitor the utilization of each CPU independently.</p>
<p>The following sections illustrate how to perform commonly needed tasks such as determining which counters are exposed, monitoring a counter, and creating your own counters to expose application status information.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Reading performance counters or categories might require administrator privileges on the local or target computer, depending on what is accessed.</p>
</div>
<section data-pdf-bookmark="Enumerating the Available Counters" data-type="sect2"><div class="sect2" id="enumerating_the_available_counters">
<h2>Enumerating the Available Counters</h2>
<p><a contenteditable="false" data-primary="performance counters" data-secondary="enumerating the available counters" data-type="indexterm" id="id3625"/>The following example enumerates over all of the available performance counters on the computer. For those that have instances, it enumerates the counters for each instance:</p>
<pre data-type="programlisting">PerformanceCounterCategory[] cats =
  PerformanceCounterCategory.GetCategories();

foreach (PerformanceCounterCategory cat in cats)
{
  Console.WriteLine ("Category: " + cat.CategoryName);

  string[] instances = cat.GetInstanceNames();
  if (instances.Length == 0)
  {
    foreach (PerformanceCounter ctr in cat.GetCounters())
      Console.WriteLine ("  Counter: " + ctr.CounterName);
  }
  else   // Dump counters with instances
  {
    foreach (string instance in instances)
    {
      Console.WriteLine ("  Instance: " + instance);
      if (cat.InstanceExists (instance))
        foreach (PerformanceCounter ctr in cat.GetCounters (instance))
          Console.WriteLine ("    Counter: " + ctr.CounterName);
    }
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The result is more than 10,000 lines long! It also takes a while to execute because <code>PerformanceCounter​Cate⁠gory.Instance​Exists</code> has an inefficient implementation. In a real system, you’d want to retrieve the more detailed information only on demand.</p>
</div>
<p>The next example uses LINQ to retrieve just .NET performance counters, writing the result to an XML file:</p>
<pre data-type="programlisting">var x =
  new XElement ("counters",
    from PerformanceCounterCategory cat in
         PerformanceCounterCategory.GetCategories()
    where cat.CategoryName.StartsWith (".NET")
    let instances = cat.GetInstanceNames()
    select new XElement ("category",
      new XAttribute ("name", cat.CategoryName),
      instances.Length == 0
      ?
        from c in cat.GetCounters()
        select new XElement ("counter",
          new XAttribute ("name", c.CounterName))
      :
        from i in instances
        select new XElement ("instance", new XAttribute ("name", i),
          !cat.InstanceExists (i)
          ?
            null
          :
            from c in cat.GetCounters (i)
            select new XElement ("counter",
              new XAttribute ("name", c.CounterName))
        )
    )
  );
x.Save ("counters.xml");</pre>
</div></section>
<section data-pdf-bookmark="Reading Performance Counter Data" data-type="sect2"><div class="sect2" id="reading_performance_counter_data">
<h2>Reading Performance Counter Data</h2>
<p><a contenteditable="false" data-primary="performance counters" data-secondary="reading data from" data-type="indexterm" id="id3626"/>To retrieve the value of a performance counter, instantiate a <code>PerformanceCounter</code> object and then call the <code>NextValue</code> or <code>NextSample</code> method. <code>NextValue</code> returns a simple <code>float</code> value; <code>NextSample</code> returns a <code>CounterSample</code> object that exposes a more advanced set of properties, such as <code>CounterFrequency</code>, <code>TimeStamp</code>, <code>BaseValue</code>, and <code>RawValue</code>.</p>
<p><code>PerformanceCounter</code>’s constructor takes a category name, counter name, and optional instance. So, to display the current processor utilization for all CPUs, you would do the following:</p>
<pre data-type="programlisting">using PerformanceCounter pc = new PerformanceCounter ("Processor",
                                                      "% Processor Time",
                                                      "_Total");
Console.WriteLine (pc.NextValue());</pre>
<p>Or to display the “real” (i.e., private) memory consumption of the current process:</p>
<pre data-type="programlisting">string procName = Process.GetCurrentProcess().ProcessName;
using PerformanceCounter pc = new PerformanceCounter ("Process",
                                                      "Private Bytes",
                                                      procName);
Console.WriteLine (pc.NextValue());</pre>
<p><code>PerformanceCounter</code> doesn’t expose a <code>ValueChanged</code> event, so if you want to monitor for changes, you must poll. In the next example, we poll every 200 ms—until signaled to quit by an <code>EventWaitHandle</code>:</p>
<pre data-type="programlisting">// need to import System.Threading as well as System.Diagnostics

static void Monitor (string category, string counter, string instance,
                     EventWaitHandle stopper)
{
  if (!PerformanceCounterCategory.Exists (category))
    throw new InvalidOperationException ("Category does not exist");

  if (!PerformanceCounterCategory.CounterExists (counter, category))
    throw new InvalidOperationException ("Counter does not exist");

  if (instance == null) instance = "";   // "" == no instance (not null!)
  if (instance != "" &amp;&amp;
      !PerformanceCounterCategory.InstanceExists (instance, category))
    throw new InvalidOperationException ("Instance does not exist");

  float lastValue = 0f;
  using (PerformanceCounter pc = new PerformanceCounter (category,
                                                      counter, instance))
    while (!stopper.WaitOne (200, false))
    {
      float value = pc.NextValue();
      if (value != lastValue)         // Only write out the value
      {                               // if it has changed.
        Console.WriteLine (value);
        lastValue = value;
      }
    }
}</pre>
<p>Here’s how we can use this method to simultaneously monitor processor and hard-drive activity:</p>
<pre data-type="programlisting">EventWaitHandle stopper = new ManualResetEvent (false);

new Thread (() =&gt;
  Monitor ("Processor", "% Processor Time", "_Total", stopper)
).Start();

new Thread (() =&gt;
  Monitor ("LogicalDisk", "% Idle Time", "C:", stopper)
).Start();

Console.WriteLine ("Monitoring - press any key to quit");
Console.ReadKey();
stopper.Set();</pre>
</div></section>
<section data-pdf-bookmark="Creating Counters and Writing Performance Data" data-type="sect2"><div class="sect2" id="creating_counters_and_writing_performan">
<h2>Creating Counters and Writing Performance Data</h2>
<p><a contenteditable="false" data-primary="performance counters" data-secondary="creating counters and writing performance data" data-type="indexterm" id="id3627"/>Before writing performance counter data, you need to create a performance category and counter. You must create the performance category along with all the counters that belong to it in one step, as follows:</p>
<pre data-type="programlisting">string category = "Nutshell Monitoring";

// We'll create two counters in this category:
string eatenPerMin = "Macadamias eaten so far";
string tooHard = "Macadamias deemed too hard";

if (!PerformanceCounterCategory.Exists (category))
{
  CounterCreationDataCollection cd = new CounterCreationDataCollection();

  cd.Add (new CounterCreationData (eatenPerMin,
          "Number of macadamias consumed, including shelling time",
          PerformanceCounterType.NumberOfItems32));

  cd.Add (new CounterCreationData (tooHard,
          "Number of macadamias that will not crack, despite much effort",
          PerformanceCounterType.NumberOfItems32));

  PerformanceCounterCategory.Create (category, "Test Category",
    PerformanceCounterCategoryType.SingleInstance, cd);
}</pre>
<p>The new counters then show up in the Windows performance-monitoring tool when you choose Add Counters. If you later want to define more counters in the same category, you must first delete the old category by calling <code>Performance​Coun⁠terCategory.Delete</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Creating and deleting performance counters requires administrative privileges. For this reason, it’s usually done as part of the application setup.</p>
</div>
<p>After you create a counter, you can update its value by instantiating a <code>PerformanceCounter</code>, setting <code>ReadOnly</code> to <code>false</code>, and setting <code>RawValue</code>. You can also use the <code>Increment</code> and <code>IncrementBy</code> methods to update the existing value:<a contenteditable="false" data-primary="" data-startref="ch13.html15" data-type="indexterm" id="id3628"/><a contenteditable="false" data-primary="" data-startref="ch13.html14" data-type="indexterm" id="id3629"/></p>
<pre data-type="programlisting">string category = "Nutshell Monitoring";
string eatenPerMin = "Macadamias eaten so far";

using (PerformanceCounter pc = new PerformanceCounter (category,
                                                       eatenPerMin, ""))
{
  pc.ReadOnly = false;
  pc.RawValue = 1000;
  pc.Increment();
  pc.IncrementBy (10);
  Console.WriteLine (pc.NextValue());    // 1011
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="The Stopwatch Class" data-type="sect1"><div class="sect1" id="the_stopwatch_class">
<h1>The Stopwatch Class</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="Stopwatch class" data-type="indexterm" id="id3630"/><a contenteditable="false" data-primary="Stopwatch class" data-type="indexterm" id="id3631"/>The <code>Stopwatch</code> class provides a convenient mechanism for measuring execution times. <code>Stopwatch</code> uses the highest-resolution mechanism that the OS and hardware provide, which is typically less than a microsecond. (In contrast, <code>DateTime.Now</code> and <code>Environment.TickCount</code> have a resolution of about 15 ms.)</p>
<p class="pagebreak-before">To use <code>Stopwatch</code>, call <code>StartNew</code>—this instantiates a <code>Stopwatch</code> and starts it ticking. (Alternatively, you can instantiate it manually and then call <code>Start</code>.) The <code>Elapsed</code> property returns the elapsed interval as a <code>TimeSpan</code>:</p>
<pre data-type="programlisting">Stopwatch s = Stopwatch.StartNew();
System.IO.File.WriteAllText ("test.txt", new string ('*', 30000000));
Console.WriteLine (s.Elapsed);       // 00:00:01.4322661</pre>
<p><code>Stopwatch</code> also exposes an <code>ElapsedTicks</code> property, which returns the number of elapsed “ticks” as a <code>long</code>. To convert from ticks to seconds, divide by <code>StopWatch​.Fre⁠quency</code>. There’s also an <code>ElapsedMilliseconds</code> property, which is often the most convenient.</p>
<p>Calling <code>Stop</code> freezes <code>Elapsed</code> and <code>ElapsedTicks</code>. There’s no background activity incurred by a “running” <code>Stopwatch</code>, so calling <code>Stop</code> is optional.</p>
</div></section>
<section data-pdf-bookmark="Cross-Platform Diagnostic Tools" data-type="sect1"><div class="sect1" id="cross_platform_diagnostics_tools">
<h1>Cross-Platform Diagnostic Tools</h1>
<p><a contenteditable="false" data-primary="diagnostics" data-secondary="cross-platform tools" data-type="indexterm" id="id3632"/>In this section, we briefly describe the cross-platform diagnostic tools available to .NET:</p>
<dl>
<dt>dotnet-counters</dt>
<dd>Provides an overview of the state of a running application</dd>
<dt>dotnet-trace</dt>
<dd>For more detailed performance and event monitoring</dd>
<dt>dotnet-dump</dt>
<dd>To obtain a memory dump on demand or after a crash</dd>
</dl>
<p>These tools do not require administrative elevation and are suitable for both development and production environments.</p>
<section data-pdf-bookmark="dotnet-counters" data-type="sect2"><div class="sect2" id="dotnet_counters">
<h2>dotnet-counters</h2>
<p><a contenteditable="false" data-primary="dotnet-counters tool" data-type="indexterm" id="id3633"/>The <em>dotnet-counters</em> tool monitors the memory and CPU usage of a .NET process and writes the data to the console (or a file).</p>
<p>To install the tool, run the following from a command prompt or terminal with <span class="keep-together"><em>dotnet</em></span> in the path:</p>
<pre data-type="programlisting">dotnet tool install --global dotnet-counters</pre>
<p>You can then start monitoring a process, as follows:</p>
<pre data-type="programlisting">dotnet-counters monitor System.Runtime --process-id <em>&lt;&lt;ProcessID&gt;&gt;</em></pre>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Runtime" data-type="indexterm" id="id3634"/><code>System.Runtime</code> means that we want to monitor all counters under the <em>System.Runtime</em> category. You can specify either a category or counter name (the <code>dotnet-counters list</code> command lists all available categories and counters).</p>
<p class="pagebreak-before">The output is continually refreshed and looks like this:</p>
<pre data-type="programlisting">Press p to pause, r to resume, q to quit.
    Status: Running

[System.Runtime]
    # of Assemblies Loaded                            63
    % Time in GC (since last GC)                       0
    Allocation Rate (Bytes / sec)                244,864
    CPU Usage (%)                                      6
    Exceptions / sec                                   0
    GC Heap Size (MB)                                  8
    Gen 0 GC / sec                                     0
    Gen 0 Size (B)                               265,176
    Gen 1 GC / sec                                     0
    Gen 1 Size (B)                               451,552
    Gen 2 GC / sec                                     0
    Gen 2 Size (B)                                    24
    LOH Size (B)                               3,200,296
    Monitor Lock Contention Count / sec                0
    Number of Active Timers                            0
    ThreadPool Completed Work Items / sec             15
    ThreadPool Queue Length                            0
    ThreadPool Threads Count                           9
    Working Set (MB)                                  52</pre>
<p>Here are all available commands:</p>
<table class="border">
<thead>
<tr>
<th>Commands</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>list</code></td>
<td>Displays a list of counter names along with a description of each</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>Displays a list of dotnet processes eligible for monitoring</td>
</tr>
<tr>
<td><code>monitor</code></td>
<td>Displays values of selected counters (periodically refreshed)</td>
</tr>
<tr>
<td><code>collect</code></td>
<td>Saves counter information to a file</td>
</tr>
</tbody>
</table>
<p>The following parameters are supported:</p>
<table class="border">
<thead>
<tr>
<th>Options/arguments</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--version</code></td>
<td>Displays the version of <em>dotnet-counters</em>.</td>
</tr>
<tr>
<td><code>-h, --help</code></td>
<td>Displays help about the program.</td>
</tr>
<tr>
<td><code>-p, --process-id</code></td>
<td>ID of dotnet process to monitor. Applies to the <code>monitor</code> and <code>collect</code> commands.</td>
</tr>
<tr>
<td><code>--refresh-interval</code></td>
<td>Sets the desired refresh interval in seconds. Applies to the <code>monitor</code> and <code>collect</code> commands.</td>
</tr>
<tr>
<td><code>-o, --output</code></td>
<td>Sets the output file name. Applies to the <code>collect</code> command.</td>
</tr>
<tr>
<td><code>--format</code></td>
<td>Sets the output format. Valid are <em>csv</em> or <em>json</em>. Applies to the <code>collect</code> command.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="dotnet-trace" data-type="sect2"><div class="sect2" id="dotnet_trace">
<h2>dotnet-trace</h2>
<p><a contenteditable="false" data-primary="dotnet-trace tool" data-type="indexterm" id="id3635"/><a contenteditable="false" data-primary="traces" data-type="indexterm" id="id3636"/>Traces are timestamped records of events in your program, such as a method being called or a database being queried. Traces can also include performance metrics and custom events, and can contain local context such as the value of local variables. Traditionally, .NET Framework and frameworks such as ASP.NET used ETW. In .NET 5, application traces are written to ETW when running on Windows and LTTng on Linux.</p>
<p>To install the tool, run the following command:</p>
<pre data-type="programlisting">dotnet tool install --global dotnet-trace</pre>
<p>To start recording a program’s events, run the following command:</p>
<pre data-type="programlisting">dotnet-trace collect --process-id <em>&lt;&lt;ProcessId&gt;&gt;</em></pre>
<p>This runs <em>dotnet-trace</em> with the default profile, which collects CPU and .NET runtime events and writes to a file called <em>trace.nettrace</em>. You can specify other profiles with the <code>--profile</code> switch: <em>gc-verbose</em> tracks garbage collection and sampled object allocation, and <em>gc-collect</em> tracks garbage collection with a low overhead. The <code>-o</code> switch lets you specify a different output filename.</p>
<p>The default output is a <em>.netperf</em> file, which can be analyzed directly on a Windows machine with the PerfView tool. Alternatively, you can instruct <em>dotnet-trace</em> to create a file compatible with Speedscope, which is a free online analysis service at <a href="https://speedscope.app"><em>https://speedscope.app</em></a>. To create a Speedscope (<em>.speedscope.json</em>) file, use the option <code>--format speedscope</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can download the latest version of PerfView from <a href="https://github.com/microsoft/perfview"><em>https://github.com/microsoft/perfview</em></a>. The version that ships with Windows 10 might not support <em>.netperf</em> files.</p>
</div>
<p>The following commands are supported:</p>
<table class="border">
<thead>
<tr>
<th>Commands</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>collect</code></td>
<td>Starts recording counter information to a file.</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>Displays a list of dotnet processes eligible for monitoring.</td>
</tr>
<tr>
<td><code>list-profiles</code></td>
<td>Lists prebuilt tracing profiles with a description of providers and filters in each.</td>
</tr>
<tr>
<td><code>convert &lt;file&gt;</code></td>
<td>Converts from the <em>nettrace</em> (<em>.netperf</em>) format to an alternative format. Currently, <em>speedscope</em> is the only target option.</td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Custom trace events" data-type="sect3"><div class="sect3" id="custom_trace_events">
<h3>Custom trace events</h3>
<p>Your app can emit custom events by defining a custom <code>EventSource</code>:</p>
<pre data-type="programlisting">[EventSource (Name = "<strong>MyTestSource</strong>")]
public sealed class MyEventSource : EventSource
{
  public static MyEventSource Instance = new MyEventSource ();

  MyEventSource() : base (EventSourceSettings.EtwSelfDescribingEventFormat)
  {
  }

  public void Log (string message, int someNumber)
  {
    WriteEvent (1, message, someNumber);
  }
}</pre>
<p>The <code>WriteEvent</code> method is overloaded to accept various combinations of simple types (primarily strings and integers). You can then call it as follows:</p>
<pre data-type="programlisting">MyEventSource.Instance.Log ("Something", 123);</pre>
<p>When calling <em>dotnet-trace</em>, you must specify the name(s) of any custom event sources that want to record:</p>
<pre data-type="programlisting">dotnet-trace collect --process-id <em>&lt;&lt;ProcessId&gt;&gt;</em> <strong>--providers MyTestSource</strong></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="dotnet-dump" data-type="sect2"><div class="sect2" id="dotnet_dump">
<h2>dotnet-dump</h2>
<p><a contenteditable="false" data-primary="core dump" data-type="indexterm" id="id3637"/><a contenteditable="false" data-primary="dotnet-dump tool" data-type="indexterm" id="id3638"/><a contenteditable="false" data-primary="dump" data-type="indexterm" id="id3639"/>A <em>dump</em>, sometimes called a <em>core dump</em>, is a snapshot of the state of a process’s virtual memory. You can dump a running process on demand, or configure the OS to generate a dump when an application crashes.</p>
<p>On Ubuntu Linux, the following command enables a core dump upon application crash (the necessary steps can vary between different flavors of Linux):</p>
<pre data-type="programlisting">ulimit -c unlimited</pre>
<p>On Windows, use <em>regedit.exe</em> to create or edit the following key in the local machine hive:</p>
<pre data-type="programlisting">SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps</pre>
<p>Under that, add a key with the same name as your executable (e.g., <em>foo.exe</em>), and under that key, add the following keys:</p>
<ul>
<li><p><code>DumpFolder</code> (REG_EXPAND_SZ), with a value indicating the path to which you want dump files written</p></li>
<li><p><code>DumpType</code> (REG_DWORD), with a value of 2 to request a full dump</p></li>
<li><p>(Optionally) <code>DumpCount</code> (REG_DWORD), indicating the maximum number of dump files before the oldest is removed</p></li>
</ul>
<p>To install the tool, run the following command:</p>
<pre data-type="programlisting">dotnet tool install --global dotnet-dump</pre>
<p>After you’ve installed it, you can initiate a dump on demand (without ending the process), as follows:</p>
<pre data-type="programlisting">dotnet-dump collect --process-id <em>&lt;&lt;YourProcessId&gt;&gt;</em></pre>
<p>The following command starts an interactive shell for analyzing a dump file:</p>
<pre data-type="programlisting">dotnet-dump analyze <em>&lt;&lt;dumpfile&gt;&gt;</em></pre>
<p>If an exception took down the application, you can use the <em>printexceptions</em> command (<em>pe</em> for short) to display details of that exception. The dotnet-dump shell supports numerous additional commands, which you can list with the <em>help</em> command.<a contenteditable="false" data-primary="" data-startref="ch13.html0" data-type="indexterm" id="id3640"/></p>
</div></section>
</div></section>
</div></section></body></html>