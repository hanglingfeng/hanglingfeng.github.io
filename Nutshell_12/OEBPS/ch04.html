<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Advanced C#</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Advanced C#" data-pdf-bookmark="Chapter 4. Advanced C#" data-type="chapter" epub:type="chapter"><div class="chapter" id="advanced_chash">
<h1><span class="label">Chapter 4. </span>Advanced C#</h1>
<p>In this chapter, we cover advanced C# topics that build on concepts explored in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#chash_language_basics">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#creating_types_in_chash">3</a>. You should read the first four sections sequentially; you can read the remaining sections in any order.</p>
<section data-pdf-bookmark="Delegates" data-type="sect1"><div class="sect1" id="delegates">
<h1>Delegates</h1>
<p><a contenteditable="false" data-primary="delegates" data-type="indexterm" id="ch04.html100"/>A delegate is an object that knows how to call a method.</p>
<p><a contenteditable="false" data-primary="delegate type" data-type="indexterm" id="id2273"/>A <em>delegate type</em> defines the kind of method that <em>delegate instances</em> can call. Specifically, it defines the method’s <em>return type</em> and its <em>parameter types</em>. The following defines a delegate type called <code>Transformer</code>:</p>
<pre data-type="programlisting">delegate int Transformer (int x);</pre>
<p><code>Transformer</code> is compatible with any method with an <code>int</code> return type and a single <code>int</code> parameter, such as this:</p>
<pre data-type="programlisting">int Square (int x) { return x * x; }</pre>
<p>Or, more tersely:</p>
<pre data-type="programlisting">int Square (int x) =&gt; x * x;</pre>
<p>Assigning a method to a delegate variable creates a delegate <em>instance</em>:</p>
<pre data-type="programlisting">Transformer t = Square;</pre>
<p>You can invoke a delegate instance in the same way as a method:</p>
<pre data-type="programlisting">int answer = t(3);    // answer is 9</pre>
<p>Here’s a complete example:</p>
<pre data-type="programlisting"><strong>Transformer t = Square;</strong>          // Create delegate instance
int result = <strong>t(3);</strong>               // Invoke delegate
Console.WriteLine (result);      // 9

int Square (int x) =&gt; x * x;

<strong>delegate int Transformer (int x)</strong>;   // Delegate type declaration</pre>
<p>A delegate instance literally acts as a delegate for the caller: the caller invokes the delegate, and then the delegate calls the target method. This indirection decouples the caller from the target method.</p>
<p>The statement:</p>
<pre data-type="programlisting">Transformer t = Square;</pre>
<p>is shorthand for:</p>
<pre data-type="programlisting">Transformer t = new Transformer (Square);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="method group" data-type="indexterm" id="id2274"/>Technically, we are specifying a <em>method group</em> when we refer to <code>Square</code> without brackets or arguments. If the method is overloaded, C# will pick the correct overload based on the signature of the delegate to which it’s being assigned.</p>
</div>
<p>The expression</p>
<pre data-type="programlisting">t(3)</pre>
<p>is shorthand for</p>
<pre data-type="programlisting">t.Invoke(3)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A delegate is similar to a <em>callback</em>, a general term that captures constructs such as C function pointers.</p>
</div>
<section data-pdf-bookmark="Writing Plug-in Methods with Delegates" data-type="sect2"><div class="sect2" id="writing_plug_in_methods_with_delegates">
<h2>Writing Plug-in Methods with Delegates</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="writing plug-in methods with" data-type="indexterm" id="id2275"/><a contenteditable="false" data-primary="plug-in methods, writing with delegates" data-type="indexterm" id="id2276"/>A delegate variable is assigned a method at runtime. This is useful for writing plug-in methods. In this example, we have a utility method named <code>Transform</code> that applies a transform to each element in an integer array. The <code>Transform</code> method has a delegate parameter, which you can use for specifying a plug-in transform:</p>
<pre data-type="programlisting">int[] values = { 1, 2, 3 };
Transform (values, <strong>Square</strong>);      // Hook in the Square method

foreach (int i in values)
  Console.Write (i + "  ");      // 1   4   9

void Transform (int[] values, <strong>Transformer t</strong>)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = t (values[i]);
}

int Square (int x) =&gt; x * x;
int Cube (int x) =&gt; x * x * x;

delegate int Transformer (int x);</pre>
<p>We can change the transformation just by changing <code>Square</code> to <code>Cube</code> in the second line of code.</p>
<p>Our <code>Transform</code> method is a <em>higher-order function</em> because it’s a function that takes a function as an argument. (A method that <em>returns</em> a delegate would also be a higher-order function.)</p>
</div></section>
<section data-pdf-bookmark="Instance and Static Method Targets" data-type="sect2"><div class="sect2" id="instance_and_static_method_targets">
<h2>Instance and Static Method Targets</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="instance/static method targets" data-type="indexterm" id="id2277"/><a contenteditable="false" data-primary="instance methods" data-secondary="delegates and" data-type="indexterm" id="id2278"/><a contenteditable="false" data-primary="static methods" data-type="indexterm" id="id2279"/>A delegate’s target method can be a local, static, or instance method. The following illustrates a static target method:</p>
<pre data-type="programlisting">Transformer t = <strong>Test.Square</strong>;
Console.WriteLine (t(10));      // 100

class <strong>Test</strong> { public <strong>static</strong> int <strong>Square</strong> (int x) =&gt; x * x; }

delegate int Transformer (int x);</pre>
<p>The following illustrates an instance target method:</p>
<pre data-type="programlisting">Test test = new Test();
Transformer t = <strong>test.Square</strong>;
Console.WriteLine (t(10));      // 100

class <strong>Test</strong> { public int <strong>Square</strong> (int x) =&gt; x * x; }

delegate int Transformer (int x);</pre>
<p>When an <em>instance</em> method is assigned to a delegate object, the latter maintains a reference not only to the method but also to the <em>instance</em> to which the method belongs. The <code>System.Delegate</code> class’s <code>Target</code> property represents this instance (and will be null for a delegate referencing a static method). Here’s an example:</p>
<pre data-type="programlisting">MyReporter r = new MyReporter();
r.Prefix = "%Complete: ";
ProgressReporter p = r.ReportProgress;
p(99);                                 // %Complete: 99
Console.WriteLine (p.Target == r);     // True
Console.WriteLine (p.Method);          // Void ReportProgress(Int32)
r.Prefix = "";
p(99);                                 // 99

public delegate void ProgressReporter (int percentComplete);

class MyReporter
{
  public string Prefix = "";

  public void ReportProgress (int percentComplete)
    =&gt; Console.WriteLine (Prefix + percentComplete);
}</pre>
<p>Because the instance is stored in the delegate’s <code>Target</code> property, its lifetime is extended to (at least as long as) the delegate’s lifetime.</p>
</div></section>
<section data-pdf-bookmark="Multicast Delegates" data-type="sect2"><div class="sect2" id="multicast_delegates">
<h2>Multicast Delegates</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="multicast" data-type="indexterm" id="id2280"/><a contenteditable="false" data-primary="multicast delegates" data-type="indexterm" id="id2281"/>All delegate instances have <em>multicast</em> capability. This means that a delegate instance can reference not just a single target method but also a list of target methods. <a contenteditable="false" data-primary="+ (plus sign)" data-secondary="combining delegate instances" data-type="indexterm" id="id2282"/><a contenteditable="false" data-primary="+= (add to self) operator" data-secondary="combining delegate instances" data-type="indexterm" id="id2283"/><a contenteditable="false" data-primary="add to self (+=) operator" data-secondary="combining delegate instances" data-type="indexterm" id="id2284"/><a contenteditable="false" data-primary="plus sign (+)" data-secondary="combining delegate instances" data-type="indexterm" id="id2285"/>The <code>+</code> and <code>+=</code> operators combine delegate instances:</p>
<pre data-type="programlisting">SomeDelegate d = SomeMethod1;
d += SomeMethod2;</pre>
<p>The last line is functionally the same as the following:</p>
<pre data-type="programlisting">d = d + SomeMethod2;</pre>
<p>Invoking <code>d</code> will now call both <code>SomeMethod1</code> and <code>SomeMethod2</code>. Delegates are invoked in the order in which they are added.</p>
<p><a contenteditable="false" data-primary="- (minus sign)" data-secondary="removing delegate instances" data-type="indexterm" id="id2286"/><a contenteditable="false" data-primary="-= operator" data-secondary="removing delegate instances" data-type="indexterm" id="id2287"/><a contenteditable="false" data-primary="minus sign (-)" data-secondary="removing delegate instances" data-type="indexterm" id="id2288"/>The <code>-</code> and <code>-=</code> operators remove the right delegate operand from the left delegate operand:</p>
<pre data-type="programlisting">d -= SomeMethod1;</pre>
<p>Invoking <code>d</code> will now cause only <code>SomeMethod2</code> to be invoked.</p>
<p><a contenteditable="false" data-primary="+= (add to self) operator" data-secondary="delegate variable assignment" data-type="indexterm" id="id2289"/><a contenteditable="false" data-primary="add to self (+=) operator" data-secondary="delegate variable assignment" data-type="indexterm" id="id2290"/>Calling <code>+</code> or <code>+=</code> on a delegate variable with a <code>null</code> value works, and it is equivalent to assigning the variable to a new value:</p>
<pre data-type="programlisting">SomeDelegate d = null;
d += SomeMethod1;       // Equivalent (when d is null) to d = SomeMethod1;</pre>
<p>Similarly, calling <code>-=</code> on a delegate variable with a single matching target is equivalent to assigning <code>null</code> to that variable.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Delegates are <em>immutable</em>, so when you call <code>+=</code> or <code>-=</code>, you’re in fact creating a <em>new</em> delegate instance and assigning it to the existing variable.</p>
</div>
<p>If a multicast delegate has a nonvoid return type, the caller receives the return value from the last method to be invoked. The preceding methods are still called, but their return values are discarded. For most scenarios in which multicast delegates are used, they have <code>void</code> return types, so this subtlety does not arise.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Delegate" data-type="indexterm" id="id2291"/><a contenteditable="false" data-primary="System..." data-secondary="System.MulticastDelegate" data-type="indexterm" id="id2292"/>All delegate types implicitly derive from <code>System.MulticastDelegate</code>, which inherits from <code>System.Delegate</code>. C# compiles <code>+</code>, <code>-</code>, <code>+=</code>, and <code>-=</code> operations made on a delegate to the static <code>Combine</code> and <code>Remove</code> methods of the <code>System.Delegate</code> class.</p>
</div>
<section data-pdf-bookmark="Multicast delegate example" data-type="sect3"><div class="sect3" id="multicast_delegate_example">
<h3>Multicast delegate example</h3>
<p>Suppose that you wrote a method that took a long time to execute. That method could regularly report progress to its caller by invoking a delegate. In this example, the <code>HardWork</code> method has a <code>ProgressReporter</code> delegate parameter, which it invokes to indicate progress:</p>
<pre data-type="programlisting">public delegate void ProgressReporter (int percentComplete);

public class Util
{
  public static void HardWork (ProgressReporter p)
  {
    for (int i = 0; i &lt; 10; i++)
    {
      p (i * 10);                           // Invoke delegate
      System.Threading.Thread.Sleep (100);  // Simulate hard work
    }
  }
}</pre>
<p>To monitor progress, we can create a multicast delegate instance <code>p</code>, such that progress is monitored by two independent methods:</p>
<pre data-type="programlisting">ProgressReporter p = WriteProgressToConsole;
p += WriteProgressToFile;
Util.HardWork (p);

void WriteProgressToConsole (int percentComplete)
  =&gt; Console.WriteLine (percentComplete);

void WriteProgressToFile (int percentComplete)
  =&gt; System.IO.File.WriteAllText ("progress.txt",
                                   percentComplete.ToString());</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Generic Delegate Types" data-type="sect2"><div class="sect2" id="generic_delegate_types">
<h2>Generic Delegate Types</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="generic delegate types" data-type="indexterm" id="id2293"/><a contenteditable="false" data-primary="generic types" data-secondary="delegate types" data-type="indexterm" id="id2294"/>A delegate type can contain generic type parameters:</p>
<pre data-type="programlisting">public delegate T Transformer<strong>&lt;T&gt;</strong> (<strong>T</strong> arg);</pre>
<p>With this definition, we can write a generalized <code>Transform</code> utility method that works on any type:</p>
<pre data-type="programlisting">int[] values = { 1, 2, 3 };
Util.Transform (values, Square);      // Hook in Square
foreach (int i in values)
  Console.Write (i + "  ");           // 1   4   9

int Square (int x) =&gt; x * x;

public class Util
{
  public static void Transform&lt;T&gt; (T[] values, <strong>Transformer&lt;T&gt; t</strong>)
  {
    for (int i = 0; i &lt; values.Length; i++)
      values[i] = t (values[i]);
  }
}</pre>
</div></section>
<section data-pdf-bookmark="The Func and Action Delegates" data-type="sect2"><div class="sect2" id="the_func_and_action_delegates">
<h2>The Func and Action Delegates</h2>
<p><a contenteditable="false" data-primary="Action delegate" data-type="indexterm" id="id2295"/><a contenteditable="false" data-primary="delegates" data-secondary="Func and Action delegates" data-type="indexterm" id="id2296"/><a contenteditable="false" data-primary="Func delegate" data-type="indexterm" id="id2297"/>With generic delegates, it becomes possible to write a small set of delegate types that are so general they can work for methods of any return type and any (reasonable) number of arguments. These delegates are the <code>Func</code> and <code>Action</code> delegates, defined in the <code>System</code> namespace (the <code>in</code> and <code>out</code> annotations indicate <em>variance</em>, which we cover in the context of delegates shortly):</p>
<pre data-type="programlisting">delegate TResult Func &lt;out TResult&gt;                ();
delegate TResult Func &lt;in T, out TResult&gt;          (T arg);
delegate TResult Func &lt;in T1, in T2, out TResult&gt;  (T1 arg1, T2 arg2);
<em>... and so on, up to T16</em>

delegate void Action                 ();
delegate void Action &lt;in T&gt;          (T arg);
delegate void Action &lt;in T1, in T2&gt;  (T1 arg1, T2 arg2);
<em>... and so on, up to T16</em></pre>
<p>These delegates are extremely general. The <code>Transformer</code> delegate in our previous example can be replaced with a <code>Func</code> delegate that takes a single argument of type <code>T</code> and returns a same-typed value:</p>
<pre data-type="programlisting">public static void Transform&lt;T&gt; (T[] values, <strong>Func&lt;T,T&gt; transformer</strong>)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = transformer (values[i]);
}</pre>
<p>The only practical scenarios not covered by these delegates are <code>ref</code>/<code>out</code> and pointer parameters.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When C# was first introduced, the <code>Func</code> and <code>Action</code> delegates did not exist (because generics did not exist). It’s for this historical reason that much of .NET uses custom delegate types rather than <code>Func</code> and <code>Action</code>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Delegates Versus Interfaces" data-type="sect2"><div class="sect2" id="delegates_versus_interfaces">
<h2>Delegates Versus Interfaces</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="interfaces versus" data-type="indexterm" id="id2298"/><a contenteditable="false" data-primary="interface" data-secondary="delegates versus" data-type="indexterm" id="id2299"/>A problem that you can solve with a delegate can also be solved with an interface. For instance, we can rewrite our original example with an interface called <span class="keep-together"><code>ITransformer</code></span> instead of a delegate:</p>
<pre data-type="programlisting">int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Squarer());
foreach (int i in values)
  Console.WriteLine (i);

public interface ITransformer
{
  int Transform (int x);
}

public class Util
{
 public static void TransformAll (int[] values, ITransformer t)
 {
   for (int i = 0; i &lt; values.Length; i++)
     values[i] = t.Transform (values[i]);
 }
}

class Squarer : ITransformer
{
  public int Transform (int x) =&gt; x * x;
}</pre>
<p>A delegate design might be a better choice than an interface design if one or more of these conditions are true:</p>
<ul>
<li><p>The interface defines only a single method.</p></li>
<li><p>Multicast capability is needed.</p></li>
<li><p>The subscriber needs to implement the interface multiple times.</p></li>
</ul>
<p>In the <code>ITransformer</code> example, we don’t need to multicast. However, the interface defines only a single method. Furthermore, our subscriber might need to implement <code>ITransformer</code> multiple times, to support different transforms, such as square or cube. With interfaces, we’re forced into writing a separate type per transform because a class can implement <code>ITransformer</code> only once. This is quite cumbersome:</p>
<pre data-type="programlisting">int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Cuber());
foreach (int i in values)
  Console.WriteLine (i);

class Squarer : ITransformer
{
  public int Transform (int x) =&gt; x * x;
}

class Cuber : ITransformer
{
  public int Transform (int x) =&gt; x * x * x;
}</pre>
</div></section>
<section data-pdf-bookmark="Delegate Compatibility" data-type="sect2"><div class="sect2" id="delegate_compatibility">
<h2>Delegate Compatibility</h2>
<section data-pdf-bookmark="Type compatibility" data-type="sect3"><div class="sect3" id="type_compatibility">
<h3>Type compatibility</h3>
<p><a contenteditable="false" data-primary="delegates" data-secondary="type compatibility" data-type="indexterm" id="id2300"/><a contenteditable="false" data-primary="delegates" data-secondary="compatibility" data-type="indexterm" id="ch04.html101"/>Delegate types are all incompatible with one another, even if their signatures are the same:</p>
<pre data-type="programlisting">D1 d1 = Method1;
D2 d2 = d1;                           // Compile-time error

void Method1() { }

delegate void D1();
delegate void D2();</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The following, however, is permitted:</p>
<pre data-type="programlisting">D2 d2 = <strong>new</strong> D2 (d1);</pre>
</div>
<p>Delegate instances are considered equal if they have the same method targets:</p>
<pre data-type="programlisting">D d1 = Method1;
D d2 = Method1;
Console.WriteLine (d1 == d2);         // True

void Method1() { }
delegate void D();</pre>
<p>Multicast delegates are considered equal if they reference the same methods <em>in the same order</em>.</p>
</div></section>
<section data-pdf-bookmark="Parameter compatibility" data-type="sect3"><div class="sect3" id="parameter_compatibility">
<h3>Parameter compatibility</h3>
<p><a contenteditable="false" data-primary="delegates" data-secondary="parameter compatibility" data-type="indexterm" id="id2301"/>When you call a method, you can supply arguments that have more specific types than the parameters of that method. This is ordinary polymorphic behavior. For the same reason, a delegate can have more specific parameter types than its method target. <a contenteditable="false" data-primary="contravariance" data-type="indexterm" id="id2302"/>This is called <em>contravariance</em>. Here’s an example:</p>
<pre data-type="programlisting">StringAction sa = new StringAction (ActOnObject);
sa ("hello");

void ActOnObject (object o) =&gt; Console.WriteLine (o);   // hello

delegate void StringAction (string s);</pre>
<p>(As with type parameter variance, delegates are variant only for <em>reference <span class="keep-together">conversions</span></em>.)</p>
<p>A delegate merely calls a method on someone else’s behalf. In this case, the <code>StringAction</code> is invoked with an argument of type <code>string</code>. When the argument is then relayed to the target method, the argument is implicitly upcast to an <code>object</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The standard event pattern is designed to help you utilize contravariance through its use of the common <code>EventArgs</code> base class. For example, you can have a single method invoked by two different delegates, one passing a <code>MouseEventArgs</code> and the other passing a <code>KeyEventArgs</code>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Return type compatibility" data-type="sect3"><div class="sect3" id="return_type_compatibility">
<h3>Return type compatibility</h3>
<p><a contenteditable="false" data-primary="delegates" data-secondary="return type compatibility" data-type="indexterm" id="id2303"/>If you call a method, you might get back a type that is more specific than what you asked for. This is ordinary polymorphic behavior. For the same reason, a delegate’s target method might return a more specific type than described by the delegate. <a contenteditable="false" data-primary="covariance" data-type="indexterm" id="id2304"/>This is called <em>covariance</em>:</p>
<pre data-type="programlisting">ObjectRetriever o = new ObjectRetriever (RetrieveString);
object result = o();
Console.WriteLine (result);      // hello

string RetrieveString() =&gt; "hello";

delegate object ObjectRetriever();</pre>
<p><code>ObjectRetriever</code> expects to get back an <code>object</code>, but an <code>object</code> <em>subclass</em> will also do: delegate return types are <em>covariant</em>.</p>
</div></section>
<section data-pdf-bookmark="Generic delegate type parameter variance" data-type="sect3"><div class="sect3" id="generic_delegate_type_parameter_varianc">
<h3>Generic delegate type parameter variance</h3>
<p><a contenteditable="false" data-primary="delegates" data-secondary="generic delegate type parameter variance" data-type="indexterm" id="id2305"/><a contenteditable="false" data-primary="generic types" data-secondary="delegate types" data-type="indexterm" id="id2306"/>In <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>, we saw how generic interfaces support covariant and contravariant type parameters. The same capability exists for delegates, too.</p>
<p>If you’re defining a generic delegate type, it’s good practice to do the following:</p>
<ul>
<li><p>Mark a type parameter used only on the return value as covariant (<code>out</code>).</p></li>
<li><p>Mark any type parameters used only on parameters as contravariant (<code>in</code>).</p></li>
</ul>
<p>Doing so allows conversions to work naturally by respecting inheritance relationships between types.</p>
<p>The following delegate (defined in the <code>System</code> namespace) has a covariant <code>TResult:</code></p>
<pre data-type="programlisting">delegate TResult Func&lt;out TResult&gt;();</pre>
<p>This allows:</p>
<pre data-type="programlisting">Func&lt;string&gt; x = ...;
Func&lt;object&gt; y = x;</pre>
<p>The following delegate (defined in the <code>System</code> namespace) has a contravariant <code>T:</code></p>
<pre data-type="programlisting">delegate void Action&lt;in T&gt; (T arg);</pre>
<p>This allows:<a contenteditable="false" data-primary="" data-startref="ch04.html101" data-type="indexterm" id="id2307"/><a contenteditable="false" data-primary="" data-startref="ch04.html100" data-type="indexterm" id="id2308"/></p>
<pre data-type="programlisting">Action&lt;object&gt; x = ...;
Action&lt;string&gt; y = x;</pre>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Events" data-type="sect1"><div class="sect1" id="events">
<h1>Events</h1>
<p>When using delegates, two emergent roles commonly appear: <em>broadcaster</em> and <em>subscriber</em>.</p>
<p><a contenteditable="false" data-primary="broadcaster type" data-type="indexterm" id="id2309"/><a contenteditable="false" data-primary="subscribers" data-type="indexterm" id="id2310"/>The <em>broadcaster</em> is a type that contains a delegate field. The broadcaster decides when to broadcast, by invoking the delegate.</p>
<p><a contenteditable="false" data-primary="-= operator" data-secondary="unsubscribing from events" data-type="indexterm" id="id2311"/><a contenteditable="false" data-primary="+= (add to self) operator" data-secondary="subscribing to events" data-type="indexterm" id="id2312"/><a contenteditable="false" data-primary="add to self (+=) operator" data-secondary="subscribing to events" data-type="indexterm" id="id2313"/>The <em>subscribers</em> are the method target recipients. A subscriber decides when to start and stop listening by calling <code>+=</code> and <code>-=</code> on the broadcaster’s delegate. A subscriber does not know about, or interfere with, other subscribers.</p>
<p>Events are a language feature that formalizes this pattern. An <code>event</code> is a construct that exposes just the subset of delegate features required for the broadcaster/subscriber model. The main purpose of events is to <em>prevent subscribers from interfering with one another</em>.</p>
<p>The easiest way to declare an event is to put the <code>event</code> keyword in front of a delegate member:</p>
<pre data-type="programlisting">// Delegate definition
public delegate void PriceChangedHandler (decimal oldPrice,
                                          decimal newPrice);
public class Broadcaster
{
  // Event declaration
  public <strong>event</strong> PriceChangedHandler PriceChanged;
}</pre>
<p>Code within the <code>Broadcaster</code> type has full access to <code>PriceChanged</code> and can treat it as a delegate. Code outside of <code>Broadcaster</code> can perform only <code>+=</code> and <code>-=</code> operations on the <code>PriceChanged</code> event.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="how_do_events_work_on_the_insidequestio">
<h1>How Do Events Work on the Inside?</h1>
<p><a contenteditable="false" data-primary="events" data-secondary="mechanism of operation" data-type="indexterm" id="id2314"/>Three things happen under the hood when you declare an event as follows:</p>
<pre data-type="programlisting">public class Broadcaster
{
  public <strong>event</strong> PriceChangedHandler PriceChanged;
}</pre>
<p>First, the compiler translates the event declaration into something close to the following:</p>
<pre data-type="programlisting">PriceChangedHandler priceChanged;   // private delegate
public event PriceChangedHandler PriceChanged
{
  add    { priceChanged += value; }
  remove { priceChanged -= value; }
}</pre>
<p><a contenteditable="false" data-primary="event accessors" data-type="indexterm" id="id2315"/>The <code>add</code> and <code>remove</code> keywords denote explicit <em>event accessors</em>—which act rather like property accessors. We describe how to write these later.</p>
<p>Second, the compiler looks <em>within</em> the <code>Broadcaster</code> class for references to <code>PriceChanged</code> that perform operations other than <code>+=</code> or <code>-=</code> and redirects them to the underlying <code>priceChanged</code> delegate field.</p>
<p>Third, the compiler translates <code>+=</code> and <code>-=</code> operations on the event to calls to the event’s <code>add</code> and <code>remove</code> accessors. Interestingly, this makes the behavior of <code>+=</code> and <code>-=</code> unique when applied to events: unlike in other scenarios, it’s not simply a shortcut for <code>+</code> and <code>-</code> followed by an assignment.</p>
</div></aside>
<p>Consider the following example. The <code>Stock</code> class fires its <code>PriceChanged</code> event every time the <code>Price</code> of the <code>Stock</code> changes:</p>
<pre data-type="programlisting">public delegate void PriceChangedHandler (decimal oldPrice,
                                          decimal newPrice);
public class Stock
{
  string symbol;
  decimal price;

  public Stock (string symbol) =&gt; this.symbol = symbol;

  public event PriceChangedHandler PriceChanged;

  public decimal Price
  {
    get =&gt; price;
    set
    {
      if (price == value) return;      // Exit if nothing has changed
      decimal oldPrice = price;
      price = value;
      if (PriceChanged != null)           // If invocation list not
        <strong>PriceChanged (oldPrice, price);</strong>   // empty, fire event.
    }
  }
}</pre>
<p>If we remove the <code>event</code> keyword from our example so that <code>PriceChanged</code> becomes an ordinary delegate field, our example would give the same results. However, <code>Stock</code> would be less robust insomuch as subscribers could do the following things to interfere with one another:</p>
<ul>
<li><p>Replace other subscribers by reassigning <code>PriceChanged</code> (instead of using the <code>+=</code> operator).</p></li>
<li><p>Clear all subscribers (by setting <code>PriceChanged</code> to <code>null</code>).</p></li>
<li><p>Broadcast to other subscribers by invoking the delegate.</p></li>
</ul>
<section data-pdf-bookmark="Standard Event Pattern" data-type="sect2"><div class="sect2" id="standard_event_pattern">
<h2>Standard Event Pattern</h2>
<p><a contenteditable="false" data-primary="events" data-secondary="standard event pattern" data-type="indexterm" id="ch04.html102"/>In almost all cases for which events are defined in the .NET libraries, their definition adheres to a standard pattern designed to provide consistency across library and user code. <a contenteditable="false" data-primary="System..." data-secondary="System.EventArgs" data-type="indexterm" id="id2316"/>At the core of the standard event pattern is <code>System.EventArgs</code>, a predefined .NET class with no members (other than the static <code>Empty</code> field). <code>EventArgs</code> is a base class for conveying information for an event. In our <code>Stock</code> example, we would subclass <code>EventArgs</code> to convey the old and new prices when a <code>PriceChanged</code> event is fired:</p>
<pre class="pagebreak-before" data-type="programlisting">public class PriceChangedEventArgs : System.EventArgs
{
  public readonly decimal LastPrice;
  public readonly decimal NewPrice;

  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
  {
    LastPrice = lastPrice;
    NewPrice = newPrice;
  }
}</pre>
<p>For reusability, the <code>EventArgs</code> subclass is named according to the information it contains (rather than the event for which it will be used). It typically exposes data as properties or as read-only fields.</p>
<p>With an <code>EventArgs</code> subclass in place, the next step is to choose or define a delegate for the event. There are three rules:</p>
<ul>
<li><p>It must have a <code>void</code> return type.</p></li>
<li><p>It must accept two arguments: the first of type <code>object</code> and the second a subclass of <code>EventArgs</code>. The first argument indicates the event broadcaster, and the second argument contains the extra information to convey.</p></li>
<li><p>Its name must end with <code>EventHandler</code>.</p></li>
</ul>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.EventHandler&lt;&gt;" data-type="indexterm" id="id2317"/>.NET defines a generic delegate called <code>System.EventHandler&lt;&gt;</code> to help with this:</p>
<pre data-type="programlisting">public delegate void EventHandler&lt;TEventArgs&gt; (object source, TEventArgs e)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Before generics existed in the language (prior to C# 2.0), we would have had to instead write a custom delegate as follows:</p>
<pre data-type="programlisting">public delegate void PriceChangedHandler
  (object sender, PriceChangedEventArgs e);</pre>
<p>For historical reasons, most events within the .NET libraries use delegates defined in this way.</p>
</div>
<p>The next step is to define an event of the chosen delegate type. Here, we use the generic <code>EventHandler</code> delegate:</p>
<pre data-type="programlisting">public class Stock
{
  ...
  <strong>public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;</strong>
}</pre>
<p>Finally, the pattern requires that you write a protected virtual method that fires the event. The name must match the name of the event, prefixed with the word “On,” and then accept a single <code>EventArgs</code> argument:</p>
<pre data-type="programlisting">public class Stock
{
  ...

  public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;

  <strong>protected virtual void OnPriceChanged (PriceChangedEventArgs e)</strong>
  <strong>{</strong>
    <strong>if (PriceChanged != null) PriceChanged (this, e);</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To work robustly in multithreaded scenarios (<a data-type="xref" href="ch14.html#concurrency_and_asynchron">Chapter 14</a>), you need to assign the delegate to a temporary variable before testing and invoking it:</p>
<pre data-type="programlisting">var temp = PriceChanged;
if (temp != null) temp (this, e);</pre>
<p><a contenteditable="false" data-primary="?. (null-conditional operator)" data-type="indexterm" id="id2318"/><a contenteditable="false" data-primary="null-conditional operator (?.)" data-type="indexterm" id="id2319"/>We can achieve the same functionality without the <code>temp</code> variable with the null-conditional operator:</p>
<pre data-type="programlisting">PriceChanged?.Invoke (this, e);</pre>
<p>Being both thread-safe and succinct, this is the best general way to invoke events.</p>
</div>
<p>This provides a central point from which subclasses can invoke or override the event (assuming the class is not sealed).</p>
<p>Here’s the complete example:</p>
<pre data-type="programlisting">using System;

Stock stock = new Stock ("THPW");
stock.Price = 27.10M;
// Register with the PriceChanged event
stock.PriceChanged += stock_PriceChanged;
stock.Price = 31.59M;

void stock_PriceChanged (object sender, PriceChangedEventArgs e)
{
  if ((e.NewPrice - e.LastPrice) / e.LastPrice &gt; 0.1M)
    Console.WriteLine ("Alert, 10% stock price increase!");
}

public class PriceChangedEventArgs : EventArgs
{
  public readonly decimal LastPrice;
  public readonly decimal NewPrice;

  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
  {
    LastPrice = lastPrice; NewPrice = newPrice;
  }
}

public class Stock
{
  string symbol;
  decimal price;

  public Stock (string symbol) =&gt; this.symbol = symbol;

  <strong>public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;</strong>

  <strong>protected</strong> virtual <strong>void OnPriceChanged (PriceChangedEventArgs e)</strong>
  <strong>{</strong>
    <strong>PriceChanged?.Invoke (this, e);</strong>
  <strong>}</strong>

  public decimal Price
  {
    get =&gt; price;
    set
    {
      if (price == value) return;
      decimal oldPrice = price;
      price = value;
      <strong>OnPriceChanged (new PriceChangedEventArgs (oldPrice, price))</strong>;
    }
  }
}</pre>
<p>The predefined nongeneric <code>EventHandler</code> delegate can be used when an event doesn’t carry extra information. In this example, we rewrite <code>Stock</code> such that the <span class="keep-together"><code>PriceChanged</code></span> event is fired after the price changes, and no information about the event is necessary, other than it happened. We also make use of the <code>Even⁠t​Args.Empty</code> property in order to avoid unnecessarily instantiating an instance of <code>EventArgs</code>:<a contenteditable="false" data-primary="" data-startref="ch04.html102" data-type="indexterm" id="id2320"/></p>
<pre data-type="programlisting"><strong>public class Stock</strong>
<strong>{</strong>
  string symbol;
  decimal price;

  public Stock (string symbol) { this.symbol = symbol; }

  public event <strong>EventHandler</strong> <strong>PriceChanged;</strong>

  <strong>protected virtual void OnPriceChanged (EventArgs e)</strong>
  <strong>{</strong>
    <strong>PriceChanged?.Invoke (this, e);</strong>
  <strong>}</strong>

  public decimal Price
  {
    get { return price; }
    set
    {
      if (price == value) return;
      price = value;
      OnPriceChanged (<strong>EventArgs.Empty</strong><strong>);</strong>
    }
  }
<strong>}</strong></pre>
</div></section>
<section data-pdf-bookmark="Event Accessors" data-type="sect2"><div class="sect2" id="event_accessors">
<h2>Event Accessors</h2>
<p><a contenteditable="false" data-primary="-= operator" data-secondary="event accessors" data-type="indexterm" id="id2321"/><a contenteditable="false" data-primary="+= (add to self) operator" data-secondary="event accessors" data-type="indexterm" id="id2322"/><a contenteditable="false" data-primary="accessors" data-type="indexterm" id="id2323"/><a contenteditable="false" data-primary="add to self (+=) operator" data-secondary="event accessors" data-type="indexterm" id="id2324"/><a contenteditable="false" data-primary="events" data-secondary="accessors" data-type="indexterm" id="id2325"/>An event’s <em>accessors</em> are the implementations of its <code>+=</code> and <code>-=</code> functions. By default, accessors are implemented implicitly by the compiler. Consider this event <span class="keep-together">declaration</span>:</p>
<pre data-type="programlisting">public event EventHandler PriceChanged;</pre>
<p>The compiler converts this to the following:</p>
<ul>
<li><p>A private delegate field</p></li>
<li><p>A public pair of event accessor functions (<code>add_PriceChanged</code> and <code>remove_Pri⁠ce​Changed</code>) whose implementations forward the <code>+=</code> and <code>-=</code> operations to the private delegate field</p></li>
</ul>
<p>You can take over this process by defining <em>explicit</em> event accessors. Here’s a manual implementation of the <code>PriceChanged</code> event from our previous example:</p>
<pre data-type="programlisting">private EventHandler priceChanged;         // Declare a private delegate

public event EventHandler PriceChanged
{
  <strong>add    { priceChanged += value; }</strong>
  <strong>remove { priceChanged -= value; }</strong>
}</pre>
<p>This example is functionally identical to C#’s default accessor implementation (except that C# also ensures thread safety around updating the delegate via a lock-free compare-and-swap algorithm; see <a href="http://albahari.com/threading"><em class="hyperlink">http://albahari.com/threading</em></a>). By defining event accessors ourselves, we instruct C# not to generate default field and accessor logic.</p>
<p>With explicit event accessors, you can apply more complex strategies to the storage and access of the underlying delegate. There are three scenarios for which this is useful:</p>
<ul>
<li><p>When the event accessors are merely relays for another class that is broadcasting the event.</p></li>
<li><p>When the class exposes many events, for which most of the time very few subscribers exist, such as a Windows control. In such cases, it is better to store the subscriber’s delegate instances in a dictionary because a dictionary will contain less storage overhead than dozens of null delegate field references.</p></li>
<li><p>When explicitly implementing an interface that declares an event.</p></li>
</ul>
<p>Here is an example that illustrates the last point:</p>
<pre data-type="programlisting">public interface IFoo { event EventHandler Ev; }

class Foo : IFoo
{
  private EventHandler ev;

  event EventHandler IFoo.Ev
  {
    add    { ev += value; }
    remove { ev -= value; }
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>add</code> and <code>remove</code> parts of an event are compiled to <code>add_<em>XXX</em></code> and <code>remove_<em>XXX</em></code> methods.</p>
</div>
</div></section>
<section data-pdf-bookmark="Event Modifiers" data-type="sect2"><div class="sect2" id="event_modifiers">
<h2>Event Modifiers</h2>
<p><a contenteditable="false" data-primary="events" data-secondary="modifiers" data-type="indexterm" id="id2326"/>Like methods, events can be virtual, overridden, abstract, or sealed. Events can also be static:</p>
<pre data-type="programlisting">public class Foo
{
  public static event EventHandler&lt;EventArgs&gt; StaticEvent;
  public virtual event EventHandler&lt;EventArgs&gt; VirtualEvent;
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Lambda Expressions" data-type="sect1"><div class="sect1" id="lambda_expressions">
<h1>Lambda Expressions</h1>
<p><a contenteditable="false" data-primary="lambda expressions" data-type="indexterm" id="ch04.html103"/>A <em>lambda expression</em> is an unnamed method written in place of a delegate instance. The compiler immediately converts the lambda expression to either of the following:</p>
<ul>
<li><p>A delegate instance.</p></li>
<li><p><a contenteditable="false" data-primary="expression trees" data-secondary="lambda expressions and" data-type="indexterm" id="id2327"/>An <em>expression tree</em>, of type <code>Expression&lt;TDelegate&gt;</code>, representing the code inside the lambda expression in a traversable object model. This allows the lambda expression to be interpreted later at runtime (see <a data-type="xref" href="ch08.html#building_query_expressions">“Building Query Expressions”</a>).</p></li>
</ul>
<p><a contenteditable="false" data-primary="=&gt; (lambda operator)" data-type="indexterm" id="id2328"/><a contenteditable="false" data-primary="lambda operator (=&gt;)" data-type="indexterm" id="id2329"/>In the following example, <code>x =&gt; x * x</code> is a lambda expression:</p>
<pre data-type="programlisting">Transformer sqr = <strong>x =&gt; x * x</strong>;
Console.WriteLine (sqr(3));    // 9

delegate int Transformer (int i);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Internally, the compiler resolves lambda expressions of this type by writing a private method and then moving the expression’s code into that method.</p>
</div>
<p>A lambda expression has the following form:</p>
<pre data-type="programlisting">(<em>parameters</em>) =&gt; <em>expression-or-statement-block</em></pre>
<p>For convenience, you can omit the parentheses if and only if there is exactly one parameter of an inferable type.</p>
<p>In our example, there is a single parameter, <code>x</code>, and the expression is <code>x * x</code>:</p>
<pre data-type="programlisting">x =&gt; x * x;</pre>
<p>Each parameter of the lambda expression corresponds to a delegate parameter, and the type of the expression (which may be <code>void</code>) corresponds to the return type of the delegate.</p>
<p>In our example, <code>x</code> corresponds to parameter <code>i</code>, and the expression <code>x * x</code> corresponds to the return type <code>int</code>, therefore being compatible with the <code>Transformer</code> delegate:</p>
<pre data-type="programlisting">delegate int Transformer (int i);</pre>
<p><a contenteditable="false" data-primary="statement block" data-type="indexterm" id="id2330"/>A lambda expression’s code can be a <em>statement block</em> instead of an expression. We can rewrite our example as follows:</p>
<pre data-type="programlisting">x =&gt; { return x * x; };</pre>
<p>Lambda expressions are used most commonly with the <code>Func</code> and <code>Action</code> delegates, so you will most often see our earlier expression written as follows:</p>
<pre data-type="programlisting">Func&lt;int,int&gt; sqr = x =&gt; x * x;</pre>
<p>Here’s an example of an expression that accepts two parameters:</p>
<pre data-type="programlisting">Func&lt;string,string,int&gt; totalLength = (s1, s2) =&gt; s1.Length + s2.Length;
int total = totalLength ("hello", "world");   // total is 10;</pre>
<p>If you do not need to use the parameters, you can <em>discard</em> them with an underscore (from C# 9):</p>
<pre data-type="programlisting">Func&lt;string,string,int&gt; totalLength = (_,_) =&gt; ...</pre>
<p>Here’s an example of an expression that takes zero arguments:</p>
<pre data-type="programlisting">Func&lt;string&gt; greeter = () =&gt; "Hello, world";</pre>
<p>From C# 10, the compiler permits implicit typing with lambda expressions that can be resolved via the <code>Func</code> and <code>Action</code> delegates, so we can shorten this statement to:</p>
<pre data-type="programlisting"><strong>var</strong> greeter = () =&gt; "Hello, world";</pre>
<section data-pdf-bookmark="Explicitly Specifying Lambda Parameter and Return Types" data-type="sect2"><div class="sect2" id="explicitly_specifying_lambda_parameter">
<h2>Explicitly Specifying Lambda Parameter and Return Types</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="explicitly specifying parameter/return types" data-type="indexterm" id="id2331"/><a contenteditable="false" data-primary="return types" data-secondary="explicitly specifying lambda parameter and return types" data-type="indexterm" id="id2332"/>The compiler can usually <em>infer</em> the type of lambda parameters contextually. When this is not the case, you must specify the type of each parameter explicitly. Consider the following two methods:</p>
<pre data-type="programlisting">void Foo&lt;T&gt; (T x)         {}
void Bar&lt;T&gt; (Action&lt;T&gt; a) {}</pre>
<p class="pagebreak-before">The following code will fail to compile, because the compiler cannot infer the type of <code>x</code>:</p>
<pre data-type="programlisting">Bar (x =&gt; Foo (x));     // What type is x?</pre>
<p>We can fix this by explicitly specifying <code>x</code>’s type as follows:</p>
<pre data-type="programlisting">Bar (<strong>(int x)</strong> =&gt; Foo (x));</pre>
<p>This particular example is simple enough that it can be fixed in two other ways:</p>
<pre data-type="programlisting">Bar<strong>&lt;int&gt;</strong> (x =&gt; Foo (x));   // Specify type parameter for Bar
Bar&lt;int&gt; (Foo);            // As above, but with method group</pre>
<p>The following example illustrates another use for explicit parameter types (from C# 10):</p>
<pre data-type="programlisting"><strong>var</strong> sqr = (int x) =&gt; x * x;</pre>
<p>The compiler infers <code>sqr</code> to be of type <code>Func&lt;int,int&gt;</code>.  (Without specifying <code>int</code>, implicit typing would fail: the compiler would know that <code>sqr</code> should be <code>Func&lt;T,T&gt;</code>, but it wouldn’t know what <code>T</code> should be.)</p>
<p>From C# 10, you can also specify the lambda return type:</p>
<pre data-type="programlisting">var sqr = <strong>int</strong> (int x) =&gt; x;</pre>
<p>Specifying a return type can improve compiler performance with complex nested lambdas.</p>
</div></section>
<section data-pdf-bookmark="Default Lambda Parameters (C# 12)" data-type="sect2"><div class="sect2" id="default_lambda_parameters_left_parenthe">
<h2>Default Lambda Parameters (C# 12)</h2>
<p><a contenteditable="false" data-primary="C# 12" data-secondary="default lambda parameters" data-type="indexterm" id="id2333"/><a contenteditable="false" data-primary="default lambda parameters (C# 12)" data-type="indexterm" id="id2334"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="default lambda parameters (C# 12)" data-type="indexterm" id="id2335"/>Just as ordinary methods can have optional parameters:</p>
<pre data-type="programlisting">void Print (string <strong>message = ""</strong>) =&gt; Console.WriteLine (message);</pre>
<p>so, too, can lambda expressions:</p>
<pre data-type="programlisting">var print = (string <strong>message = ""</strong>) =&gt; Console.WriteLine (message);

print ("Hello");
print ();</pre>
<p>This feature is useful with libraries such as ASP.NET Minimal API.</p>
</div></section>
<section data-pdf-bookmark="Capturing Outer Variables" data-type="sect2"><div class="sect2" id="capturing_outer_variables">
<h2>Capturing Outer Variables</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="capturing outer variables" data-type="indexterm" id="ch04.html104"/><a contenteditable="false" data-primary="outer variables" data-type="indexterm" id="ch04.html105"/>A lambda expression can reference any variables that are accessible where the lambda expression is defined. These are called <em>outer variables</em>, and can include local variables, parameters, and fields:</p>
<pre data-type="programlisting">int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * <strong>factor</strong>;
Console.WriteLine (multiplier (3));            // 6</pre>
<p>Outer variables referenced by a lambda expression are called <em>captured variables</em>. <a contenteditable="false" data-primary="closures" data-type="indexterm" id="id2336"/>A lambda expression that captures variables is called a <em>closure</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Variables can also be captured by anonymous methods and local methods. The rules for captured variables, in these cases, are the same.</p>
</div>
<p>Captured variables are evaluated when the delegate is actually <em>invoked</em>, not when the variables were <em>captured</em>:</p>
<pre data-type="programlisting">int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;
<strong>factor = 10;</strong>
Console.WriteLine (multiplier (3));           // 30</pre>
<p>Lambda expressions can themselves update captured variables:</p>
<pre data-type="programlisting">int seed = 0;
Func&lt;int&gt; natural = () =&gt; seed++;
Console.WriteLine (natural());           // 0
Console.WriteLine (natural());           // 1
Console.WriteLine (seed);                // 2</pre>
<p>Captured variables have their lifetimes extended to that of the delegate. In the following example, the local variable <code>seed</code> would ordinarily disappear from scope when <code>Natural</code> finished executing. But because <code>seed</code> has been <em>captured</em>, its lifetime is extended to that of the capturing delegate, <code>natural</code>:</p>
<pre data-type="programlisting">static Func&lt;int&gt; Natural()
{
  int seed = 0;
  return () =&gt; seed++;      // Returns a <em>closure</em>
}

static void Main()
{
  Func&lt;int&gt; natural = Natural();
  Console.WriteLine (natural());      // 0
  Console.WriteLine (natural());      // 1
}</pre>
<p>A local variable <em>instantiated</em> within a lambda expression is unique per invocation of the delegate instance. If we refactor our previous example to instantiate <code>seed</code> <em>within</em> the lambda expression, we get a different (in this case, undesirable) result:</p>
<pre data-type="programlisting">static Func&lt;int&gt; Natural()
{    
  return() =&gt; { int seed = 0; return seed++; };
}

static void Main()
{
  Func&lt;int&gt; natural = Natural();
  Console.WriteLine (natural());           // 0
  Console.WriteLine (natural());           // 0
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Capturing is internally implemented by “hoisting” the captured variables into fields of a private class. When the method is called, the class is instantiated and lifetime-bound to the delegate instance.</p>
</div>
<section data-pdf-bookmark="Static lambdas" data-type="sect3"><div class="sect3" id="static_lambdas">
<h3>Static lambdas</h3>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="static lambdas (C# 9)" data-type="indexterm" id="id2337"/><a contenteditable="false" data-primary="static lambda expressions" data-type="indexterm" id="id2338"/>When you capture local variables, parameters, instance fields, or the <code>this</code> reference, the compiler may need to create and instantiate a private class to store a reference to the captured data. This incurs a small performance cost, because memory must be allocated (and subsequently collected). In situations where performance is critical, one micro-optimization strategy is to minimize the load on the garbage collector by ensuring that code hot paths incur few or no allocations.</p>
<p><a contenteditable="false" data-primary="static keyword" data-type="indexterm" id="id2339"/>From C# 9, you can ensure that a lambda expression, local function, or anonymous method doesn’t capture state by applying the <code>static</code> keyword. This can be useful in micro-optimization scenarios to prevent unintentional memory allocations. For example, we can apply the static modifier to a lambda expression as follows:</p>
<pre data-type="programlisting">Func&lt;int, int&gt; multiplier = <strong>static</strong> n =&gt; n * 2;</pre>
<p>If we later try to modify the lambda expression such that it captures a local variable, the compiler will generate an error:</p>
<pre data-type="programlisting">int factor = 2;
Func&lt;int, int&gt; multiplier = static n =&gt; n * <strong>factor</strong>;  // will not compile</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The lambda itself evaluates to a delegate instance, which requires a memory allocation. However, if the lambda doesn’t capture variables, the compiler will reuse a single cached instance across the life of the application, so there will be no cost in practice.</p>
</div>
<p>This feature can also be used with local methods. In the following example, the <code>Multiply</code> method cannot access the <code>factor</code> variable:</p>
<pre data-type="programlisting">void Foo()
{
  int factor = 123;
  <strong>static</strong> int Multiply (int x) =&gt; x * 2;   // Local static method
}</pre>
<p>Of course, the <code>Multiply</code> method could still explicitly allocate memory by calling <code>new</code>. What this protects us from is a potential allocation by <em>stealth</em>. Applying <code>static</code> here is also arguably useful as a documentation tool, indicating a reduced level of coupling.</p>
<p>Static lambdas can still access static variables and constants (because these do not require a closure).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>static</code> keyword acts merely as a <em>check</em>; it has no effect on the IL that the compiler produces. Without the <code>static</code> keyword, the compiler does not generate a closure unless it needs to (and even then, it has tricks to mitigate the cost).</p>
</div>
</div></section>
<section data-pdf-bookmark="Capturing iteration variables" data-type="sect3"><div class="sect3" id="capturing_iteration_variables">
<h3>Capturing iteration variables</h3>
<p><a contenteditable="false" data-primary="iteration variables" data-type="indexterm" id="id2340"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="capturing iteration variables" data-type="indexterm" id="id2341"/>When you capture the iteration variable of a <code>for</code> loop, C# treats that variable as though it were declared <em>outside</em> the loop. This means that the <em>same</em> variable <span class="keep-together">is captured</span> in each iteration. The following program writes <code>333</code> instead of <code>012</code>:</p>
<pre data-type="programlisting">Action[] actions = new Action[3];

for (int i = 0; i &lt; 3; i++)
  actions [i] = () =&gt; <strong>Console.Write (i)</strong>;

foreach (Action a in actions) a();     // 333</pre>
<p>Each closure (shown in boldface) captures the same variable, <code>i</code>. (This actually makes sense when you consider that <code>i</code> is a variable whose value persists between loop iterations; you can even explicitly change <code>i</code> within the loop body if you want.) The consequence is that when the delegates are later invoked, each delegate sees <code>i</code>’s value at the time of <em>invocation</em>—which is 3. We can illustrate this better by expanding the <code>for</code> loop, as follows:</p>
<pre data-type="programlisting">Action[] actions = new Action[3];
int i = 0;
actions[0] = () =&gt; Console.Write (i);
i = 1;
actions[1] = () =&gt; Console.Write (i);
i = 2;
actions[2] = () =&gt; Console.Write (i);
i = 3;
foreach (Action a in actions) a();    // 333</pre>
<p>The solution, if we want to write <code>012</code>, is to assign the iteration variable to a local variable that’s scoped <em>within</em> the loop:</p>
<pre data-type="programlisting">Action[] actions = new Action[3];
for (int i = 0; i &lt; 3; i++)
{
  int <strong>loopScopedi = i</strong>;
  actions [i] = () =&gt; Console.Write (<strong>loopScopedi</strong>);
}
foreach (Action a in actions) a();     // 012</pre>
<p>Because <code>loopScopedi</code> is freshly created on every iteration, each closure captures a <em>different</em> variable.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Prior to C# 5.0, <code>foreach</code> loops worked in the same way. This caused considerable confusion: unlike with a <code>for</code> loop, the iteration variable in a <code>foreach</code> loop is immutable, and so you would expect it to be treated as local to the loop body. The good news is that it’s now fixed and you can safely capture a <code>foreach</code> loop’s iteration variable without surprises. <a contenteditable="false" data-primary="" data-startref="ch04.html105" data-type="indexterm" id="id2342"/><a contenteditable="false" data-primary="" data-startref="ch04.html104" data-type="indexterm" id="id2343"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Lambda Expressions Versus Local Methods" data-type="sect2"><div class="sect2" id="lambda_expressions_versus_local_methods">
<h2>Lambda Expressions Versus Local Methods</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="local methods versus" data-type="indexterm" id="id2344"/><a contenteditable="false" data-primary="local methods" data-secondary="lambda expressions versus" data-type="indexterm" id="id2345"/>The functionality of local methods (see <a data-type="xref" href="ch03.html#local_methods-id00077">“Local methods”</a>) overlaps with that of lambda expressions. Local methods have the following three advantages:</p>
<ul>
<li><p>They can be recursive (they can call themselves) without ugly hacks.</p></li>
<li><p>They avoid the clutter of specifying a delegate type.</p></li>
<li><p>They incur slightly less overhead.</p></li>
</ul>
<p>Local methods are more efficient because they avoid the indirection of a delegate (which costs some CPU cycles and a memory allocation). They can also access local variables of the containing method without the compiler having to “hoist” the captured variables into a hidden class.</p>
<p>However, in many cases you <em>need</em> a delegate—most commonly when calling a higher-order function, that is, a method with a delegate-typed parameter:</p>
<pre data-type="programlisting">public void Foo (<strong>Func&lt;int,bool&gt;</strong> predicate) { ... }</pre>
<p><a contenteditable="false" data-primary="" data-startref="ch04.html103" data-type="indexterm" id="id2346"/>(You can see plenty more of these in <a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>). In such cases, you need a delegate anyway, and it’s in precisely these cases that lambda expressions are usually terser and cleaner.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Anonymous Methods" data-type="sect1"><div class="sect1" id="anonymous_methods">
<h1>Anonymous Methods</h1>
<p><a contenteditable="false" data-primary="anonymous methods" data-type="indexterm" id="id2347"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="anonymous methods versus" data-type="indexterm" id="id2348"/>Anonymous methods are a C# 2.0 feature that was mostly subsumed by C# 3.0’s lambda expressions. An anonymous method is like a lambda expression, but it lacks the following features:</p>
<ul>
<li><p>Implicitly typed parameters</p></li>
<li><p>Expression syntax (an anonymous method must always be a statement block)</p></li>
<li><p>The ability to compile to an expression tree, by assigning to <code>Expression&lt;T&gt;</code></p></li>
</ul>
<p>An anonymous method uses the <code>delegate</code> keyword followed (optionally) by a parameter declaration and then a method body. For example:</p>
<pre data-type="programlisting">Transformer sqr = <strong>delegate (int x) {return x * x;}</strong>;
Console.WriteLine (sqr(3));                            // 9

delegate int Transformer (int i);</pre>
<p class="pagebreak-before">The first line is semantically equivalent to the following lambda expression:</p>
<pre data-type="programlisting">Transformer sqr =       <strong>(int x) =&gt; {return x * x;}</strong>;</pre>
<p>Or simply:</p>
<pre data-type="programlisting">Transformer sqr =            <strong>x  =&gt; x * x</strong>;</pre>
<p>Anonymous methods capture outer variables in the same way lambda expressions do, and can be preceded by the <code>static</code> keyword to make them behave like static lambdas.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A unique feature of anonymous methods is that you can omit the parameter declaration entirely—even if the delegate expects it. This can be useful in declaring events with a default empty handler:</p>
<pre data-type="programlisting">public event EventHandler Clicked = delegate { };</pre>
<p>This avoids the need for a null check before firing the event. The following is also legal:</p>
<pre data-type="programlisting">// Notice that we omit the parameters:
Clicked += delegate { Console.WriteLine ("clicked"); };</pre>
</div>
</div></section>
<section data-pdf-bookmark="try Statements and Exceptions" data-type="sect1"><div class="sect1" id="try_statements_and_exceptions">
<h1>try Statements and Exceptions</h1>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-type="indexterm" id="ch04.html106"/>A <code>try</code> statement specifies a code block subject to error-handling or cleanup code. The <code>try</code> <em>block</em> must be followed by one or more <code>catch</code> <em>blocks</em> and/or a <code>finally</code> <em>block</em>, or both. The <code>catch</code> block executes when an error is thrown in the <code>try</code> block. The <code>finally</code> block executes after execution leaves the <code>try</code> block (or, if present, the <code>catch</code> block) to perform cleanup code, regardless of whether an exception was thrown.</p>
<p>A <code>catch</code> block has access to an <code>Exception</code> object that contains information about the error. You use a <code>catch</code> block to either compensate for the error or <em>rethrow</em> the exception. You rethrow an exception if you merely want to log the problem or if you want to rethrow a new, higher-level exception type.</p>
<p>A <code>finally</code> block adds determinism to your program: the CLR endeavors to always execute it. It’s useful for cleanup tasks such as closing network connections.</p>
<p>A <code>try</code> statement looks like this:</p>
<pre data-type="programlisting">try
{
  ... // exception may get thrown within execution of this block
}
catch (ExceptionA ex)
{
  ... // handle exception of type ExceptionA
}
catch (ExceptionB ex)
{
  ... // handle exception of type ExceptionB
}
finally
{
  ... // cleanup code
}</pre>
<p>Consider the following program:</p>
<pre data-type="programlisting">int y = Calc (0);
Console.WriteLine (y);

int Calc (int x) =&gt; 10 / x;</pre>
<p>Because <code>x</code> is zero, the runtime throws a <code>DivideByZeroException</code> and our program terminates. We can prevent this by catching the exception as follows:</p>
<pre data-type="programlisting"><strong>try</strong>
<strong>{</strong>
  int y = Calc (0);
  Console.WriteLine (y);
<strong>}</strong>
<strong>catch (DivideByZeroException ex)</strong>
<strong>{</strong>
  Console.WriteLine ("x cannot be zero");
<strong>}</strong>
<strong>Console.WriteLine ("program completed");</strong>

int Calc (int x) =&gt; 10 / x;</pre>
<p>Here’s the output:</p>
<pre data-type="programlisting"><strong>x cannot be zero</strong>
<strong>program completed</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is a simple example to illustrate exception handling. We could deal with this particular scenario better in practice by checking explicitly for the divisor being zero before calling <code>Calc</code>.</p>
<p>Checking for preventable errors is preferable to relying on <code>try</code>/<code>catch</code> blocks because exceptions are relatively expensive to handle, taking hundreds of clock cycles or more.</p>
</div>
<p>When an exception is thrown within a <code>try</code> statement, the CLR performs a test:</p>
<p><em>Does the</em> <code>try</code> <em>statement have any compatible</em> <code>catch</code> <em>blocks?</em></p>
<ul>
<li><p>If so, execution jumps to the compatible <code>catch</code> block, followed by the <code>finally</code> block (if present), and then execution continues normally.</p></li>
<li><p>If not, execution jumps directly to the <code>finally</code> block (if present), then the CLR looks up the call stack for other <code>try</code> blocks; if found, it repeats the test.</p></li>
</ul>
<p>If no function in the call stack takes responsibility for the exception, the program terminates.</p>
<section data-pdf-bookmark="The catch Clause" data-type="sect2"><div class="sect2" id="the_catch_clause">
<h2>The catch Clause</h2>
<p><a contenteditable="false" data-primary="catch clause" data-type="indexterm" id="ch04.html107"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="catch clause" data-type="indexterm" id="ch04.html108"/>A <code>catch</code> clause specifies what type of exception to catch. <a contenteditable="false" data-primary="System..." data-secondary="System.Exception" data-type="indexterm" id="id2349"/>This must either be <code>System.Exception</code> or a subclass of <code>System.Exception</code>.</p>
<p>Catching <code>System.Exception</code> catches all possible errors. This is useful in the following circumstances:</p>
<ul>
<li><p>Your program can potentially recover regardless of the specific exception type.</p></li>
<li><p>You plan to rethrow the exception (perhaps after logging it).</p></li>
<li><p>Your error handler is the last resort, prior to termination of the program.</p></li>
</ul>
<p>More typically, though, you catch <em>specific exception types</em> in order to avoid having to deal with circumstances for which your handler wasn’t designed (e.g., an <code>OutOfMemoryException</code>).</p>
<p>You can handle multiple exception types with multiple <code>catch</code> clauses (again, this example could be written with explicit argument checking rather than exception handling):</p>
<pre data-type="programlisting">class Test
{
  static void Main (string[] args)
  {
    try
    {
      byte b = byte.Parse (args[0]);
      Console.WriteLine (b);
    }
    catch (IndexOutOfRangeException)
    {
      Console.WriteLine ("Please provide at least one argument");
    }
    catch (FormatException)
    {
      Console.WriteLine ("That's not a number!");
    }
    catch (OverflowException)
    {
      Console.WriteLine ("You've given me more than a byte!");
    }
  }
}</pre>
<p>Only one <code>catch</code> clause executes for a given exception. If you want to include a safety net to catch more general exceptions (such as <code>System.Exception</code>), you must put the more-specific handlers <em>first</em>.</p>
<p>An exception can be caught without specifying a variable, if you don’t need to access its properties:</p>
<pre data-type="programlisting">catch (OverflowException)   // no variable
{
  ...
}</pre>
<p>Furthermore, you can omit both the variable and the type (meaning that all exceptions will be caught):</p>
<pre data-type="programlisting">catch { ... }</pre>
<section data-pdf-bookmark="Exception filters" data-type="sect3"><div class="sect3" id="exception_filters">
<h3>Exception filters</h3>
<p><a contenteditable="false" data-primary="exception filter" data-type="indexterm" id="id2350"/>You can specify an <em>exception filter</em> in a <code>catch</code> clause by adding a <code>when</code> clause:</p>
<pre data-type="programlisting">catch (WebException ex) <strong>when (ex.Status == WebExceptionStatus.Timeout)</strong>
{
  ...
}</pre>
<p>If a <code>WebException</code> is thrown in this example, the Boolean expression following the <code>when</code> keyword is then evaluated. If the result is false, the <code>catch</code> block in question is ignored and any subsequent <code>catch</code> clauses are considered. With exception filters, it can be meaningful to catch the same exception type again:</p>
<pre data-type="programlisting">catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{ ... }
catch (WebException ex) when (ex.Status == WebExceptionStatus.SendFailure)
{ ... }</pre>
<p>The Boolean expression in the <code>when</code> clause can be side-effecting, such as a method that logs the exception for diagnostic purposes.<a contenteditable="false" data-primary="" data-startref="ch04.html108" data-type="indexterm" id="id2351"/><a contenteditable="false" data-primary="" data-startref="ch04.html107" data-type="indexterm" id="id2352"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The finally Block" data-type="sect2"><div class="sect2" id="the_finally_block">
<h2>The finally Block</h2>
<p><a contenteditable="false" data-primary="finally blocks" data-type="indexterm" id="id2353"/>A <code>finally</code> block always executes—regardless of whether an exception is thrown and whether the <code>try</code> block runs to completion. You typically use <code>finally</code> blocks for cleanup code.</p>
<p>A <code>finally</code> block executes after any of the following:</p>
<ul>
<li><p>A <code>catch</code> block finishes (or throws a new exception).</p></li>
<li><p>The <code>try</code> block finishes (or throws an exception for which there’s no <code>catch</code> block).</p></li>
<li><p>Control leaves the <code>try</code> block because of a <code>jump</code> statement (e.g., <code>return</code> or <code>goto</code>).</p></li>
</ul>
<p>The only things that can defeat a <code>finally</code> block are an infinite loop or the process ending abruptly.</p>
<p>A <code>finally</code> block helps add determinism to a program. In the following example, the file that we open <em>always</em> gets closed, regardless of whether:</p>
<ul class="pagebreak-before">
<li><p>The <code>try</code> block finishes normally.</p></li>
<li><p>Execution returns early because the file is empty (<code>EndOfStream</code>).</p></li>
<li><p>An <code>IOException</code> is thrown while reading the file:</p></li>
</ul>
<pre data-type="programlisting">void ReadFile()
{
  StreamReader reader = null;    // In System.IO namespace
  try
  {
    reader = File.OpenText ("file.txt");
    if (reader.EndOfStream) <strong>return</strong>;
    Console.WriteLine (reader.ReadToEnd());
  }
  finally
  {
    if (reader != null) reader.Dispose();
  }
}</pre>
<p>In this example, we closed the file by calling <code>Dispose</code> on the <code>StreamReader</code>. Calling <code>Dispose</code> on an object, within a <code>finally</code> block, is a standard convention and is supported explicitly in C# through the <code>using</code> statement.</p>
<section data-pdf-bookmark="The using statement" data-type="sect3"><div class="sect3" id="the_using_statement">
<h3>The using statement</h3>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="using statement" data-type="indexterm" id="id2354"/>Many classes encapsulate unmanaged resources, such as file handles, graphics handles, or database connections. <a contenteditable="false" data-primary="System..." data-secondary="System.IDisposable" data-type="indexterm" id="id2355"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="finally block" data-type="indexterm" id="id2356"/>These classes implement <code>System.IDisposable</code>, which defines a single parameterless method named <code>Dispose</code> to clean up these resources. The <code>using</code> statement provides an elegant syntax for calling <code>Dispose</code> on an <code>IDisposable</code> object within a <code>finally</code> block.</p>
<p>Thus</p>
<pre data-type="programlisting"><strong>using</strong> (StreamReader reader = File.OpenText ("file.txt"))
{
  ...
}</pre>
<p>is precisely equivalent to the following:</p>
<pre data-type="programlisting">{
  StreamReader reader = File.OpenText ("file.txt");
  try
  {
    ...
  }
  finally
  {
    if (reader != null)
      ((IDisposable)reader).Dispose();
  }
}</pre>
</div></section>
<section data-pdf-bookmark="using declarations" data-type="sect3"><div class="sect3" id="using_declarations-id000100">
<h3>using declarations</h3>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="using declarations" data-type="indexterm" id="id2357"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="using declarations" data-type="indexterm" id="id2358"/><a contenteditable="false" data-primary="using declarations" data-type="indexterm" id="id2359"/>If you omit the brackets and statement block following a <code>using</code> statement (C# 8+), it becomes a <em>using declaration</em>. The resource is then disposed when execution falls outside the <em>enclosing</em> statement block:</p>
<pre data-type="programlisting">if (File.Exists ("file.txt"))
<strong>{</strong>
  <strong>using var reader = File.OpenText ("file.txt");</strong>
  Console.WriteLine (reader.ReadLine());
  ...
<strong>}</strong></pre>
<p>In this case, <code>reader</code> will be disposed when execution falls outside the <code>if</code> statement block.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Throwing Exceptions" data-type="sect2"><div class="sect2" id="throwing_exceptions">
<h2>Throwing Exceptions</h2>
<p><a contenteditable="false" data-primary="exceptions" data-seealso="try statements and exceptions" data-type="indexterm" id="ch04.html109"/><a contenteditable="false" data-primary="exceptions" data-secondary="throwing" data-type="indexterm" id="ch04.html1010"/><a contenteditable="false" data-primary="throwing exceptions" data-type="indexterm" id="ch04.html1011"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="throwing exceptions" data-type="indexterm" id="ch04.html1012"/>Exceptions can be thrown either by the runtime or in user code. In this example, <code>Display</code> throws a <code>System.ArgumentNullException</code>:</p>
<pre data-type="programlisting">try { Display (null); }
catch (ArgumentNullException ex)
{
  Console.WriteLine ("Caught the exception");
}

void Display (string name)
{
  if (name == null)
    <strong>throw new ArgumentNullException (nameof (name));</strong>

  Console.WriteLine (name);
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because null-checking an argument and throwing an <code>ArgumentNullException</code> is such a common code path, there’s actually a shortcut for it, from .NET 6:</p>
<pre data-type="programlisting">void Display (string name)
{
  <strong>ArgumentNullException.ThrowIfNull</strong> (name);
  Console.WriteLine (name);
}</pre>
<p>Notice that we didn’t need to specify the name of the parameter. We’ll explain why later, in <a data-type="xref" href="#callerargumentexpression-id00054">“CallerArgumentExpression”</a>.</p>
</div>
<section data-pdf-bookmark="throw expressions" data-type="sect3"><div class="sect3" id="throw_expressions-id00096">
<h3>throw expressions</h3>
<p><a contenteditable="false" data-primary="throw expressions" data-type="indexterm" id="id2360"/><a contenteditable="false" data-primary="throwing exceptions" data-secondary="throw expressions" data-type="indexterm" id="id2361"/><code>throw</code> can also appear as an expression in expression-bodied functions:</p>
<pre data-type="programlisting">public string Foo() =&gt; <strong>throw new NotImplementedException()</strong>;</pre>
<p>A <code>throw</code> expression can also appear in a ternary conditional expression:</p>
<pre data-type="programlisting">string ProperCase (string value) =&gt;
  value == null ? <strong>throw new ArgumentException ("value")</strong> :
  value == "" ? "" :
  char.ToUpper (value[0]) + value.Substring (1);</pre>
</div></section>
<section data-pdf-bookmark="Rethrowing an exception" data-type="sect3"><div class="sect3" id="rethrowing_an_exception">
<h3>Rethrowing an exception</h3>
<p><a contenteditable="false" data-primary="throwing exceptions" data-secondary="rethrowing exceptions" data-type="indexterm" id="id2362"/>You can capture and rethrow an exception as follows:</p>
<pre data-type="programlisting">try {  ...  }
catch (Exception ex)
{
  // Log error
  ...
  <strong>throw;          // Rethrow same exception</strong>
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If we replaced <code>throw</code> with <code>throw ex</code>, the example would still work, but the <code>StackTrace</code> property of the newly propagated exception would no longer reflect the original error.</p>
</div>
<p>Rethrowing in this manner lets you log an error without <em>swallowing</em> it. It also lets you back out of handling an exception should circumstances turn out to be beyond what you expected. The other common scenario is to rethrow a more specific exception type:</p>
<pre data-type="programlisting">try
{
  ... // Parse a DateTime from XML element data
}
catch (FormatException ex)
{
  throw new XmlException ("Invalid DateTime", ex);
}</pre>
<p>Notice that when we constructed <code>XmlException</code>, we passed in the original exception, <code>ex</code>, as the second argument. This argument populates the <code>InnerException</code> property of the new exception and aids debugging. Nearly all types of exception offer a similar constructor.</p>
<p>Rethrowing a <em>less</em>-specific exception is something you might do when crossing a trust boundary, so as not to leak technical information to potential hackers.<a contenteditable="false" data-primary="" data-startref="ch04.html1012" data-type="indexterm" id="id2363"/><a contenteditable="false" data-primary="" data-startref="ch04.html1011" data-type="indexterm" id="id2364"/><a contenteditable="false" data-primary="" data-startref="ch04.html1010" data-type="indexterm" id="id2365"/><a contenteditable="false" data-primary="" data-startref="ch04.html109" data-type="indexterm" id="id2366"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Key Properties of System.Exception" data-type="sect2"><div class="sect2" id="key_properties_of_systemdotexception">
<h2>Key Properties of System.Exception</h2>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Exception" data-type="indexterm" id="id2367"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="key properties of System.Exception" data-type="indexterm" id="id2368"/>The most important properties of <code>System.Exception</code> are the following:</p>
<dl>
<dt><code>StackTrace</code></dt>
<dd>A string representing all the methods that are called from the origin of the exception to the <code>catch</code> block.</dd>
<dt><code>Message</code></dt>
<dd>A string with a description of the error.</dd>
<dt><code>InnerException</code></dt>
<dd>The inner exception (if any) that caused the outer exception. This, itself, can have another <code>InnerException</code>.</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All exceptions in C# are runtime exceptions—there is no equivalent to Java’s compile-time checked exceptions.</p>
</div>
</div></section>
<section data-pdf-bookmark="Common Exception Types" data-type="sect2"><div class="sect2" id="common_exception_types">
<h2>Common Exception Types</h2>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="common exception types" data-type="indexterm" id="id2369"/>The following exception types are used widely throughout the CLR and .NET libraries. You can throw these yourself or use them as base classes for deriving custom exception types:</p>
<dl>
<dt><code>System.ArgumentException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.ArgumentException" data-type="indexterm" id="id2370"/>Thrown when a function is called with a bogus argument. This generally indicates a program bug.</dd>
<dt><code>System.ArgumentNullException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.ArgumentNullException" data-type="indexterm" id="id2371"/>Subclass of <code>ArgumentException</code> that’s thrown when a function argument is (unexpectedly) <code>null</code>.</dd>
<dt><code>System.ArgumentOutOfRangeException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.ArgumentOutOfRangeException" data-type="indexterm" id="id2372"/>Subclass of <code>ArgumentException</code> that’s thrown when a (usually numeric) argument is too big or too small. For example, this is thrown when passing a negative number into a function that accepts only positive values.</dd>
<dt><code>System.InvalidOperationException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.InvalidOperationException" data-type="indexterm" id="id2373"/>Thrown when the state of an object is unsuitable for a method to successfully execute, regardless of any particular argument values. Examples include reading an unopened file or getting the next element from an enumerator for which the underlying list has been modified partway through the iteration.</dd>
<dt><code>System.NotSupportedException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.NotSupportedException" data-type="indexterm" id="id2374"/>Thrown to indicate that a particular functionality is not supported. A good example is calling the <code>Add</code> method on a collection for which <code>IsReadOnly</code> returns <code>true</code>.</dd>
<dt><code>System.NotImplementedException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.NotImplementedException" data-type="indexterm" id="id2375"/>Thrown to indicate that a function has not yet been implemented.</dd>
<dt><code>System.ObjectDisposedException</code></dt>
<dd><a contenteditable="false" data-primary="System..." data-secondary="System.ObjectDisposedException" data-type="indexterm" id="id2376"/>Thrown when the object upon which the function is called has been disposed.</dd>
</dl>
<p><a contenteditable="false" data-primary="NullReferenceException" data-type="indexterm" id="id2377"/>Another commonly encountered exception type is <code>NullReferenceException</code>. The CLR throws this exception when you attempt to access a member of an object whose value is <code>null</code> (indicating a bug in your code). You can throw a <code>NullReferenceException</code> directly (for testing purposes) as follows:</p>
<pre data-type="programlisting">throw null;</pre>
</div></section>
<section data-pdf-bookmark="The TryXXX Method Pattern" data-type="sect2"><div class="sect2" id="the_tryxxx_method_pattern">
<h2>The TryXXX Method Pattern</h2>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="TryXXX method pattern" data-type="indexterm" id="id2378"/><a contenteditable="false" data-primary="TryXXX method pattern" data-type="indexterm" id="id2379"/>When writing a method, you have a choice, when something goes wrong, to return some kind of failure code or throw an exception. In general, you throw an exception when the error is outside the normal workflow—or if you expect that the immediate caller won’t be able to cope with it. Occasionally, though, it can be best to offer both choices to the consumer. An example of this is the <code>int</code> type, which defines two versions of its <code>Parse</code> method:</p>
<pre data-type="programlisting">public int Parse     (string input);
public bool TryParse (string input, out int returnValue);</pre>
<p>If parsing fails, <code>Parse</code> throws an exception; <code>TryParse</code> returns <code>false</code>.</p>
<p>You can implement this pattern by having the <code><em>XXX</em></code> method call the <code>Try<em>XXX</em></code> method as follows:</p>
<pre data-type="programlisting">public <em>return-type XXX</em> (<em>input-type</em> input)
{
  <em>return-type</em> returnValue;
  if (!Try<em>XXX</em> (input, out returnValue))
    throw new <em>YYY</em>Exception (...)
  return returnValue;
}</pre>
</div></section>
<section data-pdf-bookmark="Alternatives to Exceptions" data-type="sect2"><div class="sect2" id="alternatives_to_exceptions">
<h2>Alternatives to Exceptions</h2>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="alternatives to exceptions" data-type="indexterm" id="id2380"/>As with <code>int.TryParse</code>, a function can communicate failure by sending an error code back to the calling function via a return type or parameter. Although this can work with simple and predictable failures, it becomes clumsy when extended to unusual or unpredictable errors, polluting method signatures and creating unnecessary complexity and clutter.</p>

<p>It also cannot generalize to functions that are not methods, such as operators (e.g., the division operator) or properties. An alternative is to place the error in a common place where all functions in the call stack can see it (e.g., a static method that stores the current error per thread). This, though, requires each function to participate in an error-propagation pattern, which is cumbersome and, ironically, itself error prone.<a contenteditable="false" data-primary="" data-startref="ch04.html106" data-type="indexterm" id="id2381"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Enumeration and Iterators" data-type="sect1"><div class="sect1" id="enumeration_and_iterators">
<h1>Enumeration and Iterators</h1>
<section data-pdf-bookmark="Enumeration" data-type="sect2"><div class="sect2" id="enumeration-id00012">
<h2>Enumeration</h2>
<p><a contenteditable="false" data-primary="enumeration" data-type="indexterm" id="id2382"/><a contenteditable="false" data-primary="enumerators" data-type="indexterm" id="id2383"/>An <em>enumerator</em> is a read-only, forward-only cursor over a <em>sequence of values</em>. C# treats a type as an enumerator if it does any of the following:</p>
<ul>
<li><p>Has a public parameterless method named <code>MoveNext</code> and property called <span class="keep-together"><code>Current</code></span></p></li>
<li><p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.Generic.IEnumerator&lt;T&gt;" data-type="indexterm" id="id2384"/>Implements <code>System.Collections.Generic.IEnumerator&lt;T&gt;</code></p></li>
<li><p>Implements <code>System.Collections.IEnumerator</code></p></li>
</ul>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.IEnumerator" data-type="indexterm" id="id2385"/>The <code>foreach</code> statement iterates over an <em>enumerable</em> object. An enumerable object is the logical representation of a sequence. It is not itself a cursor but an object that produces cursors over itself. C# treats a type as enumerable if it does any of the following (the check is performed in this order):</p>
<ul>
<li><p><a contenteditable="false" data-primary="Get..." data-secondary="GetEnumerator method" data-type="indexterm" id="id2386"/>Has a public parameterless method named <code>GetEnumerator</code> that returns an enumerator</p></li>
<li><p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.Generic.IEnumerable&lt;T&gt;" data-type="indexterm" id="id2387"/>Implements <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code></p></li>
<li><p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.IEnumerable" data-type="indexterm" id="id2388"/>Implements <code>System.Collections.IEnumerable</code></p></li>
<li><p>(From C# 9) Can bind to an <em>extension method</em> named <code>GetEnumerator</code> that returns an enumerator (see <a data-type="xref" href="#extension_methods">“Extension Methods”</a>)</p></li>
</ul>
<p>The enumeration pattern is as follows:</p>
<pre data-type="programlisting">class <em>Enumerator</em>   // Typically implements IEnumerator or IEnumerator&lt;T&gt;
{
  public <em>IteratorVariableType</em> Current { get {...} }
  public bool MoveNext() {...}
}

class <em>Enumerable</em>   // Typically implements IEnumerable or IEnumerable&lt;T&gt;
{
  public <em>Enumerator</em> GetEnumerator() {...}
}</pre>
<p>Here is the high-level way of iterating through the characters in the word “beer” using a <code>foreach</code> statement:</p>
<pre data-type="programlisting">foreach (char c in "beer")
  Console.WriteLine (c);</pre>
<p>Here is the low-level way of iterating through the characters in “beer” without using a <code>foreach</code> statement:</p>
<pre data-type="programlisting">using (var enumerator = "beer".<strong>GetEnumerator()</strong>)
  while (enumerator.<strong>MoveNext()</strong>)
  {
    var element = enumerator.<strong>Current</strong>;
    Console.WriteLine (element);
  }</pre>
<p>If the enumerator implements <code>IDisposable</code>, the <code>foreach</code> statement also acts as a <code>using</code> statement, implicitly disposing the enumerator object.</p>
<p><a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a> explains the enumeration interfaces in further detail.</p>
</div></section>
<section data-pdf-bookmark="Collection Initializers and Collection Expressions" data-type="sect2"><div class="sect2" id="collection_initializers_and_collection">
<h2>Collection Initializers and Collection Expressions</h2>
<p><a contenteditable="false" data-primary="enumeration" data-secondary="collection initializers and collection expressions" data-type="indexterm" id="id2389"/>You can instantiate and populate an enumerable object in a single step via a <em>collection initializer</em>:</p>
<pre data-type="programlisting">using System.Collections.Generic;

var list = new List&lt;int&gt; <strong>{1, 2, 3}</strong>;</pre>
<p><a contenteditable="false" data-primary="C# 12" data-secondary="collection expressions" data-type="indexterm" id="id2390"/><a contenteditable="false" data-primary="collection expressions" data-type="indexterm" id="id2391"/>From C# 12, you can shorten this further with a <em>collection expression</em> (note the square brackets):</p>
<pre data-type="programlisting">using System.Collections.Generic;

List&lt;int&gt; list = <strong>[1, 2, 3]</strong>;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="target typing" data-type="indexterm" id="id2392"/>Collection expressions are <em>target-typed</em>, meaning that the type of <code>[1,2,3]</code> depends on the type to which it’s assigned (in this case, <code>List&lt;int&gt;</code>). In the following example, the target types are <code>int[]</code> and <code>Span&lt;int&gt;</code> (which we cover in <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>):</p>
<pre data-type="programlisting">int[] array = [1, 2, 3];
Span&lt;int&gt; span = [1, 2, 3];</pre>
<p>Target typing means that you can omit the type in other scenarios where the compiler can infer it, such as when calling methods:</p>
<pre data-type="programlisting">Foo ([1, 2, 3]);

void Foo (List&lt;int&gt; numbers) { ... }</pre>
</div>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.Generic" data-type="indexterm" id="id2393"/>The compiler translates this to the following:</p>
<pre data-type="programlisting">using System.Collections.Generic;

List&lt;int&gt; list = new List&lt;int&gt;();
list.Add (1);
list.Add (2);
list.Add (3);</pre>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.IEnumerable" data-type="indexterm" id="id2394"/>This requires that the enumerable object implements the <code>System.Collections.IEnumerable</code> interface, and that it has an <code>Add</code> method that has the appropriate number of parameters for the call. (With collection expressions, the compiler also supports other patterns to allow for the creation of read-only collections.)</p>
<p>You can similarly initialize dictionaries (see <a data-type="xref" href="ch07.html#dictionaries">“Dictionaries”</a>) as follows:</p>
<pre data-type="programlisting">var dict = new Dictionary&lt;int, string&gt;()
{
  { 5, "five" },
  { 10, "ten" }
};</pre>
<p class="pagebreak-before">Or, more succinctly:</p>
<pre data-type="programlisting">var dict = new Dictionary&lt;int, string&gt;()
{
  [3] = "three",
  [10] = "ten"
};</pre>
<p>The latter is valid not only with dictionaries but also with any type for which an indexer exists.</p>
</div></section>
<section data-pdf-bookmark="Iterators" data-type="sect2"><div class="sect2" id="iterators">
<h2>Iterators</h2>
<p><a contenteditable="false" data-primary="iterators" data-type="indexterm" id="ch04.html1013"/>Whereas a <code>foreach</code> statement is a <em>consumer</em> of an enumerator, an iterator is a <em>producer</em> of an enumerator. In this example, we use an iterator to return a sequence of Fibonacci numbers (where each number is the sum of the previous two):</p>
<pre data-type="programlisting">using System;
using System.Collections.Generic;

foreach (int fib in Fibs(6))
  Console.Write (fib + "  ");
}

IEnumerable&lt;int&gt; Fibs (int fibCount)
{
  for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)
  {
    <strong>yield return prevFib;</strong>
    int newFib = prevFib+curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}

OUTPUT: 1  1  2  3  5  8</pre>
<p>Whereas a <code>return</code> statement expresses, “Here’s the value you asked me to return from this method,” a <code>yield return</code> statement expresses, “Here’s the next element you asked me to yield from this enumerator.” On each <code>yield</code> statement, control is returned to the caller, but the callee’s state is maintained so that the method can continue executing as soon as the caller enumerates the next element. The lifetime of this state is bound to the enumerator such that the state can be released when the caller has finished enumerating.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="IEnumerable&lt;T&gt;" data-type="indexterm" id="id2395"/><a contenteditable="false" data-primary="IEnumerator&lt;T&gt;" data-type="indexterm" id="id2396"/>The compiler converts iterator methods into private classes that implement <code>IEnumerable&lt;T&gt;</code> and/or <code>IEnumerator&lt;T&gt;</code>. <a contenteditable="false" data-primary="MoveNext method" data-type="indexterm" id="id2397"/>The logic within the iterator block is “inverted” and spliced into the <code>MoveNext</code> method and <code>Current</code> property on the compiler-written enumerator class. This means that when you call an iterator method, all you’re doing is instantiating the compiler-written class; none of your code actually runs! Your code runs only when you start enumerating over the resultant sequence, typically with a <code>foreach</code> statement.</p>
</div>
<p>Iterators can be local methods (see <a data-type="xref" href="ch03.html#local_methods-id00077">“Local methods”</a>).<a contenteditable="false" data-primary="" data-startref="ch04.html1013" data-type="indexterm" id="id2398"/></p>
</div></section>
<section data-pdf-bookmark="Iterator Semantics" data-type="sect2"><div class="sect2" id="iterator_semantics">
<h2>Iterator Semantics</h2>
<p><a contenteditable="false" data-primary="iterators" data-secondary="semantics" data-type="indexterm" id="ch04.html1014"/>An iterator is a method, property, or indexer that contains one or more <code>yield</code> statements. An iterator must return one of the following four interfaces (otherwise, the compiler will generate an error):</p>
<pre data-type="programlisting">// Enumerable interfaces
System.Collections.IEnumerable
System.Collections.Generic.IEnumerable&lt;T&gt;

// Enumerator interfaces
System.Collections.IEnumerator
System.Collections.Generic.IEnumerator&lt;T&gt;</pre>
<p>An iterator has different semantics, depending on whether it returns an <em>enumerable</em> interface or an <em>enumerator</em> interface. We describe this in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>.</p>
<p><em>Multiple yield statements</em> are permitted:</p>
<pre data-type="programlisting">foreach (string s in Foo())
  Console.WriteLine(s);         // Prints "One","Two","Three"

IEnumerable&lt;string&gt; Foo()
{
  <strong>yield return</strong> "One";
  <strong>yield return</strong> "Two";
  <strong>yield return</strong> "Three";
}</pre>
<section data-pdf-bookmark="yield break" data-type="sect3"><div class="sect3" id="yield_break">
<h3>yield break</h3>
<p><a contenteditable="false" data-primary="iterators" data-secondary="yield break statement" data-type="indexterm" id="id2399"/><a contenteditable="false" data-primary="yield break statement" data-type="indexterm" id="id2400"/>A return statement is illegal in an iterator block; instead you must use the <code>yield break</code> statement to indicate that the iterator block should exit early, without returning more elements. We can modify <code>Foo</code> as follows to demonstrate:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; Foo (bool breakEarly)
{
  yield return "One";
  yield return "Two";

  if (breakEarly)
    <strong>yield break;</strong>

  yield return "Three";
}</pre>
</div></section>
<section data-pdf-bookmark="Iterators and try/catch/finally blocks" data-type="sect3"><div class="sect3" id="iterators_and_trysoliduscatchsolidusfin">
<h3>Iterators and try/catch/finally blocks</h3>
<p><a contenteditable="false" data-primary="catch clause" data-type="indexterm" id="id2401"/><a contenteditable="false" data-primary="iterators" data-secondary="try/catch/finally blocks" data-type="indexterm" id="id2402"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="try/catch/finally blocks" data-type="indexterm" id="id2403"/>A <code>yield return</code> statement cannot appear in a <code>try</code> block that has a <code>catch</code> clause:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; Foo()
{
  try { yield return "One"; }    // Illegal
  catch { ... }
}</pre>
<p><a contenteditable="false" data-primary="finally blocks" data-type="indexterm" id="id2404"/>Nor can <code>yield return</code> appear in a <code>catch</code> or <code>finally</code> block. These restrictions are due to the fact that the compiler must translate iterators into ordinary classes with <code>MoveNext</code>, <code>Current</code>, and <code>Dispose</code> members, and translating exception-handling blocks would create excessive complexity.</p>
<p>You can, however, yield within a <code>try</code> block that has (only) a <code>finally</code> block:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; Foo()
{
  try { yield return "One"; }    // OK
  finally { ... }
}</pre>
<p>The code in the <code>finally</code> block executes when the consuming enumerator reaches the end of the sequence or is disposed. A <code>foreach</code> statement implicitly disposes the enumerator if you break early, making this a safe way to consume enumerators. When working with enumerators explicitly, a trap is to abandon enumeration early without disposing it, circumventing the <code>finally</code> block. You can avoid this risk by wrapping explicit use of enumerators in a <code>using</code> statement:<a contenteditable="false" data-primary="" data-startref="ch04.html1014" data-type="indexterm" id="id2405"/></p>
<pre data-type="programlisting">string firstElement = null;
var sequence = Foo();
using (var enumerator = sequence.GetEnumerator())
  if (enumerator.MoveNext())
    firstElement = enumerator.Current;</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Composing Sequences" data-type="sect2"><div class="sect2" id="composing_sequences-id00005">
<h2>Composing Sequences</h2>
<p><a contenteditable="false" data-primary="iterators" data-secondary="composing sequences" data-type="indexterm" id="id2406"/>Iterators are highly composable. We can extend our example, this time to output even Fibonacci numbers only:</p>
<pre data-type="programlisting">using System;
using System.Collections.Generic;

foreach (int fib in EvenNumbersOnly (Fibs(6)))
  Console.WriteLine (fib);

IEnumerable&lt;int&gt; Fibs (int fibCount)
{
  for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)
  {
    <strong>yield return prevFib;</strong>
    int newFib = prevFib+curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}

IEnumerable&lt;int&gt; EvenNumbersOnly (IEnumerable&lt;int&gt; sequence)
{
  foreach (int x in sequence)
    if ((x % 2) == 0)
      yield return x;
}</pre>
<p>Each element is not calculated until the last moment—when requested by a <code>MoveNext()</code> operation. <a data-type="xref" href="#composing_sequences-id00056">Figure 4-1</a> shows the data requests and data output over time.</p>
<figure><div class="figure" id="composing_sequences-id00056">
<img alt="Composing sequences" src="assets/cn10_0401.png"/>
<h6><span class="label">Figure 4-1. </span>Composing sequences</h6>
</div></figure>
<p>The composability of the iterator pattern is extremely useful in LINQ; we discuss the subject again in <a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>.</p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Nullable Value Types" data-type="sect1"><div class="sect1" id="nullable_value_types">
<h1 class="less_space">Nullable Value Types</h1>
<p><a contenteditable="false" data-primary="nullable value types" data-type="indexterm" id="ch04.html1015"/>Reference types can represent a nonexistent value with a null reference. Value types, however, cannot ordinarily represent null values:</p>
<pre data-type="programlisting">string s = null;       // OK, Reference Type
int i = null;          // Compile Error, Value Type cannot be null</pre>
<p>To represent null in a value type, you must use a special construct called a <em>nullable type</em>. <a contenteditable="false" data-primary="? (question mark)" data-secondary="in nullable types" data-type="indexterm" id="id2407"/><a contenteditable="false" data-primary="question mark (?)" data-secondary="in nullable types" data-type="indexterm" id="id2408"/>A nullable type is denoted with a value type followed by the <code>?</code> symbol:</p>
<pre data-type="programlisting">int<strong>?</strong> i = null;                     // OK, Nullable Type
Console.WriteLine (i == null);     // True</pre>
<section data-pdf-bookmark="Nullable&lt;T&gt; Struct" data-type="sect2"><div class="sect2" id="nullableless_thantgreater_than_struct">
<h2>Nullable&lt;T&gt; Struct</h2>
<p><a contenteditable="false" data-primary="nullable value types" data-secondary="Nullable&lt;T&gt; struct" data-type="indexterm" id="id2409"/><a contenteditable="false" data-primary="Nullable&lt;T&gt; struct" data-type="indexterm" id="id2410"/><a contenteditable="false" data-primary="System..." data-secondary="System.Nullable&lt;T&gt;" data-type="indexterm" id="id2411"/><code>T?</code> translates into <code>System.Nullable&lt;T&gt;</code>, which is a lightweight immutable structure, having only two fields, to represent <code>Value</code> and <code>HasValue</code>. The essence of <code>System.Nullable&lt;T&gt;</code> is very simple:</p>
<pre data-type="programlisting">public struct Nullable&lt;T&gt; where T : struct
{
  public T Value {get;}
  public bool HasValue {get;}
  public T GetValueOrDefault();
  public T GetValueOrDefault (T defaultValue);
  ...
}</pre>
<p>The code</p>
<pre data-type="programlisting">int? i = null;
Console.WriteLine (i == null);              // True</pre>
<p>translates to the following:</p>
<pre data-type="programlisting">Nullable&lt;int&gt; i = new Nullable&lt;int&gt;();
Console.WriteLine (! i.HasValue);           // True</pre>
<p>Attempting to retrieve <code>Value</code> when <code>HasValue</code> is false throws an <code>InvalidOperatio⁠n​Exception</code>. <code>GetValueOrDefault()</code> returns <code>Value</code> if <code>HasValue</code> is true; otherwise, it returns <code>new T()</code> or a specified custom default value.</p>
<p>The default value of <code>T?</code> is <code>null</code>.</p>
</div></section>
<section data-pdf-bookmark="Implicit and Explicit Nullable Conversions" data-type="sect2"><div class="sect2" id="implicit_and_explicit_nullable_conversi">
<h2>Implicit and Explicit Nullable Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="implicit/explicit nullable conversions" data-type="indexterm" id="id2412"/><a contenteditable="false" data-primary="nullable value types" data-secondary="implicit/explicit nullable conversions" data-type="indexterm" id="id2413"/>The conversion from <code>T</code> to <code>T?</code> is implicit, whereas from <code>T?</code> to <code>T</code> the conversion is explicit:</p>
<pre data-type="programlisting">int? x = 5;        // implicit
int y = (int)x;    // explicit</pre>
<p>The explicit cast is directly equivalent to calling the nullable object’s <code>Value</code> property. Hence, an <code>InvalidOperationException</code> is thrown if <code>HasValue</code> is false.</p>
</div></section>
<section data-pdf-bookmark="Boxing and Unboxing Nullable Values" data-type="sect2"><div class="sect2" id="boxing_and_unboxing_nullable_values">
<h2>Boxing and Unboxing Nullable Values</h2>
<p><a contenteditable="false" data-primary="boxing" data-secondary="nullable values" data-type="indexterm" id="id2414"/><a contenteditable="false" data-primary="nullable value types" data-secondary="boxing/unboxing nullable values" data-type="indexterm" id="id2415"/><a contenteditable="false" data-primary="unboxing" data-secondary="nullable values" data-type="indexterm" id="id2416"/>When <code>T?</code> is boxed, the boxed value on the heap contains <code>T</code>, not <code>T?</code>. This optimization is possible because a boxed value is a reference type that can already express null.</p>
<p>C# also permits the unboxing of nullable value types with the <code>as</code> operator. The result will be <code>null</code> if the cast fails:</p>
<pre data-type="programlisting">object o = "string";
int? x = o as int?;
Console.WriteLine (x.HasValue);   // False</pre>
</div></section>
<section data-pdf-bookmark="Operator Lifting" data-type="sect2"><div class="sect2" id="operator_lifting">
<h2>Operator Lifting</h2>
<p><a contenteditable="false" data-primary="nullable value types" data-secondary="operator lifting" data-type="indexterm" id="id2417"/><a contenteditable="false" data-primary="operator lifting" data-secondary="nullable value types" data-type="indexterm" id="id2418"/>The <code>Nullable&lt;T&gt;</code> struct does not define operators such as <code>&lt;</code>, <code>&gt;</code>, or even <code>==</code>. Despite this, the following code compiles and executes correctly:</p>
<pre data-type="programlisting">int? x = 5;
int? y = 10;
bool b = x &lt; y;      // true</pre>
<p>This works because the compiler borrows or “lifts” the less-than operator from the underlying value type. Semantically, it translates the preceding comparison expression into this:</p>
<pre data-type="programlisting">bool b = (x.HasValue &amp;&amp; y.HasValue) ? (x.Value &lt; y.Value) : false;</pre>
<p>In other words, if both <code>x</code> and <code>y</code> have values, it compares via <code>int</code>’s less-than operator; otherwise, it returns <code>false</code>.</p>
<p>Operator lifting means that you can implicitly use <code>T</code>’s operators on <code>T?</code>. You can define operators for <code>T?</code> in order to provide special-purpose null behavior, but in the vast majority of cases, it’s best to rely on the compiler automatically applying systematic nullable logic for you. Here are some examples:</p>
<pre data-type="programlisting">int? x = 5;
int? y = null;

// Equality operator examples
Console.WriteLine (x == y);    // False
Console.WriteLine (x == null); // False
Console.WriteLine (x == 5);    // True
Console.WriteLine (y == null); // True
Console.WriteLine (y == 5);    // False
Console.WriteLine (y != 5);    // True

// Relational operator examples
Console.WriteLine (x &lt; 6);     // True
Console.WriteLine (y &lt; 6);     // False
Console.WriteLine (y &gt; 6);     // False

// All other operator examples
Console.WriteLine (x + 5);     // 10
Console.WriteLine (x + y);     // <em>null</em> (prints empty line)</pre>
<p>The compiler performs null logic differently depending on the category of operator. The following sections explain these different rules.</p>
<section data-pdf-bookmark="Equality operators (== and !=)" data-type="sect3"><div class="sect3" id="equality_operators_left_parenthesisequa">
<h3>Equality operators (== and !=)</h3>
<p><a contenteditable="false" data-primary="!= (inequality operator)" data-type="indexterm" id="id2419"/><a contenteditable="false" data-primary="== (equality operator)" data-secondary="operator lifting and" data-type="indexterm" id="id2420"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="operator lifting and" data-type="indexterm" id="id2421"/><a contenteditable="false" data-primary="inequality operator (!=)" data-type="indexterm" id="id2422"/><a contenteditable="false" data-primary="operator lifting" data-secondary="equality operators (== and !=)" data-type="indexterm" id="id2423"/>Lifted equality operators handle nulls just like reference types do. This means that two null values are equal:</p>
<pre data-type="programlisting">Console.WriteLine (       <strong>null</strong> ==        <strong>null</strong>);   // True
Console.WriteLine ((bool?)<strong>null</strong> == (bool?)<strong>null</strong>);   // True</pre>
<p>Further:</p>
<ul>
<li><p>If exactly one operand is null, the operands are unequal.</p></li>
<li><p>If both operands are non-null, their <code>Value</code>s are compared.</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Relational operators (&lt;, &lt;=,  &gt;=, &gt;)" data-type="sect3"><div class="sect3" id="relational_operators_left_parenthesisle">
<h3>Relational operators (&lt;, &lt;=,  &gt;=, &gt;)</h3>
<p><a contenteditable="false" data-primary="operator lifting" data-secondary="relational operators" data-type="indexterm" id="id2424"/><a contenteditable="false" data-primary="relational operators" data-type="indexterm" id="id2425"/>The relational operators work on the principle that it is meaningless to compare null operands. This means that comparing a null value to either a null or a non-null value returns <code>false</code>:</p>
<pre data-type="programlisting">bool b = x &lt; y;    // Translation:

bool b = (x.HasValue &amp;&amp; y.HasValue) 
         ? (x.Value &lt; y.Value)
         : false;

// b is false (assuming x is 5 and y is null)</pre>
</div></section>
<section data-pdf-bookmark="All other operators (+, −, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;, +, ++, --, !, ~)" data-type="sect3"><div class="sect3" id="all_other_operators_left_parenthesisplu">
<h3>All other operators (+, −, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;, +, ++, --, !, ~)</h3>
<p>These operators return null when any of the operands are null. This pattern should be familiar to SQL users:</p>
<pre data-type="programlisting">int? c = x + y;   // Translation:

int? c = (x.HasValue &amp;&amp; y.HasValue)
         ? (int?) (x.Value + y.Value) 
         : null;

// c is null (assuming x is 5 and y is null)</pre>
<p>An exception is when the <code>&amp;</code> and <code>|</code> operators are applied to <code>bool?</code>, which we discuss shortly.</p>
</div></section>
<section data-pdf-bookmark="Mixing nullable and non-nullable types" data-type="sect3"><div class="sect3" id="mixing_nullable_and_non_nullable_types">
<h3>Mixing nullable and non-nullable types</h3>
<p><a contenteditable="false" data-primary="operator lifting" data-secondary="mixing nullable and non-nullable operators" data-type="indexterm" id="id2426"/>You can mix and match nullable and non-nullable value types (this works because there is an implicit conversion from <code>T</code> to <code>T?</code>):</p>
<pre data-type="programlisting">int? a = null;
int b = 2;
int? c = a + b;   // c is null - equivalent to a + (int?)b</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="bool? with &amp; and | Operators" data-type="sect2"><div class="sect2" id="boolquestion_mark_with_ampersand_and_ve">
<h2>bool? with &amp; and | Operators</h2>
<p><a contenteditable="false" data-primary="&amp; (ampersand)" data-secondary="bool? with &amp; operator" data-type="indexterm" id="id2427"/><a contenteditable="false" data-primary="| (vertical bar)" data-secondary="bool? with | operator" data-type="indexterm" id="id2428"/><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="bool? with &amp; operator" data-type="indexterm" id="id2429"/><a contenteditable="false" data-primary="nullable value types" data-secondary="bool? with &amp; and | operators" data-type="indexterm" id="id2430"/><a contenteditable="false" data-primary="vertical bar (|)" data-secondary="bool? with | operator" data-type="indexterm" id="id2431"/>When supplied operands of type <code>bool?</code> the <code>&amp;</code> and <code>|</code> operators treat <code>null</code> as an <em>unknown value</em>. So, <code>null | true</code> is true because:</p>
<ul>
<li><p>If the unknown value is false, the result would be true.</p></li>
<li><p>If the unknown value is true, the result would be true.</p></li>
</ul>
<p>Similarly, <code>null &amp; false</code> is false. This behavior should be familiar to SQL users. The following example enumerates other combinations:</p>
<pre data-type="programlisting">bool? n = null;
bool? f = false;
bool? t = true;
Console.WriteLine (n | n);    // <em>(null)</em>
Console.WriteLine (n | f);    // <em>(null)</em>
Console.WriteLine (n | t);    // True
Console.WriteLine (n &amp; n);    // <em>(null)</em>
Console.WriteLine (n &amp; f);    // False
Console.WriteLine (n &amp; t);    // <em>(null)</em></pre>
</div></section>
<section data-pdf-bookmark="Nullable Value Types and Null Operators" data-type="sect2"><div class="sect2" id="nullable_value_types_and_null_operators">
<h2>Nullable Value Types and Null Operators</h2>
<p><a contenteditable="false" data-primary="null operators" data-type="indexterm" id="id2432"/><a contenteditable="false" data-primary="nullable value types" data-secondary="null operators and" data-type="indexterm" id="id2433"/>Nullable value types work particularly well with the <code>??</code> operator (see <a data-type="xref" href="ch02.html#null_coalescing_operator">“Null-Coalescing Operator”</a>), as illustrated in this example:</p>
<pre data-type="programlisting">int? x = null;
int y = x ?? 5;        // y is 5

int? a = null, b = 1, c = 2;
Console.WriteLine (a ?? b ?? c);  // 1 <em>(first non-null value)</em></pre>
<p>Using <code>??</code> on a nullable value type is equivalent to calling <code>GetValueOrDefault</code> with an explicit default value except that the expression for the default value is never evaluated if the variable is not null.</p>
<p><a contenteditable="false" data-primary="?? (null-coalescing operator)" data-type="indexterm" id="id2434"/><a contenteditable="false" data-primary="?. (null-conditional operator)" data-type="indexterm" id="id2435"/><a contenteditable="false" data-primary="null-coalescing operator (??)" data-type="indexterm" id="id2436"/><a contenteditable="false" data-primary="null-conditional operator (?.)" data-type="indexterm" id="id2437"/>Nullable value types also work well with the null-conditional operator (see <a data-type="xref" href="ch02.html#null_conditional_operator">“Null-Conditional Operator”</a>). In the following example, length evaluates to null:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
int? length = sb<strong>?.</strong>ToString().Length;</pre>
<p>We can combine this with the null-coalescing operator to evaluate to zero instead of null:</p>
<pre data-type="programlisting">int length = sb<strong>?.</strong>ToString().Length ?? 0;  // Evaluates to 0 if sb is null</pre>
</div></section>
<section data-pdf-bookmark="Scenarios for Nullable Value Types" data-type="sect2"><div class="sect2" id="scenarios_for_nullable_value_types">
<h2>Scenarios for Nullable Value Types</h2>
<p><a contenteditable="false" data-primary="nullable value types" data-secondary="scenarios for" data-type="indexterm" id="id2438"/>One of the most common scenarios for nullable value types is to represent unknown values. This frequently occurs in database programming, where a class is mapped to a table with nullable columns. If these columns are strings (e.g., an EmailAddress column on a Customer table), there is no problem because string is a reference type in the CLR, which can be null. However, most other SQL column types map to CLR struct types, making nullable value types very useful when mapping SQL to the CLR:</p>
<pre data-type="programlisting">// Maps to a Customer table in a database
public class Customer
{
  ...
  public decimal? AccountBalance;
}</pre>
<p><a contenteditable="false" data-primary="ambient property" data-type="indexterm" id="id2439"/>A nullable type can also be used to represent the backing field of what’s sometimes called an <em>ambient property</em>. An ambient property, if null, returns the value of its parent:</p>
<pre data-type="programlisting">public class Row
{
  ...
  Grid parent;
  Color? color;

  public Color Color
  {
    get { return color ?? parent.Color; }
    set { color = value == parent.Color ? (Color?)null : value; }
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Alternatives to Nullable Value Types" data-type="sect2"><div class="sect2" id="alternatives_to_nullable_value_types">
<h2>Alternatives to Nullable Value Types</h2>
<p><a contenteditable="false" data-primary="nullable value types" data-secondary="alternatives to" data-type="indexterm" id="id2440"/>Before nullable value types were part of the C# language (i.e., before C# 2.0), there were many strategies to deal with them, examples of which still appear in the .NET libraries for historical reasons. One of these strategies is to designate a particular non-null value as the “null value”; an example is in the string and array classes. <code>String.IndexOf</code> returns the magic value of <code>−1</code> when the character is not found:</p>
<pre data-type="programlisting">int i = "Pink".IndexOf ('b');
Console.WriteLine (i);         // −1</pre>
<p>However, <code>Array.IndexOf</code> returns <code>−1</code> only if the index is 0-bounded. The more general formula is that <code>IndexOf</code> returns one less than the lower bound of the array. In the next example, <code>IndexOf</code> returns <code>0</code> when an element is not found:</p>
<pre class="pagebreak-before" data-type="programlisting">// Create an array whose lower bound is 1 instead of 0:

Array a = Array.CreateInstance (typeof (string),
                                new int[] {2}, new int[] {1});
a.SetValue ("a", 1);
a.SetValue ("b", 2);
Console.WriteLine (Array.IndexOf (a, "c"));  // 0</pre>
<p>Nominating a “magic value” is problematic for several reasons:</p>
<ul>
<li><p>It means that each value type has a different representation of null. In contrast, nullable value types provide one common pattern that works for all value types.</p></li>
<li><p>There might be no reasonable designated value. In the previous example, −1 could not always be used. The same is true for our earlier example representing an unknown account balance.</p></li>
<li><p>Forgetting to test for the magic value results in an incorrect value that might go unnoticed until later in execution—when it pulls an unintended magic trick. Forgetting to test <code>HasValue</code> on a null value, however, throws an <code>InvalidOperationException</code> on the spot.</p></li>
<li><p>The ability for a value to be null is not captured in the <em>type</em>. Types communicate the intention of a program, allow the compiler to check for correctness, and enable a consistent set of rules enforced by the compiler.<a contenteditable="false" data-primary="" data-startref="ch04.html1015" data-type="indexterm" id="id2441"/></p></li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="Nullable Reference Types" data-type="sect1"><div class="sect1" id="nullable_reference_types-id00081">
<h1>Nullable Reference Types</h1>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="nullable reference types" data-type="indexterm" id="ch04.html1016"/><a contenteditable="false" data-primary="nullable reference types" data-type="indexterm" id="ch04.html1017"/>Whereas <em>nullable value types</em> bring nullability to value types, <em>nullable reference types</em> (C# 8+) do the opposite. <a contenteditable="false" data-primary="NullReferenceException" data-type="indexterm" id="id2442"/>When enabled, they bring (a degree of) <em>non-nullability</em> to reference types, with the purpose of helping to avoid <code>NullReferenceException</code>s.</p>
<p>Nullable reference types introduce a level of safety that’s enforced purely by the compiler, in the form of warnings when it detects code that’s at risk of generating a <code>NullReferenceException</code>.</p>
<p>To enable nullable reference types, you must either add the <code>Nullable</code> element to your <em>.csproj</em> project file (if you want to enable it for the entire project):</p>
<pre data-type="programlisting">&lt;PropertyGroup&gt;
  <strong>&lt;Nullable&gt;enable&lt;/Nullable&gt;</strong>
&lt;/PropertyGroup&gt;</pre>
<p>or/and use the following directives in your code, in the places where it should take effect:</p>
<pre data-type="programlisting">#nullable enable   // enables nullable reference types from this point on
#nullable disable  // disables nullable reference types from this point on
#nullable restore  // resets nullable reference types to project setting</pre>
<p>After being enabled, the compiler makes non-nullability the default: if you want a reference type to accept nulls without the compiler generating a warning, you must apply the <code>?</code> suffix to indicate a <em>nullable reference type</em>. In the following example, <code>s1</code> is non-nullable, whereas <code>s2</code> is nullable:</p>
<pre data-type="programlisting">#nullable enable    // Enable nullable reference types

string s1 = null;   // Generates a compiler warning!
<strong>string?</strong> s2 = null;  // OK: s2 is <em>nullable reference type</em></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because nullable reference types are compile-time constructs, there’s no runtime difference between <code>string</code> and <code>string?</code>. In contrast, nullable value types introduce something concrete into the type system, namely the <code>Nullable&lt;T&gt;</code> struct.</p>
</div>
<p>The following also generates a warning because <code>x</code> is not initialized:</p>
<pre data-type="programlisting">class Foo { string x; }</pre>
<p>The warning disappears if you initialize <code>x</code>, either via a field initializer or via code in the constructor.</p>
<section data-pdf-bookmark="The Null-Forgiving Operator" data-type="sect2"><div class="sect2" id="the_null_forgiving_operator">
<h2>The Null-Forgiving Operator</h2>
<p><a contenteditable="false" data-primary="! (null-forgiving operator)" data-type="indexterm" id="id2443"/><a contenteditable="false" data-primary="null-forgiving operator (!)" data-type="indexterm" id="id2444"/><a contenteditable="false" data-primary="nullable reference types" data-secondary="null-forgiving operator" data-type="indexterm" id="id2445"/>The compiler also warns you upon dereferencing a nullable reference type, if it thinks a <code>NullReferenceException</code> might occur. In the following example, accessing the string’s <code>Length</code> property generates a warning:</p>
<pre data-type="programlisting">void Foo (<strong>string?</strong> s) =&gt; Console.Write (<strong>s.Length</strong>);</pre>
<p>You can remove the warning with the <em>null-forgiving operator</em> (<code>!</code>):</p>
<pre data-type="programlisting">void Foo (string? s) =&gt; Console.Write (<strong>s!.Length</strong>);</pre>
<p>Our use of the null-forgiving operator in this example is dangerous in that we could end up throwing the very <code>NullReferenceException</code> we were trying to avoid in the first place. We could fix it as follows:</p>
<pre data-type="programlisting">void Foo (string? s)
{
  if (s != null) Console.Write (s.Length);
}</pre>
<p>Notice now that we don’t need the null-forgiving operator. This is because the compiler performs <em>static flow analysis</em> and is smart enough to infer—at least in simple cases—when a dereference is safe and there’s no chance of a <code>NullReferenceException</code>.</p>
<p>The compiler’s ability to detect and warn is not bulletproof, and there are also limits to what’s possible in terms of coverage. For instance, it’s unable to know whether an array’s elements have been populated, and so the following does not generate a warning:</p>
<pre data-type="programlisting">var strings = new string[10];
Console.WriteLine (strings[0].Length);</pre>
</div></section>
<section data-pdf-bookmark="Separating the Annotation and Warning Contexts" data-type="sect2"><div class="sect2" id="separating_the_annotation_and_warning_c">
<h2>Separating the Annotation and Warning Contexts</h2>
<p><a contenteditable="false" data-primary="#nullable enable directive" data-primary-sortas="nullable" data-type="indexterm" id="id2446"/>Enabling nullable reference types via the <code>#nullable enable</code> directive (or the <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> project setting) does two things:</p>
<ul>
<li><p><a contenteditable="false" data-primary="nullable annotation context" data-type="indexterm" id="id2447"/>It enables the <em>nullable annotation context</em>, which tells the compiler to treat all reference-type variable declarations as non-nullable unless suffixed by the <code>?</code> symbol.</p></li>
<li><p><a contenteditable="false" data-primary="nullable reference types" data-secondary="separating annotation and warning contexts" data-type="indexterm" id="id2448"/>It enables the <em>nullable warning context</em>, which tells the compiler to generate warnings upon encountering code at risk of throwing a <code>NullReference​Excep⁠tion</code>.</p></li>
</ul>
<p>It can sometimes be useful to separate these two concepts and enable <em>just</em> the annotation context, or (less usefully) <em>just</em> the warning context:</p>
<pre data-type="programlisting">#nullable enable <strong>annotations</strong>    // Enable the annotation context
// OR:
#nullable enable <strong>warnings</strong>       // Enable the warning context</pre>
<p>(The same trick works with <code>#nullable disable</code> and <code>#nullable restore</code>.)</p>
<p>You can also do it via the project file:</p>
<pre data-type="programlisting">&lt;Nullable&gt;<strong>annotations</strong>&lt;/Nullable&gt;
&lt;!-- OR --&gt;
&lt;Nullable&gt;<strong>warnings</strong>&lt;/Nullable&gt;</pre>
<p>Enabling just the annotation context for a particular class or assembly can be a good first step in introducing nullable reference types into a legacy codebase. By correctly annotating public members, you ensure your class or assembly can act as a “good citizen” to other classes or assemblies—so that <em>they</em> can benefit fully from nullable reference types—without having to deal with warnings in your own class or assembly.</p>
</div></section>
<section data-pdf-bookmark="Treating Nullable Warnings as Errors" data-type="sect2"><div class="sect2" id="treating_nullable_warnings_as_errors">
<h2>Treating Nullable Warnings as Errors</h2>
<p><a contenteditable="false" data-primary="nullable reference types" data-secondary="treating nullable warnings as errors" data-type="indexterm" id="id2449"/>In greenfield projects, it makes sense to fully enable the nullable context from the outset. You might want to take the additional step of treating nullable warnings as errors so that your project cannot compile until all null warnings have been resolved:<a contenteditable="false" data-primary="" data-startref="ch04.html1017" data-type="indexterm" id="id2450"/><a contenteditable="false" data-primary="" data-startref="ch04.html1016" data-type="indexterm" id="id2451"/></p>
<pre data-type="programlisting">&lt;PropertyGroup&gt;
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
  <strong>&lt;WarningsAsErrors&gt;CS8600;CS8602;CS8603&lt;/WarningsAsErrors&gt;</strong>
&lt;/PropertyGroup&gt;</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Extension Methods" data-type="sect1"><div class="sect1" id="extension_methods">
<h1>Extension Methods</h1>
<p><a contenteditable="false" data-primary="extension methods" data-type="indexterm" id="ch04.html1018"/><a contenteditable="false" data-primary="static classes" data-type="indexterm" id="ch04.html1019"/><a contenteditable="false" data-primary="static methods" data-type="indexterm" id="ch04.html1020"/><a contenteditable="false" data-primary="type system, C#" data-secondary="extension methods" data-type="indexterm" id="ch04.html1021"/>Extension methods allow an existing type to be extended with new methods without altering the definition of the original type. An extension method is a static method of a static class, where the <code>this</code> modifier is applied to the first parameter. The type of the first parameter will be the type that is extended:</p>
<pre data-type="programlisting">public static class StringHelper
{
  public static bool IsCapitalized (this string s)
  {
    if (string.IsNullOrEmpty(s)) return false;
    return char.IsUpper (s[0]);
  }
}</pre>
<p>The <code>IsCapitalized</code> extension method can be called as though it were an instance method on a string, as follows:</p>
<pre data-type="programlisting">Console.WriteLine ("Perth".IsCapitalized());</pre>
<p>An extension method call, when compiled, is translated back into an ordinary static method call:</p>
<pre data-type="programlisting">Console.WriteLine (StringHelper.IsCapitalized ("Perth"));</pre>
<p>The translation works as follows:</p>
<pre data-type="programlisting">arg0.Method (arg1, arg2, ...);              // Extension method call
StaticClass.Method (arg0, arg1, arg2, ...); // Static method call</pre>
<p>Interfaces can be extended, too:</p>
<pre data-type="programlisting">public static T First&lt;T&gt; (this <strong>IEnumerable&lt;T&gt;</strong> sequence)
{
  foreach (T element in sequence)
    return element;

  throw new InvalidOperationException ("No elements!");
}
...
Console.WriteLine ("Seattle".First());   // S</pre>
<section data-pdf-bookmark="Extension Method Chaining" data-type="sect2"><div class="sect2" id="extension_method_chaining">
<h2>Extension Method Chaining</h2>
<p><a contenteditable="false" data-primary="chaining" data-secondary="extension methods" data-type="indexterm" id="id2452"/><a contenteditable="false" data-primary="extension methods" data-secondary="chaining" data-type="indexterm" id="id2453"/>Extension methods, like instance methods, provide a tidy way to chain functions. Consider the following two functions:</p>
<pre data-type="programlisting">public static class StringHelper
{
  public static string Pluralize (this string s) {...}
  public static string Capitalize (this string s) {...}
}</pre>
<p><code>x</code> and <code>y</code> are equivalent, and both evaluate to <code>"Sausages"</code>, but <code>x</code> uses extension methods, whereas <code>y</code> uses static methods:</p>
<pre data-type="programlisting">string x = "sausage".Pluralize().Capitalize();
string y = StringHelper.Capitalize (StringHelper.Pluralize ("sausage"));</pre>
</div></section>
<section data-pdf-bookmark="Ambiguity and Resolution" data-type="sect2"><div class="sect2" id="ambiguity_and_resolution">
<h2>Ambiguity and Resolution</h2>
<section data-pdf-bookmark="Namespaces" data-type="sect3"><div class="sect3" id="namespaces-id00080">
<h3>Namespaces</h3>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="ambiguity and resolution" data-type="indexterm" id="id2454"/><a contenteditable="false" data-primary="extension methods" data-secondary="namespaces" data-type="indexterm" id="id2455"/><a contenteditable="false" data-primary="namespaces" data-secondary="extension methods and" data-type="indexterm" id="id2456"/>An extension method cannot be accessed unless its class is in scope, typically by its namespace being imported. Consider the extension method <code>IsCapitalized</code> in the following example:</p>
<pre data-type="programlisting">using System;

namespace Utils
{
  public static class StringHelper
  {
    public static bool <strong>IsCapitalized</strong> (this string s)
    {
      if (string.IsNullOrEmpty(s)) return false;
      return char.IsUpper (s[0]);
    }
  }
}</pre>
<p>To use <code>IsCapitalized</code>, the following application must import <code>Utils</code> in order to avoid a compile-time error:</p>
<pre data-type="programlisting">namespace MyApp
{
  <strong>using Utils;</strong>

  class Test
  {
    static void Main() =&gt; Console.WriteLine ("Perth".IsCapitalized());
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Extension methods versus instance methods" data-type="sect3"><div class="sect3" id="extension_methods_versus_instance_metho">
<h3>Extension methods versus instance methods</h3>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="instance methods versus" data-type="indexterm" id="id2457"/><a contenteditable="false" data-primary="extension methods" data-secondary="precedence among" data-type="indexterm" id="id2458"/><a contenteditable="false" data-primary="instance methods" data-secondary="extension methods versus" data-type="indexterm" id="id2459"/>Any compatible instance method will always take precedence over an extension method. In the following example, <code>Test</code>’s <code>Foo</code> method will always take precedence, even when called with an argument <code>x</code> of type <code>int</code>:</p>
<pre data-type="programlisting">class Test
{
  public void Foo (<strong>object</strong> x) { }    // This method always wins
}

static class Extensions
{
  public static void Foo (this Test t, <strong>int</strong> x) { }
}</pre>
<p>The only way to call the extension method in this case is via normal static syntax, in other words, <code>Extensions.Foo(...)</code>.</p>
</div></section>
<section data-pdf-bookmark="Extension methods versus extension methods" data-type="sect3"><div class="sect3" id="extension_methods_versus_extension_meth">
<h3>Extension methods versus extension methods</h3>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="disambiguating two methods with same signature" data-type="indexterm" id="id2460"/>If two extension methods have the same signature, the extension method must be called as an ordinary static method to disambiguate the method to call. If one extension method has more specific arguments, however, the more specific method takes precedence.</p>
<p>To illustrate, consider the following two classes:</p>
<pre data-type="programlisting">static class StringHelper
{
  public static bool IsCapitalized (this <strong>string</strong> s) {...}
}
static class ObjectHelper
{
  public static bool IsCapitalized (this <strong>object</strong> s) {...}
}</pre>
<p>The following code calls <code>StringHelper</code>’s <code>IsCapitalized</code> method:</p>
<pre data-type="programlisting">bool test1 = "Perth".IsCapitalized();</pre>
<p>Classes and structs are considered more specific than interfaces.</p>
</div></section>
<section data-pdf-bookmark="Demoting an extension method" data-type="sect3"><div class="sect3" id="demoting_an_extension_method">
<h3>Demoting an extension method</h3>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="demoting" data-type="indexterm" id="id2461"/>An interesting scenario can arise when Microsoft adds an extension method to a .NET runtime library that conflicts with an extension method in some existing third-party library. As the author of the third-party library, you might want to “withdraw” your extension method, but without removing it and without breaking binary compatibility with existing consumers.</p>
<p>Fortunately, this is easy to accomplish, simply by removing the <code>this</code> keyword from your extension method’s definition. This demotes your extension method to an ordinary static method. The beauty of this solution is that any assembly that was compiled against your old library will continue to work (and bind to <em>your</em> method, as before). The reason is that extension method calls are converted to static method calls during compilation.</p>
<p>Consumers will be affected by your demotion only when they recompile, at which time calls to your former extension method will bind to Microsoft’s version (if the namespace has been imported). Should the consumer still want to call your method, they can do so by invoking it as a static method.<a contenteditable="false" data-primary="" data-startref="ch04.html1021" data-type="indexterm" id="id2462"/><a contenteditable="false" data-primary="" data-startref="ch04.html1020" data-type="indexterm" id="id2463"/><a contenteditable="false" data-primary="" data-startref="ch04.html1019" data-type="indexterm" id="id2464"/><a contenteditable="false" data-primary="" data-startref="ch04.html1018" data-type="indexterm" id="id2465"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Anonymous Types" data-type="sect1"><div class="sect1" id="anonymous_types">
<h1>Anonymous Types</h1>
<p><a contenteditable="false" data-primary="anonymous types" data-type="indexterm" id="id2466"/><a contenteditable="false" data-primary="classes" data-secondary="anonymous types" data-type="indexterm" id="id2467"/><a contenteditable="false" data-primary="type system, C#" data-secondary="anonymous types" data-type="indexterm" id="id2468"/>An anonymous type is a simple class created by the compiler on the fly to store a set of values. To create an anonymous type, use the <code>new</code> keyword followed by an object initializer, specifying the properties and values the type will contain; for example:</p>
<pre data-type="programlisting">var dude = new { Name = "Bob", Age = 23 };</pre>
<p>The compiler translates this to (approximately) the following:</p>
<pre data-type="programlisting">internal class AnonymousGeneratedTypeName
{
  private string name;  // Actual field name is irrelevant
  private int    age;   // Actual field name is irrelevant

  public AnonymousGeneratedTypeName (string name, int age)
  {
    this.name = name; this.age = age;
  }

  public string  Name =&gt; name;
  public int     Age  =&gt; age;

  // The Equals and GetHashCode methods are overridden (see <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>).
  // The ToString method is also overridden.
}
...

var dude = new AnonymousGeneratedTypeName ("Bob", 23);</pre>
<p>You must use the <code>var</code> keyword to reference an anonymous type because it doesn’t have a name.</p>
<p>The property name of an anonymous type can be inferred from an expression that is itself an identifier (or ends with one); thus</p>
<pre data-type="programlisting">int <strong>Age</strong> = 23;
var dude = new { Name = "Bob", <strong>Age,</strong> Age.ToString().<strong>Length</strong> };</pre>
<p>is equivalent to the following:</p>
<pre data-type="programlisting">var dude = new { Name = "Bob", <strong>Age =</strong> Age<strong>, Length =</strong> Age.ToString().Length };</pre>
<p>Two anonymous type instances declared within the same assembly will have the same underlying type if their elements are named and typed identically:</p>
<pre data-type="programlisting">var a1 = new { X = 2, Y = 4 };
var a2 = new { X = 2, Y = 4 };
Console.WriteLine (a1.GetType() == a2.GetType());   // True</pre>
<p>Additionally, the <code>Equals</code> method is overridden to perform <em>structural equality comparison</em> (comparison of the data):</p>
<pre data-type="programlisting">Console.WriteLine (a1.Equals (a2));   // True</pre>
<p>Whereas the equality operator (<code>==</code>) performs referential comparison:</p>
<pre data-type="programlisting">Console.WriteLine (a1 == a2);         // False</pre>
<p>You can create arrays of anonymous types as follows:</p>
<pre data-type="programlisting">var dudes = new[]
{
  new { Name = "Bob", Age = 30 },
  new { Name = "Tom", Age = 40 }
};</pre>
<p>A method cannot (usefully) return an anonymously typed object, because it is illegal to write a method whose return type is <code>var</code>:</p>
<pre data-type="programlisting"><strong>var</strong> Foo() =&gt; new { Name = "Bob", Age = 30 };  // Not legal!</pre>
<p>(In the following sections, we will describe records and tuples, which offer alternative approaches for returning multiple values from a method.)</p>
<p>Anonymous types are immutable, so instances cannot be modified after creation. However, from C# 10, you can use the <code>with</code> keyword to create a copy with variations (<em>nondestructive mutation</em>):</p>
<pre data-type="programlisting">var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 <strong>with { E = 10 }</strong>; 
Console.WriteLine (a2);      // { A = 1, B = 2, C = 3, D = 4, <strong>E = 10</strong> }</pre>
<p>Anonymous types are particularly useful when writing LINQ queries (see <a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>).</p>
</div></section>
<section data-pdf-bookmark="Tuples" data-type="sect1"><div class="sect1" id="tuples-id00099">
<h1>Tuples</h1>
<p><a contenteditable="false" data-primary="tuples" data-type="indexterm" id="ch04.html1022"/>Like anonymous types, tuples provide a simple way to store a set of values. Tuples were introduced into C# with the main purpose of allowing methods to return multiple values without resorting to <code>out</code> parameters (something you cannot do with anonymous types). Since then, however, <em>records</em> have been introduced, offering a concise typed approach that we will describe in the following section.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Tuples do almost everything that anonymous types do and have the potential advantage of being value types, but they suffer—as you’ll see soon—from runtime type erasure with named elements.</p>
</div>
<p><a contenteditable="false" data-primary="tuple literal" data-type="indexterm" id="id2469"/>The simplest way to create a <em>tuple literal</em> is to list the desired values in parentheses. This creates a tuple with <em>unnamed</em> elements, which you refer to as <code>Item1</code>, <code>Item2</code>, and so on:</p>
<pre data-type="programlisting">var bob = <strong>("Bob", 23)</strong>;    // Allow compiler to infer the element types

Console.WriteLine (bob.Item1);   // Bob
Console.WriteLine (bob.Item2);   // 23</pre>
<p>Tuples are <em>value types</em>, with <em>mutable</em> (read/write) elements:</p>
<pre data-type="programlisting">var joe = bob;                 // joe is a *copy* of bob
joe.Item1 = "Joe";             // Change joe’s Item1 from Bob to Joe
Console.WriteLine (bob);       // (Bob, 23)
Console.WriteLine (joe);       // (Joe, 23)</pre>
<p><a contenteditable="false" data-primary="tuple types" data-type="indexterm" id="id2470"/>Unlike with anonymous types, you can specify a <em>tuple type</em> explicitly. Just list each of the element types in parentheses:</p>
<pre data-type="programlisting"><strong>(string,int)</strong> bob  = ("Bob", 23);</pre>
<p class="pagebreak-before">This means that you can usefully return a tuple from a method:</p>
<pre data-type="programlisting"><strong>(string,int)</strong> person = GetPerson();  // Could use 'var' instead if we want
Console.WriteLine (person.Item1);   // Bob
Console.WriteLine (person.Item2);   // 23

<strong>(string,int)</strong> GetPerson() =&gt; <strong>("Bob", 23)</strong>;</pre>
<p>Tuples play well with generics, so the following types are all legal:</p>
<pre data-type="programlisting">Task&lt;(string,int)&gt;
Dictionary&lt;(string,int),Uri&gt;
IEnumerable&lt;(int id, string name)&gt;   // See below for naming elements</pre>
<section data-pdf-bookmark="Naming Tuple Elements" data-type="sect2"><div class="sect2" id="naming_tuple_elements">
<h2>Naming Tuple Elements</h2>
<p><a contenteditable="false" data-primary="tuples" data-secondary="naming tuple elements" data-type="indexterm" id="id2471"/><a contenteditable="false" data-primary="tuples" data-secondary="ValueTuple.Create" data-type="indexterm" id="id2472"/><a contenteditable="false" data-primary="ValueTuple.Create" data-type="indexterm" id="id2473"/>You can optionally give meaningful names to elements when creating tuple literals:</p>
<pre data-type="programlisting">var tuple = (<strong>name:</strong>"Bob", <strong>age:</strong>23);

Console.WriteLine (tuple.<strong>name</strong>);     // Bob
Console.WriteLine (tuple.<strong>age</strong>);      // 23</pre>
<p>You can do the same when specifying <em>tuple types</em>:</p>
<pre data-type="programlisting">var person = GetPerson();
Console.WriteLine (person.<strong>name</strong>);    // Bob
Console.WriteLine (person.<strong>age</strong>);     // 23

(string <strong>name</strong>, int <strong>age)</strong> GetPerson() =&gt; ("Bob", 23);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In <a data-type="xref" href="#records-id00087">“Records”</a>, we’ll show how you can define simple classes or structs noiselessly, making it effortless to define a formal return type:</p>
<pre data-type="programlisting">var person = GetPerson();
Console.WriteLine (person.Name);    // Bob
Console.WriteLine (person.Age);     // 23

Person GetPerson() =&gt; new ("Bob", 23); 
<strong>record Person (string Name, int Age)</strong>;</pre>
<p>Unlike with tuples, a record’s properties (<code>Name</code> and <code>Age</code>) are strongly typed and so can easily be refactored. This approach also reduces code duplication and encourages good design in a couple of ways. First, the process of deciding on a simple noncontrived name for the type helps validate your design (an inability to do so can indicate lack of a single cohesive purpose). Second, it’s likely that you’ll end up adding methods or other code to the record (well-named types tend to <em>attract code</em>), and moving code to the data is a core principle of good object-oriented design.</p>
</div>
<p>Note that you can still treat the elements as unnamed and refer to them as <code>Item1</code>, <code>Item2</code>, etc. (although Visual Studio hides these fields from IntelliSense).</p>
<p class="pagebreak-before">Element names are automatically <em>inferred</em> from property or field names:</p>
<pre data-type="programlisting">var now = DateTime.Now;
var tuple = (now.Day, now.Month, now.Year);
Console.WriteLine (tuple.Day);               // OK</pre>
<p>Tuples are type compatible with one another if their element types match up (in order). Their element names need not:</p>
<pre data-type="programlisting">(string name, int age, char sex)  bob1 = ("Bob", 23, 'M');
(string <strong>age</strong>,  int <strong>sex</strong>, char <strong>name</strong>) bob2 = bob1;   // No error!</pre>
<p>Our particular example leads to confusing results:</p>
<pre data-type="programlisting">Console.WriteLine (bob2.name);    // M
Console.WriteLine (bob2.age);     // Bob
Console.WriteLine (bob2.sex);     // 23</pre>
<section data-pdf-bookmark="Type erasure" data-type="sect3"><div class="sect3" id="type_erasure">
<h3>Type erasure</h3>
<p><a contenteditable="false" data-primary="tuples" data-secondary="type erasure" data-type="indexterm" id="id2474"/>We stated previously that the C# compiler handles anonymous types by building custom classes with named properties for each of the elements. With tuples, C# works differently and uses a preexisting family of generic structs:</p>
<pre data-type="programlisting">public struct ValueTuple&lt;T1&gt;
public struct ValueTuple&lt;T1,T2&gt;
public struct ValueTuple&lt;T1,T2,T3&gt;
...</pre>
<p>Each of the <code>ValueTuple&lt;&gt;</code> structs has fields named <code>Item1</code>, <code>Item2</code>, and so on.</p>
<p><a contenteditable="false" data-primary="ValueTuple&lt;string,int&gt;" data-type="indexterm" id="id2475"/>Hence, <code>(string,int)</code> is an alias for <code>ValueTuple&lt;string,int&gt;</code>, and this means that named tuple elements have no corresponding property names in the underlying types. Instead, the names exist only in the source code, and in the imagination of the compiler. At runtime, the names mostly disappear, so if you decompile a program that refers to named tuple elements, you’ll see just references to <code>Item1</code>, <code>Item2</code>, and so on. Further, when you examine a tuple variable in a debugger after having assigned it to an <code>object</code> (or <code>Dump</code> it in LINQPad), the element names are not there. And for the most part, you cannot use <em>reflection</em> (<a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>) to determine a tuple’s element names at runtime. This means that with APIs such as <code>System.Net.Http.HttpClient</code>, tuples cannot replace anonymous types in scenarios such as the following:</p>
<pre data-type="programlisting">// Create JSON payload:
var json = JsonContent.Create (<strong>new { id = 123, name = "Test" }</strong>)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We said that the names <em>mostly</em> disappear because there’s an exception. With methods/properties that return named tuple types, <a contenteditable="false" data-primary="TupleElementNamesAttribute" data-type="indexterm" id="id2476"/>the compiler emits the element names by applying a custom attribute called <code>TupleElementNamesAttribute</code> (see <a data-type="xref" href="#attributes">“Attributes”</a>) to the member’s return type. This allows named elements to work when calling methods in a different assembly (for which the compiler does not have the source code).</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Aliasing Tuples (C# 12)" data-type="sect2"><div class="sect2" id="aliasing_tuples_left_parenthesischash_o">
<h2>Aliasing Tuples (C# 12)</h2>
<p><a contenteditable="false" data-primary="aliasing" data-secondary="tuples" data-type="indexterm" id="id2477"/><a contenteditable="false" data-primary="tuples" data-secondary="aliasing (C# 12)" data-type="indexterm" id="id2478"/><a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id2479"/>From C# 12, you can leverage the <code>using</code> directive to define aliases for tuples:</p>
<pre data-type="programlisting">using Point = (int, int);
Point p = (3, 4);</pre>
<p>This feature also works with tuples that have named elements:</p>
<pre data-type="programlisting">using Point = (int X, int Y);    // Legal (but not necessarily *good*!)
Point p = (3, 4);</pre>
<p>Again, we’ll see shortly how records offer a fully typed solution with the same level of conciseness:</p>
<pre data-type="programlisting">Point p = new (3, 4);
record Point (int X, int Y);</pre>
</div></section>
<section data-pdf-bookmark="ValueTuple.Create" data-type="sect2"><div class="sect2" id="valuetupledotcreate">
<h2>ValueTuple.Create</h2>
<p><a contenteditable="false" data-primary="ValueTuple.Create" data-type="indexterm" id="id2480"/>You can also create tuples via a factory method on the (nongeneric) <code>ValueTuple</code> type:</p>
<pre data-type="programlisting">ValueTuple&lt;string,int&gt; bob1 = <strong>ValueTuple.Create</strong> ("Bob", 23);
(string,int)           bob2 = <strong>ValueTuple.Create</strong> ("Bob", 23);
(string name, int age) bob3 = <strong>ValueTuple.Create</strong> ("Bob", 23);</pre>
</div></section>
<section data-pdf-bookmark="Deconstructing Tuples" data-type="sect2"><div class="sect2" id="deconstructing_tuples">
<h2>Deconstructing Tuples</h2>
<p><a contenteditable="false" data-primary="tuples" data-secondary="deconstructing" data-type="indexterm" id="id2481"/>Tuples implicitly support the deconstruction pattern (see <a data-type="xref" href="ch03.html#deconstructors-id00060">“Deconstructors”</a>), so you can easily <em>deconstruct</em> a tuple into individual variables. Consider the following:</p>
<pre data-type="programlisting">var bob = ("Bob", 23);

<strong>string name = bob.Item1;</strong>
<strong>int age = bob.Item2;</strong></pre>
<p>With the tuple’s deconstructor, you can simplify the code to this:</p>
<pre data-type="programlisting">var bob = ("Bob", 23);

<strong>(string name, int age) = bob;   // Deconstruct the bob tuple into</strong>
    <strong>                            // separate variables (name and age).</strong>
<strong>Console.WriteLine (name);</strong>
Console.WriteLine (age);</pre>
<p>The syntax for deconstruction is confusingly similar to the syntax for declaring a tuple with named elements. The following highlights the difference:</p>
<pre data-type="programlisting">(string name, int age)      = bob;   // Deconstructing a tuple
(string name, int age) bob2 = bob;   // Declaring a new tuple</pre>
<p>Here’s another example, this time when calling a method, and with type inference (<code>var</code>):</p>
<pre data-type="programlisting"><strong>var (name, age, sex)</strong> = GetBob();
Console.WriteLine (name);        // Bob
Console.WriteLine (age);         // 23
Console.WriteLine (sex);         // M

string, int, char) GetBob() =&gt; ( "Bob", 23, 'M');</pre>
<p>You can also deconstruct directly into fields and properties, which provides a nice shortcut for populating multiple fields or properties in a constructor:</p>
<pre data-type="programlisting">class Point
{
  public readonly int X, Y;
  public Point (int x, int y) =&gt; <strong>(X, Y) = (x, y)</strong>;
}</pre>
</div></section>
<section data-pdf-bookmark="Equality Comparison" data-type="sect2"><div class="sect2" id="equality_comparison-id00016">
<h2>Equality Comparison</h2>
<p><a contenteditable="false" data-primary="tuples" data-secondary="equality comparison" data-type="indexterm" id="id2482"/>As with anonymous types, the <code>Equals</code> method performs structural equality comparison. This means that it compares the underlying <em>data</em> rather than the <em>reference</em>:</p>
<pre data-type="programlisting">var t1 = ("one", 1);
var t2 = ("one", 1);
Console.WriteLine (t1.Equals (t2));    // True</pre>
<p>In addition, <code>ValueTuple&lt;&gt;</code> overloads the <code>==</code> and <code>!=</code> operators:</p>
<pre data-type="programlisting">Console.WriteLine (t1 == t2);    // True (from C# 7.3)</pre>
<p>Tuples also override the <code>GetHashCode</code> method, making it practical to use tuples as keys in dictionaries. We cover equality comparison in detail in <a data-type="xref" href="ch06.html#equality_comparison-id00067">“Equality Comparison”</a>, and dictionaries in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>.</p>
<p>The <code>ValueTuple&lt;&gt;</code> types also implement <code>IComparable</code> (see <a data-type="xref" href="ch06.html#order_comparison">“Order Comparison”</a>), making it possible to use tuples as a sorting key.</p>
</div></section>
<section data-pdf-bookmark="The System.Tuple classes" data-type="sect2"><div class="sect2" id="the_systemdottuple_classes">
<h2>The System.Tuple classes</h2>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Tuple" data-type="indexterm" id="id2483"/><a contenteditable="false" data-primary="tuples" data-secondary="System.Tuple classes" data-type="indexterm" id="id2484"/>You’ll find another family of generic types in the <code>System</code> namespace called <code>Tuple</code> (rather than <code>ValueTuple</code>). These were introduced back in 2010 and were defined as classes (whereas the <code>ValueTuple</code> types are structs). Defining tuples as classes was in retrospect considered a mistake: in the scenarios in which tuples are commonly used, structs have a slight performance advantage (in that they avoid unnecessary memory allocations), with almost no downside. Hence, when Microsoft added language support for tuples in C# 7, it ignored the existing <code>Tuple</code> types in favor of the new <code>ValueTuple</code>. You might still come across the <code>Tuple</code> classes in code written prior to C# 7. They have no special language support and are used as follows:<a contenteditable="false" data-primary="" data-startref="ch04.html1022" data-type="indexterm" id="id2485"/></p>
<pre data-type="programlisting">Tuple&lt;string,int&gt; t = Tuple.Create ("Bob", 23);  // Factory method 
Console.WriteLine (t.Item1);       // Bob
Console.WriteLine (t.Item2);       // 23</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Records" data-type="sect1"><div class="sect1" id="records-id00087">
<h1>Records</h1>
<p><a contenteditable="false" data-primary="records" data-type="indexterm" id="ch04.html1023"/>A <em>record</em> is a special kind of class or struct that’s designed to work well with immutable (read-only) data. Its most useful feature is <em>nondestructive mutation</em>; however, records are also useful in creating types that just combine or hold data. In simple cases, they eliminate boilerplate code while honoring the equality semantics most suitable for immutable types.</p>
<p>Records are purely a C# compile-time construct. At runtime, the CLR sees them just as classes or structs (with a bunch of extra “synthesized” members added by the compiler).</p>
<section data-pdf-bookmark="Background" data-type="sect2"><div class="sect2" id="background">
<h2>Background</h2>
<p><a contenteditable="false" data-primary="records" data-secondary="background" data-type="indexterm" id="id2486"/>Writing immutable types (whose fields cannot be modified after initialization) is a popular strategy for simplifying software and reducing bugs. It’s also a core aspect of functional programming, where mutable state is avoided and functions are treated as data. LINQ is inspired by this principle.</p>
<p>In order to “modify” an immutable object, you must create a new one and copy over the data while incorporating your modifications (this is called <em>nondestructive mutation</em>). <a contenteditable="false" data-primary="shallow copy" data-type="indexterm" id="id2487"/>In terms of performance, this is not as inefficient as you might expect, because a <em>shallow copy</em> will always suffice (a <em>deep copy</em>, where you also copy subobjects and collections, is unnecessary when data is immutable). But in terms of coding effort, implementing nondestructive mutation can be very inefficient, especially when there are many properties. Records solve this problem via a language-supported pattern.</p>
<p>A second issue is that programmers—particularly <em>functional programmers</em>—sometimes use immutable types just to combine data (without adding behavior). Defining such types is more work than it should be, requiring a constructor to assign each parameter to each public property (a deconstructor may also be useful). With records, the compiler can do this work for you.</p>
<p>Finally, one of the consequences of an object being immutable is that its identity cannot change, which means that it’s more useful for such types to implement <em>structural equality</em> than <em>referential equality</em>. Structural equality means that two instances are the same if their data is the same (as with tuples). Records give you structural equality by default—regardless of whether the underlying type is a class or struct—without any boilerplate code.</p>
</div></section>
<section data-pdf-bookmark="Defining a Record" data-type="sect2"><div class="sect2" id="defining_a_record">
<h2>Defining a Record</h2>
<p><a contenteditable="false" data-primary="records" data-secondary="defining a record" data-type="indexterm" id="ch04.html1024"/>A record definition is like a class or struct definition, and can contain the same kinds of members, including fields, properties, methods, and so on. Records can implement interfaces, and (class-based) records can subclass other (class-based) records.</p>
<p class="pagebreak-before">By default, the underlying type of a record is a class:</p>
<pre data-type="programlisting">record Point { }          // Point is a class</pre>
<p>From C# 10, the underlying type of a record can also be a struct:</p>
<pre data-type="programlisting">record <strong>struct</strong> Point { }   // Point is a struct</pre>
<p>(<code>record class</code> is also legal and has the same meaning as <code>record</code>.)</p>
<p>A simple record might contain just a bunch of init-only properties, and perhaps a constructor:</p>
<pre data-type="programlisting">record Point
{
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  public double X { <strong>get; init;</strong> }
  public double Y { <strong>get; init;</strong> }    
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Our constructor employs a shortcut that we described in the preceding section.</p>
<pre data-type="programlisting">(X, Y) = (x, y);</pre>
<p>is equivalent (in this case) to the following:</p>
<pre data-type="programlisting">{ this.X = x; this.Y = y; }</pre>
</div>
<p>Upon compilation, C# transforms the record definition into a class (or struct) and performs the following additional steps:</p>
<ul>
<li><p>It writes a protected <em>copy constructor</em> (and a hidden <em>Clone</em> method) to facilitate nondestructive mutation.</p></li>
<li><p>It overrides/overloads the equality-related functions to implement structural equality.</p></li>
<li><p>It overrides the <code>ToString()</code> method (to expand the record’s public properties, as with anonymous types).</p></li>
</ul>
<p>The preceding record declaration expands into something like this:</p>
<pre data-type="programlisting">class Point
{  
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    

  <strong>protected Point (Point original)    // “Copy constructor”</strong>
  <strong>{</strong>
    <strong>this.X = original.X; this.Y = original.Y</strong>
  <strong>}</strong>

  // This method has a strange compiler-generated name:
  <strong>public virtual Point &lt;Clone&gt;$() =&gt; new Point (this);   // Clone method</strong>

  <strong>// Additional code to override Equals, ==, !=, GetHashCode, ToString()</strong>
  <strong>// ...</strong>
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While there’s nothing to stop you from putting <em>optional parameters</em> into the constructor, a good pattern (at least in public libraries) is to leave them out of the constructor and expose them purely as init-only properties:</p>
<pre data-type="programlisting">new Foo (123, 234) { Optional2 = 345 };

record Foo
{
  public Foo (int required1, int required2) { ... }

  public int Required1 { get; init; }
  public int Required2 { get; init; }

  <strong>public int Optional1 { get; init; }</strong>
  <strong>public int Optional2 { get; init; }</strong>
}</pre>
<p>The advantage of this pattern is that you can safely add init-only properties later without breaking binary compatibility with consumers who have compiled against older versions of your assembly.</p>
</div>
<section data-pdf-bookmark="Parameter lists" data-type="sect3"><div class="sect3" id="parameter_lists">
<h3>Parameter lists</h3>
<p><a contenteditable="false" data-primary="parameter lists" data-type="indexterm" id="id2488"/><a contenteditable="false" data-primary="records" data-secondary="parameter lists" data-type="indexterm" id="id2489"/>A record definition can be shortened through the use of a <em>parameter list</em>:</p>
<pre data-type="programlisting">record Point <strong>(double X, double Y)</strong>
{
  // You can optionally define additional class members here...
}</pre>
<p>Parameters can include the <code>in</code> and <code>params</code> modifiers, but not <code>out</code> or <code>ref</code>. If a parameter list is specified, the compiler performs the following extra steps:</p>
<ul>
<li><p>It writes an init-only property per parameter.</p></li>
<li><p>It writes a <em>primary constructor</em> to populate the properties.</p></li>
<li><p>It writes a deconstructor.</p></li>
</ul>
<p>This means that if we declare our <code>Point</code> record simply as:</p>
<pre data-type="programlisting">record Point <strong>(double X, double Y);</strong></pre>
<p>the compiler will end up generating (almost) exactly what we listed in the preceding expansion. A minor difference is that the parameter names in the primary constructor will end up as <code>X</code> and <code>Y</code> instead of <code>x</code> and <code>y</code>:</p>
<pre data-type="programlisting">  public Point (double <strong>X</strong>, double <strong>Y</strong>)   // “Primary constructor”
  {
    this.X = X; this.Y = Y;
  }</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Also, due to being a <em>primary constructor</em>, parameters <code>X</code> and <code>Y</code> become magically available to any field or property initializers in your record. We discuss the subtleties of this later, in <a data-type="xref" href="#primary_constructors">“Primary Constructors”</a>.</p>
</div>
<p>Another difference, when you define a parameter list, is that the compiler also generates a deconstructor:</p>
<pre data-type="programlisting">  public void Deconstruct (out double X, out double Y)   // Deconstructor
  {
    X = this.X; Y = this.Y;
  }</pre>
<p>Records with parameter lists can be subclassed using the following syntax:</p>
<pre data-type="programlisting">record Point3D (double X, double Y, double Z) <strong>: Point (X, Y)</strong>;</pre>
<p>The compiler then emits a primary constructor as follows:</p>
<pre data-type="programlisting">class Point3D : Point
{
  public double Z { get; init; }

  public Point3D (double X, double Y, double Z) <strong>: base (X, Y)</strong> 
    =&gt; this.Z = Z;
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Parameter lists offer a nice shortcut when you need a class that simply groups together a bunch of values (a <em>product type</em> in functional programming) and can also be useful for prototyping. As we’ll see later, they’re not so helpful when you need to add logic to the <code>init</code> accessors (such as argument validation).<a contenteditable="false" data-primary="" data-startref="ch04.html1024" data-type="indexterm" id="id2490"/></p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="mutability_with_record_structs">
<h1>Mutability with Record Structs</h1>
<p><a contenteditable="false" data-primary="record structs" data-type="indexterm" id="id2491"/><a contenteditable="false" data-primary="structs" data-secondary="mutability with record structs" data-type="indexterm" id="id2492"/><a contenteditable="false" data-primary="parameter lists" data-type="indexterm" id="id2493"/><a contenteditable="false" data-primary="records" data-secondary="mutability with record structs" data-type="indexterm" id="id2494"/>When you define a parameter list in a record struct, the compiler emits writable properties instead of init-only properties, unless you prefix the record declaration with <code>readonly</code>:</p>
<pre data-type="programlisting">readonly record struct Point (double X, double Y);</pre>
<p>The rationale is that in typical use cases, the safety benefits of immutability arise not from a <em>struct</em> being immutable but from its <em>home</em> being immutable. In the following example, we are unable to mutate field <code>X</code>, even though <code>X</code> is writable:</p>
<pre data-type="programlisting">var test = new Immutable();
test.Field.X++;  // Prohibited, because Field is readonly
test.Prop.X++;   // Prohibited, because Prop is {get;} only

class Immutable
{
  public readonly Mutable Field;
  public Mutable Prop { get; }
}

struct Mutable { public int X, Y; }</pre>
<p>And while we could do the following:</p>
<pre data-type="programlisting">var test = new Immutable();
Mutable m = test.Prop;
m.X++;</pre>
<p>all that we would achieve is to mutate a local variable (a <em>copy</em> of <code>test.Prop</code>). Mutating a local variable can be a useful optimization and doesn’t invalidate the benefits of an immutable type system.</p>
<p>Conversely, if we made <code>Field</code> a writable field, and <code>Prop</code> a writable property, we could simply replace their contents—regardless of how the <code>Mutable</code> struct was declared.</p>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Nondestructive Mutation" data-type="sect2"><div class="sect2" id="nondestructive_mutation">
<h2>Nondestructive Mutation</h2>
<p><a contenteditable="false" data-primary="copy constructor" data-type="indexterm" id="id2495"/><a contenteditable="false" data-primary="nondestructive mutation" data-type="indexterm" id="id2496"/><a contenteditable="false" data-primary="records" data-secondary="nondestructive mutation" data-type="indexterm" id="id2497"/>The most important step that the compiler performs with all records is to write a <em>copy constructor</em> (and a hidden <em>Clone</em> method). This enables nondestructive mutation via the <code>with</code> keyword:</p>
<pre data-type="programlisting">Point p1 = new Point (3, 3);
Point p2 = p1 <strong>with { Y = 4 }</strong>;
Console.WriteLine (p2);       // Point { X = 3, <strong>Y = 4</strong> }

record Point (double X, double Y);</pre>
<p>In this example, <code>p2</code> is a copy of <code>p1</code>, but with its <code>Y</code> property set to 4. The benefit is more apparent when there are more properties:</p>
<pre data-type="programlisting">Test t1 = new Test (1, 2, 3, 4, 5, 6, 7, 8);
Test t2 = <strong>t1 with { A = 10, C = 30 }</strong>;
Console.WriteLine (t2);

record Test (int A, int B, int C, int D, int E, int F, int G, int H);</pre>
<p>Here’s the output:</p>
<pre data-type="programlisting">Test { <strong>A = 10</strong>, B = 2, <strong>C = 30</strong>, D = 4, E = 5, F = 6, G = 7, H = 8 }</pre>
<p>Nondestructive mutation occurs in two phases:</p>
<ol>
<li><p>First, the <em>copy constructor</em> clones the record. By default, it copies each of the record’s underlying fields, creating a faithful replica while bypassing (the overhead of) any logic in the <code>init</code> accessors. All fields are included (public and private, as well as the hidden fields that back automatic properties).</p></li>
<li><p>Then, each property in the <em>member initializer list</em> is updated (this time using the <code>init</code> accessors).</p></li>
</ol>
<p>The compiler translates</p>
<pre data-type="programlisting">Test t2 = <strong>t1 with { A = 10, C = 30 }</strong>;</pre>
<p>into something functionally equivalent to the following:</p>
<pre data-type="programlisting">Test t2 = new Test(t1);  // Use copy constructor to clone t1 field by field
t2.A = 10;               // Update property A
t2.C = 30;               // Update property C</pre>
<p>(The same code would not compile if you wrote it explicitly because <code>A</code> and <code>C</code> are init-only properties. Furthermore, the copy constructor is <em>protected</em>; C# works around this by invoking it via a public hidden method that it writes into the record called <code>&lt;Clone&gt;$</code>.)</p>
<p>If necessary, you can define your own <em>copy constructor</em>. C# will then use your definition instead of writing one itself:</p>
<pre data-type="programlisting"><strong>protected Point (Point original)</strong>
{
  this.X = original.X; this.Y = original.Y;
}</pre>
<p>Writing a custom copy constructor might be useful if your record contains mutable subobjects or collections that you wish to clone, or if there are computed fields that you wish to clear. Unfortunately, you can only <em>replace</em>, not <em>enhance</em>, the default implementation.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When subclassing another record, the copy constructor is responsible for copying only its own fields. To copy the base record’s fields, delegate to the base:</p>
<pre data-type="programlisting">protected Point (Point original) <strong>: base (original)</strong>
{
  ...
}</pre>
</div>
</div></section>
<section data-pdf-bookmark="Property Validation" data-type="sect2"><div class="sect2" id="property_validation">
<h2>Property Validation</h2>
<p><a contenteditable="false" data-primary="property validation" data-type="indexterm" id="id2498"/><a contenteditable="false" data-primary="records" data-secondary="property validation" data-type="indexterm" id="id2499"/>With explicit properties, you can write validation logic into the <code>init</code> accessors. In the following example, we ensure that <code>X</code> can never be <code>NaN</code> (Not a Number):</p>
<pre data-type="programlisting">record Point
{
  // Notice that we assign x to the X property (and not the _x field):
  public Point (double x, double y) =&gt; (<strong>X, Y) = (x, y)</strong>;

  double _x;
  public double X
  { 
    <strong>get =&gt; _x;</strong>
    <strong>init</strong>
    <strong>{</strong>
    <strong>  if (double.IsNaN (value))</strong>
    <strong>    throw new ArgumentException ("X Cannot be NaN");</strong>
    <strong>  _x = value;</strong>
    <strong>}</strong>
 <strong/> }
  public double Y { <strong>get; init;</strong> }    
}</pre>
<p>Our design ensures that validation occurs both during construction and when the object is nondestructively mutated:</p>
<pre data-type="programlisting">Point p1 = new Point (2, 3);
Point p2 = p1 <strong>with { X = double.NaN }</strong>;   // throws an exception</pre>
<p>Recall that the automatically generated <em>copy constructor</em> copies over all fields and automatic properties. This means that the generated copy constructor will now look like this:</p>
<pre data-type="programlisting">protected Point (Point original)
 {
   _x = original._x; Y = original.Y;
 }</pre>
<p>Notice that the copying of the <code>_x</code> field circumvents the <code>X</code> property accessor. However, this cannot break anything, because it’s faithfully copying an object that will have already been safely populated via <code>X</code>’s <code>init</code> accessor.</p>
</div></section>
<section data-pdf-bookmark="Calculated Fields and Lazy Evaluation" data-type="sect2"><div class="sect2" id="calculated_fields_and_lazy_evaluation">
<h2>Calculated Fields and Lazy Evaluation</h2>
<p><a contenteditable="false" data-primary="calculated fields" data-type="indexterm" id="ch04.html1025"/><a contenteditable="false" data-primary="lazy evaluation" data-type="indexterm" id="ch04.html1026"/><a contenteditable="false" data-primary="records" data-secondary="calculated fields and lazy evaluation" data-type="indexterm" id="ch04.html1027"/>A popular functional programming pattern that works well with immutable types is <em>lazy evaluation</em>, where a value is not computed until required and then is cached for reuse. Suppose, for instance, that we want to define a property in our <code>Point</code> record that returns the distance from the origin <code>(0, 0)</code>:</p>
<pre data-type="programlisting">record Point (double X, double Y)
{
  public double DistanceFromOrigin =&gt; Math.Sqrt (X*X + Y*Y);
}</pre>
<p>Let’s now try to refactor this to avoid the cost of recomputing <code>DistanceFromOrigin</code> every time the property is accessed. We’ll start by removing the property list and defining <code>X</code>, <code>Y</code>, and <code>DistanceFromOrigin</code> as read-only properties. Then we can calculate the latter in the constructor:</p>
<pre data-type="programlisting">record Point
{
  public double X { get; }
  public double Y { get; }
  <strong>public double DistanceFromOrigin { get; }</strong>

  public Point (double x, double y) =&gt;
    (X, Y, <strong>DistanceFromOrigin</strong>) = (x, y, <strong>Math.Sqrt (x*x + y*y)</strong>);
}</pre>
<p>This works, but it doesn’t allow for nondestructive mutation (changing <code>X</code> and <code>Y</code> to init-only properties would break the code because <code>DistanceFromOrigin</code> would become stale after the <code>init</code> accessors execute). It’s also suboptimal in that the calculation is always performed, regardless of whether the <code>DistanceFromOrigin</code> property is ever read. The optimal solution is to cache its value in a field and populate it <em>lazily</em> (on first use):</p>
<pre data-type="programlisting">record Point
{
  ...

  <strong>double? _distance;</strong>
  public double DistanceFromOrigin
  {
    get
    {
    <strong>  if (_distance == null)</strong> 
    <strong>    _distance = Math.Sqrt (X*X + Y*Y);</strong>

    <strong>  return _distance.Value;</strong>
    }
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Technically, we <em>mutate</em> <code>_distance</code> in this code. It’s still fair, though, to call <code>Point</code> an immutable type. Mutating a field purely to populate a lazy value does not invalidate the principles or benefits of immutability, and can even be masked through the use of the <code>Lazy&lt;T&gt;</code> type that we describe in <a data-type="xref" href="ch21.html#advanced_threadin">Chapter 21</a>.</p>
</div>
<p>With C#’s <em>null-coalescing assignment operator</em> (<code>??=</code>), we can reduce the entire property declaration to one line of code:</p>
<pre data-type="programlisting">  public double DistanceFromOrigin =&gt; _distance <strong>??=</strong> Math.Sqrt (X*X + Y*Y);</pre>
<p>(This says, return <code>_distance</code> if it’s non-null; otherwise, return <code>Math.Sqrt (X*X + Y*Y)</code> while assigning it to <code>_distance</code>.)</p>
<p>To make this work with init-only properties, we need one further step, which is to clear the cached <code>_distance</code> field when <code>X</code> or <code>Y</code> is updated via the <code>init</code> accessor. Here’s the complete code:</p>
<pre data-type="programlisting">record Point
{
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  double _x, _y;
  public double X { get =&gt; _x; init { _x = value; <strong>_distance = null</strong>; } }
  public double Y { get =&gt; _y; init { _y = value; <strong>_distance = null</strong>; } }
    
  double? _distance;
  public double DistanceFromOrigin =&gt; _distance ??= Math.Sqrt (X*X + Y*Y);
}</pre>
<p><code>Point</code> can now be mutated nondestructively:</p>
<pre data-type="programlisting">Point p1 = new Point (2, 3);
Console.WriteLine (p1.DistanceFromOrigin);   // 3.605551275463989
Point p2 = p1 with { Y = 4 };
Console.WriteLine (p2.DistanceFromOrigin);   // 4.47213595499958</pre>
<p>A nice bonus is that the autogenerated copy constructor copies over the cached <code>_distance</code> field. This means that should a record have other properties that aren’t involved in the calculation, a nondestructive mutation of those properties wouldn’t trigger an unnecessary loss of the cached value. If you don’t care for this bonus, an alternative to clearing the cached value in the <code>init</code> accessors is to write a custom copy constructor that ignores the cached field. This is more concise because it works with parameter lists, and the custom copy constructor can leverage the deconstructor:</p>
<pre data-type="programlisting">record Point (double X, double Y)
{
  double? _distance;
  public double DistanceFromOrigin =&gt; _distance ??= Math.Sqrt (X*X + Y*Y);

  <strong>protected Point (Point other) =&gt; (X, Y) = other;</strong>
}</pre>
<p>Note that with either solution, the addition of lazy calculated fields breaks the default structural equality comparison (because such fields may or may not be populated), although we’ll see shortly that it’s relatively easy to fix.<a contenteditable="false" data-primary="" data-startref="ch04.html1027" data-type="indexterm" id="id2500"/><a contenteditable="false" data-primary="" data-startref="ch04.html1026" data-type="indexterm" id="id2501"/><a contenteditable="false" data-primary="" data-startref="ch04.html1025" data-type="indexterm" id="id2502"/></p>
</div></section>
<section data-pdf-bookmark="Primary Constructors" data-type="sect2"><div class="sect2" id="primary_constructors">
<h2>Primary Constructors</h2>
<p><a contenteditable="false" data-primary="constructors" data-secondary="primary" data-type="indexterm" id="ch04.html1028"/><a contenteditable="false" data-primary="primary constructors" data-type="indexterm" id="ch04.html1029"/><a contenteditable="false" data-primary="records" data-secondary="primary constructors" data-type="indexterm" id="ch04.html1030"/>When you define a record with a parameter list, the compiler generates property declarations automatically, as well as a <em>primary constructor</em> (and a deconstructor). As we’ve seen, this works well in simple cases, and in more complex cases you can omit the parameter list and write the property declarations and constructor manually.</p>
<p>C# also offers a mildly useful intermediate option—if you’re willing to deal with the curious semantics of primary constructors—which is to define a parameter list while writing some or all of the property declarations yourself:</p>
<pre data-type="programlisting">record Student (string ID, string LastName, string GivenName)
{
  <strong>public string ID { get; } = ID;</strong>
}</pre>
<p>In this case, we “took over” the <code>ID</code> property definition, defining it as read-only (instead of init-only), preventing it from partaking in nondestructive mutation. If you never need to nondestructively mutate a particular property, making it read-only lets you store computed data in the record without having to code up a refresh mechanism.</p>
<p>Notice that we needed to include a <em>property initializer</em> (in boldface):</p>
<pre data-type="programlisting">  public string ID { get; } <strong>= ID</strong>;</pre>
<p>When you “take over” a property declaration, you become responsible for initializing its value; the primary constructor no longer does this automatically. (This exactly matches the behavior when defining primary constructors on classes or structs.) Also note that the <code>ID</code> in boldface refers to the <em>primary constructor parameter</em>, not the <code>ID</code> property.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>With record structs, it’s legal to redefine a property as a field:</p>
<pre data-type="programlisting">record struct Student (string ID)
{
  public string ID = ID;
}</pre>
</div>
<p>In keeping with the semantics of primary constructors on classes and structs (see <a data-type="xref" href="#primary_constructors">“Primary Constructors”</a>), the primary constructor parameters (<code>ID</code>, <code>LastName</code>, and <code>GivenName</code> in this case) are magically visible to all field and property initializers. We can illustrate this by extending our example as follows:</p>
<pre data-type="programlisting">record Student (string <strong>ID</strong>, string LastName, string FirstName)
{
  public string ID { get; } = <strong>ID</strong>;
  readonly int _enrollmentYear = int.Parse (<strong>ID</strong>.Substring (0, 4));
}</pre>
<p>Again, the <code>ID</code> in boldface refers to the primary constructor parameter, not the property. (The reason for there not being an ambiguity is that it’s illegal to access properties from initializers.)</p>
<p>In this example, we calculated <code>_enrollmentYear</code> from the first four digits of the <code>ID</code>. While it’s safe to store this in a read-only field (because the <code>ID</code> property is read-only and so cannot be nondestructively mutated), this code would not work so well in the real world. The reason is that without an explicit constructor, there’s no central place in which to validate <code>ID</code> and throw a meaningful exception should it be invalid (a common requirement).</p>
<p>Validation is also a good reason for needing to write explicit init-only accessors (as we discussed in <a data-type="xref" href="#property_validation">“Property Validation”</a>). Unfortunately, primary constructors do not play well in this scenario. To illustrate, consider the following record, where an <code>init</code> accessor performs a null validation check:</p>
<pre data-type="programlisting">record Person (string Name)
{
  string _name <strong>= Name</strong>;
  public string Name
  {
    get  =&gt; _name;
    init =&gt; _name = value ?? throw new ArgumentNullException ("Name");
  }
}</pre>
<p>Because <code>Name</code> is not an automatic property, it cannot define an initializer. The best we can do is put the initializer on the backing field (in boldface). Unfortunately, doing so bypasses the null check:</p>
<pre data-type="programlisting">var p = new Person (null);    // Succeeds! (bypasses the null check)</pre>
<p>The difficulty is that there’s no way to assign a primary constructor parameter to a property without writing the constructor ourselves. While there are workarounds (such as factoring the <code>init</code> validation logic into a separate static method that we call twice), the simplest workaround is to avoid the parameter list altogether and write an ordinary constructor manually (and deconstructor, should you need it):<a contenteditable="false" data-primary="" data-startref="ch04.html1030" data-type="indexterm" id="id2503"/><a contenteditable="false" data-primary="" data-startref="ch04.html1029" data-type="indexterm" id="id2504"/><a contenteditable="false" data-primary="" data-startref="ch04.html1028" data-type="indexterm" id="id2505"/></p>
<pre data-type="programlisting">record Person
{
  public Person (string name) =&gt; <strong>Name = name</strong>;  // Assign to *PROPERTY*

  string _name;
  public string Name { get =&gt; _name; init =&gt; ... }
}</pre>
</div></section>
<section data-pdf-bookmark="Records and Equality Comparison" data-type="sect2"><div class="sect2" id="records_and_equality_comparison">
<h2>Records and Equality Comparison</h2>
<p><a contenteditable="false" data-primary="equality comparison" data-secondary="records and" data-type="indexterm" id="id2506"/><a contenteditable="false" data-primary="records" data-secondary="equality comparison and" data-type="indexterm" id="id2507"/>Just as with structs, anonymous types, and tuples, records provide structural equality out of the box, meaning that two records are equal if their fields (and automatic properties) are equal:</p>
<pre data-type="programlisting">var p1 = new Point (1, 2);
var p2 = new Point (1, 2);
Console.WriteLine (p1.Equals (p2));   // True

record Point (double X, double Y);</pre>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="records and" data-type="indexterm" id="id2508"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="records and" data-type="indexterm" id="id2509"/>The <em>equality operator</em> also works with records (as it does with tuples):</p>
<pre data-type="programlisting">Console.WriteLine (p1 == p2);         // True</pre>
<p>The default equality implementation for records is unavoidably fragile. In particular, it breaks if the record contains lazy values, transient values, arrays, or collection types (which require special handling for equality comparison). Fortunately, it’s relatively easy to fix (should you need equality to work), and doing so is less work than adding full equality behavior to classes or structs.</p>
<p>Unlike with classes and structs, you do not (and cannot) override the <code>object.Equals</code> method; instead, you define a public <code>Equals</code> method with the following signature:</p>
<pre data-type="programlisting">record Point (double X, double Y)
{
  double _someOtherField;
  <strong>public virtual bool Equals (Point other)</strong> =&gt;
    other != null &amp;&amp; X == other.X &amp;&amp; Y == other.Y;
}</pre>
<p>The <code>Equals</code> method must be <code>virtual</code> (not <code>override</code>), and it must be <em>strongly typed</em> such that it accepts the actual record type (<code>Point</code> in this case, not <code>object</code>). Once you get the signature right, the compiler will automatically patch in your method.</p>
<p>In our example, we changed the equality logic such that we compare only <code>X</code> and <code>Y</code> (and ignore <code>_someOtherField</code>).</p>
<p>Should you subclass another record, you can call the <code>base.Equals</code> method:</p>
<pre data-type="programlisting">  public virtual bool Equals (Point other) =&gt; <strong>base.Equals (other) &amp;&amp;</strong> ...</pre>
<p>As with any type, if you take over equality comparison, you should also override <code>GetHashCode()</code>. A nice feature of records is that you don’t overload <code>!=</code> or <code>==</code>; nor do you implement <code>IEquatable&lt;T&gt;</code>: this is all done for you. We cover this topic of equality comparison fully in <a data-type="xref" href="ch06.html#equality_comparison-id00067">“Equality Comparison”</a>.<a contenteditable="false" data-primary="" data-startref="ch04.html1023" data-type="indexterm" id="id2510"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Patterns" data-type="sect1"><div class="sect1" id="patterns">
<h1>Patterns</h1>
<p><a contenteditable="false" data-primary="patterns" data-type="indexterm" id="ch04.html1031"/>In <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>, we demonstrated how to use the <code>is</code> operator to test whether a reference conversion will succeed:</p>
<pre data-type="programlisting">if (obj <strong>is string</strong>)
  Console.WriteLine (((string)obj).Length);</pre>
<p>Or, more concisely:</p>
<pre data-type="programlisting">if (obj <strong>is string s</strong>)
  Console.WriteLine (s.Length);</pre>
<p>This shortcut employs one kind of pattern called a <em>type pattern</em>. The <code>is</code> operator also supports other patterns that were introduced in recent versions of C#, such as the <em>property pattern</em>:</p>
<pre data-type="programlisting">if (obj <strong>is string { Length:4 }</strong>)
  Console.WriteLine ("A string with 4 characters");</pre>
<p>Patterns are supported in the following contexts:</p>
<ul>
<li><p>After the <code>is</code> operator (<code><em>variable</em> is <em>pattern</em></code>)</p></li>
<li><p>In switch statements</p></li>
<li><p>In switch expressions</p></li>
</ul>
<p>We’ve already covered the type pattern (and briefly, the tuple pattern) in <a data-type="xref" href="ch02.html#switching_on_types">“Switching on types”</a> and <a data-type="xref" href="ch03.html#the_is_operator">“The is operator”</a>. In this section, we cover more advanced patterns that were introduced in recent versions of C#.</p>
<p>Some of the more specialized patterns are intended mostly for use in switch statements/expressions. Here, they reduce the need for <code>when</code> clauses and let you use switches where you couldn’t previously.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The patterns in this section are mildly to moderately useful in some scenarios. Remember that you can always replace highly patterned switch expressions with simple <code>if</code> statements—or, in some cases, the ternary conditional operator—often without much extra code.</p>
</div>
<section data-pdf-bookmark="Constant Pattern" data-type="sect2"><div class="sect2" id="constant_pattern">
<h2>Constant Pattern</h2>
<p><a contenteditable="false" data-primary="constant pattern" data-type="indexterm" id="id2511"/><a contenteditable="false" data-primary="patterns" data-secondary="constant pattern" data-type="indexterm" id="id2512"/>The constant pattern lets you match directly to a constant, and is useful when working with the <code>object</code> type:</p>
<pre data-type="programlisting">void Foo (object obj) 
{
  if (<strong>obj is 3</strong>) ...
}</pre>
<p>This expression in boldface is equivalent to the following:</p>
<pre data-type="programlisting"><strong>obj is int &amp;&amp; (int)obj == 3</strong></pre>
<p>(Being a static operator, C# won’t let you use <code>==</code> to compare an <code>object</code> directly to a constant, because the compiler needs to know the types in advance.)</p>
<p>On its own, this pattern is only marginally useful in that there’s a reasonable alternative:</p>
<pre data-type="programlisting">if (3.Equals (obj)) ...</pre>
<p>As we’ll see soon, the constant pattern becomes much more useful with <em>pattern combinators</em>.</p>
</div></section>
<section data-pdf-bookmark="Relational Patterns" data-type="sect2"><div class="sect2" id="relational_patterns">
<h2>Relational Patterns</h2>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="relational patterns" data-type="indexterm" id="id2513"/><a contenteditable="false" data-primary="patterns" data-secondary="relational patterns (C# 9)" data-type="indexterm" id="id2514"/><a contenteditable="false" data-primary="relational patterns" data-type="indexterm" id="id2515"/>From C# 9, you can use the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators in patterns:</p>
<pre data-type="programlisting">if (x <strong>is &gt; 100</strong>) Console.WriteLine ("x is greater than 100");</pre>
<p>This becomes meaningfully useful in a <code>switch</code>:</p>
<pre data-type="programlisting">string GetWeightCategory (decimal bmi) =&gt; bmi switch
{
  &lt; 18.5m =&gt; "underweight",
  &lt; 25m =&gt; "normal",
  &lt; 30m =&gt; "overweight",
  _ =&gt; "obese"
};</pre>
<p>Relational patterns become even more useful in conjunction with <em>pattern combinators</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The relational pattern also works when the variable has a compile-time type of <code>object</code>, but you have to be extremely careful with your use of numeric constants. In the following example, the last line prints False because we are attempting to match a decimal value to an integer literal:</p>
<pre data-type="programlisting">object obj = 2m;                  // obj is decimal
Console.WriteLine (obj is &lt; 3m);  // True
Console.WriteLine (obj is &lt; 3);   // False</pre>
</div>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Pattern Combinators" data-type="sect2"><div class="sect2" id="pattern_combinators">
<h2 class="less_space">Pattern Combinators</h2>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="pattern combinators" data-type="indexterm" id="id2516"/><a contenteditable="false" data-primary="pattern combinators" data-type="indexterm" id="id2517"/><a contenteditable="false" data-primary="patterns" data-secondary="pattern combinators (C# 9)" data-type="indexterm" id="id2518"/>From C# 9, you can use the <code>and</code>, <code>or</code>, and <code>not</code> keywords to combine patterns:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name) =&gt; name.ToUpper() is <strong>"JANET" or "JOHN"</strong>;

bool IsVowel (char c) =&gt; c is <strong>'a' or 'e' or 'i' or 'o' or 'u'</strong>;

bool Between1And9 (int n) =&gt; n is <strong>&gt;= 1 and &lt;= 9</strong>;

bool IsLetter (char c) =&gt; c is <strong>&gt;= 'a' and &lt;= 'z'</strong>
                            <strong>or &gt;= 'A' and &lt;= 'Z'</strong>;</pre>
<p>As with the <code>&amp;&amp;</code> and <code>||</code> operators, <code>and</code> has higher precedence than <code>or</code>. You can override this with parentheses.</p>
<p>A nice trick is to combine the <code>not</code> combinator with the <em>type pattern</em> to test whether an object is (not) a type:</p>
<pre data-type="programlisting">if (obj is <strong>not string</strong>) ...</pre>
<p>This looks nicer than:</p>
<pre data-type="programlisting">if (!(obj is string)) ...</pre>
</div></section>
<section data-pdf-bookmark="var Pattern" data-type="sect2"><div class="sect2" id="var_pattern">
<h2>var Pattern</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="var pattern" data-type="indexterm" id="id2519"/><a contenteditable="false" data-primary="var pattern" data-type="indexterm" id="id2520"/>The <em>var pattern</em> is a variation of the <em>type pattern</em> whereby you replace the type name with the <code>var</code> keyword. The conversion always succeeds, so its purpose is merely to let you reuse the variable that follows:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name) =&gt; 
  name.ToUpper() is <strong>var upper</strong> &amp;&amp; (<strong>upper</strong> == "JANET" || <strong>upper</strong> == "JOHN");</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name)
{
  string upper = name.ToUpper();
  return upper == "JANET" || upper == "JOHN";
}</pre>
<p>The ability to introduce and reuse an intermediate variable (<code>upper</code>, in this case) in an expression-bodied method is convenient—particularly in lambda expressions. Unfortunately, it tends to be useful only when the method in question has a <code>bool</code> return type.</p>
</div></section>
<section data-pdf-bookmark="Tuple and Positional Patterns" data-type="sect2"><div class="sect2" id="tuple_and_positional_patterns">
<h2>Tuple and Positional Patterns</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="tuple and positional patterns" data-type="indexterm" id="id2521"/><a contenteditable="false" data-primary="positional patterns" data-type="indexterm" id="id2522"/><a contenteditable="false" data-primary="tuple patterns" data-type="indexterm" id="id2523"/>The <em>tuple pattern</em> (introduced in C# 8) matches tuples:</p>
<pre data-type="programlisting">var p = (2, 3);
Console.WriteLine (p <strong>is (2, 3)</strong>);   // True</pre>
<p>You can use this to switch on multiple values:</p>
<pre data-type="programlisting">int AverageCelsiusTemperature (Season season, bool daytime) =&gt;
  <strong>(season, daytime)</strong> switch
  {
    (Season.Spring, true) =&gt; 20,
    (Season.Spring, false) =&gt; 16,
    (Season.Summer, true) =&gt; 27,
    (Season.Summer, false) =&gt; 22,
    (Season.Fall, true) =&gt; 18,
    (Season.Fall, false) =&gt; 12,
    (Season.Winter, true) =&gt; 10,
    (Season.Winter, false) =&gt; -2,
    _ =&gt; throw new Exception ("Unexpected combination")
};

enum Season { Spring, Summer, Fall, Winter };</pre>
<p>The tuple pattern can be considered a special case of the <em>positional pattern</em> (C# 8+), <a contenteditable="false" data-primary="Deconstruct method" data-type="indexterm" id="id2524"/>which matches any type that exposes a <code>Deconstruct</code> method (see <a data-type="xref" href="ch03.html#deconstructors-id00060">“Deconstructors”</a>). In the following example, we leverage the <code>Point</code> record’s compiler-generated deconstructor:</p>
<pre data-type="programlisting">var p = new Point (2, 2);
Console.WriteLine (<strong>p is (2, 2)</strong>);  // True

record Point (int X, int Y);      // Has compiler-generated deconstructor</pre>
<p>You can deconstruct as you match, using the following syntax:</p>
<pre data-type="programlisting">Console.WriteLine (p is <strong>(var x, var y) &amp;&amp; x == y</strong>);   // True</pre>
<p>Here’s a switch expression that combines a type pattern with a positional pattern:</p>
<pre data-type="programlisting">string Print (object obj) =&gt; obj switch 
{
  Point <strong>(0, 0)</strong>                      =&gt; "Empty point",
  Point <strong>(var x, var y)</strong> when x == y  =&gt; "Diagonal"
  ...
};</pre>
</div></section>
<section data-pdf-bookmark="Property Patterns" data-type="sect2"><div class="sect2" id="property_patterns">
<h2>Property Patterns</h2>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="property patterns" data-type="indexterm" id="id2525"/><a contenteditable="false" data-primary="patterns" data-secondary="property patterns" data-type="indexterm" id="id2526"/><a contenteditable="false" data-primary="property patterns" data-type="indexterm" id="id2527"/>A property pattern (C# 8+) matches on one or more of an object’s property values. We gave a simple example previously in the context of the <code>is</code> operator:</p>
<pre data-type="programlisting">if (obj is <strong>string { Length:4 }</strong>) ...</pre>
<p>However, this doesn’t save much over the following:</p>
<pre data-type="programlisting">if (obj is string s &amp;&amp; s.Length == 4) ...</pre>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Uri class" data-type="indexterm" id="id2528"/>With switch statements and expressions, property patterns are more useful. Consider the <code>System.Uri</code> class, which represents a URI. It has properties that include <code>Scheme</code>, <code>Host</code>, <code>Port</code>, and <code>IsLoopback</code>. In writing a firewall, we could decide whether to allow or block a URI by employing a switch expression that uses property patterns:</p>
<pre data-type="programlisting">bool ShouldAllow (Uri uri) =&gt; uri switch
{
  <strong>{ Scheme: "http",  Port: 80  }</strong> =&gt; true,
  <strong>{ Scheme: "https", Port: 443 }</strong> =&gt; true,
  <strong>{ Scheme: "ftp",   Port: 21  }</strong> =&gt; true,
  <strong>{ IsLoopback: true           }</strong> =&gt; true,
  _ =&gt; false
};</pre>
<p>You can nest properties, making the following clause legal:</p>
<pre data-type="programlisting">  { Scheme: <strong>{ Length: 4 }</strong>, Port: 80 } =&gt; true,</pre>

<p>which, from C# 10, can be simplified to:</p>
<pre data-type="programlisting">  { <strong>Scheme.Length: 4</strong>, Port: 80 } =&gt; true,</pre>
<p>You can use other patterns inside property patterns, including the relational pattern:</p>
<pre data-type="programlisting">  { Host: { <strong>Length: &lt; 1000</strong> }, <strong>Port: &gt; 0</strong> } =&gt; true,</pre>
<p>More elaborate conditions can be expressed with a <code>when</code> clause:</p>
<pre data-type="programlisting">  { Scheme: "http" } <strong>when string.IsNullOrWhiteSpace (uri.Query)</strong> =&gt; true,</pre>
<p>You can also combine the property pattern with the type pattern:</p>
<pre data-type="programlisting">bool ShouldAllow (<strong>object</strong> uri) =&gt; uri switch
{
  <strong>Uri</strong> { Scheme: "http",  Port: 80  } =&gt; true,
  <strong>Uri</strong> { Scheme: "https", Port: 443 } =&gt; true,
  ...</pre>
<p>As you might expect with type patterns, you can introduce a variable at the end of a clause and then consume that variable:</p>
<pre data-type="programlisting">  Uri { Scheme: "http", Port: 80 } <strong>httpUri</strong> =&gt; <strong>httpUri</strong>.Host.Length &lt; 1000,</pre>
<p>You can also use that variable in a <code>when</code> clause:</p>
<pre data-type="programlisting">  Uri { Scheme: "http", Port: 80 } httpUri 
                                   <strong>when</strong> httpUri.Host.Length &lt; 1000 =&gt; true,</pre>
<p>A somewhat bizarre twist with property patterns is that you can also introduce variables at the <em>property</em> level:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80, Host: <strong>string host</strong> } =&gt; <strong>host</strong>.Length &lt; 1000,</pre>
<p>Implicit typing is permitted, so you can substitute <code>string</code> with <code>var</code>. Here’s a complete example:</p>
<pre data-type="programlisting">bool ShouldAllow (Uri uri) =&gt; uri switch
{
  { Scheme: "http",  Port: 80, Host: <strong>var host</strong> } =&gt; <strong>host</strong>.Length &lt; 1000,
  { Scheme: "https", Port: 443                } =&gt; true,
  { Scheme: "ftp",   Port: 21                 } =&gt; true,
  { IsLoopback: true                          } =&gt; true,
  _ =&gt; false
};</pre>
<p>It’s difficult to invent examples for which this saves more than a few characters. In our case, the alternative is actually shorter:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80 } =&gt; uri.<strong>Host</strong>.Length &lt; 1000 =&gt; ...</pre>
<p>Or:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80, <strong>Host: { Length: &lt; 1000 }</strong> } =&gt; ...</pre>
</div></section>
<section data-pdf-bookmark="List Patterns" data-type="sect2"><div class="sect2" id="list_patterns-id00076">
<h2>List Patterns</h2>
<p><a contenteditable="false" data-primary="C# 11" data-secondary="list patterns" data-type="indexterm" id="id2529"/><a contenteditable="false" data-primary="list patterns" data-type="indexterm" id="id2530"/>List patterns (from C# 11) work with any collection type that is countable (with a <code>Count</code> or <code>Length</code> property) and indexable (with an indexer of type <code>int</code> or <code>System.Index</code>).</p>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="in list patterns" data-type="indexterm" id="id2531"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="in list patterns" data-type="indexterm" id="id2532"/>A list pattern matches a series of elements in square brackets:</p>
<pre data-type="programlisting">int[] numbers = { 0, 1, 2, 3, 4 };
Console.Write (numbers is <strong>[0, 1, 2, 3, 4]</strong>);   // True</pre>
<p>An underscore matches a single element of any value:</p>
<pre data-type="programlisting">Console.Write (numbers is <strong>[0, 1, _, _, 4]</strong>);   // True</pre>
<p>The <code>var</code> pattern also works in matching a single element:</p>
<pre data-type="programlisting">Console.Write (numbers is [0, 1, <strong>var x</strong>, 3, 4] <strong>&amp;&amp; x &gt; 1</strong>);   // True</pre>
<p><a contenteditable="false" data-primary="slicing" data-secondary="list patterns and" data-type="indexterm" id="id2533"/>Two dots indicate a <em>slice</em>. A slice matches zero or more elements:</p>
<pre data-type="programlisting">Console.Write (numbers is <strong>[0, .., 4]</strong>);    // True</pre>
<p>With arrays and other types that support indices and ranges (see <a data-type="xref" href="ch02.html#indices_and_ranges-id00073">“Indices and Ranges”</a>), you can follow a slice with a <code>var</code> pattern:</p>
<pre data-type="programlisting">Console.Write (numbers is [0, <strong>.. var mid</strong>, 4] &amp;&amp; <strong>mid.Contains (2)</strong>); // True</pre>
<p>A list pattern can include at most one slice.<a contenteditable="false" data-primary="" data-startref="ch04.html1031" data-type="indexterm" id="id2534"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Attributes" data-type="sect1"><div class="sect1" id="attributes">
<h1>Attributes</h1>
<p><a contenteditable="false" data-primary="attributes" data-type="indexterm" id="ch04.html1032"/>You’re already familiar with the notion of attributing code elements of a program with modifiers, such as <code>virtual</code> or <code>ref</code>. These constructs are built into the language. <em>Attributes</em> are an extensible mechanism for adding custom information to code elements (assemblies, types, members, return values, parameters, and generic type parameters). This extensibility is useful for services that integrate deeply into the type system, without requiring special keywords or constructs in the C# language.</p>
<section data-pdf-bookmark="Attribute Classes" data-type="sect2"><div class="sect2" id="attribute_classes">
<h2>Attribute Classes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="attribute classes" data-type="indexterm" id="id2535"/>An attribute is defined by a class that inherits (directly or indirectly) from the abstract class <code>System.Attribute</code>. To attach an attribute to a code element, specify the attribute’s type name in square brackets, before the code element. For example, the following attaches the <code>ObsoleteAttribute</code> to the <code>Foo</code> class:</p>
<pre data-type="programlisting"><strong>[ObsoleteAttribute]</strong>
<strong>public class Foo {...}</strong></pre>
<p>This particular attribute is recognized by the compiler and will cause compiler warnings if a type or member marked as obsolete is referenced. By convention, all attribute types end in the word “Attribute.” C# recognizes this and allows you to omit the suffix when attaching an attribute:</p>
<pre data-type="programlisting"><strong>[Obsolete]</strong>
<strong>public class Foo {...}</strong></pre>
<p><code>ObsoleteAttribute</code> is a type declared in the <code>System</code> namespace as follows (simplified for brevity):</p>
<pre data-type="programlisting">public sealed class ObsoleteAttribute : Attribute {...}</pre>
<p>The .NET libraries include many predefined attributes. We describe how to write your own attributes in <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>.</p>
</div></section>
<section data-pdf-bookmark="Named and Positional Attribute Parameters" data-type="sect2"><div class="sect2" id="named_and_positional_attribute_paramete">
<h2>Named and Positional Attribute Parameters</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="named/positional parameters" data-type="indexterm" id="id2536"/><a contenteditable="false" data-primary="System..." data-secondary="System.Attribute" data-type="indexterm" id="id2537"/>Attributes can have parameters. In the following example, we apply <code>XmlTypeAttribute</code> to a class. <a contenteditable="false" data-primary="System..." data-secondary="System.Xml.Serialization" data-type="indexterm" id="id2538"/>This attribute instructs the XML serializer (in <code>System.Xml.Serialization</code>) as to how an object is represented in XML and accepts several <em>attribute parameters</em>. The following attribute maps the <code>CustomerEntity</code> class to an XML element named <code>Customer</code>, which belongs to the <code>http://oreilly.com</code> namespace:</p>
<pre data-type="programlisting"><strong>[XmlType ("Customer", Namespace="http://oreilly.com")]</strong>
<strong>public class CustomerEntity { ... }</strong></pre>
<p>(We cover XML and JSON serialization in the online supplement at <a href="http://www.albahari.com/nutshell"><em class="hyperlink">http://www.albahari.com/nutshell</em></a>.)</p>
<p><a contenteditable="false" data-primary="patterns" data-secondary="positional patterns" data-type="indexterm" id="id2539"/><a contenteditable="false" data-primary="positional patterns" data-type="indexterm" id="id2540"/>Attribute parameters fall into one of two categories: <em>positional</em> or <em>named</em>. In the preceding example, the first argument is a positional parameter; the second is a named parameter. Positional parameters correspond to parameters of the attribute type’s public constructors. Named parameters correspond to public fields or public properties on the attribute type.</p>
<p>When specifying an attribute, you must include positional parameters that correspond to one of the attribute’s constructors. Named parameters are optional.</p>
<p>In <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>, we describe the valid parameter types and rules for their evaluation.</p>
</div></section>
<section data-pdf-bookmark="Applying Attributes to Assemblies and Backing Fields" data-type="sect2"><div class="sect2" id="applying_attributes_to_assemblies_and_b">
<h2>Applying Attributes to Assemblies and Backing Fields</h2>
<p><a contenteditable="false" data-primary="assemblies" data-secondary="applying attributes to" data-type="indexterm" id="id2541"/><a contenteditable="false" data-primary="attributes" data-secondary="applying to assemblies and backing fields" data-type="indexterm" id="id2542"/><a contenteditable="false" data-primary="backing fields" data-type="indexterm" id="id2543"/>Implicitly, the target of an attribute is the code element it immediately precedes, which is typically a type or type member. You can also attach attributes, however, to an assembly. This requires that you explicitly specify the attribute’s target. Here is how you can use the <code>AssemblyFileVersion</code> attribute to attach a version to the assembly:</p>
<pre data-type="programlisting">[assembly: AssemblyFileVersion ("1.2.3.4")]</pre>
<p>With the <code>field:</code> prefix, you can apply an attribute to the backing fields of an automatic property. This is useful in special cases, such as when applying the (now-deprecated) <code>NonSerialized</code> attribute:</p>
<pre data-type="programlisting">[<strong>field:</strong>NonSerialized]
public int MyProperty { get; set; }</pre>
</div></section>
<section data-pdf-bookmark="Applying Attributes to Lambda Expressions" data-type="sect2"><div class="sect2" id="applying_attributes_to_lambda_expressio">
<h2>Applying Attributes to Lambda Expressions</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="applying to lambda expressions (C# 10)" data-type="indexterm" id="id2544"/><a contenteditable="false" data-primary="C# 10" data-secondary="applying attributes to lambda expressions" data-type="indexterm" id="id2545"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="applying attributes to (C# 10)" data-type="indexterm" id="id2546"/>From C# 10, you can apply attributes to the method, parameters, and return value of a lambda expression:</p>
<pre data-type="programlisting">Action&lt;int&gt; a = [Description ("Method")]
                [return: Description ("Return value")]
                ([Description ("Parameter")]int x) =&gt; Console.Write (x);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is useful when working with frameworks—such as ASP.NET—that rely on you placing attributes on methods that you write. With this feature, you can avoid having to create named methods for simple operations.</p>
</div>
<p>These attributes are applied to the compiler-generated method to which the delegate points. In <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>, we’ll describe how to reflect over attributes in code. For now, here’s the extra code you need to resolve that indirection:</p>
<pre data-type="programlisting">var methodAtt = a.GetMethodInfo().GetCustomAttributes();
var paramAtt = a.GetMethodInfo().GetParameters()[0].GetCustomAttributes();
var returnAtt = a.GetMethodInfo().ReturnParameter.GetCustomAttributes();</pre>
<p>To avoid syntactical ambiguity when applying attributes to a parameter on a lambda expression, parentheses are always required. Attributes are not permitted on expression-tree lambdas.</p>
</div></section>
<section data-pdf-bookmark="Specifying Multiple Attributes" data-type="sect2"><div class="sect2" id="specifying_multiple_attributes">
<h2>Specifying Multiple Attributes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="specifying multiple attributes" data-type="indexterm" id="id2547"/>You can specify multiple attributes for a single code element. You can list each attribute either within the same pair of square brackets (separated by a comma) or in separate pairs of square brackets (or a combination of the two). The following three examples are semantically identical:</p>
<pre data-type="programlisting">[Serializable, Obsolete, CLSCompliant(false)]
public class Bar {...}

[Serializable] [Obsolete] [CLSCompliant(false)]
public class Bar {...}

[Serializable, Obsolete]
[CLSCompliant(false)]
public class Bar {...}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Caller Info Attributes" data-type="sect1"><div class="sect1" id="caller_info_attributes">
<h1>Caller Info Attributes</h1>
<p><a contenteditable="false" data-primary="attributes" data-secondary="caller info attributes" data-type="indexterm" id="id2548"/><a contenteditable="false" data-primary="caller info attributes" data-type="indexterm" id="id2549"/>You can tag optional parameters with one of three <em>caller info attributes</em>, which instruct the compiler to feed information obtained from the caller’s source code into the parameter’s default value:</p>
<ul>
<li><p><code>[CallerMemberName]</code> applies the caller’s member name.</p></li>
<li><p><code>[CallerFilePath]</code> applies the path to the caller’s source code file.</p></li>
<li><p><code>[CallerLineNumber]</code> applies the line number in the caller’s source code file.</p></li>
</ul>
<p>The <code>Foo</code> method in the following program demonstrates all three:</p>
<pre data-type="programlisting">using System;
using System.Runtime.CompilerServices;

class Program
{
  static void Main() =&gt; Foo();

  static void Foo (
    <strong>[CallerMemberName]</strong> string memberName = null,
    <strong>[CallerFilePath]</strong> string filePath = null,
    <strong>[CallerLineNumber]</strong> int lineNumber = 0)
  {
    Console.WriteLine (memberName);
    Console.WriteLine (filePath);
    Console.WriteLine (lineNumber);
  }
}</pre>
<p>Assuming that our program resides in <em>c:\source\test\Program.cs</em>, the output would be:</p>
<pre data-type="programlisting">Main
c:\source\test\Program.cs
6</pre>
<p>As with standard optional parameters, the substitution is done at the <em>calling site</em>. Hence, our <code>Main</code> method is syntactic sugar for this:</p>
<pre data-type="programlisting">static void Main() =&gt; Foo ("Main", @"c:\source\test\Program.cs", 6);</pre>
<p>Caller info attributes are useful for logging—and for implementing patterns such as firing a single change notification event whenever any property on an object changes. In fact, there’s a standard interface for this in the <code>System.ComponentModel</code> namespace, called <code>INotifyPropertyChanged</code>:</p>
<pre data-type="programlisting">public interface INotifyPropertyChanged
{
  event PropertyChangedEventHandler PropertyChanged;
}

public delegate void PropertyChangedEventHandler
  (object sender, PropertyChangedEventArgs e);

public class PropertyChangedEventArgs : EventArgs
{
  public PropertyChangedEventArgs (<strong>string propertyName</strong>);
  public virtual string PropertyName { get; }
}</pre>
<p>Notice that <code>PropertyChangedEventArgs</code> requires the name of the property that changed. By applying the <code>[CallerMemberName]</code> attribute, however, we can implement this interface and invoke the event without ever specifying property names:<a contenteditable="false" data-primary="" data-startref="ch04.html1032" data-type="indexterm" id="id2550"/></p>
<pre data-type="programlisting">public class Foo : INotifyPropertyChanged
{
  public event PropertyChangedEventHandler PropertyChanged = delegate { };

  void RaisePropertyChanged (<strong>[CallerMemberName]</strong> string propertyName = null)
    =&gt; PropertyChanged (this, new PropertyChangedEventArgs (propertyName));

  string customerName;
  public string CustomerName
  {  
    get =&gt; customerName;
    set  
    {  
      if (value == customerName) return;
      customerName = value;
      <strong>RaisePropertyChanged();</strong>
      // The compiler converts the above line to:
      // <strong>RaisePropertyChanged ("CustomerName");</strong>
    } 
  }
}</pre>
<section data-pdf-bookmark="CallerArgumentExpression" data-type="sect2"><div class="sect2" id="callerargumentexpression-id00054">
<h2>CallerArgumentExpression</h2>
<p><a contenteditable="false" data-primary="C# 10" data-secondary="CallerArgumentExpression" data-type="indexterm" id="id2551"/><a contenteditable="false" data-primary="CallerArgumentExpression" data-type="indexterm" id="id2552"/><a contenteditable="false" data-primary="method parameters" data-secondary="CallerArgumentExpression and" data-type="indexterm" id="id2553"/>A method parameter to which you apply the <code>[CallerArgumentExpression]</code> attribute (from C# 10) captures an argument expression from the call site:</p>
<pre data-type="programlisting">Print (<strong>Math.PI * 2</strong>);

void Print (double number,
           [<strong>CallerArgumentExpression("number")</strong>] string expr = null)
  =&gt; Console.WriteLine (expr);

// Output: <strong>Math.PI * 2</strong></pre>
<p>The compiler feeds in the calling expression’s source code literally, including <span class="keep-together">comments</span>:</p>
<pre data-type="programlisting">Print (<strong>Math.PI /*(π)*/ * 2</strong>);

// Output:  <strong>Math.PI /*(π)*/ * 2</strong></pre>
<p>The main application for this feature is when writing validation and assertion libraries. In the following example, an exception is thrown, whose message includes the text “2 + 2 == 5”. This aids in debugging:</p>
<pre data-type="programlisting">Assert (2 + 2 == 5);

void Assert (bool condition,
            [<strong>CallerArgumentExpression ("condition")</strong>] string message = null)
{
  if (!condition) throw new Exception ("Assertion failed: " + message);
}</pre>
<p>Another example is the static <code>ThrowIfNull</code> method on the <code>ArgumentNullException</code> class. This method was introduced in .NET 6 and is defined as follows:</p>
<pre data-type="programlisting">public static void ThrowIfNull (object argument,
  <strong>[CallerArgumentExpression("argument")]</strong> string paramName = null)
{
  if (argument == null)
    throw new ArgumentNullException (paramName);
}</pre>
<p>It is used as follows:</p>
<pre data-type="programlisting">void Print (string message)
{
  <strong>ArgumentNullException.ThrowIfNull (message);</strong> 
  ...
}</pre>
<p>You can use <code>[CallerArgumentExpression]</code> multiple times, to capture multiple argument expressions.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Dynamic Binding" data-type="sect1"><div class="sect1" id="dynamic_binding">
<h1>Dynamic Binding</h1>
<p><a contenteditable="false" data-primary="binding" data-secondary="dynamic binding" data-type="indexterm" id="ch04.html1033"/><a contenteditable="false" data-primary="dynamic binding" data-type="indexterm" id="ch04.html1034"/><em>Dynamic binding</em> defers <em>binding</em>—the process of resolving types, members, and operators—from compile time to runtime. Dynamic binding is useful when at compile time <em>you</em> know that a certain function, member, or operation exists, but the <em>compiler</em> does not. This commonly occurs when you are interoperating with dynamic languages (such as IronPython) and COM as well as for scenarios in which you might otherwise use reflection.</p>
<p>A dynamic type is declared with the contextual keyword <code>dynamic</code>:</p>
<pre data-type="programlisting">dynamic d = GetSomeObject();
d.Quack();</pre>
<p>A dynamic type tells the compiler to relax. We expect the runtime type of <code>d</code> to have a <code>Quack</code> method. We just can’t prove it statically. Because <code>d</code> is dynamic, the compiler defers binding <code>Quack</code> to <code>d</code> until runtime. To understand what this means requires distinguishing between <em>static binding</em> and <em>dynamic binding</em>.</p>
<section data-pdf-bookmark="Static Binding Versus Dynamic Binding" data-type="sect2"><div class="sect2" id="static_binding_versus_dynamic_binding">
<h2>Static Binding Versus Dynamic Binding</h2>
<p><a contenteditable="false" data-primary="binding" data-secondary="static versus dynamic" data-type="indexterm" id="id2554"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="static binding versus" data-type="indexterm" id="id2555"/><a contenteditable="false" data-primary="static binding" data-type="indexterm" id="id2556"/>The canonical binding example is mapping a name to a specific function when compiling an expression. To compile the following expression, the compiler needs to find the implementation of the method named <code>Quack</code>:</p>
<pre data-type="programlisting">d.Quack();</pre>
<p>Let’s suppose that the static type of <code>d</code> is <code>Duck</code>:</p>
<pre data-type="programlisting">Duck d = ...
d.Quack();</pre>
<p>In the simplest case, the compiler does the binding by looking for a parameterless method named <code>Quack</code> on <code>Duck</code>. Failing that, the compiler extends its search to methods taking optional parameters, methods on base classes of <code>Duck</code>, and extension methods that take <code>Duck</code> as its first parameter. If no match is found, you’ll get a compilation error. Regardless of what method is bound, the bottom line is that the binding is done by the compiler, and the binding utterly depends on statically knowing the types of the operands (in this case, <code>d</code>). This makes it <em>static binding</em>.</p>
<p>Now let’s change the static type of <code>d</code> to <code>object</code>:</p>
<pre data-type="programlisting">object d = ...
d.Quack();</pre>
<p>Calling <code>Quack</code> gives us a compilation error, because although the value stored in <code>d</code> can contain a method called <code>Quack</code>, the compiler cannot know it, because the only information it has is the type of the variable, which in this case is <code>object</code>. But let’s now change the static type of <code>d</code> to <code>dynamic</code>:</p>
<pre data-type="programlisting">dynamic d = ...
d.Quack();</pre>
<p>A <code>dynamic</code> type is like <code>object</code>—it’s equally nondescriptive about a type. The difference is that it lets you use it in ways that aren’t known at compile time. A dynamic object binds at runtime based on its runtime type, not its compile-time type. When the compiler sees a dynamically bound expression (which in general is an expression that contains any value of type <code>dynamic</code>), it merely packages up the expression such that the binding can be done later at runtime.</p>
<p>At runtime, if a dynamic object implements <code>IDynamicMetaObjectProvider</code>, that interface is used to perform the binding. If not, binding occurs in almost the same way as it would have had the compiler known the dynamic object’s runtime type. These two alternatives are called <em>custom binding</em> and <em>language binding</em>.</p>
</div></section>
<section data-pdf-bookmark="Custom Binding" data-type="sect2"><div class="sect2" id="custom_binding">
<h2>Custom Binding</h2>
<p><a contenteditable="false" data-primary="custom binding" data-type="indexterm" id="id2557"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="custom binding" data-type="indexterm" id="id2558"/><a contenteditable="false" data-primary="IDynamicMetaObjectProvider (IDMOP)" data-type="indexterm" id="id2559"/>Custom binding occurs when a dynamic object implements <code>IDynamicMetaObjectProvider</code> (IDMOP). Although you can implement IDMOP on types that you write in C#, and that is useful to do, <a contenteditable="false" data-primary="DLR (Dynamic Language Runtime)" data-type="indexterm" id="id2560"/><a contenteditable="false" data-primary="Dynamic Language Runtime (DLR)" data-type="indexterm" id="id2561"/>the more common case is that you have acquired an IDMOP object from a dynamic language that is implemented in .NET on the Dynamic Language Runtime (DLR), such as IronPython or IronRuby. Objects from those languages implicitly implement IDMOP as a means to directly control the meanings of operations performed on them.</p>
<p>We discuss custom binders in greater detail in <a data-type="xref" href="ch19.html#dynamic_programming">Chapter 19</a>, but for now, let’s write a simple one to demonstrate the feature:</p>
<pre data-type="programlisting">using System;
using System.Dynamic;

dynamic d = new Duck();
d.Quack();                  // Quack method was called
d.Waddle();                 // Waddle method was called

public class Duck : DynamicObject
{
  public override bool TryInvokeMember (
    InvokeMemberBinder binder, object[] args, out object result)
  {
    Console.WriteLine (binder.Name + " method was called");
    result = null;
    return true;
  }
}</pre>
<p>The <code>Duck</code> class doesn’t actually have a <code>Quack</code> method. Instead, it uses custom binding to intercept and interpret all method calls.</p>
</div></section>
<section data-pdf-bookmark="Language Binding" data-type="sect2"><div class="sect2" id="language_binding">
<h2>Language Binding</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="language binding" data-type="indexterm" id="id2562"/><a contenteditable="false" data-primary="language binding" data-type="indexterm" id="id2563"/>Language binding occurs when a dynamic object does not implement <code>IDynamic​Me⁠taObjectProvider</code>. It is useful when working around imperfectly designed types or inherent limitations in the .NET type system (we explore more scenarios in <a data-type="xref" href="ch19.html#dynamic_programming">Chapter 19</a>). A typical problem when using numeric types is that they have no common interface. We have seen that we can bind methods dynamically; the same is true for operators:</p>
<pre data-type="programlisting">int x = 3, y = 4;
Console.WriteLine (Mean (x, y));

dynamic Mean (dynamic x, dynamic y) =&gt; (x + y) / 2;</pre>
<p>The benefit is obvious—you don’t need to duplicate code for each numeric type. However, you lose static type safety, risking runtime exceptions rather than compile-time errors.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dynamic binding circumvents static type safety, but not runtime type safety. Unlike with reflection (<a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>), you can’t circumvent member accessibility rules with dynamic binding.</p>
</div>
<p>By design, language runtime binding behaves as similarly as possible to static binding, had the runtime types of the dynamic objects been known at compile time. In our previous example, the behavior of our program would be identical if we hardcoded <code>Mean</code> to work with the <code>int</code> type. The most notable exception in parity between static and dynamic binding is for extension methods, which we discuss in <a data-type="xref" href="#uncallable_functions">“Uncallable Functions”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dynamic binding also incurs a performance hit. Because of the DLR’s caching mechanisms, however, repeated calls to the same dynamic expression are optimized—allowing you to efficiently call dynamic expressions in a loop. This optimization brings the typical overhead for a simple dynamic expression on today’s hardware down to less than 100 ns.</p>
</div>
</div></section>
<section data-pdf-bookmark="RuntimeBinderException" data-type="sect2"><div class="sect2" id="runtimebinderexception">
<h2>RuntimeBinderException</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="RuntimeBinderException" data-type="indexterm" id="id2564"/><a contenteditable="false" data-primary="RuntimeBinderException" data-type="indexterm" id="id2565"/>If a member fails to bind, a <code>RuntimeBinderException</code> is thrown. You can think of this like a compile-time error at runtime:</p>
<pre data-type="programlisting">dynamic d = 5;
d.Hello();                  // throws RuntimeBinderException</pre>
<p>The exception is thrown because the <code>int</code> type has no <code>Hello</code> method.</p>
</div></section>
<section data-pdf-bookmark="Runtime Representation of Dynamic" data-type="sect2"><div class="sect2" id="runtime_representation_of_dynamic">
<h2>Runtime Representation of Dynamic</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="runtime representation of dynamic" data-type="indexterm" id="id2566"/>There is a deep equivalence between the <code>dynamic</code> and <code>object</code> types. The runtime treats the following expression as <code>true</code>:</p>
<pre data-type="programlisting">typeof (dynamic) == typeof (object)</pre>
<p>This principle extends to constructed types and array types:</p>
<pre data-type="programlisting">typeof (List&lt;dynamic&gt;) == typeof (List&lt;object&gt;)
typeof (dynamic[]) == typeof (object[])</pre>
<p>Like an object reference, a dynamic reference can point to an object of any type (except pointer types):</p>
<pre data-type="programlisting">dynamic x = "hello";
Console.WriteLine (x.GetType().Name);  // String

x = 123;  // No error (despite same variable)
Console.WriteLine (x.GetType().Name);  // Int32</pre>
<p>Structurally, there is no difference between an object reference and a dynamic reference. A dynamic reference simply enables dynamic operations on the object it points to. You can convert from <code>object</code> to <code>dynamic</code> to perform any dynamic operation you want on an <code>object</code>:</p>
<pre data-type="programlisting">object o = new System.Text.StringBuilder();
dynamic d = o;
d.Append ("hello");
Console.WriteLine (o);   // hello</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Reflecting on a type exposing (public) <code>dynamic</code> members reveals that those members are represented as annotated <code>object</code>s. For example,</p>
<pre data-type="programlisting">public class Test
{
  public dynamic Foo;
}</pre>
<p>is equivalent to:</p>
<pre data-type="programlisting">public class Test
{
  [System.Runtime.CompilerServices.DynamicAttribute]
  public object Foo;
}</pre>
<p>This allows consumers of that type to know that <code>Foo</code> should be treated as dynamic while allowing languages that don’t support dynamic binding to fall back to <code>object</code>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Dynamic Conversions" data-type="sect2"><div class="sect2" id="dynamic_conversions-id00011">
<h2>Dynamic Conversions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="conversions" data-type="indexterm" id="id2567"/>The <code>dynamic</code> type has implicit conversions to and from all other types:</p>
<pre data-type="programlisting">int i = 7;
dynamic d = i;
long j = d;        // No cast required (implicit conversion)</pre>
<p>For the conversion to succeed, the runtime type of the dynamic object must be implicitly convertible to the target static type. The preceding example worked because an <code>int</code> is implicitly convertible to a <code>long</code>.</p>
<p><a contenteditable="false" data-primary="RuntimeBinderException" data-type="indexterm" id="id2568"/>The following example throws a <code>RuntimeBinderException</code> because an <code>int</code> is not implicitly convertible to a <code>short</code>:</p>
<pre data-type="programlisting">int i = 7;
dynamic d = i;
short j = d;      // throws RuntimeBinderException</pre>
</div></section>
<section data-pdf-bookmark="var Versus dynamic" data-type="sect2"><div class="sect2" id="var_versus_dynamic">
<h2>var Versus dynamic</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="var versus dynamic types" data-type="indexterm" id="id2569"/><a contenteditable="false" data-primary="dynamic type" data-type="indexterm" id="id2570"/><a contenteditable="false" data-primary="var type, dynamic type versus" data-type="indexterm" id="id2571"/>The <code>var</code> and <code>dynamic</code> types bear a superficial resemblance, but the difference is deep:</p>
<ul class="simplelist">
<li><p><code>var</code> says, “Let the <em>compiler</em> figure out the type.”</p></li>
<li><p><code>dynamic</code> says, “Let the <em>runtime</em> figure out the type.”</p></li>
</ul>
<p>To illustrate:</p>
<pre data-type="programlisting">dynamic x = "hello";  // Static type is <strong>dynamic</strong>, runtime type is string
var y = "hello";      // Static type is <strong>string</strong>, runtime type is string
int i = x;            // Runtime error      (cannot convert string to int)
int j = y;            // Compile-time error (cannot convert string to int)</pre>
<p>The static type of a variable declared with <code>var</code> can be <code>dynamic</code>:</p>
<pre data-type="programlisting">dynamic x = "hello";
var y = x;            // Static type of y is dynamic
int z = y;            // Runtime error (cannot convert string to int)</pre>
</div></section>
<section data-pdf-bookmark="Dynamic Expressions" data-type="sect2"><div class="sect2" id="dynamic_expressions">
<h2>Dynamic Expressions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="dynamic expressions" data-type="indexterm" id="id2572"/><a contenteditable="false" data-primary="dynamic expressions" data-type="indexterm" id="id2573"/><a contenteditable="false" data-primary="dynamic receivers, dynamic calls without" data-type="indexterm" id="id2574"/>Fields, properties, methods, events, constructors, indexers, operators, and conversions can all be called dynamically.</p>
<p>Trying to consume the result of a dynamic expression with a <code>void</code> return type is prohibited—just as with a statically typed expression. The difference is that the error occurs at runtime:</p>
<pre data-type="programlisting">dynamic list = new List&lt;int&gt;();
var result = list.Add (5);         // RuntimeBinderException thrown</pre>
<p>Expressions involving dynamic operands are typically themselves dynamic because the effect of absent type information is cascading:</p>
<pre data-type="programlisting">dynamic x = 2;
var y = x * 3;       // Static type of y is dynamic</pre>
<p>There are a couple of obvious exceptions to this rule. First, casting a dynamic expression to a static type yields a static expression:</p>
<pre data-type="programlisting">dynamic x = 2;
var y = (int)x;      // Static type of y is int</pre>
<p>Second, constructor invocations always yield static expressions—even when called with dynamic arguments. In this example, <code>x</code> is statically typed to a <code>StringBuilder</code>:</p>
<pre data-type="programlisting">dynamic capacity = 10;
var x = new System.Text.StringBuilder (capacity);</pre>
<p>In addition, there are a few edge cases for which an expression containing a dynamic argument is static, including passing an index to an array and delegate creation expressions.</p>
</div></section>
<section data-pdf-bookmark="Dynamic Calls Without Dynamic Receivers" data-type="sect2"><div class="sect2" id="dynamic_calls_without_dynamic_receivers">
<h2>Dynamic Calls Without Dynamic Receivers</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="dynamic calls without dynamic receivers" data-type="indexterm" id="id2575"/><a contenteditable="false" data-primary="dynamic calls" data-type="indexterm" id="id2576"/>The canonical use case for <code>dynamic</code> involves a dynamic <em>receiver</em>. This means that a dynamic object is the receiver of a dynamic function call:</p>
<pre data-type="programlisting">dynamic x = ...;
x.Foo();          // x is the receiver</pre>
<p>However, you can also call statically known functions with dynamic arguments. Such calls are subject to dynamic overload resolution, and can include the following:</p>
<ul>
<li><p>Static methods</p></li>
<li><p>Instance constructors</p></li>
<li><p>Instance methods on receivers with a statically known type</p></li>
</ul>
<p>In the following example, the particular <code>Foo</code> that gets dynamically bound is dependent on the runtime type of the dynamic argument:</p>
<pre data-type="programlisting">class Program
{
  static void Foo (int x)    =&gt; Console.WriteLine ("int");
  static void Foo (string x) =&gt; Console.WriteLine ("string");

  static void Main()
  {
    dynamic x = 5;
    dynamic y = "watermelon";

    Foo (x);    // int
    Foo (y);    // string
  }
}</pre>
<p>Because a dynamic receiver is not involved, the compiler can statically perform a basic check to see whether the dynamic call will succeed. It checks whether a function with the correct name and number of parameters exists. If no candidate is found, you get a compile-time error:</p>
<pre data-type="programlisting">class Program
{
  static void Foo (int x)    =&gt; Console.WriteLine ("int");
  static void Foo (string x) =&gt; Console.WriteLine ("string");

  static void Main()
  {
    dynamic x = 5;
    Foo (x, x);        // Compiler error - wrong number of parameters
    Fook (x);          // Compiler error - no such method name
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Static Types in Dynamic Expressions" data-type="sect2"><div class="sect2" id="static_types_in_dynamic_expressions">
<h2>Static Types in Dynamic Expressions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="static types in dynamic expressions" data-type="indexterm" id="id2577"/><a contenteditable="false" data-primary="static types" data-type="indexterm" id="id2578"/>It’s obvious that dynamic types are used in dynamic binding. It’s not so obvious that static types are also used—wherever possible—in dynamic binding. Consider the following:</p>
<pre data-type="programlisting">class Program
{
  static void Foo (object x, object y) { Console.WriteLine ("oo"); }
  static void Foo (object x, string y) { Console.WriteLine ("os"); }
  static void Foo (string x, object y) { Console.WriteLine ("so"); }
  static void Foo (string x, string y) { Console.WriteLine ("ss"); }

  static void Main()
  {
    object o = "hello";
    dynamic d = "goodbye";
    Foo (o, d);               // os
  }
}</pre>
<p>The call to <code>Foo(o,d)</code> is dynamically bound because one of its arguments, <code>d</code>, is <code>dynamic</code>. But because <code>o</code> is statically known, the binding—even though it occurs dynamically—will make use of that. In this case, overload resolution will pick the second implementation of <code>Foo</code> due to the static type of <code>o</code> and the runtime type of <code>d</code>. In other words, the compiler is “as static as it can possibly be.”</p>
</div></section>
<section data-pdf-bookmark="Uncallable Functions" data-type="sect2"><div class="sect2" id="uncallable_functions">
<h2>Uncallable Functions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="uncallable functions" data-type="indexterm" id="id2579"/>Some functions cannot be called dynamically. You cannot call the following:</p>
<ul>
<li><p>Extension methods (via extension method syntax)</p></li>
<li><p>Members of an interface, if you need to cast to that interface to do so</p></li>
<li><p>Base members hidden by a subclass</p></li>
</ul>
<p>Understanding why this is so is useful in understanding dynamic binding.</p>
<p>Dynamic binding requires two pieces of information: the name of the function to call and the object upon which to call the function. However, in each of the three uncallable scenarios, an <em>additional type</em> is involved, which is known only at compile time. As of this writing, there’s no way to specify these additional types dynamically.</p>
<p>When calling extension methods, that additional type is implicit. It’s the static class on which the extension method is defined. The compiler searches for it given the <code>using</code> directives in your source code. This makes extension methods compile-time-only concepts because <code>using</code> directives melt away upon compilation (after they’ve done their job in the binding process in mapping simple names to namespace-qualified names).</p>
<p>When calling members via an interface, you specify that additional type via an implicit or explicit cast. There are two scenarios for which you might want to do this: when calling explicitly implemented interface members and when calling interface members implemented in a type internal to another assembly. We can illustrate the former with the following two types:</p>
<pre data-type="programlisting">interface IFoo   { void Test();        }
class Foo : IFoo { void IFoo.Test() {} }</pre>
<p>To call the <code>Test</code> method, we must cast to the <code>IFoo</code> interface. This is easy with static typing:</p>
<pre data-type="programlisting">IFoo f = new Foo();   // Implicit cast to interface
f.Test();</pre>
<p>Now consider the situation with dynamic typing:</p>
<pre data-type="programlisting"><strong>IFoo</strong> f = new Foo();
dynamic d = f;
d.Test();             // Exception thrown</pre>
<p>The implicit cast shown in bold tells the <em>compiler</em> to bind subsequent member calls on <code>f</code> to <code>IFoo</code> rather than <code>Foo</code>—in other words, to view that object through the lens of the <code>IFoo</code> interface. However, that lens is lost at runtime, so the DLR cannot complete the binding. The loss is illustrated as follows:</p>
<pre data-type="programlisting">Console.WriteLine (f.GetType().Name);    // Foo</pre>
<p>A similar situation arises when calling a hidden base member: you must specify an additional type via either a cast or the <code>base</code> keyword—and that additional type is lost at runtime.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Should you need to invoke interface members dynamically, a workaround is to use the Uncapsulator open source library, available on NuGet and GitHub. Uncapsulator was written by the author to address this problem, and leverages <em>custom binding</em> to provide a better dynamic than <code>dynamic</code>:</p>
<pre data-type="programlisting">IFoo f = new Foo();
dynamic uf = f.<strong>Uncapsulate()</strong>;
uf.Test();</pre>
<p>Uncapsulator also lets you cast to base types and interfaces by name, dynamically call static members, and access nonpublic members of a type.<a contenteditable="false" data-primary="" data-startref="ch04.html1034" data-type="indexterm" id="id2580"/><a contenteditable="false" data-primary="" data-startref="ch04.html1033" data-type="indexterm" id="id2581"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Operator Overloading" data-type="sect1"><div class="sect1" id="operator_overloading">
<h1>Operator Overloading</h1>
<p><a contenteditable="false" data-primary="operator overloading" data-type="indexterm" id="ch04.html1035"/>You can overload operators to provide more natural syntax for custom types. Operator overloading is most appropriately used for implementing custom structs that represent fairly primitive data types. For example, a custom numeric type is an excellent candidate for operator overloading.</p>
<p>The following symbolic operators can be overloaded:</p>
<table class="border">
<tbody>
<tr>
<td><code>+</code> (unary)</td>
<td><code>-</code> (unary)</td>
<td><code>!</code></td>
<td><code>˜</code></td>
<td><code>++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td><code>+</code></td>
<td><code>-</code></td>
<td><code>*</code></td>
<td><code>/</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>&amp;</code></td>
<td><code>|</code></td>
<td><code>^</code></td>
<td><code>&lt;&lt;</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td><code>==</code></td>
<td><code>!=</code></td>
<td><code>&gt;</code></td>
<td><code>&lt;</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>&lt;=</code></td>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
<p>The following operators are also overloadable:</p>
<ul>
<li><p>Implicit and explicit conversions (with the <code>implicit</code> and <code>explicit</code> keywords)</p></li>
<li><p>The <code>true</code> and <code>false</code> <em>operators</em> (not <em>literals</em>)</p></li>
</ul>
<p class="pagebreak-before">The following operators are indirectly overloaded:</p>
<ul>
<li><p>The compound assignment operators (e.g., <code>+=</code>, <code>/=</code>) are implicitly overridden by overriding the noncompound operators (e.g., <code>+</code>, <code>/</code>).</p></li>
<li><p>The conditional operators <code>&amp;&amp;</code> and <code>||</code> are implicitly overridden by overriding the bitwise operators <code>&amp;</code> and <code>|</code>.</p></li>
</ul>
<section data-pdf-bookmark="Operator Functions" data-type="sect2"><div class="sect2" id="operator_functions">
<h2>Operator Functions</h2>
<p><a contenteditable="false" data-primary="operator overloading" data-secondary="operator functions" data-type="indexterm" id="id2582"/>You overload an operator by declaring an <em>operator function</em>. An operator function has the following rules:</p>
<ul>
<li><p>The name of the function is specified with the <code>operator</code> keyword followed by an operator symbol.</p></li>
<li><p>The operator function must be marked <code>static</code> and <code>public</code>.</p></li>
<li><p>The parameters of the operator function represent the operands.</p></li>
<li><p>The return type of an operator function represents the result of an expression.</p></li>
<li><p>At least one of the operands must be the type in which the operator function is declared.</p></li>
</ul>
<p>In the following example, we define a struct called <code>Note</code> representing a musical note and then overload the <code>+</code> operator:</p>
<pre data-type="programlisting">public struct Note
{
  int value;
  public Note (int semitonesFromA) { value = semitonesFromA; }
  <strong>public static Note operator + (Note x, int semitones)</strong>
  {
    return new Note (x.value + semitones);
  }
}</pre>
<p>This overload allows us to add an <code>int</code> to a <code>Note</code>:</p>
<pre data-type="programlisting">Note B = new Note (2);
Note CSharp = B + 2;</pre>
<p>Overloading an operator automatically overloads the corresponding compound assignment operator. In our example, because we overrode <code>+</code>, we can use <code>+=</code>, too:</p>
<pre data-type="programlisting">CSharp += 2;</pre>
<p><a contenteditable="false" data-primary="= (expression-bodied members)" data-type="indexterm" id="id2583"/><a contenteditable="false" data-primary="expression-bodied members (=)" data-type="indexterm" id="id2584"/>Just as with methods and properties, C# allows operator functions comprising a single expression to be written more tersely with expression-bodied syntax:</p>
<pre data-type="programlisting">public static Note operator + (Note x, int semitones)
                               =&gt; new Note (x.value + semitones);</pre>
<section data-pdf-bookmark="Checked operators" data-type="sect3"><div class="sect3" id="checked_operators">
<h3>Checked operators</h3>
<p><a contenteditable="false" data-primary="C# 11" data-secondary="checked operators" data-type="indexterm" id="id2585"/><a contenteditable="false" data-primary="checked operators" data-type="indexterm" id="id2586"/><a contenteditable="false" data-primary="operator overloading" data-secondary="checked operators" data-type="indexterm" id="id2587"/>From C# 11, when you declare an operator function, you can also declare a <code>checked</code> version:</p>
<pre data-type="programlisting">public static Note operator + (Note x, int semitones)
  =&gt; new Note (x.value + semitones);

public static Note operator <strong>checked</strong> + (Note x, int semitones)
  =&gt; checked (new Note (x.value + semitones));</pre>
<p>The checked version will be called inside checked expressions or blocks:</p>
<pre data-type="programlisting">Note B = new Note (2);
Note other = <strong>checked (</strong>B + int.MaxValue<strong>)</strong>;  // throws OverflowException</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Overloading Equality and Comparison Operators" data-type="sect2"><div class="sect2" id="overloading_equality_and_comparison_ope">
<h2>Overloading Equality and Comparison Operators</h2>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="overloading" data-type="indexterm" id="id2588"/><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="id2589"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="overloading" data-type="indexterm" id="id2590"/><a contenteditable="false" data-primary="operator overloading" data-secondary="overloading equality/comparison operators" data-type="indexterm" id="id2591"/><a contenteditable="false" data-primary="overloading" data-secondary="equality operator (==)" data-type="indexterm" id="id2592"/>Equality and comparison operators are sometimes overridden when writing structs, and in rare cases when writing classes. Special rules and obligations come with overloading the equality and comparison operators, which we explain in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>. A summary of these rules is as follows:</p>
<dl>
<dt>Pairing</dt>
<dd>The C# compiler enforces operators that are logical pairs to both be defined. These operators are (<code>==</code>  <code>!=</code>), (<code>&lt;</code>  <code>&gt;</code>), and (<code>&lt;=</code>  <code>&gt;=</code>).</dd>
<dt><code>Equals</code> and <code>GetHashCode</code></dt>
<dd>In most cases, if you overload (<code>==</code>) and (<code>!=</code>), you must override the <code>Equals</code> and <code>GetHashCode</code> methods defined on <code>object</code> in order to get meaningful behavior. The C# compiler will give a warning if you do not do this. (See <a data-type="xref" href="#equality_comparison-id00016">“Equality Comparison”</a> for more details.)</dd>
<dt><code>IComparable</code> and <code>IComparable&lt;T&gt;</code></dt>
<dd>If you overload (<code>&lt; &gt;</code>) and (<code>&lt;= &gt;=</code>), you should implement <code>IComparable</code> and <code>IComparable&lt;T&gt;</code>.</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Custom Implicit and Explicit Conversions" data-type="sect2"><div class="sect2" id="custom_implicit_and_explicit_conversion">
<h2>Custom Implicit and Explicit Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="operator overloading and" data-type="indexterm" id="id2593"/><a contenteditable="false" data-primary="operator overloading" data-secondary="custom implicit/explicit conversions" data-type="indexterm" id="id2594"/>Implicit and explicit conversions are overloadable operators. These conversions are typically overloaded to make converting between strongly related types (such as numeric types) concise and natural.</p>
<p>To convert between weakly related types, the following strategies are more suitable:</p>
<ul>
<li><p>Write a constructor that has a parameter of the type to convert from.</p></li>
<li><p>Write <code>To<em>XXX</em></code> and (static) <code>From<em>XXX</em></code> methods to convert between types.</p></li>
</ul>
<p class="pagebreak-before">As explained in the discussion on types, the rationale behind implicit conversions is that they are guaranteed to succeed and not lose information during the conversion. Conversely, an explicit conversion should be required either when runtime circumstances will determine whether the conversion will succeed or if information might be lost during the conversion.</p>
<p>In this example, we define conversions between our musical <code>Note</code> type and a double (which represents the frequency in hertz of that note):</p>
<pre data-type="programlisting">...
// Convert to hertz
public static implicit operator double (Note x)
  =&gt; 440 * Math.Pow (2, (double) x.value / 12 );

// Convert from hertz (accurate to the nearest semitone)
public static explicit operator Note (double x)
  =&gt; new Note ((int) (0.5 + 12 * (Math.Log (x/440) / Math.Log(2) ) ));
...

Note n = (Note)554.37;  // explicit conversion
double x = n;           // implicit conversion</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Following our own guidelines, this example might be better implemented with a <code>ToFrequency</code> method (and a static <code>FromFrequency</code> method) instead of implicit and explicit operators.</p>
</div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Custom conversions are ignored by the <code>as</code> and <code>is</code> operators:</p>
<pre data-type="programlisting">Console.WriteLine (554.37 is Note);   // False
Note n = 554.37 as Note;              // <em>Error</em></pre>
</div>
</div></section>
<section data-pdf-bookmark="Overloading true and false" data-type="sect2"><div class="sect2" id="overloading_true_and_false">
<h2>Overloading true and false</h2>
<p><a contenteditable="false" data-primary="operator overloading" data-secondary="true/false operators" data-type="indexterm" id="id2595"/>The <code>true</code> and <code>false</code> operators are overloaded in the extremely rare case of types that are Boolean “in spirit” but do not have a conversion to <code>bool</code>. An example is a type that implements three-state logic: by overloading <code>true</code> and <code>false</code>, such a type can work seamlessly with conditional statements and operators—namely, <code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>&amp;&amp;</code>, <code>||</code>, and <code>?:</code>. <a contenteditable="false" data-primary="System..." data-secondary="System.Data.SqlTypes.SqlBoolean" data-type="indexterm" id="id2596"/>The <code>System.Data.SqlTypes.SqlBoolean</code> struct provides this functionality:</p>
<pre data-type="programlisting">SqlBoolean a = SqlBoolean.Null;
if (a)
  Console.WriteLine ("True");
else if (!a)
  Console.WriteLine ("False");
else
  Console.WriteLine ("Null");

OUTPUT:
Null</pre>
<p>The following code is a reimplementation of the parts of <code>SqlBoolean</code> necessary to demonstrate the <code>true</code> and <code>false</code> operators:<a contenteditable="false" data-primary="" data-startref="ch04.html1035" data-type="indexterm" id="id2597"/></p>
<pre data-type="programlisting">public struct SqlBoolean
{
  public static bool operator <strong>true</strong> (SqlBoolean x)
    =&gt; x.m_value == True.m_value;

  public static bool operator <strong>false</strong> (SqlBoolean x)
    =&gt; x.m_value == False.m_value;  

  public static SqlBoolean operator <strong>!</strong> (SqlBoolean x)
  {
    if (x.m_value == Null.m_value)  return Null;
    if (x.m_value == False.m_value) return True;
    return False;
  }

  public static readonly SqlBoolean Null =  new SqlBoolean(0);
  public static readonly SqlBoolean False = new SqlBoolean(1);
  public static readonly SqlBoolean True =  new SqlBoolean(2);

  private SqlBoolean (byte value) { m_value = value; }
  private byte m_value;
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Static Polymorphism" data-type="sect1"><div class="sect1" id="static_polymorphism">
<h1>Static Polymorphism</h1>
<p><a contenteditable="false" data-primary="static polymorphism" data-type="indexterm" id="ch04.html0"/>In <a data-type="xref" href="ch18.html#calling_static_virtualsolidusabstract_i">“Calling Static Virtual/Abstract Interface Members”</a>, we introduced an advanced feature whereby an interface can define <code>static virtual</code> or <code>static abstract</code> members, which are then implemented as static members by classes and structs. Later, in <a data-type="xref" href="ch03.html#generic_constraints">“Generic Constraints”</a> we showed that applying an interface constraint to a type parameter gives a method access to that interface’s members. In this section, we’ll demonstrate how this enables <em>static polymorphism</em>, allowing for features such as generic math.</p>
<p>To illustrate, consider the following interface, which defines a static method to create a random instance of some type <code>T</code>:</p>
<pre data-type="programlisting">interface ICreateRandom&lt;T&gt;
{
  <strong>static abstract</strong> T CreateRandom();  // Create a random instance of T
}</pre>
<p>Suppose that we wish to implement this interface in the following record:</p>
<pre data-type="programlisting">record Point (int X, int Y);</pre>
<p><a contenteditable="false" data-primary="CreateRandom method" data-type="indexterm" id="id2598"/>With the help of the <code>System.Random</code> class (whose <code>Next</code> method generates a random integer), we can implement the static <code>CreateRandom</code> method as follows:</p>
<pre data-type="programlisting">record Point (int X, int Y) : ICreateRandom&lt;Point&gt;
{
  static Random rnd = new();
  <strong>public static Point CreateRandom()</strong> =&gt; new Point (rnd.Next(), rnd.Next());
}</pre>
<p>To call this method via the interface, we use a <em>constrained type parameter</em>. The following method creates an array of test data using this approach:</p>
<pre data-type="programlisting">T[] CreateTestData&lt;T&gt; (int count) <strong>where T : ICreateRandom&lt;T&gt;</strong>
{
  T[] result = new T[count];
  for (int i = 0; i &lt; count; i++)
    result [i] = <strong>T.CreateRandom()</strong>;
  return result;
}</pre>
<p>This line of code demonstrates its use:</p>
<pre data-type="programlisting">Point[] testData = CreateTestData&lt;Point&gt;(50);  // Create 50 random Points.</pre>
<p>Our call to the static <code>CreateRandom</code> method in <code>CreateTestData</code> is <em>polymorphic</em> because it works not just with <code>Point</code>, but with any type that implements <code>ICreateRandom&lt;T&gt;</code>. This is different from <em>instance</em> polymorphism, because we don’t need an <em>instance</em> of <code>ICreateRandom&lt;T&gt;</code> on which to call <code>CreateRandom</code>; we call <code>CreateRandom</code> on the type itself.</p>

<section data-pdf-bookmark="Polymorphic Operators" data-type="sect2"><div class="sect2" id="polymorphic_operators">
<h2>Polymorphic Operators</h2>
<p><a contenteditable="false" data-primary="polymorphic operators" data-type="indexterm" id="ch04.html1"/><a contenteditable="false" data-primary="static polymorphism" data-secondary="polymorphic operators" data-type="indexterm" id="ch04.html2"/>Because operators are essentially static functions (see <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>), operators can also be declared as static virtual interface members:</p>
<pre data-type="programlisting">interface IAddable&lt;T&gt; where T : IAddable&lt;T&gt;
{
   abstract static T operator + (T left, T right);
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="self-referencing type constraints" data-type="indexterm" id="id2599"/>The <em>self-referencing</em> type constraint in this interface definition is necessary to satisfy the compiler’s rules for operator overloading. Recall that when defining an operator function, at least one of the operands must be the type in which the operator function is declared. In this example, our operands are of type <code>T</code>, whereas the containing type is <code>IAddable&lt;T&gt;</code>, so we require a self-referencing type constraint to allow <code>T</code> to be treated as <code>IAddable&lt;T&gt;</code>.</p>
</div>
<p>Here’s how we can implement the interface:</p>
<pre data-type="programlisting">record Point (int X, int Y) : IAddable&lt;Point&gt;
{
  public static Point operator + (Point left, Point right) =&gt;
    new Point (left.X + right.X, left.Y + right.Y);
}</pre>
<p>With a constrained type parameter, we can then write a method that calls our addition operator polymorphically (with edge-case handling omitted for brevity):</p>
<pre data-type="programlisting">T Sum&lt;T&gt; (params T[] values) <strong>where T : IAddable&lt;T&gt;</strong>
{
  T total = values[0];
  for (int i = 1; i &lt; values.Length; i++)
    total <strong>+=</strong> values[i];
  return total;
}</pre>
<p>Our call to the <code>+</code> operator (via the <code>+=</code> operator) is polymorphic because it binds to <code>IAddable&lt;T&gt;</code>, not <code>Point</code>. Hence, our <code>Sum</code> method works with all types that implement <code>IAddable&lt;T&gt;</code>.</p>
<p>Of course, an interface such as <code>IAddable&lt;T&gt;</code> would be much more useful if it were defined in the .NET runtime, and if all .NET numeric types implemented it. Fortunately, this is indeed the case from .NET 7: the <code>System.Numerics</code> namespace includes (a more sophisticated version of) <code>IAddable</code>, along with many other arithmetic interfaces—most of which are encompassed by <code>INumber&lt;TSelf&gt;</code>.<a contenteditable="false" data-primary="" data-startref="ch04.html2" data-type="indexterm" id="id2600"/><a contenteditable="false" data-primary="" data-startref="ch04.html1" data-type="indexterm" id="id2601"/></p>
</div></section>
<section data-pdf-bookmark="Generic Math" data-type="sect2"><div class="sect2" id="generic_math-id00069">
<h2>Generic Math</h2>
<p><a contenteditable="false" data-primary="generic math" data-type="indexterm" id="ch04.html3"/><a contenteditable="false" data-primary="static polymorphism" data-secondary="generic math" data-type="indexterm" id="ch04.html4"/>Before .NET 7, code that performed arithmetic had to be hardcoded to a particular numeric type:</p>
<pre data-type="programlisting"><strong>int</strong> Sum (params <strong>int</strong>[] numbers)   // Works only with int.
{                                // Cannot use with double, decimal, etc.
    <strong>int</strong> total = 0;
    foreach (<strong>int</strong> n in numbers)
        total += n;
    return total;
}</pre>
<p><a contenteditable="false" data-primary="INumber&lt;TSelf&gt; interface" data-type="indexterm" id="id2602"/>.NET 7 introduced the <code>INumber&lt;TSelf&gt;</code> interface to unify arithmetic operations across numeric types. This means that you can now write a generic version of the preceding method:</p>
<pre data-type="programlisting">T Sum&lt;T&gt; (params T[] numbers) <strong>where T : INumber&lt;T&gt;</strong>
{
  T total = <strong>T.Zero</strong>;
  foreach (T n in numbers)
    total <strong>+=</strong> n;      // Invokes addition operator for any numeric type
  return total;
}

int intSum = Sum (3, 5, 7);
double doubleSum = Sum (3.2, 5.3, 7.1);
decimal decimalSum = Sum (3.2m, 5.3m, 7.1m);</pre>
<p><code>INumber&lt;TSelf&gt;</code> is implemented by all real and integral numeric types in .NET (as well as <code>char</code>) and can be thought of as an umbrella interface, comprising other more granular interfaces for each kind of arithmetic operation (addition, subtraction, multiplication, division, modulus calculation, comparison, and so on), as well as interfaces for parsing and formatting. Here’s one such interface:</p>
<pre data-type="programlisting">public interface IAdditionOperators&lt;TSelf, TOther, TResult&gt;
  where TSelf : IAdditionOperators&lt;TSelf, TOther, TResult&gt;?
{
  static abstract TResult operator + (TSelf left, TOther right);

  public static virtual TResult operator checked + 
    (TSelf left, TOther right) =&gt; left + right;  // Call operator above
}</pre>
<p>The <code>static abstract +</code> operator is what allows the <code>+=</code> operator to work inside our <code>Sum</code> method. Also note the use of <code>static virtual</code> on the checked operator: this provides a default fallback behavior for implementors that don’t provide a checked version of the addition operator.</p>
<p>The <code>System.Numerics</code> namespace also contains interfaces that are not part of <code>INumber</code> for operations specific to certain kinds of numbers (such as floating-point). To compute a root mean square, for instance, we can add the <code>IRootFunctions&lt;T&gt;</code> interface to the constraint list to expose its static <code>RootN</code> method to <code>T</code><a contenteditable="false" data-primary="" data-startref="ch04.html4" data-type="indexterm" id="id2603"/><a contenteditable="false" data-primary="" data-startref="ch04.html3" data-type="indexterm" id="id2604"/>:<a contenteditable="false" data-primary="" data-startref="ch04.html0" data-type="indexterm" id="id2605"/></p>
<pre data-type="programlisting">T RMS&lt;T&gt; (params T[] values) where T : INumber&lt;T&gt;<strong>, IRootFunctions&lt;T&gt;</strong>
{
  T total = T.Zero;
  for (int i = 0; i &lt; values.Length; i++)
    total += values [i] * values [i];
  // Use T.CreateChecked to convert values.Length (type int) to T.
  T count = T.CreateChecked (values.Length);
  return <strong>T.RootN</strong> (total / count, 2);   // Calculate square root
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Unsafe Code and Pointers" data-type="sect1"><div class="sect1" id="unsafe_code_and_pointers">
<h1>Unsafe Code and Pointers</h1>
<p><a contenteditable="false" data-primary="pointers" data-type="indexterm" id="ch04.html1036"/><a contenteditable="false" data-primary="unsafe code" data-type="indexterm" id="ch04.html1037"/>C# supports direct memory manipulation via pointers within blocks of code marked as <code>unsafe</code>. Pointer types are useful for interoperating with native APIs, for accessing memory outside the managed heap, and in implementing micro-optimizations in performance-critical hotspots.</p>
<p>Projects that include unsafe code must specify <code>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</code> in the project file.</p>
<section data-pdf-bookmark="Pointer Basics" data-type="sect2"><div class="sect2" id="pointer_basics">
<h2>Pointer Basics</h2>
<p><a contenteditable="false" data-primary="pointers" data-secondary="basics" data-type="indexterm" id="id2606"/>For every value type or reference type <em>V</em>, there is a corresponding pointer type <em>V*</em>. A pointer instance holds the address of a variable. Pointer types can be (unsafely) cast to any other pointer type. <a contenteditable="false" data-primary="- (pointer-to-member operator)" data-type="indexterm" id="id2607"/><a contenteditable="false" data-primary="* (asterisk)" data-secondary="as deference operator" data-type="indexterm" id="id2608"/><a contenteditable="false" data-primary="&amp; (ampersand)" data-secondary="address-of operator" data-type="indexterm" id="id2609"/><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="address-of operator" data-type="indexterm" id="id2610"/><a contenteditable="false" data-primary="asterisk (*)" data-secondary="as deference operator" data-type="indexterm" id="id2611"/><a contenteditable="false" data-primary="pointer-to-member operator (-)" data-type="indexterm" id="id2612"/>Following are the main pointer operators:</p>
<table class="border">
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>The <em>address-of</em> operator returns a pointer to the address of a variable.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>The <em>dereference</em> operator returns the variable at the address of a pointer.</td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>The <em>pointer-to-member</em> operator is a syntactic shortcut, in which <code>x-&gt;y</code> is equivalent to <code>(*x).y</code>.</td>
</tr>
</tbody>
</table>
<p>In keeping with C, adding (or subtracting) an integer offset to a pointer generates another pointer. Subtracting one pointer from another generates a 64-bit integer (on both 64-bit and 32-bit platforms).</p>
</div></section>
<section data-pdf-bookmark="Unsafe Code" data-type="sect2"><div class="sect2" id="unsafe_code">
<h2>Unsafe Code</h2>
<p><a contenteditable="false" data-primary="unsafe code" data-type="indexterm" id="id2613"/>By marking a type, type member, or statement block with the <code>unsafe</code> keyword, you’re permitted to use pointer types and perform C style pointer operations on memory within that scope. Here is an example of using pointers to quickly process a bitmap:</p>
<pre data-type="programlisting">unsafe void BlueFilter (int[,] bitmap)
{
  int length = bitmap.Length;
  fixed (int* b = bitmap)
  {
    int* p = b;
    for (int i = 0; i &lt; length; i++)
      *p++ &amp;= 0xFF;
  }
}</pre>
<p>Unsafe code can run faster than a corresponding safe implementation. In this case, the code would have required a nested loop with array indexing and bounds checking. An unsafe C# method can also be faster than calling an external C function given that there is no overhead associated with leaving the managed execution environment.</p>
</div></section>
<section data-pdf-bookmark="The fixed Statement" data-type="sect2"><div class="sect2" id="the_fixed_statement">
<h2>The fixed Statement</h2>
<p><a contenteditable="false" data-primary="fixed statement" data-type="indexterm" id="id2614"/><a contenteditable="false" data-primary="pointers" data-secondary="fixed statement and" data-type="indexterm" id="id2615"/>The <code>fixed</code> statement is required to pin a managed object, such as the bitmap in the previous example. During the execution of a program, many objects are allocated and deallocated from the heap. To avoid unnecessary waste or fragmentation of memory, the garbage collector moves objects around. Pointing to an object is futile if its address could change while referencing it, so the <code>fixed</code> statement tells the garbage collector to “pin” the object and not move it around. This can have an impact on the efficiency of the runtime, so you should use fixed blocks only briefly, and you should avoid heap allocation within the fixed block.</p>
<p>Within a <code>fixed</code> statement, you can get a pointer to any value type, an array of value types, or a string. In the case of arrays and strings, the pointer will actually point to the first element, which is a value type.</p>
<p>Value types declared inline within reference types require the reference type to be pinned, as follows:</p>
<pre data-type="programlisting">Test test = new Test();
unsafe
{
  fixed (int* p = &amp;test.X)   // Pins test
  {
    *p = 9;
  }
  Console.WriteLine (test.X);
}

class Test { public int X; }</pre>
<p>We describe the <code>fixed</code> statement further in <a data-type="xref" href="ch24.html#mapping_a_struct_to_unmanaged_memory">“Mapping a Struct to Unmanaged Memory”</a>.</p>
</div></section>
<section data-pdf-bookmark="The Pointer-to-Member Operator" data-type="sect2"><div class="sect2" id="the_pointer_to_member_operator">
<h2>The Pointer-to-Member Operator</h2>
<p><a contenteditable="false" data-primary="- (pointer-to-member operator)" data-type="indexterm" id="id2616"/><a contenteditable="false" data-primary="pointer-to-member operator (-)" data-type="indexterm" id="id2617"/>In addition to the <code>&amp;</code> and <code>*</code> operators, C# also provides the C++ style <code>-&gt;</code> operator, which you can use on structs:</p>
<pre data-type="programlisting">Test test = new Test();
unsafe
{
  Test* p = &amp;test;
  p-&gt;X = 9;
  System.Console.WriteLine (test.X);
}

struct Test { public int X; }</pre>
</div></section>
<section data-pdf-bookmark="The stackalloc Keyword" data-type="sect2"><div class="sect2" id="the_stackalloc_keyword">
<h2>The stackalloc Keyword</h2>
<p><a contenteditable="false" data-primary="pointers" data-secondary="stackalloc keyword and" data-type="indexterm" id="id2618"/><a contenteditable="false" data-primary="stackalloc keyword" data-type="indexterm" id="id2619"/>You can allocate memory in a block on the stack explicitly by using the <code>stackalloc</code> keyword. Because it is allocated on the stack, its lifetime is limited to the execution of the method, just as with any other local variable (whose life hasn’t been extended by virtue of being captured by a lambda expression, iterator block, or asynchronous function). The block can use the <code>[]</code> operator to index into memory:</p>
<pre data-type="programlisting">int* a = stackalloc int [10];
for (int i = 0; i &lt; 10; ++i)
   Console.WriteLine (a[i]);</pre>
<p>In <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>, we describe how you can use <code>Span&lt;T&gt;</code> to manage stack-allocated memory without using the <code>unsafe</code> keyword:</p>
<pre data-type="programlisting">Span&lt;int&gt; a = stackalloc int [10];
for (int i = 0; i &lt; 10; ++i)
  Console.WriteLine (a[i]);</pre>
</div></section>
<section data-pdf-bookmark="Fixed-Size Buffers" data-type="sect2"><div class="sect2" id="fixed_size_buffers">
<h2>Fixed-Size Buffers</h2>
<p><a contenteditable="false" data-primary="fixed-size buffers" data-type="indexterm" id="id2620"/><a contenteditable="false" data-primary="pointers" data-secondary="fixed-size buffers and" data-type="indexterm" id="id2621"/>The <code>fixed</code> keyword has another use, which is to create fixed-size buffers within structs (this can be useful when calling an unmanaged function; see <a data-type="xref" href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>):</p>
<pre data-type="programlisting">new UnsafeClass ("Christian Troy");

unsafe struct UnsafeUnicodeString
{
  public short Length;
  public <strong>fixed</strong> byte Buffer[30];   // Allocate block of 30 bytes
}

unsafe class UnsafeClass
{
  UnsafeUnicodeString uus;

  public UnsafeClass (string s)
  {
    uus.Length = (short)s.Length;
    fixed (byte* p = uus.Buffer)
      for (int i = 0; i &lt; s.Length; i++)
        p[i] = (byte) s[i];
  }
}</pre>
<p>Fixed-size buffers are not arrays: if <code>Buffer</code> were an array, it would consist of a reference to an object stored on the (managed) heap, rather than 30 bytes within the struct itself.</p>
<p>The <code>fixed</code> keyword is also used in this example to pin the object on the heap that contains the buffer (which will be the instance of <code>UnsafeClass</code>). Hence, <code>fixed</code> means two different things: fixed in <em>size</em> and fixed in <em>place</em>. The two are often used together, in that a fixed-size buffer must be fixed in place to be used.</p>
</div></section>
<section data-pdf-bookmark="void*" data-type="sect2"><div class="sect2" id="voidasterisk">
<h2>void*</h2>
<p><a contenteditable="false" data-primary="pointers" data-secondary="void pointer (void*)" data-type="indexterm" id="id2622"/><a contenteditable="false" data-primary="void pointer (void*)" data-type="indexterm" id="id2623"/>A <em>void pointer</em> (<code>void*</code>) makes no assumptions about the type of the underlying data and is useful for functions that deal with raw memory. An implicit conversion exists from any pointer type to <code>void*</code>. A <code>void*</code> cannot be dereferenced, and arithmetic operations cannot be performed on void pointers. Here’s an example:</p>
<pre data-type="programlisting">short[] a = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 };
unsafe
{
  fixed (short* p = a)
  {
    //sizeof returns size of value-type in bytes
    Zap (p, a.Length * sizeof (short));
  }
}
foreach (short x in a)
  Console.WriteLine (x);   // Prints all zeros

unsafe void Zap (void* memory, int byteCount)
{
  byte* b = (byte*)memory;
  for (int i = 0; i &lt; byteCount; i++)
    *b++ = 0;
}</pre>
</div></section>
<section data-pdf-bookmark="Native-Sized Integers" data-type="sect2"><div class="sect2" id="native_sized_integers">
<h2>Native-Sized Integers</h2>
<p><a contenteditable="false" data-primary="integral types" data-secondary="native-sized integers" data-type="indexterm" id="ch04.html5"/><a contenteditable="false" data-primary="native-sized integers" data-type="indexterm" id="ch04.html6"/><a contenteditable="false" data-primary="serialization, defined" data-type="indexterm" id="id2624"/>The <code>nint</code> and <code>nuint</code> <em>native-sized</em> integer types (introduced in C# 9) are sized to match the address space of the process at runtime (in practice, 32 or 64 bits). Native-sized integers behave like standard integers, with full support for arithmetic operations and overflow checking:</p>
<pre class="pagebreak-before" data-type="programlisting">nint x = 123, y = 234;
checked
{
  nint sum = x + y, product = x * y;
  Console.WriteLine (product);
}</pre>
<p>Native-sized integers can be assigned 32-bit integer constants (but not 64-bit integer constants, because these might overflow at runtime). You can use an explicit cast to convert to or from other integral types.</p>
<p>You can use native-sized integers to represent memory addresses or offsets without the use of pointers. <code>nuint</code> is also a natural type for representing the length of a memory block.</p>
<p><a contenteditable="false" data-primary="pointers" data-secondary="native-sized integers and" data-type="indexterm" id="id2625"/>When working with pointers, native-sized integers can improve efficiency because the result of subtracting two pointers in C# is always a 64-bit integer (<code>long</code>), which is inefficient on 32-bit platforms. By first casting the pointers to <code>nint</code>, the result of a subtraction is also <code>nint</code> (which will be 32 bits on a 32-bit platform):</p>
<pre data-type="programlisting">unsafe <strong>nint</strong> AddressDif (char* x, char* y) =&gt; <strong>(nint)</strong>x - <strong>(nint)</strong>y;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A good example of the real-world use of <code>nint</code> and <code>nuint</code> in conjunction with pointers is in the implementation of <code>Buffer.MemoryCopy</code>. You can see this in the .NET source code for <em>Buffer.cs</em> on GitHub, or by decompiling the method in ILSpy. A simplified version has also been included in the LINQPad samples for <em>C# 12 in a Nutshell</em>.</p>
</div>
<section data-pdf-bookmark="Runtime handling when targeting .NET 7+" data-type="sect3"><div class="sect3" id="runtime_handling_when_targeting-id00037">
<h3>Runtime handling when targeting .NET 7+</h3>
<p><a contenteditable="false" data-primary="native-sized integers" data-secondary="runtime handling when targeting .NET 7+" data-type="indexterm" id="id2626"/>For projects that target .NET 7 or above, <code>nint</code> and <code>nuint</code> act as synonyms for the underlying .NET types <code>System.IntPtr</code> and <code>System.UIntPtr</code> (in the same way that <code>int</code> acts as a synonym for <code>System.Int32</code>). This works because the <code>IntPtr</code> and <code>UIntPtr</code> types (which have existed since .NET Framework 1.0, but with limited functionality) were enhanced in .NET 7 to enable full arithmetic capabilities and overflow checking with the C# compiler.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The addition of checked arithmetic capability to <code>IntPtr</code>/<code>UIntPtr</code> is technically a breaking change. However, the effects are limited, because legacy code that relies on <code>IntPtr</code> not honoring <code>checked</code> blocks will not break when merely <em>run</em> under .NET 7+; to break, the project must also be <em>recompiled</em> with a .NET 7+ target. This means that library authors need not worry about the breaking change until they release a new version that specifically targets .NET 7 or later.</p>
</div>
</div></section>
<section data-pdf-bookmark="Runtime handling when targeting .NET 6 or below" data-type="sect3"><div class="sect3" id="runtime_handling_when_targeting-id00088">
<h3>Runtime handling when targeting .NET 6 or below</h3>
<p><a contenteditable="false" data-primary="native-sized integers" data-secondary="runtime handling when targeting .NET 6 or below" data-type="indexterm" id="id2627"/>For projects that target .NET 6 or below (or .NET Standard), <code>nint</code> and <code>nuint</code> still use <code>IntPtr</code> and <code>UIntPtr</code> as their underlying runtime types. However, because the legacy <code>IntPtr</code> and <code>UIntPtr</code> types lack support for most arithmetic operations, the compiler fills in the gaps, making the <code>nint</code>/<code>nuint</code> types behave as they would in .NET 7+ (including allowing <code>checked</code> operations). You can think of an <code>nint</code>/<code>nuint</code> variable as an <code>IntPtr</code>/<code>UIntPtr</code> wearing a special hat. This hat is recognized by the compiler to mean “please treat me as a modern <code>IntPtr</code>/<code>UIntPtr</code>.” This hat is naturally lost should you later cast to an <code>IntPtr</code>/<code>UIntPtr</code>:<a contenteditable="false" data-primary="" data-startref="ch04.html6" data-type="indexterm" id="id2628"/><a contenteditable="false" data-primary="" data-startref="ch04.html5" data-type="indexterm" id="id2629"/></p>
<pre data-type="programlisting">nint x = 123;
Console.WriteLine (x * x);   // OK: multiplication supported

IntPtr y = x;
Console.WriteLine (y * y);   // Compiler error: operator * not supported</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Function Pointers" data-type="sect2"><div class="sect2" id="function_pointers">
<h2>Function Pointers</h2>
<p><a contenteditable="false" data-primary="function pointers" data-type="indexterm" id="id2630"/><a contenteditable="false" data-primary="pointers" data-secondary="function pointers (C# 9)" data-type="indexterm" id="id2631"/>A <em>function pointer</em> (from C# 9) is like a delegate, but without the indirection of a delegate instance; instead, it points directly to a method. A function pointer can point only to static methods, lacks multicast capability, and requires an <code>unsafe</code> context (because it bypasses runtime type safety). Its main purpose is to simplify and optimize interop with unmanaged APIs (see <a data-type="xref" href="ch24.html#callbacks_from_unmanaged_code">“Callbacks from Unmanaged Code”</a>).</p>
<p>A function pointer type is declared as follows (with the return type appearing last):</p>
<pre data-type="programlisting"><strong>delegate*&lt;int, char, string, void&gt;</strong>   // (void refers to the return type)</pre>
<p>This matches a function with this signature:</p>
<pre data-type="programlisting"><strong>void</strong> SomeFunction (<strong>int</strong> x, <strong>char</strong> y, <strong>string</strong> z)</pre>
<p>The <code>&amp;</code> operator creates a function pointer from a method group. Here’s a complete example:</p>
<pre data-type="programlisting">unsafe
{
  <strong>delegate*&lt;string, int&gt;</strong> functionPointer = <strong>&amp;GetLength</strong>;
  int length = functionPointer ("Hello, world");

  static int GetLength (string s) =&gt; s.Length;
}</pre>
<p>In this example, <code>functionPointer</code> is not an <em>object</em> upon which you can call a method such as <code>Invoke</code> (or with a reference to a <code>Target</code> object). Instead, it’s a variable that points directly to the target method’s address in memory:</p>
<pre data-type="programlisting">Console.WriteLine ((IntPtr)functionPointer);</pre>
<p>Like any other pointer, it’s not subject to runtime type checking. The following treats our function’s return value as a <code>decimal</code> (which, being longer than an <code>int</code>, means that we incorporate some random memory into the output):</p>
<pre data-type="programlisting">var pointer2 = (delegate*&lt;string, <strong>decimal</strong>&gt;) (IntPtr) functionPointer;
Console.WriteLine (pointer2 ("Hello, unsafe world"));</pre>
</div></section>
<section data-pdf-bookmark="[SkipLocalsInit]" data-type="sect2"><div class="sect2" id="left_square_bracketskiplocalsinitright">
<h2>[SkipLocalsInit]</h2>
<p><a contenteditable="false" data-primary="[SkipLocalsInit] attribute" data-primary-sortas="SkipLocalsInit" data-type="indexterm" id="id2632"/>When C# compiles a method, it emits a flag that instructs the runtime to initialize the method’s local variables to their default values (by zeroing the memory). From C# 9, you can ask the compiler not to emit this flag by applying the <code>[Ski⁠p​LocalsI⁠nit]</code> attribute to a method (in the <code>System.Runtime.CompilerServices</code> namespace):</p>
<pre data-type="programlisting"><strong>[SkipLocalsInit]</strong>
void Foo() ...</pre>
<p>You can also apply this attribute to a type—which is equivalent to applying it to all of the type’s methods—or even an entire module (the container for an assembly):</p>
<pre data-type="programlisting">[module: System.Runtime.CompilerServices.SkipLocalsInit]</pre>
<p>In normal safe scenarios, <code>[SkipLocalsInit]</code> has little effect on functionality or performance, because C#’s definite assignment policy requires that you explicitly assign local variables before they can be read. This means that the JIT optimizer is likely to emit the same machine code, whether or not the attribute is applied.</p>
<p>In an unsafe context, however, use of <code>[SkipLocalsInit]</code> can usefully save the CLR from the overhead of initializing value-typed local variables, creating a small performance gain with methods that make extensive use of the stack (through a large <code>stackalloc</code>). The following example prints uninitialized memory when <code>[SkipLocalsInit]</code> is applied (instead of all zeros):</p>
<pre data-type="programlisting"><strong>[SkipLocalsInit]</strong>
unsafe void Foo()
{
  int local;
  int* ptr = &amp;local;
  Console.WriteLine (*ptr);

  int* a = stackalloc int [100];
  for (int i = 0; i &lt; 100; ++i) Console.WriteLine (a [i]);
}</pre>
<p>Interestingly, you can achieve the same result in a “safe” context through the use of <code>Span&lt;T&gt;</code>:</p>
<pre data-type="programlisting"><strong>[SkipLocalsInit]</strong>
void Foo()
{
  <strong>Span&lt;int&gt;</strong> a = stackalloc int [100];
  for (int i = 0; i &lt; 100; ++i) Console.WriteLine (a [i]);
}</pre>
<p>Consequently, use of <code>[SkipLocalsInit]</code> requires that you compile your project with <code>&lt;AllowUnsafeBlocks&gt;</code> set to true—even if none of your methods are marked as <code>unsafe</code>.<a contenteditable="false" data-primary="" data-startref="ch04.html1037" data-type="indexterm" id="id2633"/><a contenteditable="false" data-primary="" data-startref="ch04.html1036" data-type="indexterm" id="id2634"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Preprocessor Directives" data-type="sect1"><div class="sect1" id="preprocessor_directives-id00035">
<h1>Preprocessor Directives</h1>
<p><a contenteditable="false" data-primary="preprocessor directives" data-type="indexterm" id="ch04.html1038"/>Preprocessor directives supply the compiler with additional information about regions of code. The most common preprocessor directives are the conditional directives, which provide a way to include or exclude regions of code from <span class="keep-together">compilation:</span></p>
<pre data-type="programlisting"><strong>#define DEBUG</strong>
<strong>class MyClass</strong>
<strong>{</strong>
  int x;
  void Foo()
  {
    <strong>#if DEBUG</strong>
    Console.WriteLine ("Testing: x = {0}", x);
    <strong>#endif</strong>
  <strong>}</strong>
  ...
<strong>}</strong></pre>
<p>In this class, the statement in <code>Foo</code> is compiled as conditionally dependent upon the presence of the <code>DEBUG</code> symbol. If we remove the <code>DEBUG</code> symbol, the statement is not compiled. You can define preprocessor symbols within a source file (as we have done) or at a project level in the <em>.csproj</em> file:</p>
<pre data-type="programlisting">&lt;PropertyGroup&gt;
  &lt;DefineConstants&gt;DEBUG;ANOTHERSYMBOL&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;</pre>
<p><a contenteditable="false" data-primary="# (hash)" data-type="indexterm" id="id2635"/>With the <code>#if</code> and <code>#elif</code> directives, you can use the <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code> operators to perform <em>or</em>, <em>and</em>, and <em>not</em> operations on multiple symbols. The following directive instructs the compiler to include the code that follows if the <code>TESTMODE</code> symbol is defined and the <code>DEBUG</code> symbol is not defined:</p>
<pre data-type="programlisting">#if TESTMODE &amp;&amp; !DEBUG
  ...</pre>
<p>Keep in mind, however, that you’re not building an ordinary C# expression, and the symbols upon which you operate have absolutely no connection to <em>variables</em>—static or otherwise.</p>
<p><a contenteditable="false" data-primary="#error preprocessor directive" data-primary-sortas="error preprocessor directive" data-type="indexterm" id="id2636"/><a contenteditable="false" data-primary="#warning preprocessor directive" data-primary-sortas="warning preprocessor directive" data-type="indexterm" id="id2637"/><a contenteditable="false" data-primary="hash (#)" data-type="indexterm" id="id2638"/>The <code>#error</code> and <code>#warning</code> symbols prevent accidental misuse of conditional directives by making the compiler generate a warning or error given an undesirable set of compilation symbols. <a data-type="xref" href="#preprocessor_directives-id00086">Table 4-1</a> lists the preprocessor directives.</p>
<table class="border" id="preprocessor_directives-id00086">
<caption><span class="label">Table 4-1. </span>Preprocessor directives</caption>
<thead>
<tr>
<th>Preprocessor directive</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#define <em>symbol</em></code></td>
<td>Defines <code><em>symbol</em></code></td>
</tr>
<tr>
<td><code>#undef <em>symbol</em></code></td>
<td>Undefines <code><em>symbol</em></code></td>
</tr>
<tr>
	<td><code>#if <em>symbol</em> <span class="keep-together">[<em>operator symbol2</em>]...</span></code></td>
			<td><code><em>symbol</em></code> to test</td>
</tr>
<tr>
<td/>
<td><code><em>operator</em></code>s are <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, and <code>||</code> followed by <code>#else</code>, <code>#elif</code>, and <code>#endif</code></td>
</tr>
<tr>
<td><code>#else</code></td>
<td>Executes code to subsequent <code>#endif</code></td>
</tr>
<tr>
<td><code>#elif <em>symbol</em> <span class="keep-together">[<em>operator symbol2</em>]</span></code></td>
<td>Combines <code>#else</code> branch and <code>#if</code> test</td>
</tr>
<tr>
<td><code>#endif</code></td>
<td>Ends conditional directives</td>
</tr>
<tr>
<td><code>#warning <em>text</em></code></td>
			<td><code><em>text</em></code> of the warning to appear in compiler output</td>
</tr>
<tr>
<td><code>#error <em>text</em></code></td>
			<td><code><em>text</em></code> of the error to appear in compiler output</td>
</tr>
<tr>
<td><code>#error version</code></td>
<td>Reports the compiler version and exits</td>
</tr>
<tr>
			<td><code>#pragma warning <span class="keep-together">[disable | restore]</span></code></td>
<td>Disables/restores compiler warning(s)</td>
</tr>
<tr>
	<td><code>#line [ <em>number</em> ["<em>file</em>"] | <span class="keep-together">hidden</span>]</code></td>
<td><code><em>number</em></code> specifies the line in source code (a column can also be specified from C# 10); <code><em>file</em></code> is the filename to appear in computer output; <code>hidden</code> instructs debuggers to skip over code from this point until the next <code>#line</code> directive</td>
</tr>
<tr>
<td><code>#region <em>name</em></code></td>
<td>Marks the beginning of an outline</td>
</tr>
<tr>
<td><code>#endregion</code></td>
<td>Ends an outline region</td>
</tr>
<tr>
<td><code>#nullable <em>option</em></code></td>
<td>See <a data-type="xref" href="ch01.html#nullable_reference_types-id00030">“Nullable reference types”</a></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Conditional Attributes" data-type="sect2"><div class="sect2" id="conditional_attributes">
<h2>Conditional Attributes</h2>
<p><a contenteditable="false" data-primary="Conditional attribute" data-type="indexterm" id="id2639"/><a contenteditable="false" data-primary="preprocessor directives" data-secondary="Conditional attribute" data-type="indexterm" id="id2640"/>An attribute decorated with the <code>Conditional</code> attribute will be compiled only if a given preprocessor symbol is present:</p>
<pre data-type="programlisting">// file1.cs
#define DEBUG
using System;
using System.Diagnostics;
<strong>[Conditional("DEBUG")]</strong>
public class TestAttribute : Attribute {}

// file2.cs
<strong>#define DEBUG</strong>
[Test]
class Foo
{
  [Test]
  string s;
}</pre>
<p>The compiler will incorporate the <code>[Test]</code> attributes only if the <code>DEBUG</code> symbol is in scope for <em>file2.cs</em>.</p>
</div></section>
<section data-pdf-bookmark="Pragma Warning" data-type="sect2"><div class="sect2" id="pragma_warning">
<h2>Pragma Warning</h2>
<p><a contenteditable="false" data-primary="#pragma warning directive" data-primary-sortas="pragma warning directive" data-type="indexterm" id="id2641"/><a contenteditable="false" data-primary="preprocessor directives" data-secondary="pragma warning" data-type="indexterm" id="id2642"/>The compiler generates a warning when it spots something in your code that seems unintentional. Unlike errors, warnings don’t ordinarily prevent your application from compiling.</p>
<p>Compiler warnings can be extremely valuable in spotting bugs. Their usefulness, however, is undermined when you get <em>false</em> warnings. In a large application, maintaining a good signal-to-noise ratio is essential if the “real” warnings are to be noticed.</p>
<p>To this effect, the compiler allows you to selectively suppress warnings by using the <code>#pragma warning</code> directive. In this example, we instruct the compiler not to warn us about the field <code>Message</code> not being used:</p>
<pre data-type="programlisting"><strong>public class Foo</strong>
<strong>{</strong>
  static void Main() { }

  <strong>#pragma warning disable 414</strong>
  static string Message = "Hello";
  <strong>#pragma warning restore 414</strong>
}</pre>
<p>Omitting the number in the <code>#pragma warning</code> directive disables or restores all warning codes.</p>
<p>If you are thorough in applying this directive, you can compile with the <code>/warnaserror</code> switch—this instructs the compiler to treat any residual warnings as errors.</p><a contenteditable="false" data-primary="" data-startref="ch04.html1038" data-type="indexterm" id="id2643"/>
</div></section>
</div></section>
<section data-pdf-bookmark="XML Documentation" data-type="sect1"><div class="sect1" id="xml_documentation">
<h1>XML Documentation</h1>
<p><a contenteditable="false" data-primary="/// (documentation comments)" data-type="indexterm" id="id2644"/><a contenteditable="false" data-primary="documentation comments (///)" data-type="indexterm" id="id2645"/><a contenteditable="false" data-primary="XML documentation" data-type="indexterm" id="ch04.html1039"/>A <em>documentation comment</em> is a piece of embedded XML that documents a type or member. A documentation comment comes immediately before a type or member declaration and starts with three slashes:</p>
<pre data-type="programlisting"><strong>/// &lt;summary&gt;Cancels a running query.&lt;/summary&gt;</strong>
<strong>public void Cancel() { ... }</strong></pre>
<p>Multiline comments can be done like this:</p>
<pre data-type="programlisting">/// &lt;summary&gt;
/// Cancels a running query
/// &lt;/summary&gt;
public void Cancel() { ... }</pre>
<p><a contenteditable="false" data-primary="/* */ (multiline comments)" data-type="indexterm" id="id2646"/><a contenteditable="false" data-primary="multiline comments (/* */)" data-type="indexterm" id="id2647"/>Or like this (notice the extra star at the start):</p>
<pre data-type="programlisting"><strong>/**</strong> 
    &lt;summary&gt; Cancels a running query. &lt;/summary&gt;
<strong>*/</strong>
<strong>public void Cancel() { ... }</strong></pre>
<p><a contenteditable="false" data-primary=".csproj file" data-primary-sortas="csproj" data-type="indexterm" id="id2648"/>If you add the following option to your <em>.csproj</em> file:</p>
<pre data-type="programlisting">&lt;PropertyGroup&gt;
  &lt;DocumentationFile&gt;<em>SomeFile.xml</em>&lt;/DocumentationFile&gt;
&lt;/PropertyGroup&gt;</pre>
<p>the compiler extracts and collates documentation comments into the specified XML file. This has two main uses:</p>
<ul>
<li><p>If placed in the same folder as the compiled assembly, tools such as Visual Studio and LINQPad automatically read the XML file and use the information to provide IntelliSense member listings to consumers of the assembly of the same name.</p></li>
<li><p>Third-party tools (such as Sandcastle and NDoc) can transform the XML file into an HTML help file.</p></li>
</ul>
<section data-pdf-bookmark="Standard XML Documentation Tags" data-type="sect2"><div class="sect2" id="standard_xml_documentation_tags">
<h2>Standard XML Documentation Tags</h2>
<p><a contenteditable="false" data-primary="XML documentation" data-secondary="standard tags" data-type="indexterm" id="ch04.html1040"/>Here are the standard XML tags that Visual Studio and documentation generators recognize:</p>
<dl>
<dt><code>&lt;summary&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;summary&gt;<em>...</em>&lt;/summary&gt;</pre>
<p>Indicates the tool tip that IntelliSense should display for the type or member; typically a single phrase or sentence.</p></dd>
<dt><code>&lt;remarks&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;remarks&gt;<em>...</em>&lt;/remarks&gt;</pre>
<p>Additional text that describes the type or member. Documentation generators pick this up and merge it into the bulk of a type or member’s description.</p></dd>
<dt><code>&lt;param&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;param name="<em>name</em>"&gt;<em>...</em>&lt;/param&gt;</pre>
<p>Explains a parameter on a method.</p></dd>
<dt><code>&lt;returns&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;returns&gt;<em>...</em>&lt;/returns&gt;</pre>
<p>Explains the return value for a method.</p></dd>
<dt><code>&lt;exception&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;exception [cref="<em>type</em>"]&gt;<em>...</em>&lt;/exception&gt;</pre>
<p>Lists an exception that a method can throw (<code>cref</code> refers to the exception type).</p></dd>
<dt class="pagebreak-before"><code>&lt;example&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;example&gt;<em>...</em>&lt;/example&gt;</pre>
<p>Denotes an example (used by documentation generators). This usually contains both description text and source code (source code is typically within a <code>&lt;c&gt;</code> or <code>&lt;code&gt;</code> tag).</p></dd>
<dt><code>&lt;c&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;c&gt;<em>...</em>&lt;/c&gt;</pre>
<p>Indicates an inline code snippet. This tag is usually used within an <code>&lt;example&gt;</code> block.</p></dd>
<dt><code>&lt;code&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;code&gt;<em>...</em>&lt;/code&gt;</pre>
<p>Indicates a multiline code sample. This tag is usually used within an <code>&lt;example&gt;</code> block.</p></dd>
<dt><code>&lt;see&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;see cref="<em>member</em>"&gt;<em>...</em>&lt;/see&gt;</pre>
<p>Inserts an inline cross-reference to another type or member. HTML documentation generators typically convert this to a hyperlink. The compiler emits a warning if the type or member name is invalid. To refer to generic types, use curly braces; for example, <code>cref="Foo{T,U}"</code>.</p></dd>
<dt><code>&lt;seealso&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;seealso cref="<em>member</em>"&gt;<em>...</em>&lt;/seealso&gt;</pre>
<p>Cross-references another type or member. Documentation generators typically write this into a separate “See Also” section at the bottom of the page.</p></dd>
<dt><code>&lt;paramref&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;paramref name="<em>name</em>"/&gt;</pre>
<p>References a parameter from within a <code>&lt;summary&gt;</code> or <code>&lt;remarks&gt;</code> tag.</p></dd>
<dt><code>&lt;list&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;list type=[ bullet | number | table ]&gt;
  &lt;listheader&gt;
    &lt;term&gt;<em>...</em>&lt;/term&gt;
    &lt;description&gt;<em>...</em>&lt;/description&gt;
  &lt;/listheader&gt;
  &lt;item&gt;
    &lt;term&gt;<em>...</em>&lt;/term&gt;
    &lt;description&gt;<em>...</em>&lt;/description&gt;
  &lt;/item&gt;
&lt;/list&gt;</pre>
<p>Instructs documentation generators to emit a bulleted, numbered, or table-style list.</p></dd>
<dt><code>&lt;para&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;para&gt;<em>...</em>&lt;/para&gt;</pre>
<p>Instructs documentation generators to format the contents into a separate paragraph.</p></dd>
<dt><code>&lt;include&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;include file='<em>filename</em>' path='<em>tagpath</em>[@name="<em>id</em>"]'&gt;<em>...</em>&lt;/include&gt;</pre>
<p>Merges an external XML file that contains documentation. The path attribute denotes an XPath query to a specific element in that file.<a contenteditable="false" data-primary="" data-startref="ch04.html1040" data-type="indexterm" id="id2649"/></p></dd>
</dl>
</div></section>
<section data-pdf-bookmark="User-Defined Tags" data-type="sect2"><div class="sect2" id="user_defined_tags">
<h2>User-Defined Tags</h2>
<p><a contenteditable="false" data-primary="XML documentation" data-secondary="user-defined tags" data-type="indexterm" id="id2650"/>Little is special about the predefined XML tags recognized by the C# compiler, and you are free to define your own. The only special processing done by the compiler is on the <code>&lt;param&gt;</code> tag (in which it verifies the parameter name and that all the parameters on the method are documented) and the <code>cref</code> attribute (in which it verifies that the attribute refers to a real type or member and expands it to a fully qualified type or member ID). You can also use the <code>cref</code> attribute in your own tags; it is verified and expanded just as it is in the predefined <code>&lt;exception&gt;</code>, <code>&lt;permission&gt;</code>, <code>&lt;see&gt;</code>, and <code>&lt;seealso&gt;</code> tags.</p>
</div></section>
<section data-pdf-bookmark="Type or Member Cross-References" data-type="sect2"><div class="sect2" id="type_or_member_cross_references">
<h2>Type or Member Cross-References</h2>
<p><a contenteditable="false" data-primary="XML documentation" data-secondary="type or member cross-references" data-type="indexterm" id="id2651"/>Type names and type or member cross-references are translated into IDs that uniquely define the type or member. These names are composed of a prefix that defines what the ID represents and a signature of the type or member. Following are the member prefixes:</p>
<table class="border">
<thead>
<tr>
<th>XML type prefix</th>
<th>ID prefixes applied to…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>N</code></td>
<td>Namespace</td>
</tr>
<tr>
<td><code>T</code></td>
<td>Type (class, struct, enum, interface, delegate)</td>
</tr>
<tr>
<td><code>F</code></td>
<td>Field</td>
</tr>
<tr>
<td><code>P</code></td>
<td>Property (includes indexers)</td>
</tr>
<tr>
<td><code>M</code></td>
<td>Method (includes special methods)</td>
</tr>
<tr>
<td><code>E</code></td>
<td>Event</td>
</tr>
<tr>
<td><code>!</code></td>
<td>Error</td>
</tr>
</tbody>
</table>
<p>The rules describing how the signatures are generated are well documented, although fairly complex.</p>
<p>Here is an example of a type and the IDs that are generated:<a contenteditable="false" data-primary="" data-startref="ch04.html1039" data-type="indexterm" id="id2652"/></p>
<pre data-type="programlisting">// Namespaces do not have independent signatures
namespace NS
{
  /// T:NS.MyClass
  class MyClass
  {
    /// F:NS.MyClass.aField
    string aField;

    /// P:NS.MyClass.aProperty
    short aProperty {get {...} set {...}}

    /// T:NS.MyClass.NestedType
    class NestedType {...};

    /// M:NS.MyClass.X()
    void X() {...}

    /// M:NS.MyClass.Y(System.Int32,System.Double@,System.Decimal@)
    void Y(int p1, ref double p2, out decimal p3) {...}

    /// M:NS.MyClass.Z(System.Char[ ],System.Single[0:,0:])
    void Z(char[ ] p1, float[,] p2) {...}

    /// M:NS.MyClass.op_Addition(NS.MyClass,NS.MyClass)
    public static MyClass operator+(MyClass c1, MyClass c2) {...}

    /// M:NS.MyClass.op_Implicit(NS.MyClass)˜System.Int32
    public static implicit operator int(MyClass c) {...}

    /// M:NS.MyClass.#ctor
    MyClass() {...}

    /// M:NS.MyClass.Finalize
    ˜MyClass() {...}

    /// M:NS.MyClass.#cctor
    static MyClass() {...}
  }
}</pre>
</div></section>
</div></section>
</div></section></body></html>