<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Collections</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Collections" data-pdf-bookmark="Chapter 7. Collections" data-type="chapter" epub:type="chapter"><div class="chapter" id="collections-id00055">
<h1><span class="label">Chapter 7. </span>Collections</h1>
<p><a contenteditable="false" data-primary="collections" data-type="indexterm" id="ch07.html100"/>.NET provides a standard set of types for storing and managing collections of objects. These include resizable lists, linked lists, and sorted and unsorted dictionaries, as well as arrays. Of these, only arrays form part of the C# language; the remaining collections are just classes you instantiate like any other.</p>
<p>We can divide the types in the .NET BCL for collections into the following categories:</p>
<ul>
<li><p>Interfaces that define standard collection protocols</p></li>
<li><p>Ready-to-use collection classes (lists, dictionaries, etc.)</p></li>
<li><p>Base classes for writing application-specific collections</p></li>
</ul>
<p>This chapter covers each of these categories, with an additional section on the types used in determining element equality and order.</p>
<p>The collection namespaces are as follows:</p>
<table class="border">
<thead>
<tr>
<th>Namespace</th>
<th>Contains</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>System.Collections</code></td>
<td>Nongeneric collection classes and interfaces</td>
</tr>
<tr>
<td><code>System.Collections.Specialized</code></td>
<td>Strongly typed nongeneric collection classes</td>
</tr>
<tr>
<td><code>System.Collections.Generic</code></td>
<td>Generic collection classes and interfaces</td>
</tr>
<tr>
<td><code>System.Collections.ObjectModel</code></td>
<td>Proxies and bases for custom collections</td>
</tr>
<tr>
<td><code>System.Collections.Concurrent</code></td>
<td>Thread-safe collections (see <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>)</td>
</tr>
</tbody>
</table>
<section class="pagebreak-before" data-pdf-bookmark="Enumeration" data-type="sect1"><div class="sect1" id="enumeration-id00063">
<h1 class="less_space">Enumeration</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="enumeration" data-type="indexterm" id="ch07.html101"/><a contenteditable="false" data-primary="enumeration" data-type="indexterm" id="ch07.html102"/><a contenteditable="false" data-primary="enumeration" data-secondary="collections" data-type="indexterm" id="ch07.html103"/>In computing, there are many different kinds of collections, ranging from simple data structures such as arrays or linked lists, to more complex ones such as red/black trees and hashtables. Although the internal implementation and external characteristics of these data structures vary widely, the ability to traverse the contents of the collection is an almost universal need. The .NET BCL supports this need via a pair of interfaces (<code>IEnumerable</code>, <code>IEnumerator</code>, and their generic counterparts) that allow different data structures to expose a common traversal API. These are part of a larger set of collection interfaces illustrated in <a data-type="xref" href="#collection_interfaces">Figure 7-1</a>.</p>
<figure><div class="figure" id="collection_interfaces">
<img alt="Collection interfaces" src="assets/cn10_0701.png"/>
<h6><span class="label">Figure 7-1. </span>Collection interfaces</h6>
</div></figure>
<section data-pdf-bookmark="IEnumerable and IEnumerator" data-type="sect2"><div class="sect2" id="ienumerable_and_ienumerator">
<h2>IEnumerable and IEnumerator</h2>
<p><a contenteditable="false" data-primary="enumeration" data-secondary="IEnumerable and IEnumerator" data-type="indexterm" id="id2990"/><a contenteditable="false" data-primary="IEnumerable" data-type="indexterm" id="id2991"/><a contenteditable="false" data-primary="IEnumerator" data-type="indexterm" id="id2992"/>The <code>IEnumerator</code> interface defines the basic low-level protocol by which elements in a collection are traversed—or enumerated—in a forward-only manner. Its declaration is as follows:</p>
<pre data-type="programlisting">public interface IEnumerator
{
  bool MoveNext();
  object Current { get; }
  void Reset();
}</pre>
<p><code>MoveNext</code> advances the current element or “cursor” to the next position, returning <code>false</code> if there are no more elements in the collection. <code>Current</code> returns the element at the current position (usually cast from <code>object</code> to a more specific type). <code>MoveNext</code> must be called before retrieving the first element—this is to allow for an empty collection. The <code>Reset</code> method, if implemented, moves back to the start, allowing the collection to be enumerated again. <code>Reset</code> exists mainly for Component Object Model (COM) interoperability; calling it directly is generally avoided because it’s not universally supported (and is unnecessary in that it’s usually just as easy to instantiate a new enumerator).</p>
<p>Collections do not usually <em>implement</em> enumerators; instead, they <em>provide</em> enumerators, via the interface <code>IEnumerable</code>:</p>
<pre data-type="programlisting">public interface IEnumerable
{
  IEnumerator GetEnumerator();
}</pre>
<p>By defining a single method retuning an enumerator, <code>IEnumerable</code> provides flexibility in that the iteration logic can be farmed out to another class. Moreover, it means that several consumers can enumerate the collection at once without interfering with one another. You can think of <code>IEnumerable</code> as “IEnumeratorProvider,” and it is the most basic interface that collection classes implement.</p>
<p>The following example illustrates low-level use of <code>IEnumerable</code> and <code>IEnumerator</code>:</p>
<pre data-type="programlisting">string s = "Hello";

// Because string implements IEnumerable, we can call GetEnumerator():
IEnumerator rator = s.GetEnumerator();

while (rator.MoveNext())
{
  char c = (char) rator.Current;
  Console.Write (c + ".");
}

// Output:  H.e.l.l.o.</pre>
<p>However, it’s rare to call methods on enumerators directly in this manner because C# provides a syntactic shortcut: the <code>foreach</code> statement. Here’s the same example rewritten using <code>foreach</code>:</p>
<pre data-type="programlisting">string s = "Hello";      // The String class implements IEnumerable

foreach (char c in s)
  Console.Write (c + ".");</pre>
</div></section>
<section data-pdf-bookmark="IEnumerable&lt;T&gt; and IEnumerator&lt;T&gt;" data-type="sect2"><div class="sect2" id="ienumerableless_thantgreateri-id00021">
<h2>IEnumerable&lt;T&gt; and IEnumerator&lt;T&gt;</h2>
<p><a contenteditable="false" data-primary="enumeration" data-secondary="IEnumerable&lt;T&gt; and IEnumerator&lt;T&gt;" data-type="indexterm" id="ch07.html104"/><a contenteditable="false" data-primary="IEnumerable&lt;T&gt;" data-type="indexterm" id="ch07.html105"/><a contenteditable="false" data-primary="IEnumerator&lt;T&gt;" data-type="indexterm" id="ch07.html106"/><code>IEnumerator</code> and <code>IEnumerable</code> are nearly always implemented in conjunction with their extended generic versions:</p>
<pre data-type="programlisting">public interface IEnumerator&lt;T&gt; : IEnumerator, IDisposable
{
  T Current { get; }
}

public interface IEnumerable&lt;T&gt; : IEnumerable
{
  IEnumerator&lt;T&gt; GetEnumerator();
}</pre>
<p>By defining a typed version of <code>Current</code> and <code>GetEnumerator</code>, these interfaces strengthen static type safety, avoid the overhead of boxing with value-type elements, and are more convenient to the consumer. Arrays automatically implement <code>IEnumerable&lt;T&gt;</code> (where <code>T</code> is the member type of the array).</p>
<p>Thanks to the improved static type safety, calling the following method with an array of characters will generate a compile-time error:</p>
<pre data-type="programlisting">void Test (IEnumerable&lt;int&gt; numbers) { ... }</pre>
<p>It’s a standard practice for collection classes to publicly expose <code>IEnumerable&lt;T&gt;</code> while “hiding” the nongeneric <code>IEnumerable</code> through explicit interface implementation. This is so that if you directly call <code>GetEnumerator()</code>, you get back the type-safe generic <code>IEnumerator&lt;T&gt;</code>. There are times, though, when this rule is broken for reasons of backward compatibility (generics did not exist prior to C# 2.0). A good example is arrays—these must return the nongeneric (the nice way of putting it is “classic”) <code>IEnumerator</code> to avoid breaking earlier code. To get a generic <code>IEnumerator&lt;T&gt;</code>, you must cast to expose the explicit interface:</p>
<pre data-type="programlisting">int[] data = { 1, 2, 3 };
var rator = ((IEnumerable &lt;int&gt;)data).GetEnumerator();</pre>
<p>Fortunately, you rarely need to write this sort of code, thanks to the <code>foreach</code> statement.</p>
<section data-pdf-bookmark="IEnumerable&lt;T&gt; and IDisposable" data-type="sect3"><div class="sect3" id="ienumerableless_thantgreateri-id00072">
<h3>IEnumerable&lt;T&gt; and IDisposable</h3>
<p><a contenteditable="false" data-primary="IDisposable" data-secondary="IEnumerable&lt;T&gt; and" data-type="indexterm" id="id2993"/><a contenteditable="false" data-primary="IEnumerable&lt;T&gt;" data-secondary="IDisposable and" data-type="indexterm" id="id2994"/><code>IEnumerator&lt;T&gt;</code> inherits from <code>IDisposable</code>. This allows enumerators to hold references to resources such as database connections—and ensure that those resources are released when enumeration is complete (or abandoned partway through). The <code>foreach</code> statement recognizes this detail and translates the following:</p>
<pre data-type="programlisting">foreach (var element in somethingEnumerable) { ... }</pre>
<p>into the logical equivalent of this:</p>
<pre data-type="programlisting"><strong>using</strong> (var rator = somethingEnumerable.GetEnumerator())
  while (rator.MoveNext())
  {
    var element = rator.Current;
    ...
  }</pre>
<p>The <code>using</code> block ensures disposal—more on <code>IDisposable</code> in <a data-type="xref" href="ch12.html#disposal_and_garbage_collection">Chapter 12</a>.</p>
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="when_to_use_the_nongeneric_interfaces">
<h1>When to Use the Nongeneric Interfaces</h1>
<p><a contenteditable="false" data-primary="interface" data-secondary="when to use nongeneric interfaces" data-type="indexterm" id="id2995"/><a contenteditable="false" data-primary="nongeneric interfaces" data-type="indexterm" id="id2996"/>Given the extra type safety of the generic collection interfaces such as <code>IEnumerable&lt;T&gt;</code>, the question arises: do you ever need to use the nongeneric <code>IEnumerable</code> (or <code>ICollection</code> or <code>IList</code>)?</p>
<p>In the case of <code>IEnumerable</code>, you must implement this interface in conjunction with <code>IEnumerable&lt;T&gt;</code>—because the latter derives from the former. However, it’s very rare that you actually implement these interfaces from scratch: in nearly all cases, you can take the higher-level approach of using iterator methods, <code>Collection&lt;T&gt;</code>, and LINQ.</p>
<p>So, what about as a consumer? In nearly all cases, you can manage entirely with the generic interfaces. The nongeneric interfaces are still occasionally useful, though, in their ability to provide type unification for collections across all element types. The following method, for instance, counts elements in any collection <em>recursively</em>:</p>
<pre data-type="programlisting">public static int Count (IEnumerable e)
{
  int count = 0;
  foreach (object element in e)
  {
    var subCollection = element as IEnumerable;
    if (subCollection != null)
      count += Count (subCollection);
    else
      count++;
  }
  return count;
}</pre>
<p>Because C# offers covariance with generic interfaces, it might seem valid to have this method instead accept <code>IEnumerable&lt;object&gt;</code>. This, however, would fail with value-type elements and with legacy collections that don’t implement <code>IEnumerable&lt;T&gt;</code>—an example is <code>ControlCollection</code> in Windows Forms.</p>
<p>(On a slight tangent, you might have noticed a potential bug in our example: <em>cyclic</em> references will cause infinite recursion and crash the method. We could fix this most easily with the use of a <code>HashSet</code> (see <a data-type="xref" href="#hashsetless_thantgreater_than_and_sorte">“HashSet&lt;T&gt; and SortedSet&lt;T&gt;”</a>).<a contenteditable="false" data-primary="" data-startref="ch07.html106" data-type="indexterm" id="id2997"/><a contenteditable="false" data-primary="" data-startref="ch07.html105" data-type="indexterm" id="id2998"/><a contenteditable="false" data-primary="" data-startref="ch07.html104" data-type="indexterm" id="id2999"/> </p>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Implementing the Enumeration Interfaces" data-type="sect2"><div class="sect2" id="implementing_the_enumeration_interfaces">
<h2>Implementing the Enumeration Interfaces</h2>
<p><a contenteditable="false" data-primary="enumeration" data-secondary="implementing the enumeration interfaces" data-type="indexterm" id="ch07.html107"/><a contenteditable="false" data-primary="IEnumerable" data-type="indexterm" id="ch07.html108"/><a contenteditable="false" data-primary="IEnumerable&lt;T&gt;" data-secondary="implementing the enumeration interfaces" data-type="indexterm" id="ch07.html109"/>You might want to implement <code>IEnumerable</code> or <code>IEnumerable&lt;T&gt;</code> for one or more of the following reasons:</p>
<ul>
<li><p>To support the <code>foreach</code> statement</p></li>
<li><p>To interoperate with anything expecting a standard collection</p></li>
<li><p>To meet the requirements of a more sophisticated collection interface</p></li>
<li><p>To support collection initializers</p></li>
</ul>
<p>To implement <code>IEnumerable</code>/<code>IEnumerable&lt;T&gt;</code>, you must provide an enumerator. You can do this in one of three ways:</p>
<ul>
<li><p>If the class is “wrapping” another collection, by returning the wrapped collection’s enumerator</p></li>
<li><p>Via an iterator using <code>yield return</code></p></li>
<li><p>By instantiating your own <code>IEnumerator</code>/<code>IEnumerator&lt;T&gt;</code> implementation</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also subclass an existing collection: <code>Collection&lt;T&gt;</code> is designed just for this purpose (see <a data-type="xref" href="#customizable_collections_and_proxies">“Customizable Collections and Proxies”</a>). Yet another approach is to use the LINQ query operators, which we cover in <a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>.</p>
</div>
<p><a contenteditable="false" data-primary="Get..." data-secondary="GetEnumerator method" data-type="indexterm" id="id3000"/>Returning another collection’s enumerator is just a matter of calling <code>GetEnumerator</code> on the inner collection. However, this is viable only in the simplest scenarios in which the items in the inner collection are exactly what are required. <a contenteditable="false" data-primary="iterators" data-type="indexterm" id="id3001"/>A more flexible approach is to write an iterator, using C#’s <code>yield return</code> statement. An <em>iterator</em> is a C# language feature that assists in writing collections, in the same way the <code>foreach</code> statement assists in consuming collections. An iterator automatically handles the implementation of <code>IEnumerable</code> and <code>IEnumerator</code>—or their generic versions. Here’s a simple example:</p>
<pre data-type="programlisting">public class MyCollection : IEnumerable
{
  int[] data = { 1, 2, 3 };

  public IEnumerator GetEnumerator()
  {
    foreach (int i in data)
      yield return i;
  }
}</pre>
<p>Notice the “black magic”: <code>GetEnumerator</code> doesn’t appear to return an enumerator at all! Upon parsing the <code>yield return</code> statement, the compiler writes a hidden nested enumerator class behind the scenes and then refactors <code>GetEnumerator</code> to instantiate and return that class. Iterators are powerful and simple (and are used extensively in the implementation of LINQ-to-Object’s standard query operators).</p>
<p>Keeping with this approach, we can also implement the generic interface <code>IEnumerable&lt;T&gt;</code>:</p>
<pre data-type="programlisting">public class MyGenCollection : IEnumerable&lt;int&gt;
{
  int[] data = { 1, 2, 3 };

  public IEnumerator&lt;int&gt; GetEnumerator()
  {
    foreach (int i in data)
      yield return i;
  }

  // Explicit implementation keeps it hidden:
  IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}</pre>
<p>Because <code>IEnumerable&lt;T&gt;</code> inherits from <code>IEnumerable</code>, we must implement both the generic and the nongeneric versions of <code>GetEnumerator</code>. In accordance with standard practice, we’ve implemented the nongeneric version explicitly. It can simply call the generic <code>GetEnumerator</code> because <code>IEnumerator&lt;T&gt;</code> inherits from <code>IEnumerator</code>.</p>
<p>The class we’ve just written would be suitable as a basis from which to write a more sophisticated collection. However, if we need nothing above a simple <code>IEnumerable&lt;T&gt;</code> implementation, the <code>yield return</code> statement allows for an easier variation. Rather than writing a class, you can move the iteration logic into a method returning a generic <code>IEnumerable&lt;T&gt;</code> and let the compiler take care of the rest. Here’s an example:</p>
<pre data-type="programlisting">public static IEnumerable &lt;int&gt; GetSomeIntegers()
{
  yield return 1;
  yield return 2;
  yield return 3;
}</pre>
<p>Here’s our method in use:</p>
<pre data-type="programlisting">foreach (int i in Test.GetSomeIntegers())
  Console.WriteLine (i);</pre>
<p>The final approach in writing <code>GetEnumerator</code> is to write a class that implements <code>IEnumerator</code> directly. This is exactly what the compiler does behind the scenes, in resolving iterators. (Fortunately, it’s rare that you’ll need to go this far yourself.) The following example defines a collection that’s hardcoded to contain the integers 1, 2, and 3:</p>
<pre data-type="programlisting">public class MyIntList : IEnumerable
{
  int[] data = { 1, 2, 3 };

  public IEnumerator GetEnumerator() =&gt; new Enumerator (this);

  class Enumerator : IEnumerator       // Define an inner class
  {                                    // for the enumerator.
    MyIntList collection;
    int currentIndex = -1;

    public Enumerator (MyIntList items) =&gt; this.collection = items;

    public object Current
    {
      get
      {
        if (currentIndex == -1)
          throw new InvalidOperationException ("Enumeration not started!");
        if (currentIndex == collection.data.Length)
          throw new InvalidOperationException ("Past end of list!");
        return collection.data [currentIndex];
      }
    }

    public bool MoveNext()
    {
      if (currentIndex &gt;= collection.data.Length - 1) return false;
      return ++currentIndex &lt; collection.data.Length;
    }

    public void Reset() =&gt; currentIndex = -1;
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Implementing <code>Reset</code> is optional—you can instead throw a <code>NotSupportedException</code>.</p>
</div>
<p>Note that the first call to <code>MoveNext</code> should move to the first (and not the second) item in the list.</p>
<p>To get on par with an iterator in functionality, we must also implement <code>IEnumerator&lt;T&gt;</code>. Here’s an example with bounds checking omitted for brevity:</p>
<pre data-type="programlisting">class MyIntList : IEnumerable&lt;int&gt;
{
  int[] data = { 1, 2, 3 };

  // The generic enumerator is compatible with both IEnumerable and
  // IEnumerable&lt;T&gt;. We implement the nongeneric GetEnumerator method
  // explicitly to avoid a naming conflict.

  public IEnumerator&lt;int&gt; GetEnumerator() =&gt; new Enumerator(this);
  IEnumerator IEnumerable.GetEnumerator() =&gt; new Enumerator(this);

  class Enumerator : IEnumerator&lt;int&gt;
  {
    int currentIndex = -1;
    MyIntList collection;

    public Enumerator (MyIntList items) =&gt; collection = items;

    public int Current =&gt; collection.data [currentIndex];
    object IEnumerator.Current =&gt; Current;

    public bool MoveNext() =&gt; ++currentIndex &lt; collection.data.Length;

    public void Reset() =&gt; currentIndex = -1;

    // Given we don't need a Dispose method, it's good practice to
    // implement it explicitly, so it's hidden from the public interface.
    void IDisposable.Dispose() {}
  }
}</pre>
<p>The example with generics is faster because <code>IEnumerator&lt;int&gt;.Current</code> doesn’t require casting from <code>int</code> to <code>object</code> and so avoids the overhead of boxing.<a contenteditable="false" data-primary="" data-startref="ch07.html109" data-type="indexterm" id="id3002"/><a contenteditable="false" data-primary="" data-startref="ch07.html108" data-type="indexterm" id="id3003"/><a contenteditable="false" data-primary="" data-startref="ch07.html107" data-type="indexterm" id="id3004"/><a contenteditable="false" data-primary="" data-startref="ch07.html103" data-type="indexterm" id="id3005"/><a contenteditable="false" data-primary="" data-startref="ch07.html102" data-type="indexterm" id="id3006"/><a contenteditable="false" data-primary="" data-startref="ch07.html101" data-type="indexterm" id="id3007"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The ICollection and IList Interfaces" data-type="sect1"><div class="sect1" id="the_icollection_and_ilist_interfaces">
<h1>The ICollection and IList Interfaces</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="ICollection and IList interfaces" data-type="indexterm" id="ch07.html1010"/><a contenteditable="false" data-primary="ICollection" data-type="indexterm" id="ch07.html1011"/><a contenteditable="false" data-primary="ICollection&lt;T&gt;" data-type="indexterm" id="ch07.html1012"/><a contenteditable="false" data-primary="IList" data-type="indexterm" id="ch07.html1013"/>Although the enumeration interfaces provide a protocol for forward-only iteration over a collection, they don’t provide a mechanism to determine the size of the collection, access a member by index, or modify the collection. <a contenteditable="false" data-primary="IList&lt;T&gt;" data-type="indexterm" id="id3008"/>For such functionality, .NET defines the <code>ICollection</code>, <code>IList</code>, and <code>IDictionary</code> interfaces. Each comes in both generic and nongeneric versions; however, the nongeneric versions exist mostly for legacy support.</p>
<p><a data-type="xref" href="#collection_interfaces">Figure 7-1</a> showed the inheritance hierarchy for these interfaces. The easiest way to summarize them is as follows:</p>
<dl>
<dt><code>IEnumerable&lt;T&gt;</code> (and <code>IEnumerable</code>)</dt>
<dd>Provides minimum functionality (enumeration only)</dd>
<dt><code>ICollection&lt;T&gt;</code> (and <code>ICollection</code>)</dt>
<dd>Provides medium functionality (e.g., the <code>Count</code> property)</dd>
<dt><code>IList&lt;T&gt;</code><em>/</em><code>IDictionary&lt;K,V&gt;</code> and their nongeneric versions</dt>
<dd>Provide maximum functionality (including “random” access by index/key)</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s rare that you’ll need to <em>implement</em> any of these interfaces. In nearly all cases when you need to write a collection class, you can instead subclass <code>Collection&lt;T&gt;</code> (see <a data-type="xref" href="#customizable_collections_and_proxies">“Customizable Collections and Proxies”</a>). LINQ provides yet another option that covers many scenarios.</p>
</div>
<p>The generic and nongeneric versions differ in ways over and above what you might expect, particularly in the case of <code>ICollection</code>. The reasons for this are mostly historical: because generics came later, the generic interfaces were developed with the benefit of hindsight, leading to a different (and better) choice of members. For this reason, <code>ICollection&lt;T&gt;</code> does not extend <code>ICollection</code>, <code>IList&lt;T&gt;</code> does not extend <code>IList</code>, and <code>IDictionary&lt;TKey, TValue&gt;</code> does not extend <code>IDictionary</code>. Of course, a collection class itself is free to implement both versions of an interface if beneficial (which it often is).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another, subtler reason for <code>IList&lt;T&gt;</code> not extending <code>IList</code> is that casting to <code>IList&lt;T&gt;</code> would then return an interface with both <code>Add(T)</code> and <code>Add(object)</code> members. This would effectively defeat static type safety because you could call <code>Add</code> with an object of any type.</p>
</div>
<p>This section covers <code>ICollection&lt;T&gt;</code> and <code>IList&lt;T&gt;</code> and their nongeneric versions; <a data-type="xref" href="#dictionaries">“Dictionaries”</a> covers the dictionary interfaces.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There is no <em>consistent</em> rationale in the way the words “collection” and “list” are applied throughout the .NET libraries. For instance, because <code>IList&lt;T&gt;</code> is a more functional version of <code>ICollection&lt;T&gt;</code>, you might expect the class <code>List&lt;T&gt;</code> to be correspondingly more functional than the class <code>Collection&lt;T&gt;</code>. This is not the case. It’s best to consider the terms “collection” and “list” as broadly synonymous, except when a specific type is involved.</p>
</div>
<section data-pdf-bookmark="ICollection&lt;T&gt; and ICollection" data-type="sect2"><div class="sect2" id="icollectionless_thantgreater_than_and_i">
<h2>ICollection&lt;T&gt; and ICollection</h2>
<p><code>ICollection&lt;T&gt;</code> is the standard interface for countable collections of objects. It provides the ability to determine the size of a collection (<code>Count</code>), determine whether an item exists in the collection (<code>Contains</code>), copy the collection into an array (<code>ToArray</code>), and determine whether the collection is read-only (<code>IsReadOnly</code>). For writable collections, you can also <code>Add</code>, <code>Remove</code>, and <code>Clear</code> items from the collection. And because it extends <code>IEnumerable&lt;T&gt;</code>, it can also be traversed via the <code>foreach</code> statement:</p>
<pre data-type="programlisting">public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable
{
  int Count { get; }

  bool Contains (T item);
  void CopyTo (T[] array, int arrayIndex);
  bool IsReadOnly { get; }

  void Add(T item);
  bool Remove (T item);
  void Clear();
}</pre>
<p>The nongeneric <code>ICollection</code> is similar in providing a countable collection, but it doesn’t provide functionality for altering the list or checking for element membership:</p>
<pre data-type="programlisting">public interface ICollection : IEnumerable
{
   int Count { get; }
   bool IsSynchronized { get; }
   object SyncRoot { get; }
   void CopyTo (Array array, int index);
}</pre>
<p>The nongeneric interface also defines properties to assist with synchronization (<a data-type="xref" href="ch14.html#concurrency_and_asynchron">Chapter 14</a>)—these were dumped in the generic version because thread safety is no longer considered intrinsic to the collection.</p>
<p>Both interfaces are fairly straightforward to implement. If implementing a read-only <code>ICollection&lt;T&gt;</code>, the <code>Add</code>, <code>Remove</code>, and <code>Clear</code> methods should throw a <code>NotSupportedException</code>.</p>
<p>These interfaces are usually implemented in conjunction with either the <code>IList</code> or the <code>IDictionary</code> interface.</p>
</div></section>
<section data-pdf-bookmark="IList&lt;T&gt; and IList" data-type="sect2"><div class="sect2" id="ilistless_thantgreater_than_and_ilist">
<h2>IList&lt;T&gt; and IList</h2>
<p><a contenteditable="false" data-primary="IList&lt;T&gt;" data-type="indexterm" id="id3009"/><code>IList&lt;T&gt;</code> is the standard interface for collections indexable by position. In addition to the functionality inherited from <code>ICollection&lt;T&gt;</code> and <code>IEnumerable&lt;T&gt;</code>, it provides the ability to read or write an element by position (via an indexer) and insert/remove by position:</p>
<pre data-type="programlisting">public interface IList&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable
{
  T this [int index] { get; set; }
  int IndexOf (T item);
  void Insert (int index, T item);
  void RemoveAt (int index);
}</pre>
<p>The <code>IndexOf</code> methods perform a linear search on the list, returning <code>−1</code> if the specified item is not found.</p>
<p>The nongeneric version of <code>IList</code> has more members because it inherits less from <code>ICollection</code>:</p>
<pre data-type="programlisting">public interface IList : ICollection, IEnumerable
{
  object this [int index] { get; set }
  bool IsFixedSize { get; }
  bool IsReadOnly  { get; }
  int  Add      (object value);
  void Clear();
  bool Contains (object value);
  int  IndexOf  (object value);
  void Insert   (int index, object value);
  void Remove   (object value);
  void RemoveAt (int index);
}</pre>
<p>The <code>Add</code> method on the nongeneric <code>IList</code> interface returns an integer—this is the index of the newly added item. In contrast, the <code>Add</code> method on <code>ICollection&lt;T&gt;</code> has a <code>void</code> return type.</p>
<p><a contenteditable="false" data-primary="List&lt;T&gt; class" data-type="indexterm" id="id3010"/>The general-purpose <code>List&lt;T&gt;</code> class is the quintessential implementation of both <code>IList&lt;T&gt;</code> and <code>IList</code>. C# arrays also implement both the generic and nongeneric <code>IList</code>s (although the methods that add or remove elements are hidden via explicit interface implementation and throw a <code>NotSupportedException</code> if called).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>An <code>ArgumentException</code> is thrown if you try to access a multidimensional array via <code>IList</code>’s indexer. This is a trap when writing methods such as the following:</p>
<pre data-type="programlisting">public object FirstOrNull (IList list)
{
  if (list == null || list.Count == 0) return null;
  return list[0];
}</pre>
<p>This might appear bulletproof, but it will throw an exception if called with a multidimensional array. You can test for a multidimensional array at runtime with this expression (more on this in <a data-type="xref" href="ch19.html#dynamic_programming">Chapter 19</a>):</p>
<pre data-type="programlisting">list.GetType().IsArray &amp;&amp; list.GetType().GetArrayRank()&gt;1</pre>
</div>
</div></section>
<section data-pdf-bookmark="IReadOnlyCollection&lt;T&gt; and IReadOnlyList&lt;T&gt;" data-type="sect2"><div class="sect2" id="ireadonlycollectionless_thantgreater_th">
<h2>IReadOnlyCollection&lt;T&gt; and IReadOnlyList&lt;T&gt;</h2>
<p><a contenteditable="false" data-primary="IReadOnlyCollection&lt;T&gt;" data-type="indexterm" id="id3011"/><a contenteditable="false" data-primary="IReadOnlyList&lt;T&gt;" data-type="indexterm" id="id3012"/>.NET also defines collection and list interfaces that expose just the members required for read-only operations:</p>
<pre data-type="programlisting">public interface IReadOnlyCollection&lt;<strong>out</strong> T&gt; : IEnumerable&lt;T&gt;, IEnumerable
{
  int Count { get; }
}

public interface IReadOnlyList&lt;<strong>out</strong> T&gt; : IReadOnlyCollection&lt;T&gt;,
                                        IEnumerable&lt;T&gt;, IEnumerable
{
  T this[int index] { get; }
}</pre>
<p>Because the type parameter for these interfaces is used only in output positions, it’s marked as <em>covariant</em>. This allows a list of cats, for instance, to be treated as a read-only list of animals. In contrast, <code>T</code> is not marked as covariant with <code>ICollection&lt;T&gt;</code> and <code>IList&lt;T&gt;</code>, because <code>T</code> is used in both input and output positions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>These interfaces represent a read-only <em>view</em> of a collection or list; the underlying implementation might still be writable. Most of the writable (<em>mutable</em>) collections implement both the read-only and read/write interfaces.</p>
</div>
<p>In addition to letting you work with collections covariantly, the read-only interfaces allow a class to publicly expose a read-only view of a private writable collection. We demonstrate this—along with a better solution—in <a data-type="xref" href="#readonlycollectionless_thantgreater_tha">“ReadOnlyCollection&lt;T&gt;”</a>.</p>
<p><code>IReadOnlyList&lt;T&gt;</code> maps to the Windows Runtime type <code>IVectorView&lt;T&gt;</code>.<a contenteditable="false" data-primary="" data-startref="ch07.html1013" data-type="indexterm" id="id3013"/><a contenteditable="false" data-primary="" data-startref="ch07.html1012" data-type="indexterm" id="id3014"/><a contenteditable="false" data-primary="" data-startref="ch07.html1011" data-type="indexterm" id="id3015"/><a contenteditable="false" data-primary="" data-startref="ch07.html1010" data-type="indexterm" id="id3016"/></p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="The Array Class" data-type="sect1"><div class="sect1" id="the_array_class">
<h1 class="less_space">The Array Class</h1>
<p><a contenteditable="false" data-primary="Array class" data-type="indexterm" id="ch07.html1014"/><a contenteditable="false" data-primary="collections" data-secondary="Array class" data-type="indexterm" id="ch07.html1015"/><a contenteditable="false" data-primary="Array class" data-secondary="basics" data-type="indexterm" id="ch07.html1016"/>The <code>Array</code> class is the implicit base class for all single and multidimensional arrays, and it is one of the most fundamental types implementing the standard collection interfaces. The <code>Array</code> class provides type unification, so a common set of methods is available to all arrays, regardless of their declaration or underlying element type.</p>
<p>Because arrays are so fundamental, C# provides explicit syntax for their declaration and initialization, which we described in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#chash_language_basics">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#creating_types_in_chash">3</a>. When an array is declared using C#’s syntax, the CLR implicitly subtypes the <code>Array</code> <span class="keep-together">class—synthesizing</span> a <em>pseudotype</em> appropriate to the array’s dimensions and element types. This pseudotype implements the typed generic collection interfaces, such as <code>IList&lt;string&gt;</code>.</p>
<p>The CLR also treats array types specially upon construction, assigning them a contiguous space in memory. This makes indexing into arrays highly efficient, but prevents them from being resized later on.</p>
<p><code>Array</code> implements the collection interfaces up to <code>IList&lt;T&gt;</code> in both their generic and nongeneric forms. <code>IList&lt;T&gt;</code> itself is implemented explicitly, though, to keep <code>Array</code>’s public interface clean of methods such as <code>Add</code> or <code>Remove</code>, which throw an exception on fixed-length collections such as arrays. The <code>Array</code> class does actually offer a static <code>Resize</code> method, although this works by creating a new array and then copying over each element. As well as being inefficient, references to the array elsewhere in the program will still point to the original version. A better solution for resizable collections is to use the <code>List&lt;T&gt;</code> class (described in the following section).</p>
<p>An array can contain value-type or reference-type elements. Value-type elements are stored in place in the array, so an array of three long integers (each 8 bytes) will occupy 24 bytes of contiguous memory. A reference type element, however, occupies only as much space in the array as a reference (4 bytes in a 32-bit environment or 8 bytes in a 64-bit environment). <a data-type="xref" href="#arrays_in_memory">Figure 7-2</a> illustrates the effect, in memory, of the following program:</p>
<pre data-type="programlisting">StringBuilder[] builders = new StringBuilder [5];
builders [0] = new StringBuilder ("builder1");
builders [1] = new StringBuilder ("builder2");
builders [2] = new StringBuilder ("builder3");

long[] numbers = new long [3];
numbers [0] = 12345;
numbers [1] = 54321;</pre>
<figure><div class="figure" id="arrays_in_memory">
<img alt="Arrays in memory" src="assets/cn10_0702.png"/>
<h6><span class="label">Figure 7-2. </span>Arrays in memory</h6>
</div></figure>
<p>Because <code>Array</code> is a class, arrays are always (themselves) reference types—regardless of the array’s element type. This means that the statement <code>arrayB = arrayA</code> results in two variables that reference the same array. Similarly, two distinct arrays will always fail an equality test, unless you employ a <em>structural equality comparer</em>, which compares every element of the array:</p>
<pre data-type="programlisting">object[] a1 = { "string", 123, true };
object[] a2 = { "string", 123, true };

Console.WriteLine (a1 == a2);                          // False
Console.WriteLine (a1.Equals (a2));                    // False

IStructuralEquatable se1 = a1;
Console.WriteLine (se1.Equals (a2,
 <strong>StructuralComparisons.StructuralEqualityComparer</strong>));   // True</pre>
<p><a contenteditable="false" data-primary="Clone method" data-type="indexterm" id="id3017"/>Arrays can be duplicated by calling the <code>Clone</code> method: <code>arrayB = arrayA.Clone()</code>. However, this results in a shallow clone, meaning that only the memory represented by the array itself is copied. If the array contains value-type objects, the values themselves are copied; if the array contains reference type objects, just the references are copied (resulting in two arrays whose members reference the same objects). <a data-type="xref" href="#shallow_cloning_an_array">Figure 7-3</a> demonstrates the effect of adding the following code to our example:</p>
<pre data-type="programlisting">StringBuilder[] builders2 = builders;
StringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();</pre>
<figure><div class="figure" id="shallow_cloning_an_array">
<img alt="Shallow-cloning an array" src="assets/cn10_0703.png"/>
<h6><span class="label">Figure 7-3. </span>Shallow-cloning an array</h6>
</div></figure>
<p>To create a deep copy—for which reference type subobjects are duplicated—you must loop through the array and clone each element manually. The same rules apply to other .NET collection types.</p>
<p>Although <code>Array</code> is designed primarily for use with 32-bit indexers, it also has limited support for 64-bit indexers (allowing an array to theoretically address up to 2<sup>64</sup> elements) via several methods that accept both <code>Int32</code> and <code>Int64</code> parameters. These overloads are useless in practice because the CLR does not permit any <span class="keep-together">object—including</span> arrays—to exceed two gigabytes in size (whether running on a 32- or 64-bit environment).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Many of the methods on the <code>Array</code> class that you expect to be instance methods are in fact static methods. This is an odd design decision, and means that you should check for both static and instance methods when looking for a method on <code>Array</code>.<a contenteditable="false" data-primary="" data-startref="ch07.html1016" data-type="indexterm" id="id3018"/></p>
</div>
<section data-pdf-bookmark="Construction and Indexing" data-type="sect2"><div class="sect2" id="construction_and_indexing">
<h2>Construction and Indexing</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="construction and indexing" data-type="indexterm" id="ch07.html1017"/>The easiest way to create and index arrays is through C#’s language constructs:</p>
<pre data-type="programlisting">int[] myArray = { 1, 2, 3 };
int first = myArray [0];
int last = myArray [myArray.Length - 1];</pre>
<p>Alternatively, you can instantiate an array dynamically by calling <code>Array.CreateInstance</code>. This allows you to specify element type and rank (number of dimensions) at runtime as well as allowing nonzero-based arrays through specifying a lower bound. Nonzero-based arrays are not compatible with the .NET Common Language Specification (CLS), and should not be exposed as public members in a library that might be consumed by a program written in F# or Visual Basic.</p>
<p><a contenteditable="false" data-primary="Get..." data-secondary="GetValue method" data-type="indexterm" id="id3019"/><a contenteditable="false" data-primary="SetValue method" data-type="indexterm" id="id3020"/>The <code>GetValue</code> and <code>SetValue</code> methods let you access elements in a dynamically created array (they also work on ordinary arrays):</p>
<pre data-type="programlisting"> // Create a string array 2 elements in length:
 Array a = Array.CreateInstance (typeof(string), 2);
 a.SetValue ("hi", 0);                             //  → a[0] = "hi";
 a.SetValue ("there", 1);                          //  → a[1] = "there";
 string s = (string) a.GetValue (0);               //  → s = a[0];

 // We can also cast to a C# array as follows:
 string[] cSharpArray = (string[]) a;
 string s2 = cSharpArray [0];</pre>
<p>Zero-indexed arrays created dynamically can be cast to a C# array of a matching or compatible type (compatible by standard array-variance rules). For example, if <code>Apple</code> subclasses <code>Fruit</code>, <code>Apple[]</code> can be cast to <code>Fruit[]</code>. This leads to the issue of why <code>object[]</code> was not used as the unifying array type rather than the <code>Array</code> class. The answer is that <code>object[]</code> is incompatible with both multidimensional and value-type arrays (and non-zero-based arrays). An <code>int[]</code> array cannot be cast to <code>object[]</code>. Hence, we require the <code>Array</code> class for full type unification.</p>
<p><code>GetValue</code> and <code>SetValue</code> also work on compiler-created arrays, and they are useful when writing methods that can deal with an array of any type and rank. For multidimensional arrays, they accept an <em>array</em> of indexers:</p>
<pre data-type="programlisting">public object GetValue (params int[] indices)
public void   SetValue (object value, params int[] indices)</pre>
<p>The following method prints the first element of any array, regardless of rank:</p>
<pre data-type="programlisting"> void WriteFirstValue (Array a)
 {
   Console.Write (a.Rank + "-dimensional; ");

   // The indexers array will automatically initialize to all zeros, so
   // passing it into GetValue or SetValue will get/set the zero-based
   // (i.e., first) element in the array.

   int[] indexers = new int[a.Rank];
   Console.WriteLine ("First value is " +  a.GetValue (indexers));
 }

 void Demo()
 {
   int[]  oneD = { 1, 2, 3 };
   int[,] twoD = { {5,6}, {8,9} };

   WriteFirstValue (oneD);   // 1-dimensional; first value is 1
   WriteFirstValue (twoD);   // 2-dimensional; first value is 5
 }</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For working with arrays of unknown type but known rank, generics provide an easier and more efficient solution:</p>
<pre data-type="programlisting">void WriteFirstValue&lt;T&gt; (T[] array)
{
  Console.WriteLine (array[0]);
}</pre>
</div>
<p><code>SetValue</code> throws an exception if the element is of an incompatible type for the array.</p>
<p>When an array is instantiated, whether via language syntax or <code>Array.Create​In⁠stance</code>, its elements are automatically initialized to their default values. For arrays with reference type elements, this means writing nulls; for arrays with value-type elements, this means bitwise “zeroing” the members. The <code>Array</code> class also provides this functionality on demand via the <code>Clear</code> method:</p>
<pre data-type="programlisting">public static void Clear (Array array, int index, int length);</pre>
<p>This method doesn’t affect the size of the array. This is in contrast to the usual use of <code>Clear</code> (such as in <code>ICollection&lt;T&gt;.Clear</code>) whereby the collection is reduced to zero elements.<a contenteditable="false" data-primary="" data-startref="ch07.html1017" data-type="indexterm" id="id3021"/></p>
</div></section>
<section data-pdf-bookmark="Enumeration" data-type="sect2"><div class="sect2" id="enumeration">
<h2>Enumeration</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="enumeration" data-type="indexterm" id="id3022"/><a contenteditable="false" data-primary="enumeration" data-secondary="Array class" data-type="indexterm" id="id3023"/>Arrays are easily enumerated with a <code>foreach</code> statement:</p>
<pre data-type="programlisting">int[] myArray = { 1, 2, 3};
foreach (int val in myArray)
  Console.WriteLine (val);</pre>
<p>You can also enumerate using the static <code>Array.ForEach</code> method, defined as follows:</p>
<pre data-type="programlisting">public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);</pre>
<p>This uses an <code>Action</code> delegate, with this signature:</p>
<pre data-type="programlisting">public delegate void Action&lt;T&gt; (T obj);</pre>
<p>Here’s the first example rewritten with <code>Array.ForEach</code>:</p>
<pre data-type="programlisting">Array.ForEach (new[] { 1, 2, 3 }, Console.WriteLine);</pre>
<p>We can further simplify this with a <em>collection expression</em> (from C# 12):</p>
<pre data-type="programlisting">Array.ForEach ([ 1, 2, 3 ], Console.WriteLine);</pre>
</div></section>
<section data-pdf-bookmark="Length and Rank" data-type="sect2"><div class="sect2" id="length_and_rank">
<h2>Length and Rank</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="length and rank" data-type="indexterm" id="id3024"/><code>Array</code> provides the following methods and properties for querying length and rank:</p>
<pre data-type="programlisting">public int  GetLength      (int dimension);
public long GetLongLength  (int dimension);

public int  Length       { get; }
public long LongLength   { get; }

public int GetLowerBound (int dimension);
public int GetUpperBound (int dimension);

public int Rank { get; }    // Returns number of dimensions in array</pre>
<p><code>GetLength</code> and <code>GetLongLength</code> return the length for a given dimension (<code>0</code> for a single-dimensional array), and <code>Length</code> and <code>LongLength</code> return the total number of elements in the array—all dimensions included.</p>
<p><code>GetLowerBound</code> and <code>GetUpperBound</code> are useful with nonzero indexed arrays. <code>Get​Up⁠perBound</code> returns the same result as adding <code>GetLowerBound</code> to <code>GetLength</code> for any given dimension.</p>
</div></section>
<section data-pdf-bookmark="Searching" data-type="sect2"><div class="sect2" id="searching">
<h2>Searching</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="searching" data-type="indexterm" id="id3025"/><a contenteditable="false" data-primary="searching" data-secondary="within an array" data-type="indexterm" id="id3026"/>The <code>Array</code> class offers a range of methods for finding elements within a one-dimensional array:</p>
<dl>
<dt><code>BinarySearch</code> methods</dt>
<dd>For rapidly searching a sorted array for a particular item</dd>
<dt><code>IndexOf</code>/<code>LastIndex</code> methods</dt>
<dd>For searching unsorted arrays for a particular item</dd>
<dt><code>Find</code>/<code>FindLast</code>/<code>FindIndex</code>/<code>FindLastIndex</code>/<code>FindAll</code>/<code>Exists</code>/<code>TrueForAll</code></dt>
<dd>For searching unsorted arrays for item(s) that satisfy a given <code>Predicate&lt;T&gt;</code></dd>
</dl>
<p>None of the array-searching methods throws an exception if the specified value is not found. Instead, if an item is not found, methods returning an integer return <code>−1</code> (assuming a zero-indexed array), and methods returning a generic type return the type’s default value (e.g., <code>0</code> for an <code>int</code>, or <code>null</code> for a <code>string</code> ).</p>
<p>The binary search methods are fast, but they work only on sorted arrays and require that the elements be compared for <em>order</em> rather than simply <em>equality</em>. To this effect, the binary search methods can accept an <code>IComparer</code> or <code>IComparer&lt;T&gt;</code> object to arbitrate on ordering decisions (see <a data-type="xref" href="#plugging_in_equality_and_order">“Plugging in Equality and Order”</a>”). This must be consistent with any comparer used in originally sorting the array. If no comparer is provided, the type’s default ordering algorithm will be applied based on its implementation of <code>IComparable</code> / <code>IComparable&lt;T&gt;</code>.</p>
<p>The <code>IndexOf</code> and <code>LastIndexOf</code> methods perform a simple enumeration over the array, returning the position of the first (or last) element that matches the given value.</p>
<p>The predicate-based searching methods allow a method delegate or lambda expression to arbitrate on whether a given element is a “match.” A predicate is simply a delegate accepting an object and returning <code>true</code> or <code>false</code>:</p>
<pre data-type="programlisting">public delegate bool Predicate&lt;T&gt; (T object);</pre>
<p>In the following example, we search an array of strings for a name containing the letter “a”:</p>
<pre data-type="programlisting">string[] names = { "Rodney", "Jack", "Jill" };
string match = Array.Find (names, ContainsA);
Console.WriteLine (match);     // Jack

ContainsA (string name) { return name.Contains ("a"); }</pre>
<p>Here’s the same code shortened with a lambda expression:</p>
<pre data-type="programlisting">string[] names = { "Rodney", "Jack", "Jill" };
string match = Array.Find (names, <strong>n =&gt; n.Contains ("a")</strong>);     // Jack</pre>
<p><code>FindAll</code> returns an array of all items satisfying the predicate. In fact, it’s equivalent to <code>Enumerable.Where</code> in the <code>System.Linq</code> namespace, except that <code>FindAll</code> returns an array of matching items rather than an <code>IEnumerable&lt;T&gt;</code> of the same.</p>
<p><code>Exists</code> returns <code>true</code> if any array member satisfies the given predicate, and is equivalent to <code>Any</code> in <code>System.Linq.Enumerable</code>.</p>
<p><code>TrueForAll</code> returns <code>true</code> if all items satisfy the predicate, and is equivalent to <code>All</code> in <code>System.Linq.Enumerable</code>.</p>
</div></section>
<section data-pdf-bookmark="Sorting" data-type="sect2"><div class="sect2" id="sorting">
<h2>Sorting</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="sorting" data-type="indexterm" id="id3027"/><code>Array</code> has the following built-in sorting methods:</p>
<pre data-type="programlisting">// For sorting a single array:

public static void Sort&lt;T&gt; (T[] array);
public static void Sort    (Array array);

// For sorting a pair of arrays:

public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);
public static void Sort              (Array keys, Array items);</pre>
<p>Each of these methods is additionally overloaded to also accept the following:</p>
<pre data-type="programlisting">int index                 // Starting index at which to begin sorting
int length                // Number of elements to sort
IComparer&lt;T&gt; comparer     // Object making ordering decisions
Comparison&lt;T&gt; comparison  // Delegate making ordering decisions</pre>
<p>The following illustrates the simplest use of <code>Sort</code>:</p>
<pre data-type="programlisting">int[] numbers = { 3, 2, 1 };
Array.Sort (numbers);                     // Array is now { 1, 2, 3 }</pre>
<p>The methods accepting a pair of arrays work by rearranging the items of each array in tandem, basing the ordering decisions on the first array. In the next example, both the numbers and their corresponding words are sorted into numerical order:</p>
<pre data-type="programlisting">int[] numbers = { 3, 2, 1 };
string[] words = { "three", "two", "one" };
Array.Sort (numbers, words);

// numbers array is now { 1, 2, 3 }
// words   array is now { "one", "two", "three" }</pre>
<p><a contenteditable="false" data-primary="Array..." data-secondary="Array.Sort" data-type="indexterm" id="id3028"/><code>Array.Sort</code> requires that the elements in the array implement <code>IComparable</code> (see <a data-type="xref" href="ch06.html#order_comparison">“Order Comparison”</a>). This means that most built-in C# types (such as integers, as in the preceding example) can be sorted. If the elements are not intrinsically comparable or you want to override the default ordering, you must provide <code>Sort</code> with a custom <code>comparison</code> provider that reports on the relative position of two elements. There are ways to do this:</p>
<ul>
<li><p>Via a helper object that implements <code>IComparer</code> /<code>IComparer&lt;T&gt;</code> (see <a data-type="xref" href="#plugging_in_equality_and_order">“Plugging in Equality and Order”</a>)</p></li>
<li><p>Via a <code>Comparison</code> delegate:</p></li>
</ul>
<pre data-type="programlisting">public delegate int Comparison&lt;T&gt; (T x, T y);</pre>
<p>The <code>Comparison</code> delegate follows the same semantics as <code>IComparer&lt;T&gt;.CompareTo</code>: if <code>x</code> comes before <code>y</code>, a negative integer is returned; if <code>x</code> comes after <code>y</code>, a positive integer is returned; if <code>x</code> and <code>y</code> have the same sorting position, <code>0</code> is returned.</p>
<p>In the following example, we sort an array of integers such that the odd numbers come first:</p>
<pre data-type="programlisting">int[] numbers = { 1, 2, 3, 4, 5 };
Array.Sort (numbers, (x, y) =&gt; x % 2 == y % 2 ? 0 : x % 2 == 1 ? -1 : 1);

// numbers array is now { 1, 3, 5, 2, 4 }</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As an alternative to calling <code>Sort</code>, you can use LINQ’s <code>OrderBy</code> and <code>ThenBy</code> operators. Unlike <code>Array.Sort</code>, the LINQ operators don’t alter the original array, instead emitting the sorted result in a fresh <code>IEnumerable&lt;T&gt;</code> sequence.</p>
</div>
</div></section>
<section data-pdf-bookmark="Reversing Elements" data-type="sect2"><div class="sect2" id="reversing_elements">
<h2>Reversing Elements</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="reversing elements" data-type="indexterm" id="id3029"/>The following <code>Array</code> methods reverse the order of all—or a portion of—elements in an array:</p>
<pre data-type="programlisting">public static void Reverse (Array array);
public static void Reverse (Array array, int index, int length);</pre>
</div></section>
<section data-pdf-bookmark="Copying" data-type="sect2"><div class="sect2" id="copying">
<h2>Copying</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="copying" data-type="indexterm" id="id3030"/><code>Array</code> provides four methods to perform shallow copying: <code>Clone</code>, <code>CopyTo</code>, <code>Copy</code>, and <code>ConstrainedCopy</code>. The former two are instance methods; the latter two are static methods.</p>
<p><a contenteditable="false" data-primary="Clone method" data-type="indexterm" id="id3031"/><a contenteditable="false" data-primary="Copy method" data-type="indexterm" id="id3032"/><a contenteditable="false" data-primary="CopyTo method" data-type="indexterm" id="id3033"/>The <code>Clone</code> method returns a whole new (shallow-copied) array. The <code>CopyTo</code> and <code>Copy</code> methods copy a contiguous subset of the array. Copying a multidimensional rectangular array requires you to map the multidimensional index to a linear index. For example, the middle square (<code>position[1,1]</code>) in a 3 × 3 array is represented with the index 4, from the calculation: 1 * 3 + 1. The source and destination ranges can overlap without causing a problem.</p>
<p><a contenteditable="false" data-primary="ConstrainedCopy method" data-type="indexterm" id="id3034"/><code>ConstrainedCopy</code> performs an <em>atomic</em> operation: if all of the requested elements cannot be successfully copied (due to a type error, for instance), the operation is rolled back.</p>
<p><code>Array</code> also provides an <code>AsReadOnly</code> method that returns a wrapper that prevents elements from being reassigned.</p>
</div></section>
<section data-pdf-bookmark="Converting and Resizing" data-type="sect2"><div class="sect2" id="converting_and_resizing">
<h2>Converting and Resizing</h2>
<p><a contenteditable="false" data-primary="Array class" data-secondary="converting/resizing" data-type="indexterm" id="id3035"/><a contenteditable="false" data-primary="Array..." data-secondary="Array.ConvertAll method" data-type="indexterm" id="id3036"/><code>Array.ConvertAll</code> creates and returns a new array of element type <code>TOutput</code>, calling the supplied <code>Converter</code> delegate to copy over the elements. <code>Converter</code> is defined as follows:</p>
<pre data-type="programlisting">public delegate TOutput Converter&lt;TInput,TOutput&gt; (TInput input)</pre>
<p>The following converts an array of floats to an array of integers:</p>
<pre data-type="programlisting">float[] reals = { 1.3f, 1.5f, 1.8f };
int[] wholes = Array.ConvertAll (reals, r =&gt; Convert.ToInt32 (r));

// wholes array is { 1, 2, 2 }</pre>
<p><a contenteditable="false" data-primary="Resize method" data-type="indexterm" id="id3037"/>The <code>Resize</code> method works by creating a new array and copying over the elements, returning the new array via the reference parameter. However, any references to the original array in other objects will remain unchanged.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>System.Linq</code> namespace offers an additional buffet of extension methods suitable for array conversion. These methods return an <code>IEnumerable&lt;T&gt;</code>, which you can convert back to an array via <code>Enumerable</code> ’s <code>ToArray</code> method.<a contenteditable="false" data-primary="" data-startref="ch07.html1015" data-type="indexterm" id="id3038"/><a contenteditable="false" data-primary="" data-startref="ch07.html1014" data-type="indexterm" id="id3039"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Lists, Queues, Stacks, and Sets" data-type="sect1"><div class="sect1" id="listscomma_queuescomma_stackscomma_and">
<h1>Lists, Queues, Stacks, and Sets</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="lists, queues, stacks, and sets" data-type="indexterm" id="ch07.html1018"/><a contenteditable="false" data-primary="list-like collections" data-type="indexterm" id="ch07.html1019"/>.NET provides a basic set of concrete collection classes that implement the interfaces described in this chapter. This section concentrates on the <em>list-like</em> collections (versus the <em>dictionary-like</em> collections, which we cover in <a data-type="xref" href="#dictionaries">“Dictionaries”</a>). As with the interfaces we discussed previously, you usually have a choice of generic or nongeneric versions of each type. In terms of flexibility and performance, the generic classes win, making their nongeneric counterparts redundant except for backward compatibility. This differs from the situation with collection interfaces, for which the nongeneric versions are still occasionally useful.</p>
<p>Of the classes described in this section, the generic <code>List</code> class is the most commonly used.</p>
<section data-pdf-bookmark="List&lt;T&gt; and ArrayList" data-type="sect2"><div class="sect2" id="listless_thantgreater_than_and_arraylis">
<h2>List&lt;T&gt; and ArrayList</h2>
<p><a contenteditable="false" data-primary="Array..." data-secondary="ArrayList" data-type="indexterm" id="ch07.html1020"/><a contenteditable="false" data-primary="list-like collections" data-secondary="List&lt;T&gt; and ArrayList" data-type="indexterm" id="ch07.html1021"/><a contenteditable="false" data-primary="List&lt;T&gt; class" data-type="indexterm" id="ch07.html1022"/>The generic <code>List</code> and nongeneric <code>ArrayList</code> classes provide a dynamically sized array of objects and are among the most commonly used of the collection classes. <code>ArrayList</code> implements <code>IList</code>, whereas <code>List&lt;T&gt;</code> implements both <code>IList</code> and <code>IList&lt;T&gt;</code> (and the read-only version, <code>IReadOnlyList&lt;T&gt;</code>). Unlike with arrays, all interfaces are implemented publicly, and methods such as <code>Add</code> and <code>Remove</code> are exposed and work as you would expect.</p>
<p>Internally, <code>List&lt;T&gt;</code> and <code>ArrayList</code> work by maintaining an internal array of objects, replaced with a larger array upon reaching capacity. Appending elements is efficient (because there is usually a free slot at the end), but inserting elements can be slow (because all elements after the insertion point must be shifted to make a free slot), as can removing elements (especially near the start). As with arrays, searching is efficient if the <code>BinarySearch</code> method is used on a list that has been sorted, but it is otherwise inefficient because each item must be individually checked.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>List&lt;T&gt;</code> is up to several times faster than <code>ArrayList</code> if <code>T</code> is a value type, because <code>List&lt;T&gt;</code> avoids the overhead of boxing and unboxing elements.</p>
</div>
<p><code>List&lt;T&gt;</code> and <code>ArrayList</code> provide constructors that accept an existing collection of elements: these copy each element from the existing collection into the new <code>List&lt;T&gt;</code> or <code>ArrayList</code>:</p>
<pre data-type="programlisting">public class List&lt;T&gt; : IList&lt;T&gt;, IReadOnlyList&lt;T&gt;
{
  public List ();
  public List (IEnumerable&lt;T&gt; collection);
  public List (int capacity);

  // Add+Insert
  public void Add         (T item);
  public void AddRange    (IEnumerable&lt;T&gt; collection);
  public void Insert      (int index, T item);
  public void InsertRange (int index, IEnumerable&lt;T&gt; collection);

  // Remove
  public bool Remove      (T item);
  public void RemoveAt    (int index);
  public void RemoveRange (int index, int count);
  public int  RemoveAll   (Predicate&lt;T&gt; match);

  // Indexing
  public T this [int index] { get; set; }
  public List&lt;T&gt; GetRange (int index, int count);
  public Enumerator&lt;T&gt; GetEnumerator();

  // Exporting, copying and converting:
  public T[] ToArray();
  public void CopyTo (T[] array);
  public void CopyTo (T[] array, int arrayIndex);
  public void CopyTo (int index, T[] array, int arrayIndex, int count);
  public ReadOnlyCollection&lt;T&gt; AsReadOnly();
  public List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter &lt;T,TOutput&gt;
                                            converter);
  // Other:
  public void Reverse();            // Reverses order of elements in list.
  public int Capacity { get;set; }  // Forces expansion of internal array.
  public void TrimExcess();         // Trims internal array back to size.
  public void Clear();              // Removes all elements, so Count=0.
}

public delegate TOutput Converter &lt;TInput, TOutput&gt; (TInput input);</pre>
<p>In addition to these members, <code>List&lt;T&gt;</code> provides instance versions of all of <code>Array</code>’s searching and sorting methods.</p>
<p>The following code demonstrates <code>List</code>’s properties and methods (for examples on searching and sorting, see <a data-type="xref" href="#the_array_class">“The Array Class”</a>):</p>
<pre data-type="programlisting">var words = new List&lt;string&gt;();    // New string-typed list

words.Add ("melon");
words.Add ("avocado");
words.AddRange (["banana", "plum"]);
words.Insert (0, "lemon");                   // Insert at start
words.InsertRange (0, ["peach", "nashi"]);   // Insert at start

words.Remove ("melon");
words.RemoveAt (3);                         // Remove the 4th element
words.RemoveRange (0, 2);                   // Remove first 2 elements

// Remove all strings starting in 'n':
words.RemoveAll (s =&gt; s.StartsWith ("n"));

Console.WriteLine (words [0]);                          // first word
Console.WriteLine (words [words.Count - 1]);            // last word
foreach (string s in words) Console.WriteLine (s);      // all words
List&lt;string&gt; subset = words.GetRange (1, 2);            // 2nd-&gt;3rd words

string[] wordsArray = words.ToArray();    // Creates a new typed array

// Copy first two elements to the end of an existing array:
string[] existing = new string [1000];
words.CopyTo (0, existing, 998, 2);

List&lt;string&gt; upperCaseWords = words.ConvertAll (s =&gt; s.ToUpper());
List&lt;int&gt; lengths = words.ConvertAll (s =&gt; s.Length);</pre>
<p>The nongeneric <code>ArrayList</code> class requires clumsy casts—as the following example demonstrates:</p>
<pre data-type="programlisting">ArrayList al = new ArrayList();
al.Add ("hello");
string first = <strong>(string)</strong> al [0];
string[] strArr = <strong>(string[])</strong> al.ToArray (typeof (string));</pre>
<p>Such casts cannot be verified by the compiler; the following compiles successfully but then fails at runtime:</p>
<pre data-type="programlisting">int first = <strong>(int)</strong> al [0];    // Runtime exception</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An <code>ArrayList</code> is functionally similar to <code>List&lt;object&gt;</code>. Both are useful when you need a list of mixed-type elements that share no common base type (other than <code>object</code>). A possible advantage of choosing an <code>ArrayList</code>, in this case, would be if you need to deal with the list using reflection (<a data-type="xref" href="ch19.html#dynamic_programming">Chapter 19</a>). Reflection is easier with a nongeneric <code>ArrayList</code> than a <code>List&lt;object&gt;</code>.</p>
</div>
<p>If you import the <code>System.Linq</code> namespace, you can convert an <code>ArrayList</code> to a generic <code>List</code> by calling <code>Cast</code> and then <code>ToList</code>:</p>
<pre data-type="programlisting">ArrayList al = new ArrayList();
al.AddRange (new[] { 1, 5, 9 } );
List&lt;int&gt; list = al.Cast&lt;int&gt;().ToList();</pre>
<p><code>Cast</code> and <code>ToList</code> are extension methods in the <code>System.Linq.Enumerable</code> class.<a contenteditable="false" data-primary="" data-startref="ch07.html1022" data-type="indexterm" id="id3040"/><a contenteditable="false" data-primary="" data-startref="ch07.html1021" data-type="indexterm" id="id3041"/><a contenteditable="false" data-primary="" data-startref="ch07.html1020" data-type="indexterm" id="id3042"/></p>
</div></section>
<section data-pdf-bookmark="LinkedList&lt;T&gt;" data-type="sect2"><div class="sect2" id="linkedlistless_thantgreater-id00024">
<h2>LinkedList&lt;T&gt;</h2>
<p><a contenteditable="false" data-primary="LinkedList&lt;T&gt;" data-type="indexterm" id="id3043"/><a contenteditable="false" data-primary="list-like collections" data-secondary="LinkedList&lt;T&gt;" data-type="indexterm" id="id3044"/><code>LinkedList&lt;T&gt;</code> is a generic doubly linked list (see <a data-type="xref" href="#linkedlistless_thantgreater-id00075">Figure 7-4</a>). A doubly linked list is a chain of nodes in which each references the node before, the node after, and the actual element. Its main benefit is that an element can always be inserted efficiently anywhere in the list because it just involves creating a new node and updating a few references. However, finding where to insert the node in the first place can be slow because there’s no intrinsic mechanism to index directly into a linked list; each node must be traversed, and binary-chop searches are not possible.</p>
<figure><div class="figure" id="linkedlistless_thantgreater-id00075">
<img alt="LinkedList&lt;T&gt;" src="assets/cn10_0704.png"/>
<h6><span class="label">Figure 7-4. </span>LinkedList&lt;T&gt;</h6>
</div></figure>
<p><code>LinkedList&lt;T&gt;</code> implements <code>IEnumerable&lt;T&gt;</code> and <code>ICollection&lt;T&gt;</code> (and their nongeneric versions), but not <code>IList&lt;T&gt;</code> because access by index is not supported. List nodes are implemented via the following class:</p>
<pre data-type="programlisting">public sealed class LinkedListNode&lt;T&gt;
{
  public LinkedList&lt;T&gt; List { get; }
  public LinkedListNode&lt;T&gt; Next { get; }
  public LinkedListNode&lt;T&gt; Previous { get; }
  public T Value { get; set; }
}</pre>
<p>When adding a node, you can specify its position either relative to another node or at the start/end of the list. <code>LinkedList&lt;T&gt;</code> provides the following methods for this:</p>
<pre data-type="programlisting">public void AddFirst(LinkedListNode&lt;T&gt; node);
public LinkedListNode&lt;T&gt; AddFirst (T value);

public void AddLast (LinkedListNode&lt;T&gt; node);
public LinkedListNode&lt;T&gt; AddLast (T value);

public void AddAfter (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);
public LinkedListNode&lt;T&gt; AddAfter (LinkedListNode&lt;T&gt; node, T value);

public void AddBefore (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);
public LinkedListNode&lt;T&gt; AddBefore (LinkedListNode&lt;T&gt; node, T value);</pre>
<p>Similar methods are provided to remove elements:</p>
<pre data-type="programlisting">public void Clear();

public void RemoveFirst();
public void RemoveLast();

public bool Remove (T value);
public void Remove (LinkedListNode&lt;T&gt; node);</pre>
<p><code>LinkedList&lt;T&gt;</code> has internal fields to keep track of the number of elements in the list as well as the head and tail of the list. These are exposed in the following public properties:</p>
<pre data-type="programlisting">public int Count { get; }                      // Fast
public LinkedListNode&lt;T&gt; First { get; }        // Fast
public LinkedListNode&lt;T&gt; Last { get; }         // Fast</pre>
<p><code>LinkedList&lt;T&gt;</code> also supports the following searching methods (each requiring that the list be internally enumerated):</p>
<pre data-type="programlisting">public bool Contains (T value);
public LinkedListNode&lt;T&gt; Find (T value);
public LinkedListNode&lt;T&gt; FindLast (T value);</pre>
<p class="pagebreak-before">Finally, <code>LinkedList&lt;T&gt;</code> supports copying to an array for indexed processing and obtaining an enumerator to support the <code>foreach</code> statement:</p>
<pre data-type="programlisting">public void CopyTo (T[] array, int index);
public Enumerator&lt;T&gt; GetEnumerator();</pre>
<p>Here’s a demonstration on the use of <code>LinkedList&lt;string&gt;</code>:</p>
<pre data-type="programlisting">var tune = new LinkedList&lt;string&gt;();
tune.AddFirst ("do");                           // <strong>do</strong>
tune.AddLast ("so");                            // do - <strong>so</strong>

tune.AddAfter (tune.First, "re");               // do - <strong>re</strong>- so
tune.AddAfter (tune.First.Next, "mi");          // do - re - <strong>mi</strong>- so
tune.AddBefore (tune.Last, "fa");               // do - re - mi - <strong>fa</strong>- so

tune.RemoveFirst();                             // re - mi - fa - so
tune.RemoveLast();                              // re - mi - fa

LinkedListNode&lt;string&gt; miNode = tune.Find ("mi");
tune.Remove (miNode);                           // re - fa
tune.AddFirst (miNode);                         // <strong>mi</strong>- re - fa

foreach (string s in tune) Console.WriteLine (s);</pre>
</div></section>
<section data-pdf-bookmark="Queue&lt;T&gt; and Queue" data-type="sect2"><div class="sect2" id="queueless_thantgreater_than_and_queue">
<h2>Queue&lt;T&gt; and Queue</h2>
<p><a contenteditable="false" data-primary="list-like collections" data-secondary="Queue&lt;T&gt; and Queue" data-type="indexterm" id="id3045"/><a contenteditable="false" data-primary="Queue" data-type="indexterm" id="id3046"/><a contenteditable="false" data-primary="Queue&lt;T&gt;" data-type="indexterm" id="id3047"/><code>Queue&lt;T&gt;</code> and <code>Queue</code> are first-in, first-out (FIFO) data structures, providing methods to <code>Enqueue</code> (add an item to the tail of the queue) and <code>Dequeue</code> (retrieve and remove the item at the head of the queue). A <code>Peek</code> method is also provided to return the element at the head of the queue without removing it, and a <code>Count</code> property (useful in checking that elements are present before dequeuing).</p>
<p>Although queues are enumerable, they do not implement <code>IList&lt;T&gt;</code>/<code>IList</code>, because members cannot be accessed directly by index. A <code>ToArray</code> method is provided, however, for copying the elements to an array from which they can be randomly accessed:</p>
<pre data-type="programlisting">public class Queue&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable
{
  public Queue();
  public Queue (IEnumerable&lt;T&gt; collection);   // Copies existing elements
  public Queue (int capacity);                // To lessen auto-resizing
  public void Clear();
  public bool Contains (T item);
  public void CopyTo (T[] array, int arrayIndex);
  public int Count { get; }
  public T Dequeue();
  public void Enqueue (T item);
  public Enumerator&lt;T&gt; GetEnumerator();       // To support foreach
  public T Peek();
  public T[] ToArray();
  public void TrimExcess();
}</pre>
<p>The following is an example of using <code>Queue&lt;int&gt;</code>:</p>
<pre data-type="programlisting">var q = new Queue&lt;int&gt;();
q.Enqueue (10);
q.Enqueue (20);
int[] data = q.ToArray();         // Exports to an array
Console.WriteLine (q.Count);      // "2"
Console.WriteLine (q.Peek());     // "10"
Console.WriteLine (q.Dequeue());  // "10"
Console.WriteLine (q.Dequeue());  // "20"
Console.WriteLine (q.Dequeue());  // throws an exception (queue empty)</pre>
<p>Queues are implemented internally using an array that’s resized as required—much like the generic <code>List</code> class. The queue maintains indexes that point directly to the head and tail elements; therefore, enqueuing and dequeuing are extremely quick operations (except when an internal resize is required).</p>
</div></section>
<section data-pdf-bookmark="Stack&lt;T&gt; and Stack" data-type="sect2"><div class="sect2" id="stackless_thantgreater_than_and_stack">
<h2>Stack&lt;T&gt; and Stack</h2>
<p><a contenteditable="false" data-primary="Last-In First-Out (LIFO)" data-type="indexterm" id="id3048"/><a contenteditable="false" data-primary="LIFO (Last-In First-Out)" data-type="indexterm" id="id3049"/><a contenteditable="false" data-primary="list-like collections" data-secondary="Stack&lt;T&gt; and Stack" data-type="indexterm" id="id3050"/><a contenteditable="false" data-primary="Stack (data structure)" data-type="indexterm" id="id3051"/><a contenteditable="false" data-primary="Stack&lt;T&gt;" data-type="indexterm" id="id3052"/><code>Stack&lt;T&gt;</code> and <code>Stack</code> are last-in, first-out (LIFO) data structures, providing methods to <code>Push</code> (add an item to the top of the stack) and <code>Pop</code> (retrieve and remove an element from the top of the stack). A nondestructive <code>Peek</code> method is also provided, as is a <code>Count</code> property and a <code>ToArray</code> method for exporting the data for random access:</p>
<pre data-type="programlisting">public class Stack&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable
{
  public Stack();
  public Stack (IEnumerable&lt;T&gt; collection);   // Copies existing elements
  public Stack (int capacity);                // Lessens auto-resizing
  public void Clear();
  public bool Contains (T item);
  public void CopyTo (T[] array, int arrayIndex);
  public int Count { get; }
  public Enumerator&lt;T&gt; GetEnumerator();       // To support foreach
  public T Peek();
  public T Pop();
  public void Push (T item);
  public T[] ToArray();
  public void TrimExcess();
}</pre>
<p>The following example demonstrates <code>Stack&lt;int&gt;</code>:</p>
<pre data-type="programlisting">var s = new Stack&lt;int&gt;();
s.Push (1);                      //            Stack = 1
s.Push (2);                      //            Stack = 1,2
s.Push (3);                      //            Stack = 1,2,3
Console.WriteLine (s.Count);     // Prints 3
Console.WriteLine (s.Peek());    // Prints 3,  Stack = 1,2,3
Console.WriteLine (s.Pop());     // Prints 3,  Stack = 1,2
Console.WriteLine (s.Pop());     // Prints 2,  Stack = 1
Console.WriteLine (s.Pop());     // Prints 1,  Stack = &lt;empty&gt;
Console.WriteLine (s.Pop());     // throws exception</pre>
<p>Stacks are implemented internally with an array that’s resized as required, as with <code>Queue&lt;T&gt;</code> and <code>List&lt;T&gt;</code>.</p>
</div></section>
<section data-pdf-bookmark="BitArray" data-type="sect2"><div class="sect2" id="bitarray">
<h2>BitArray</h2>
<p><a contenteditable="false" data-primary="BitArray class" data-type="indexterm" id="id3053"/><a contenteditable="false" data-primary="list-like collections" data-secondary="BitArray" data-type="indexterm" id="id3054"/>A <code>BitArray</code> is a dynamically sized collection of compacted <code>bool</code> values. It is more memory efficient than both a simple array of <code>bool</code> and a generic <code>List</code> of <code>bool</code> because it uses only one bit for each value, whereas the <code>bool</code> type otherwise occupies one byte for each value.</p>
<p><code>BitArray</code>’s indexer reads and writes individual bits:</p>
<pre data-type="programlisting">var bits = new BitArray(2);
bits[1] = true;</pre>
<p>There are four bitwise operator methods (<code>And</code>, <code>Or</code>, <code>Xor</code>, and <code>Not</code>). All but the last accept another <code>BitArray</code>:</p>
<pre data-type="programlisting">bits.Xor (bits);               // Bitwise exclusive-OR bits with itself
Console.WriteLine (bits[1]);   // False</pre>
</div></section>
<section data-pdf-bookmark="HashSet&lt;T&gt; and SortedSet&lt;T&gt;" data-type="sect2"><div class="sect2" id="hashsetless_thantgreater_than_and_sorte">
<h2>HashSet&lt;T&gt; and SortedSet&lt;T&gt;</h2>
<p><a contenteditable="false" data-primary="HashSet&lt;T&gt;" data-type="indexterm" id="id3055"/><a contenteditable="false" data-primary="list-like collections" data-secondary="HashSet&lt;T&gt; and SortedSet&lt;T&gt;" data-type="indexterm" id="id3056"/><a contenteditable="false" data-primary="SortedSet&lt;T&gt;" data-type="indexterm" id="id3057"/><code>HashSet&lt;T&gt;</code> and <code>SortedSet&lt;T&gt;</code> have the following distinguishing features:</p>
<ul>
<li><p>Their <code>Contains</code> methods execute quickly using a hash-based lookup.</p></li>
<li><p>They do not store duplicate elements and silently ignore requests to add duplicates.</p></li>
<li><p>You cannot access an element by position.</p></li>
</ul>
<p><code>SortedSet&lt;T&gt;</code> keeps elements in order, whereas <code>HashSet&lt;T&gt;</code> does not.</p>
<p>The commonality of the <code>HashSet&lt;T&gt;</code> and <code>SortedSet&lt;T&gt;</code> types is captured by the interface <code>ISet&lt;T&gt;</code>. From .NET 5, these classes also implement an interface called <code>IReadOnlySet&lt;T&gt;</code>, which is also implemented by the immutable set types (see <a data-type="xref" href="#immutable_collections">“Immutable Collections”</a>).</p>
<p><code>HashSet&lt;T&gt;</code> is implemented with a hashtable that stores just keys; <code>SortedSet&lt;T&gt;</code> is implemented with a red/black tree.</p>
<p>Both collections implement <code>ICollection&lt;T&gt;</code> and offer methods that you would expect, such as <code>Contains</code>, <code>Add</code>, and <code>Remove</code>. In addition, there’s a predicate-based removal method called <code>RemoveWhere</code>.</p>
<p class="pagebreak-before">The following constructs a <code>HashSet&lt;char&gt;</code> from an existing collection, tests for membership, and then enumerates the collection (notice the absence of duplicates):</p>
<pre data-type="programlisting">var letters = new HashSet&lt;char&gt; ("the quick brown fox");

Console.WriteLine (letters.Contains ('t'));      // true
Console.WriteLine (letters.Contains ('j'));      // false

foreach (char c in letters) Console.Write (c);   // the quickbrownfx</pre>
<p>(The reason we can pass a <code>string</code> into <code>HashSet&lt;char&gt;</code>’s constructor is because <code>string</code> implements <code>IEnumerable&lt;char&gt;</code>.)</p>
<p>The really interesting methods are the set operations. The following set operations are <em>destructive</em> in that they modify the set:</p>
<pre data-type="programlisting">public void UnionWith           (IEnumerable&lt;T&gt; other);   // Adds
public void IntersectWith       (IEnumerable&lt;T&gt; other);   // Removes
public void ExceptWith          (IEnumerable&lt;T&gt; other);   // Removes
public void SymmetricExceptWith (IEnumerable&lt;T&gt; other);   // Removes</pre>
<p>whereas the following methods simply query the set and so are nondestructive:</p>
<pre data-type="programlisting">public bool IsSubsetOf         (IEnumerable&lt;T&gt; other);
public bool IsProperSubsetOf   (IEnumerable&lt;T&gt; other);
public bool IsSupersetOf       (IEnumerable&lt;T&gt; other);
public bool IsProperSupersetOf (IEnumerable&lt;T&gt; other);
public bool Overlaps           (IEnumerable&lt;T&gt; other);
public bool SetEquals          (IEnumerable&lt;T&gt; other);</pre>
<p><code>UnionWith</code> adds all the elements in the second set to the original set (excluding duplicates). <code>IntersectWith</code> removes the elements that are not in both sets. We can extract all of the vowels from our set of characters as follows:</p>
<pre data-type="programlisting">var letters = new HashSet&lt;char&gt; ("the quick brown fox");
letters.IntersectWith ("aeiou");
foreach (char c in letters) Console.Write (c);     // euio</pre>
<p><code>ExceptWith</code> removes the specified elements from the source set. Here, we strip all vowels from the set:</p>
<pre data-type="programlisting">var letters = new HashSet&lt;char&gt; ("the quick brown fox");
letters.ExceptWith ("aeiou");
foreach (char c in letters) Console.Write (c);     // th qckbrwnfx</pre>
<p><code>SymmetricExceptWith</code> removes all but the elements that are unique to one set or the other:</p>
<pre data-type="programlisting">var letters = new HashSet&lt;char&gt; ("the quick brown fox");
letters.SymmetricExceptWith ("the lazy brown fox");
foreach (char c in letters) Console.Write (c);     // quicklazy</pre>
<p>Note that because <code>HashSet&lt;T&gt;</code> and <code>SortedSet&lt;T&gt;</code> implement <code>IEnumerable&lt;T&gt;</code>, you can use another type of set (or collection) as the argument to any of the set operation methods.</p>
<p><code>SortedSet&lt;T&gt;</code> offers all the members of <code>HashSet&lt;T&gt;</code>, plus the following:</p>
<pre data-type="programlisting">public virtual SortedSet&lt;T&gt; GetViewBetween (T lowerValue, T upperValue)
public IEnumerable&lt;T&gt; Reverse()
public T Min { get; }
public T Max { get; }</pre>
<p><code>SortedSet&lt;T&gt;</code> also accepts an optional <code>IComparer&lt;T&gt;</code> in its constructor (rather than an <em>equality comparer</em>).</p>
<p>Here’s an example of loading the same letters into a <code>SortedSet&lt;char&gt;</code>:</p>
<pre data-type="programlisting">var letters = new SortedSet&lt;char&gt; ("the quick brown fox");
foreach (char c in letters) Console.Write (c);   //  bcefhiknoqrtuwx</pre>
<p>Following on from this, we can obtain the letters in the set between <em>f</em> and <em>i</em> as follows:<a contenteditable="false" data-primary="" data-startref="ch07.html1019" data-type="indexterm" id="id3058"/><a contenteditable="false" data-primary="" data-startref="ch07.html1018" data-type="indexterm" id="id3059"/></p>
<pre data-type="programlisting">foreach (char c in letters.<strong>GetViewBetween</strong> ('f', 'i'))
  Console.Write (c);                                    //  fhi</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Dictionaries" data-type="sect1"><div class="sect1" id="dictionaries">
<h1>Dictionaries</h1>
<p><a contenteditable="false" data-primary="dictionaries" data-type="indexterm" id="ch07.html1023"/>A dictionary is a collection in which each element is a key/value pair. Dictionaries are most commonly used for lookups and sorted lists.</p>
<p>.NET defines a standard protocol for dictionaries, via the interfaces <code>IDictionary</code> and <code>IDictionary &lt;TKey, TValue&gt;</code>, as well as a set of general-purpose dictionary classes. The classes each differ in the following regard:</p>
<ul>
<li><p>Whether or not items are stored in sorted sequence</p></li>
<li><p>Whether or not items can be accessed by position (index) as well as by key</p></li>
<li><p>Whether it’s generic or nongeneric</p></li>
<li><p>Whether it’s fast or slow to retrieve items by key from a large dictionary</p></li>
</ul>
<p><a data-type="xref" href="#dictionary_classes">Table 7-1</a> summarizes each of the dictionary classes and how they differ in these respects. The performance times are in milliseconds and based on performing 50,000 operations on a dictionary with integer keys and values on a 1.5 GHz PC. (The differences in performance between generic and nongeneric counterparts using the same underlying collection structure are due to boxing, and show up only with value-type elements.)</p>
<table class="border pagebreak-before less_space" id="dictionary_classes">
<caption class="less_space"><span class="label">Table 7-1. </span>Dictionary classes</caption>
<thead>
<tr>
<th>Type</th>
<th>Internal structure</th>
<th>Retrieve by index?</th>
<th>Memory overhead (avg. bytes per item)</th>
<th>Speed: random insertion</th>
<th>Speed: sequential insertion</th>
<th>Speed: retrieval by key</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Unsorted</strong></td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td><span class="keep-together"><code>Dictionary &lt;K,V&gt;</code></span></td>
<td>Hashtable</td>
<td>No</td>
<td>22</td>
<td>30</td>
<td>30</td>
<td>20</td>
</tr>
<tr>
<td><code>Hashtable</code></td>
<td>Hashtable</td>
<td>No</td>
<td>38</td>
<td>50</td>
<td>50</td>
<td>30</td>
</tr>
<tr>
<td><span class="keep-together"><code>ListDictionary</code></span></td>
<td>Linked list</td>
<td>No</td>
<td>36</td>
<td>50,000</td>
<td>50,000</td>
<td>50,000</td>
</tr>
<tr>
<td><code>OrderedDictionary</code></td>
<td>Hashtable + array</td>
<td>Yes</td>
<td>59</td>
<td>70</td>
<td>70</td>
<td>40</td>
</tr>
<tr>
<td><strong>Sorted</strong></td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td><code>SortedDictionary &lt;K,V&gt;</code></td>
<td>Red/black tree</td>
<td>No</td>
<td>20</td>
<td>130</td>
<td>100</td>
<td>120</td>
</tr>
<tr>
<td><code>SortedList &lt;K,V&gt;</code></td>
<td>2xArray</td>
<td>Yes</td>
<td>2</td>
<td>3,300</td>
<td>30</td>
<td>40</td>
</tr>
<tr>
<td><code>SortedList</code></td>
<td>2xArray</td>
<td>Yes</td>
<td>27</td>
<td>4,500</td>
<td>100</td>
<td>180</td>
</tr>
</tbody>
</table>
<p>In Big-O notation, retrieval time by key is as follows:</p>
<ul>
<li><p>O(1) for <code>Hashtable</code>, <code>Dictionary</code>, and <code>OrderedDictionary</code></p></li>
<li><p>O(log <em>n</em>) for <code>SortedDictionary</code> and <code>SortedList</code></p></li>
<li><p>O(<em>n</em>) for <code>ListDictionary</code> (and nondictionary types such as <code>List&lt;T&gt;</code>)</p></li>
</ul>
<p><em>n</em> is the number of elements in the collection.</p>
<section data-pdf-bookmark="IDictionary&lt;TKey,TValue&gt;" data-type="sect2"><div class="sect2" id="idictionaryless_thantkeycommatvaluegrea">
<h2>IDictionary&lt;TKey,TValue&gt;</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="IDictionary&lt;TKey,TValue&gt;" data-type="indexterm" id="id3060"/><a contenteditable="false" data-primary="IDictionary&lt;TKey,TValue&gt;" data-type="indexterm" id="id3061"/><code>IDictionary&lt;TKey,TValue&gt;</code> defines the standard protocol for all key/value-based collections. It extends <code>ICollection&lt;T&gt;</code> by adding methods and properties to access elements based on a key of arbitrary type:</p>
<pre data-type="programlisting">public interface IDictionary &lt;TKey, TValue&gt; :
  ICollection &lt;KeyValuePair &lt;TKey, TValue&gt;&gt;, IEnumerable
{
   bool ContainsKey (TKey key);
   bool TryGetValue (TKey key, out TValue value);
   void Add         (TKey key, TValue value);
   bool Remove      (TKey key);

   TValue this [TKey key]      { get; set; }  // Main indexer - by key
   ICollection &lt;TKey&gt; Keys     { get; }       // Returns just keys
   ICollection &lt;TValue&gt; Values { get; }       // Returns just values
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There’s also an interface called <code>IReadOnlyDictionary&lt;TKey,TValue&gt;</code> that defines the read-only subset of dictionary members.</p>
</div>
<p>To add an item to a dictionary, you either call <code>Add</code> or use the index’s set accessor—the latter adds an item to the dictionary if the key is not already present (or updates the item if it is present). Duplicate keys are forbidden in all dictionary implementations, so calling <code>Add</code> twice with the same key throws an exception.</p>
<p>To retrieve an item from a dictionary, use either the indexer or the <code>TryGetValue</code> method. If the key doesn’t exist, the indexer throws an exception, whereas <code>TryGetValue</code> returns <code>false</code>. You can test for membership explicitly by calling <code>Contain⁠s​Key</code>; however, this incurs the cost of two lookups if you then subsequently retrieve the item.</p>
<p>Enumerating directly over an <code>IDictionary&lt;TKey,TValue&gt;</code> returns a sequence of <code>KeyValuePair</code> structs:</p>
<pre data-type="programlisting">public struct KeyValuePair &lt;TKey, TValue&gt;
{
  public TKey Key     { get; }
  public TValue Value { get; }
}</pre>
<p>You can enumerate over just the keys or values via the dictionary’s <code>Keys</code>/<code>Values</code> properties.</p>
<p>We demonstrate the use of this interface with the generic <code>Dictionary</code> class in the following section.</p>
</div></section>
<section data-pdf-bookmark="IDictionary" data-type="sect2"><div class="sect2" id="idictionary">
<h2>IDictionary</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="IDictionary" data-type="indexterm" id="id3062"/><a contenteditable="false" data-primary="IDictionary" data-type="indexterm" id="id3063"/>The nongeneric <code>IDictionary</code> interface is the same in principle as <code>IDictionary&lt;TKey,TValue&gt;</code>, apart from two important functional differences. It’s important to be aware of these differences, because <code>IDictionary</code> appears in legacy code (including the .NET BCL itself in places):</p>
<ul>
<li><p>Retrieving a nonexistent key via the indexer returns null (rather than throwing an exception).</p></li>
<li><p><code>Contains</code> tests for membership rather than <code>ContainsKey</code>.</p></li>
</ul>
<p>Enumerating over a nongeneric <code>IDictionary</code> returns a sequence of <code>Dictionary​En⁠try</code> structs:</p>
<pre data-type="programlisting">public struct DictionaryEntry
{
  public object Key   { get; set; }
  public object Value { get; set; }
}</pre>
</div></section>
<section data-pdf-bookmark="Dictionary&lt;TKey,TValue&gt; and Hashtable" data-type="sect2"><div class="sect2" id="dictionaryless_thantkeycommatvaluegreat">
<h2>Dictionary&lt;TKey,TValue&gt; and Hashtable</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="Dictionary&lt;TKey,TValue&gt; and Hashtable" data-type="indexterm" id="ch07.html1024"/><a contenteditable="false" data-primary="Dictionary&lt;TKey,TValue&gt;" data-type="indexterm" id="ch07.html1025"/><a contenteditable="false" data-primary="Hashtable class" data-type="indexterm" id="ch07.html1026"/>The generic <code>Dictionary</code> class is one of the most commonly used collections (along with the <code>List&lt;T&gt;</code> collection). It uses a hashtable data structure to store keys and values, and it is fast and efficient.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The nongeneric version of <code>Dictionary&lt;TKey,TValue&gt;</code> is called <code>Hashtable</code>; there is no nongeneric class called <code>Dictionary</code>. When we refer simply to <code>Dictionary</code>, we mean the generic <code>Dictionary&lt;TKey,TValue&gt;</code> class.</p>
</div>
<p><code>Dictionary</code> implements both the generic and nongeneric <code>IDictionary</code> interfaces, the generic <code>IDictionary</code> being exposed publicly. <code>Dictionary</code> is, in fact, a “textbook” implementation of the generic <code>IDictionary</code>.</p>
<p>Here’s how to use it:</p>
<pre data-type="programlisting">var d = new Dictionary&lt;string, int&gt;();

d.Add("One", 1);
d["Two"] = 2;     // adds to dictionary because "two" isn't already present
d["Two"] = 22;    // updates dictionary because "two" is now present
d["Three"] = 3;

Console.WriteLine (d["Two"]);                // Prints "22"
Console.WriteLine (d.ContainsKey ("One"));   // true (fast operation)
Console.WriteLine (d.ContainsValue (3));     // true (slow operation)
int val = 0;
if (!d.TryGetValue ("onE", out val))
  Console.WriteLine ("No val");              // "No val" (case sensitive)

// Three different ways to enumerate the dictionary:

foreach (KeyValuePair&lt;string, int&gt; kv in d)          //  One; 1
  Console.WriteLine (kv.Key + "; " + kv.Value);      //  Two; 22
                                                     //  Three; 3

foreach (string s in d.Keys) Console.Write (s);      // OneTwoThree
Console.WriteLine();
foreach (int i in d.Values) Console.Write (i);       // 1223</pre>
<p>Its underlying hashtable works by converting each element’s key into an integer hashcode—a pseudo-unique value—and then applying an algorithm to convert the hashcode into a hash key. This hash key is used internally to determine which “bucket” an entry belongs to. If the bucket contains more than one value, a linear search is performed on the bucket. A good hash function does not strive to return strictly unique hashcodes (which would usually be impossible); it strives to return hashcodes that are evenly distributed across the 32-bit integer space. This avoids the scenario of ending up with a few very large (and inefficient) buckets.</p>
<p>A dictionary can work with keys of any type, providing it’s able to determine equality between keys and obtain hashcodes. By default, equality is determined via the key’s <code>object.Equals</code> method, and the pseudo-unique hashcode is obtained via the key’s <code>GetHashCode</code> method. You can change this behavior either by overriding these methods or by providing an <code>IEqualityComparer</code> object when constructing the dictionary. A common application of this is to specify a case-insensitive equality comparer when using string keys:</p>
<pre data-type="programlisting">var d = new Dictionary&lt;string, int&gt; (StringComparer.OrdinalIgnoreCase);</pre>
<p>We discuss this further in <a data-type="xref" href="#plugging_in_equality_and_order">“Plugging in Equality and Order”</a>.</p>
<p>As with many other types of collections, you can improve the performance of a dictionary slightly by specifying the collection’s expected size in the constructor, avoiding or lessening the need for internal resizing operations.</p>
<p>The nongeneric version is named <code>Hashtable</code> and is functionally similar apart from differences stemming from it exposing the nongeneric <code>IDictionary</code> interface discussed previously.</p>
<p>The downside to <code>Dictionary</code> and <code>Hashtable</code> is that the items are not sorted. Furthermore, the original order in which the items were added is not retained. As with all dictionaries, duplicate keys are not allowed.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When the generic collections were introduced back in 2005, the CLR team chose to name them according to what they represent (<code>Dictionary</code>, <code>List</code>) rather than how they are internally implemented (<code>Hashtable</code>, <code>ArrayList</code>). Although this is good because it gives them the freedom to later change the implementation, it also means that the <em>performance contract</em> (often the most important criteria in choosing one kind of collection over another) is no longer captured in the name.<a contenteditable="false" data-primary="" data-startref="ch07.html1026" data-type="indexterm" id="id3064"/><a contenteditable="false" data-primary="" data-startref="ch07.html1025" data-type="indexterm" id="id3065"/><a contenteditable="false" data-primary="" data-startref="ch07.html1024" data-type="indexterm" id="id3066"/></p>
</div>
</div></section>
<section data-pdf-bookmark="OrderedDictionary" data-type="sect2"><div class="sect2" id="ordereddictionary">
<h2>OrderedDictionary</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="OrderedDictionary" data-type="indexterm" id="id3067"/><a contenteditable="false" data-primary="OrderedDictionary" data-type="indexterm" id="id3068"/>An <code>OrderedDictionary</code> is a nongeneric dictionary that maintains elements in the same order that they were added. With an <code>OrderedDictionary</code>, you can access elements both by index and by key.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An <code>OrderedDictionary</code> is not a <em>sorted</em> dictionary.</p>
</div>
<p>An <code>OrderedDictionary</code> is a combination of a <code>Hashtable</code> and an <code>ArrayList</code>. This means that it has all the functionality of a <code>Hashtable</code>, plus functions such as <code>RemoveAt</code>, and an integer indexer. It also exposes <code>Keys</code> and <code>Values</code> properties that return elements in their original order.</p>
<p>This class was introduced in .NET 2.0; yet, peculiarly, there’s no generic version.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="ListDictionary and HybridDictionary" data-type="sect2"><div class="sect2" id="listdictionary_and_hybriddictionary">
<h2 class="less_space">ListDictionary and HybridDictionary</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="ListDictionary and HybridDictionary" data-type="indexterm" id="id3069"/><a contenteditable="false" data-primary="HybridDictionary" data-type="indexterm" id="id3070"/><a contenteditable="false" data-primary="ListDictionary" data-type="indexterm" id="id3071"/><code>ListDictionary</code> uses a singly linked list to store the underlying data. It doesn’t provide sorting, although it does preserve the original entry order of the items. <code>ListDictionary</code> is extremely slow with large lists. Its only real “claim to fame” is its efficiency with very small lists (fewer than 10 items).</p>
<p><code>HybridDictionary</code> is a <code>ListDictionary</code> that automatically converts to a <code>Hashtable</code> upon reaching a certain size, to address <code>ListDictionary</code>’s problems with performance. The idea is to get a low memory footprint when the dictionary is small, and good performance when the dictionary is large. However, given the overhead in converting from one to the other—and the fact that a <code>Dictionary</code> is not excessively heavy or slow in either scenario—you wouldn’t suffer unreasonably by using a <code>Dictionary</code> to begin with.</p>
<p>Both classes come only in nongeneric form.</p>
</div></section>
<section data-pdf-bookmark="Sorted Dictionaries" data-type="sect2"><div class="sect2" id="sorted_dictionaries">
<h2>Sorted Dictionaries</h2>
<p><a contenteditable="false" data-primary="dictionaries" data-secondary="sorted" data-type="indexterm" id="id3072"/>The .NET BCL provides two dictionary classes internally structured such that their content is always sorted by key:</p>
<ul>
<li><p><code>SortedDictionary&lt;TKey,TValue&gt;</code></p></li>
<li><p><a contenteditable="false" data-primary="SortedDictionary&lt;TKey,TValue&gt;" data-type="indexterm" id="id3073"/><code>SortedList&lt;TKey,TValue&gt;</code><sup><a data-type="noteref" href="ch07.html#ch01fn6" id="ch01fn6-marker">1</a></sup></p></li>
</ul>
<p>(In this section, we abbreviate <code>&lt;TKey,TValue&gt;</code> to <code>&lt;,&gt;</code>.)</p>
<p><code>SortedDictionary&lt;,&gt;</code> uses a red/black tree: a data structure designed to perform consistently well in any insertion or retrieval scenario.</p>
<p><code>SortedList&lt;,&gt;</code> is implemented internally with an ordered array pair, providing fast retrieval (via a binary-chop search) but poor insertion performance (because existing values need to be shifted to make room for a new entry).</p>
<p><code>SortedDictionary&lt;,&gt;</code> is much faster than <code>SortedList&lt;,&gt;</code> at inserting elements in a random sequence (particularly with large lists). <code>SortedList&lt;,&gt;</code>, however, has an extra ability: to access items by index as well as by key. With a sorted list, you can go directly to the <em>n</em>th element in the sorting sequence (via the indexer on the <code>Keys</code>/<code>Values</code> properties). To do the same with a <code>SortedDictionary&lt;,&gt;</code>, you must manually enumerate over <em>n</em> items. (Alternatively, you could write a class that combines a sorted dictionary with a list class.)</p>
<p>None of the three collections allows duplicate keys (as is the case with all <span class="keep-together">dictionaries</span>).</p>
<p>The following example uses reflection to load all of the methods defined in <span class="keep-together"><code>System.Object</code></span> into a sorted list keyed by name and then enumerates their keys and values:</p>
<pre data-type="programlisting">// MethodInfo is in the System.Reflection namespace

var sorted = new SortedList &lt;string, MethodInfo&gt;();

foreach (MethodInfo m in typeof (object).GetMethods())
  sorted [m.Name] = m;

foreach (string name in sorted.Keys)
  Console.WriteLine (name);

foreach (MethodInfo m in sorted.Values)
  Console.WriteLine (m.Name + " returns a " + m.ReturnType);</pre>
<p>Here’s the result of the first enumeration:</p>
<pre data-type="programlisting">Equals
GetHashCode
GetType
ReferenceEquals
ToString</pre>
<p>Here’s the result of the second enumeration:</p>
<pre data-type="programlisting">Equals returns a System.Boolean
GetHashCode returns a System.Int32
GetType returns a System.Type
ReferenceEquals returns a System.Boolean
ToString returns a System.String</pre>
<p>Notice that we populated the dictionary through its indexer. If we instead used the <code>Add</code> method, it would throw an exception because the <code>object</code> class upon which we’re reflecting overloads the <code>Equals</code> method, and you can’t add the same key twice to a dictionary. By using the indexer, the later entry overwrites the earlier entry, preventing this error.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can store multiple members of the same key by making each value element a list:</p>
<pre data-type="programlisting">SortedList &lt;string, List&lt;MethodInfo&gt;&gt;</pre>
</div>

<p>Extending our example, the following retrieves the <code>MethodInfo</code> whose key is <code>"GetHashCode"</code>, just as with an ordinary dictionary:</p>
<pre data-type="programlisting">Console.WriteLine (sorted ["GetHashCode"]);      // Int32 GetHashCode()</pre>
<p>So far, everything we’ve done would also work with a <code>SortedDictionary&lt;,&gt;</code>. The following two lines, however, which retrieve the last key and value, work only with a sorted list:<a contenteditable="false" data-primary="" data-startref="ch07.html1023" data-type="indexterm" id="id3074"/></p>
<pre data-type="programlisting">Console.WriteLine (sorted.Keys  [sorted.Count - 1]);            // ToString
Console.WriteLine (sorted.Values[sorted.Count - 1].IsVirtual);  // True</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Customizable Collections and Proxies" data-type="sect1"><div class="sect1" id="customizable_collections_and_proxies">
<h1>Customizable Collections and Proxies</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="customizable collections and proxies" data-type="indexterm" id="ch07.html1027"/><a contenteditable="false" data-primary="customizable collections and proxies" data-type="indexterm" id="ch07.html1028"/>The collection classes discussed in previous sections are convenient in that you can directly instantiate them, but they don’t allow you to control what happens when an item is added to or removed from the collection. With strongly typed collections in an application, you sometimes need this control; for instance:</p>
<ul>
<li><p>To fire an event when an item is added or removed</p></li>
<li><p>To update properties because of the added or removed item</p></li>
<li><p>To detect an “illegal” add/remove operation and throw an exception (for example, if the operation violates a business rule)</p></li>
</ul>
<p>The .NET BCL provides collection classes for this exact purpose, in the <code>System​.Col⁠lections.ObjectModel</code> namespace. These are essentially proxies or wrappers that implement <code>IList&lt;T&gt;</code> or <code>IDictionary&lt;,&gt;</code> by forwarding the methods through to an underlying collection. Each <code>Add</code>, <code>Remove</code>, or <code>Clear</code> operation is routed via a virtual method that acts as a “gateway” when overridden.</p>
<p>Customizable collection classes are commonly used for publicly exposed collections; for instance, a collection of controls exposed publicly on a <code>System​.Win⁠dows.Form</code> class.</p>
<section data-pdf-bookmark="Collection&lt;T&gt; and CollectionBase" data-type="sect2"><div class="sect2" id="collectionless_thantgreater_than_and_co">
<h2>Collection&lt;T&gt; and CollectionBase</h2>
<p><a contenteditable="false" data-primary="Collection&lt;T&gt;" data-type="indexterm" id="ch07.html1029"/><a contenteditable="false" data-primary="customizable collections and proxies" data-secondary="Collection&lt;T&gt; and CollectionBase" data-type="indexterm" id="ch07.html1030"/>The <code>Collection&lt;T&gt;</code> class is a customizable wrapper for <code>List&lt;T&gt;</code>.</p>
<p>As well as implementing <code>IList&lt;T&gt;</code> and <code>IList</code>, it defines four additional virtual methods and a protected property as follows:</p>
<pre data-type="programlisting">public class Collection&lt;T&gt; :
  IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable
{
   // ...

   protected virtual void ClearItems();
   protected virtual void InsertItem (int index, T item);
   protected virtual void RemoveItem (int index);
   protected virtual void SetItem (int index, T item);

   protected IList&lt;T&gt; Items { get; }
}</pre>
<p>The virtual methods provide the gateway by which you can “hook in” to change or enhance the list’s normal behavior. The protected <code>Items</code> property allows the implementer to directly access the “inner list”—this is used to make changes internally without the virtual methods firing.</p>
<p>The virtual methods need not be overridden; they can be left alone until there’s a requirement to alter the list’s default behavior. The following example demonstrates the typical “skeleton” use of <code>Collection&lt;T&gt;</code>:</p>
<pre data-type="programlisting">Zoo zoo = new Zoo();
zoo.Animals.Add (new Animal ("Kangaroo", 10));
zoo.Animals.Add (new Animal ("Mr Sea Lion", 20));
foreach (Animal a in zoo.Animals) Console.WriteLine (a.Name);

public class Animal
{
  public string Name;
  public int Popularity;

  public Animal (string name, int popularity)
  {
    Name = name; Popularity = popularity;
  }
}

public class AnimalCollection : Collection &lt;Animal&gt;
{
  // AnimalCollection is already a fully functioning list of animals.
  // No extra code is required.
}

public class Zoo   // The class that will expose AnimalCollection.
{                  // This would typically have additional members.

  public readonly AnimalCollection Animals = new AnimalCollection();
}</pre>
<p>As it stands, <code>AnimalCollection</code> is no more functional than a simple <code>List&lt;Animal&gt;</code>; its role is to provide a base for future extension. To illustrate, let’s now add a <code>Zoo</code> property to <code>Animal</code> so that it can reference the <code>Zoo</code> in which it lives and override each of the virtual methods in <code>Collection&lt;Animal&gt;</code> to maintain that property automatically:</p>
<pre data-type="programlisting">public class Animal
{
  public string Name;
  public int Popularity;
  public Zoo Zoo { get; internal set; }
  public Animal(string name, int popularity)
  {
    Name = name; Popularity = popularity;
  }
}

public class AnimalCollection : Collection &lt;Animal&gt;
{
  Zoo zoo;
  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }

  protected override void InsertItem (int index, Animal item)
  {
    base.InsertItem (index, item);
    item.Zoo = zoo;
  }
  protected override void SetItem (int index, Animal item)
  {
    base.SetItem (index, item);
    item.Zoo = zoo;
  }
  protected override void RemoveItem (int index)
  {
    this [index].Zoo = null;
    base.RemoveItem (index);
  }
  protected override void ClearItems()
  {
    foreach (Animal a in this) a.Zoo = null;
    base.ClearItems();
  }
}

public class Zoo
{
  public readonly AnimalCollection Animals;
  public Zoo() { Animals = new AnimalCollection (this); }
}</pre>
<p><code>Collection&lt;T&gt;</code> also has a constructor accepting an existing <code>IList&lt;T&gt;</code>. Unlike with other collection classes, the supplied list is <em>proxied</em> rather than <em>copied</em>, meaning that subsequent changes will be reflected in the wrapping <code>Collection&lt;T&gt;</code> (although <em>without</em> <code>Collection&lt;T&gt;</code>’s virtual methods firing). Conversely, changes made via the <code>Collection&lt;T&gt;</code> will change the underlying list.</p>
<section data-pdf-bookmark="CollectionBase" data-type="sect3"><div class="sect3" id="collectionbase">
<h3>CollectionBase</h3>
<p><a contenteditable="false" data-primary="CollectionBase" data-type="indexterm" id="id3075"/><code>CollectionBase</code> is the nongeneric version of <code>Collection&lt;T&gt;</code>. This provides most of the same features as <code>Collection&lt;T&gt;</code> but is clumsier to use. Instead of the template methods <code>InsertItem</code>, <code>RemoveItem</code>, <code>SetItem</code>, and <code>ClearItem</code>, <code>CollectionBase</code> has “hook” methods that double the number of methods required: <code>OnInsert</code>, <span class="keep-together"><code>OnInsertComplete</code></span>, <code>OnSet</code>, <code>OnSetComplete</code>, <code>OnRemove</code>, <code>OnRemoveComplete</code>, <code>OnClear</code>, and <code>OnClearComplete</code>. Because <code>CollectionBase</code> is nongeneric, you must also implement typed methods when subclassing it—at a minimum, a typed indexer and <code>Add</code> method.<a contenteditable="false" data-primary="" data-startref="ch07.html1030" data-type="indexterm" id="id3076"/><a contenteditable="false" data-primary="" data-startref="ch07.html1029" data-type="indexterm" id="id3077"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="KeyedCollection&lt;TKey,TItem&gt; and DictionaryBase" data-type="sect2"><div class="sect2" id="keyedcollectionless_thantkeycommatitemg">
<h2>KeyedCollection&lt;TKey,TItem&gt; and DictionaryBase</h2>
<p><a contenteditable="false" data-primary="customizable collections and proxies" data-secondary="KeyedCollection&lt;TKey,TItem&gt; and DictionaryBase" data-type="indexterm" id="ch07.html1031"/><code>KeyedCollection&lt;TKey,TItem&gt;</code> subclasses <code>Collection&lt;TItem&gt;</code>. It both adds and subtracts functionality. What it adds is the ability to access items by key, much like with a dictionary. What it subtracts is the ability to proxy your own inner list.</p>
<p>A keyed collection has some resemblance to an <code>OrderedDictionary</code> in that it combines a linear list with a hashtable. However, unlike <code>OrderedDictionary</code>, it doesn’t implement <code>IDictionary</code> and doesn’t support the concept of a key/value <em>pair</em>. Keys are obtained instead from the items themselves: via the abstract <code>GetKeyForItem</code> method. This means enumerating a keyed collection is just like enumerating an ordinary list.</p>
<p>You can best think of <code>KeyedCollection&lt;TKey,TItem&gt;</code> as <code>Collection&lt;TItem&gt;</code> plus fast lookup by key.</p>
<p>Because it subclasses <code>Collection&lt;&gt;</code>, a keyed collection inherits all of <code>Collection&lt;&gt;</code>’s functionality, except for the ability to specify an existing list in construction. The additional members it defines are as follows:</p>
<pre data-type="programlisting">public abstract class KeyedCollection &lt;TKey, TItem&gt; : Collection &lt;TItem&gt;

  // ...

  protected abstract TKey GetKeyForItem(TItem item);
  protected void ChangeItemKey(TItem item, TKey newKey);

  // Fast lookup by key - this is in addition to lookup by index.
  public TItem this[TKey key] { get; }

  protected IDictionary&lt;TKey, TItem&gt; Dictionary { get; }
}</pre>
<p><code>GetKeyForItem</code> is what the implementer overrides to obtain an item’s key from the underlying object. The <code>ChangeItemKey</code> method must be called if the item’s key property changes, in order to update the internal dictionary. The <code>Dictionary</code> property returns the internal dictionary used to implement the lookup, which is created when the first item is added. This behavior can be changed by specifying a creation threshold in the constructor, delaying the internal dictionary from being created until the threshold is reached (in the interim, a linear search is performed if an item is requested by key). A good reason not to specify a creation threshold is that having a valid dictionary can be useful in obtaining an <code>ICollection&lt;&gt;</code> of keys, via the <code>Dictionary</code>’s <code>Keys</code> property. This collection can then be passed on to a public property.</p>
<p>The most common use for <code>KeyedCollection&lt;,&gt;</code> is in providing a collection of items accessible both by index and by name. To demonstrate this, let’s revisit the zoo, this time implementing <code>AnimalCollection</code> as a <code>KeyedCollection&lt;string,​Ani⁠mal&gt;</code>:</p>
<pre data-type="programlisting">public class Animal
{
  string name;
  public string Name
  {
    get { return name; }
    set {
      if (Zoo != null) Zoo.Animals.NotifyNameChange (this, value);
      name = value;
    }
  }
  public int Popularity;
  public Zoo Zoo { get; internal set; }

  public Animal (string name, int popularity)
  {
    Name = name; Popularity = popularity;
  }
}

public class AnimalCollection : KeyedCollection &lt;string, Animal&gt;
{
  Zoo zoo;
  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }

  internal void NotifyNameChange (Animal a, string newName) =&gt;
    this.ChangeItemKey (a, newName);

  protected override string GetKeyForItem (Animal item) =&gt; item.Name;

  // The following methods would be implemented as in the previous example
  protected override void InsertItem (int index, Animal item)...
  protected override void SetItem (int index, Animal item)...
  protected override void RemoveItem (int index)...
  protected override void ClearItems()...
}

public class Zoo
{
  public readonly AnimalCollection Animals;
  public Zoo() { Animals = new AnimalCollection (this); }
}</pre>
<p>The following code demonstrates its use:</p>
<pre data-type="programlisting">Zoo zoo = new Zoo();
zoo.Animals.Add (new Animal ("Kangaroo", 10));
zoo.Animals.Add (new Animal ("Mr Sea Lion", 20));
Console.WriteLine (zoo.Animals [0].Popularity);               // 10
Console.WriteLine (zoo.Animals ["Mr Sea Lion"].Popularity);   // 20
zoo.Animals ["Kangaroo"].Name = "Mr Roo";
Console.WriteLine (zoo.Animals ["Mr Roo"].Popularity);        // 10</pre>
<section data-pdf-bookmark="DictionaryBase" data-type="sect3"><div class="sect3" id="dictionarybase">
<h3>DictionaryBase</h3>
<p><a contenteditable="false" data-primary="DictionaryBase" data-type="indexterm" id="id3078"/>The nongeneric version of <code>KeyedCollection</code> is called <code>DictionaryBase</code>. This legacy class takes a very different approach in that it implements <code>IDictionary</code> and uses clumsy hook methods like <code>CollectionBase</code>: <code>OnInsert</code>, <code>OnInsertComplete</code>, <code>OnSet</code>, <code>OnSetComplete</code>, <code>OnRemove</code>, <code>OnRemoveComplete</code>, <code>OnClear</code>, and <code>OnClearComplete</code> (and additionally, <code>OnGet</code>). The primary advantage of implementing <code>IDictionary</code> over taking the <code>KeyedCollection</code> approach is that you don’t need to subclass it in order to obtain keys. But since the very purpose of <code>DictionaryBase</code> is to be subclassed, it’s no advantage at all. The improved model in <code>KeyedCollection</code> is almost certainly due to the fact that it was written some years later, with the benefit of hindsight. <code>DictionaryBase</code> is best considered useful for backward compatibility.<a contenteditable="false" data-primary="" data-startref="ch07.html1031" data-type="indexterm" id="id3079"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="ReadOnlyCollection&lt;T&gt;" data-type="sect2"><div class="sect2" id="readonlycollectionless_thantgreater_tha">
<h2>ReadOnlyCollection&lt;T&gt;</h2>
<p><a contenteditable="false" data-primary="customizable collections and proxies" data-secondary="ReadOnlyCollection&lt;T&gt;" data-type="indexterm" id="id3080"/><a contenteditable="false" data-primary="ReadOnlyCollection&lt;T&gt;" data-type="indexterm" id="id3081"/><code>ReadOnlyCollection&lt;T&gt;</code> is a wrapper, or <em>proxy</em>, that provides a read-only view of a collection. This is useful in allowing a class to publicly expose read-only access to a collection that the class can still update internally.</p>
<p>A read-only collection accepts the input collection in its constructor, to which it maintains a permanent reference. It doesn’t take a static copy of the input collection, so subsequent changes to the input collection are visible through the read-only wrapper.</p>
<p>To illustrate, suppose that your class wants to provide read-only public access to a list of strings called <code>Names</code>. We could do this as follows:</p>
<pre data-type="programlisting">public class Test
{
  List&lt;string&gt; names = new List&lt;string&gt;();
  public <strong>IReadOnlyList</strong>&lt;string&gt; Names =&gt; names;
}</pre>
<p>Although <code>Names</code> returns a read-only interface, the consumer can still downcast at runtime to <code>List&lt;string&gt;</code> or <code>IList&lt;string&gt;</code> and then call <code>Add</code>, <code>Remove</code>, or <code>Clear</code> on the list. <code>ReadOnlyCollection&lt;T&gt;</code> provides a more robust solution:</p>
<pre data-type="programlisting">public class Test
{
  List&lt;string&gt; names = new List&lt;string&gt;();
  public ReadOnlyCollection&lt;string&gt; Names { get; private set; }

  public Test() =&gt; Names = new ReadOnlyCollection&lt;string&gt; (names);

  public void AddInternally() =&gt; names.Add ("test");
}</pre>
<p>Now, only members within the <code>Test</code> class can alter the list of names:<a contenteditable="false" data-primary="" data-startref="ch07.html1028" data-type="indexterm" id="id3082"/><a contenteditable="false" data-primary="" data-startref="ch07.html1027" data-type="indexterm" id="id3083"/></p>
<pre data-type="programlisting">Test t = new Test();

Console.WriteLine (t.Names.Count);       // 0
t.AddInternally();
Console.WriteLine (t.Names.Count);       // 1

t.Names.Add ("test");                    // Compiler error
((IList&lt;string&gt;) t.Names).Add ("test");  // NotSupportedException</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Immutable Collections" data-type="sect1"><div class="sect1" id="immutable_collections">
<h1>Immutable Collections</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="immutable collections" data-type="indexterm" id="ch07.html1032"/><a contenteditable="false" data-primary="immutable collections" data-type="indexterm" id="ch07.html1033"/>We just described how <code>ReadOnlyCollection&lt;T&gt;</code> creates a read-only view of a collection. Restricting the ability to write (<em>mutate</em>) a collection—or any other object—simplifies software and reduces bugs.</p>
<p>The <em>immutable collections</em> extend this principle, by providing collections that cannot be modified at all after initialization. Should you need to add an item to an immutable collection, you must instantiate a new collection, leaving the old one untouched.</p>
<p><a contenteditable="false" data-primary="functional programming" data-type="indexterm" id="id3084"/>Immutability is a hallmark of <em>functional programming</em> and has the following benefits:</p>
<ul>
<li><p>It eliminates a large class of bugs associated with changing state.</p></li>
<li><p>It vastly simplifies parallelism and multithreading, by avoiding most of the thread-safety problems that we describe in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch14.html#concurrency_and_asynchron">14</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch22.html#parallel_programming-id00071">22</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch23.html#spanless_thantgreater_than_and-id00089">23</a>.</p></li>
<li><p>It makes code easier to reason about.</p></li>
</ul>
<p>The disadvantage of immutability is that when you need to make a change, you must create a whole new object. This incurs a performance hit, although there are mitigating strategies that we discuss in this section, including the ability to reuse portions of the original structure.</p>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.Immutable" data-type="indexterm" id="id3085"/>The immutable collections are part of .NET (in .NET Framework, they are available via the <em>System.Collections.Immutable</em> NuGet package). All collections are defined in the <code>System.Collections.Immutable</code> namespace:</p>
<table class="border">
<thead>
<tr>
<th>Type</th>
<th>Internal structure</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ImmutableArray&lt;T&gt;</code></td>
<td>Array</td>
</tr>
<tr>
<td><code>ImmutableList&lt;T&gt;</code></td>
<td>AVL tree</td>
</tr>
<tr>
<td><code>ImmutableDictionary&lt;K,V&gt;</code></td>
<td>AVL tree</td>
</tr>
<tr>
<td><code>ImmutableHashSet&lt;T&gt;</code></td>
<td>AVL tree</td>
</tr>
<tr>
<td><code>ImmutableSortedDictionary&lt;K,V&gt;</code></td>
<td>AVL tree</td>
</tr>
<tr>
<td><code>ImmutableSortedSet&lt;T&gt;</code></td>
<td>AVL tree</td>
</tr>
<tr>
<td><code>ImmutableStack&lt;T&gt;</code></td>
<td>Linked list</td>
</tr>
<tr>
<td><code>ImmutableQueue&lt;T&gt;</code></td>
<td>Linked list</td>
</tr>
</tbody>
</table>
<p>The <code>ImmutableArray&lt;T&gt;</code> and <code>ImmutableList&lt;T&gt;</code> types are both immutable versions of <code>List&lt;T&gt;</code>. Both do the same job but with different performance characteristics that we discuss in <a data-type="xref" href="#immutable_collections_and_performance">“Immutable Collections and Performance”</a>.</p>
<p>The immutable collections expose a public interface similar to their mutable counterparts. The key difference is that the methods that appear to alter the collection (such as <code>Add</code> or <code>Remove</code>) don’t alter the original collection; instead they return a new collection with the requested item added or removed. This is called <em>nondestructive mutation</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Immutable collections prevent the adding and removing of items; they don’t prevent the items <em>themselves</em> from being mutated. To get the full benefits of immutability, you need to ensure that only immutable items end up in an immutable collection.</p>
</div>
<section data-pdf-bookmark="Creating Immutable Collections" data-type="sect2"><div class="sect2" id="creating_immutable_collections">
<h2>Creating Immutable Collections</h2>
<p><a contenteditable="false" data-primary="immutable collections" data-secondary="creating" data-type="indexterm" id="id3086"/>Each immutable collection type offers a <code>Create&lt;T&gt;()</code> method, which accepts optional initial values and returns an initialized immutable collection:</p>
<pre data-type="programlisting">ImmutableArray&lt;int&gt; array = ImmutableArray.Create&lt;int&gt; (1, 2, 3);</pre>
<p>Each collection also offers a <code>CreateRange&lt;T&gt;</code> method, which does the same job as <code>Create&lt;T&gt;</code>; the difference is that its parameter type is <code>IEnumerable&lt;T&gt;</code> instead of <code>params T[]</code>.</p>
<p>You can also create an immutable collection from an existing <code>IEnumerable&lt;T&gt;</code>, using appropriately extension methods (<code>ToImmutableArray</code>, <code>ToImmutableList</code>, <code>ToImmutableDictionary</code>, and so on):</p>
<pre data-type="programlisting">var list = new[] { 1, 2, 3 }.ToImmutableList();</pre>
</div></section>
<section data-pdf-bookmark="Manipulating Immutable Collections" data-type="sect2"><div class="sect2" id="manipulating_immutable_collections">
<h2>Manipulating Immutable Collections</h2>
<p><a contenteditable="false" data-primary="immutable collections" data-secondary="manipulating" data-type="indexterm" id="id3087"/>The <code>Add</code> method returns a new collection containing the existing elements plus the new one:</p>
<pre data-type="programlisting">var oldList = ImmutableList.Create&lt;int&gt; (1, 2, 3);

ImmutableList&lt;int&gt; newList = oldList.Add (4);

Console.WriteLine (oldList.Count);     // 3  (unaltered)
Console.WriteLine (newList.Count);     // 4</pre>
<p>The <code>Remove</code> method operates in the same fashion, returning a new collection with the item removed.</p>
<p>Repeatedly adding or removing elements in this manner is inefficient, because a new immutable collection is created for each add or remove operation. A better solution is to call <code>AddRange</code> (or <code>RemoveRange</code>), which accepts an <code>IEnumerable&lt;T&gt;</code> of items, which are all added or removed in one go:</p>
<pre data-type="programlisting">var anotherList = oldList.AddRange ([4, 5, 6]);</pre>
<p>The immutable list and array also defines <code>Insert</code> and <code>InsertRange</code> methods to insert elements at a particular index, a <code>RemoveAt</code> method to remove at an index, and <code>RemoveAll</code>, which removes based on a predicate.</p>
</div></section>
<section data-pdf-bookmark="Builders" data-type="sect2"><div class="sect2" id="builders">
<h2>Builders</h2>
<p><a contenteditable="false" data-primary="builder class" data-type="indexterm" id="id3088"/><a contenteditable="false" data-primary="immutable collections" data-secondary="builders" data-type="indexterm" id="id3089"/>For more complex initialization needs, each immutable collection class defines a <em>builder</em> counterpart. Builders are classes that are functionally equivalent to a mutable collection, with similar performance characteristics. After the data is initialized, calling <code>.ToImmutable()</code> on a builder returns an immutable collection.</p>
<pre data-type="programlisting">ImmutableArray&lt;int&gt;.Builder builder = ImmutableArray.CreateBuilder&lt;int&gt;();
builder.Add (1);
builder.Add (2);
builder.Add (3);
builder.RemoveAt (0);
ImmutableArray&lt;int&gt; myImmutable = builder.ToImmutable();</pre>
<p>You also can use builders to <em>batch</em> multiple updates to an existing immutable collection:</p>
<pre data-type="programlisting">var builder2 = myImmutable<strong>.ToBuilder()</strong>;
builder2.Add (4);      // Efficient
builder2.Remove (2);   // Efficient
...                    // More changes to builder...
// Return a new immutable collection with all the changes applied:
ImmutableArray&lt;int&gt; myImmutable2 = builder2.ToImmutable();</pre>
</div></section>
<section data-pdf-bookmark="Immutable Collections and Performance" data-type="sect2"><div class="sect2" id="immutable_collections_and_performance">
<h2>Immutable Collections and Performance</h2>
<p><a contenteditable="false" data-primary="AVL tree" data-type="indexterm" id="id3090"/><a contenteditable="false" data-primary="immutable collections" data-secondary="performance" data-type="indexterm" id="id3091"/>Most of the immutable collections use an <em>AVL tree</em> internally, which allows the add/remove operations to reuse portions of the original internal structure rather than having to re-create the entire thing from scratch. This reduces the overhead of add/remove operations from potentially <em>huge</em> (with large collections) to just <em>moderately large</em>, but it comes at the cost of making read operations slower. The end result is that most immutable collections are slower than their mutable counterparts for both reading and writing.</p>
<p><a contenteditable="false" data-primary="ImmutableList&lt;T&gt;" data-type="indexterm" id="id3092"/>The most seriously affected is <code>ImmutableList&lt;T&gt;</code>, which for both read and add operations, is 10 to 200 times slower than <code>List&lt;T&gt;</code> (depending on the size of the list). <a contenteditable="false" data-primary="ImmutableArray&lt;T&gt;" data-type="indexterm" id="id3093"/>This is why <code>ImmutableArray&lt;T&gt;</code> exists: by using an array inside, it avoids the overhead for read operations (for which it’s comparable in performance to an ordinary mutable array). The flipside is that it’s <em>much</em> slower than (even) <code>ImmutableList&lt;T&gt;</code> for add operations because none of the original structure can be reused.</p>
<p>Hence, <code>ImmutableArray&lt;T&gt;</code> is desirable when you want unimpeded <em>read</em>-performance and don’t expect many subsequent calls to <code>Add</code> or <code>Remove</code> (without using a builder).</p>
<table class="border">
<thead>
<tr>
<th>Type</th>
<th>Read performance</th>
<th>Add performance</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ImmutableList&lt;T&gt;</code></td>
<td>Slow</td>
<td>Slow</td>
</tr>
<tr>
<td><code>ImmutableArray&lt;T&gt;</code></td>
<td>Very fast</td>
<td>Very slow</td>
</tr>
</tbody>
</table>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Calling <code>Remove</code> on an <code>ImmutableArray</code> is more expensive than calling <code>Remove</code> on a <code>List&lt;T&gt;</code>—even in the worst-case scenario of removing the first element—because allocating the new collection places additional load on the garbage collector.</p>
</div>
<p>Although the immutable collections as a whole incur a potentially significant performance cost, it’s important to keep the overall magnitude in perspective. An <code>Add</code> operation on an <code>ImmutableList</code> with a million elements is still likely to occur in less than a microsecond on a typical laptop, and a read operation, in less than 100 nanoseconds. And, if you need to perform write-operations in a loop, you can avoid the accumulated cost with a builder.</p>
<p>The following factors also work to mitigate the costs:</p>
<ul>
<li><p>Immutability allows for easy concurrency and parallelization (<a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>), so you can employ all available cores. Parallelizing with mutable state easily leads to errors and requires the use of locks or concurrent collections, both of which hurt performance.</p></li>
<li><p>With immutability, you don’t need to “defensively copy” collections or data structures to guard against unexpected change. This was a factor in favoring the use of immutable collections in writing recent portions of Visual Studio.</p></li>
<li><p>In most typical programs, few collections have enough items for the difference to matter.</p></li>
</ul>
<p>In addition to Visual Studio, the well-performing Microsoft Roslyn toolchain was built with immutable collections, demonstrating how the benefits can outweigh the costs.<a contenteditable="false" data-primary="" data-startref="ch07.html1033" data-type="indexterm" id="id3094"/><a contenteditable="false" data-primary="" data-startref="ch07.html1032" data-type="indexterm" id="id3095"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Frozen Collections" data-type="sect1"><div class="sect1" id="frozen_collections">
<h1>Frozen Collections</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="frozen collections" data-type="indexterm" id="id3096"/><a contenteditable="false" data-primary="frozen collections" data-type="indexterm" id="id3097"/><a contenteditable="false" data-primary="System..." data-secondary="System.Collections.Frozen" data-type="indexterm" id="id3098"/>From .NET 8, the <code>System.Collections.Frozen</code> namespace contains the following two read-only collection classes:</p>
<pre data-type="programlisting">FrozenDictionary&lt;TKey,TValue&gt;
FrozenSet&lt;T&gt;</pre>
<p>These are similar to <code>ImmutableDictionary&lt;K,V&gt;</code> and <code>ImmutableHashSet&lt;T&gt;</code>, but lack methods for nondestructive mutation (such as <code>Add</code> or <code>Remove</code>), allowing for highly optimized read performance. To create a frozen collection, you start with another collection or sequence and then call the <code>ToFrozenDictionary</code> or <code>ToFrozenSet</code> extension method:</p>
<pre data-type="programlisting">int[] numbers = { 10, 20, 30 };
FrozenSet&lt;int&gt; frozen = numbers<strong>.ToFrozenSet()</strong>;
Console.WriteLine (frozen.Contains (10));   // True</pre>
<p>Frozen collections are great for lookups that are initialized at the start of a program and then used throughout the life of the application:</p>
<pre data-type="programlisting">class Disassembler
{
  public readonly static IReadOnlyDictionary&lt;string,string&gt; OpCodeLookup =
    new Dictionary&lt;string, string&gt;()
    {
      { "ADC", "Add with Carry" },
      { "ADD", "Add" },
      { "AND", "Logical AND" },
      { "ANDN", "Logical AND NOT" },
      ...
    }
    <strong>.ToFrozenDictionary()</strong>;

  ...
}</pre>
<p>The frozen collections implement the standard dictionary/set interfaces, including their read-only versions. In this example, we exposed our <code>FrozenDictionary&lt;string,string&gt;</code> as a field of type <code>IReadOnlyDictionary&lt;string,string&gt;</code>.</p>
</div></section>
<section data-pdf-bookmark="Plugging in Equality and Order" data-type="sect1"><div class="sect1" id="plugging_in_equality_and_order">
<h1>Plugging in Equality and Order</h1>
<p><a contenteditable="false" data-primary="collections" data-secondary="plugging in equality and order" data-type="indexterm" id="ch07.html1034"/>In the sections <a data-type="xref" href="ch04.html#equality_comparison-id00016">“Equality Comparison”</a> and <a data-type="xref" href="ch06.html#order_comparison">“Order Comparison”</a>, we described the standard .NET protocols that make a type equatable, hashable, and comparable. A type that implements these protocols can function correctly in a dictionary or sorted list “out of the box.” More specifically:</p>
<ul>
<li><p>A type for which <code>Equals</code> and <code>GetHashCode</code> return meaningful results can be used as a key in a <code>Dictionary</code> or <code>Hashtable</code>.</p></li>
<li><p>A type that implements <code>IComparable</code> /<code>IComparable&lt;T&gt;</code> can be used as a key in any of the <em>sorted</em> dictionaries or lists.</p></li>
</ul>
<p>A type’s default equating or comparison implementation typically reflects what is most “natural” for that type. Sometimes, however, the default behavior is not what you want. You might need a dictionary whose <code>string</code> type key is treated without respect to case. Or you might want a sorted list of customers, sorted by each customer’s postcode. For this reason, .NET also defines a matching set of “plug-in” protocols. The plug-in protocols achieve two things:</p>
<ul>
<li><p>They allow you to switch in alternative equating or comparison behavior.</p></li>
<li><p>They allow you to use a dictionary or sorted collection with a key type that’s not intrinsically equatable or comparable.</p></li>
</ul>
<p>The plug-in protocols consist of the following interfaces:</p>
<dl>
<dt><code>IEqualityComparer</code> and <code>IEqualityComparer&lt;T&gt;</code></dt>
<dd><ul>
<li><p>Performs plug-in <em>equality comparison and hashing</em></p></li>
<li><p>Recognized by <code>Hashtable</code> and <code>Dictionary</code></p></li>
</ul></dd>
<dt><code>IComparer</code> and <code>IComparer&lt;T&gt;</code></dt>
<dd><ul>
<li><p>Performs plug-in <em>order comparison</em></p></li>
<li><p>Recognized by the sorted dictionaries and collections; also, <code>Array.Sort</code></p></li>
</ul></dd>
</dl>
<p>Each interface comes in both generic and nongeneric forms. The <code>IEquality​Com⁠parer</code> interfaces also have a default implementation in a class called <code>Equality​Comparer</code>.</p>
<p>In addition, there are interfaces called <code>IStructuralEquatable</code> and <code>IStructuralComparable</code> which allow for the option of structural comparisons on classes and arrays.</p>
<section data-pdf-bookmark="IEqualityComparer and EqualityComparer" data-type="sect2"><div class="sect2" id="iequalitycomparer_and_equalitycomparer">
<h2>IEqualityComparer and EqualityComparer</h2>
<p><a contenteditable="false" data-primary="collections" data-secondary="IEqualityComparer and EqualityComparer" data-type="indexterm" id="ch07.html1035"/><a contenteditable="false" data-primary="EqualityComparer" data-type="indexterm" id="ch07.html1036"/><a contenteditable="false" data-primary="IEqualityComparer" data-type="indexterm" id="ch07.html1037"/>An equality comparer switches in nondefault equality and hashing behavior, primarily for the <code>Dictionary</code> and <code>Hashtable</code> classes.</p>
<p>Recall the requirements of a hashtable-based dictionary. It needs answers to two questions for any given key:</p>
<ul>
<li><p>Is it the same as another?</p></li>
<li><p>What is its integer hashcode?</p></li>
</ul>
<p>An equality comparer answers these questions by implementing the <code>IEquality​Com⁠parer</code> interfaces:</p>
<pre data-type="programlisting">public interface IEqualityComparer&lt;T&gt;
{
   bool Equals (T x, T y);
   int GetHashCode (T obj);
}

public interface IEqualityComparer     // Nongeneric version
{
   bool Equals (object x, object y);
   int GetHashCode (object obj);
}</pre>
<p>To write a custom comparer, you implement one or both of these interfaces (implementing both gives maximum interoperability). Because this is somewhat tedious, an alternative is to subclass the abstract <code>EqualityComparer</code> class, defined as follows:</p>
<pre data-type="programlisting">public abstract class EqualityComparer&lt;T&gt; : IEqualityComparer,
                                            IEqualityComparer&lt;T&gt;
{
  <strong>public abstract bool Equals (T x, T y);</strong>
  <strong>public abstract int GetHashCode (T obj);</strong>

  bool IEqualityComparer.Equals (object x, object y);
  int IEqualityComparer.GetHashCode (object obj);

  public static EqualityComparer&lt;T&gt; Default { get; }
}</pre>
<p><code>EqualityComparer</code> implements both interfaces; your job is simply to override the two abstract methods.</p>
<p>The semantics for <code>Equals</code> and <code>GetHashCode</code> follow the same rules for <code>object.Equals</code> and <code>object.GetHashCode</code>, described in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>. In the following example, we define a <code>Customer</code> class with two fields and then write an equality comparer that matches both the first and last names:</p>
<pre data-type="programlisting">public class Customer
{
  public string LastName;
  public string FirstName;

  public Customer (string last, string first)
  {
    LastName = last;
    FirstName = first;
  }
}
public class LastFirstEqComparer : EqualityComparer &lt;Customer&gt;
{
  public override bool Equals (Customer x, Customer y)
    =&gt; x.LastName == y.LastName &amp;&amp; x.FirstName == y.FirstName;

  public override int GetHashCode (Customer obj)
    =&gt; (obj.LastName + ";" + obj.FirstName).GetHashCode();
}</pre>
<p>To illustrate how this works, let’s create two customers:</p>
<pre data-type="programlisting">Customer c1 = new Customer ("Bloggs", "Joe");
Customer c2 = new Customer ("Bloggs", "Joe");</pre>
<p>Because we’ve not overridden <code>object.Equals</code>, normal reference type equality semantics apply:</p>
<pre data-type="programlisting">Console.WriteLine (c1 == c2);               // False
Console.WriteLine (c1.Equals (c2));         // False</pre>
<p>The same default equality semantics apply when using these customers in a <code>Dictionary</code> without specifying an equality comparer:</p>
<pre data-type="programlisting">var d = new Dictionary&lt;Customer, string&gt;();
d [c1] = "Joe";
Console.WriteLine (d.ContainsKey (c2));         // False</pre>
<p>Now, with the custom equality comparer:</p>
<pre data-type="programlisting">var eqComparer = new LastFirstEqComparer();
var d = new Dictionary&lt;Customer, string&gt; (eqComparer);
d [c1] = "Joe";
Console.WriteLine (d.ContainsKey (c2));         // True</pre>
<p>In this example, we would have to be careful not to change the customer’s <code>FirstName</code> or <code>LastName</code> while it was in use in the dictionary; otherwise, its hashcode would change and the <code>Dictionary</code> would break.</p>
<section data-pdf-bookmark="EqualityComparer&lt;T&gt;.Default" data-type="sect3"><div class="sect3" id="equalitycomparerless_thantgreater_thand">
<h3>EqualityComparer&lt;T&gt;.Default</h3>
<p><a contenteditable="false" data-primary="EqualityComparer&lt;T&gt;.Default" data-type="indexterm" id="id3099"/>Calling <code>EqualityComparer&lt;T&gt;.Default</code> returns a general-purpose equality comparer that you can use as an alternative to the static <code>object.Equals</code> method. The advantage is that it first checks whether <code>T</code> implements <code>IEquatable&lt;T&gt;</code>, and if so, it calls that implementation instead, avoiding the boxing overhead. This is particularly useful in generic methods:</p>
<pre data-type="programlisting">static bool Foo&lt;T&gt; (T x, T y)
{
  bool same = <strong>EqualityComparer&lt;T&gt;.Default.Equals</strong> (x, y);
  ...</pre>
</div></section>
<section data-pdf-bookmark="ReferenceEqualityComparer.Instance (.NET 5+)" data-type="sect3"><div class="sect3" id="referenceequalitycomparerdotinstance_le">
<h3>ReferenceEqualityComparer.Instance (.NET 5+)</h3>
<p><a contenteditable="false" data-primary="ReferenceEqualityComparer.Instance" data-type="indexterm" id="id3100"/>From .NET 5, <code>ReferenceEqualityComparer.Instance</code> returns an equality comparer that always applies referential equality. In the case of value types, its <code>Equals</code> method always returns false.<a contenteditable="false" data-primary="" data-startref="ch07.html1037" data-type="indexterm" id="id3101"/><a contenteditable="false" data-primary="" data-startref="ch07.html1036" data-type="indexterm" id="id3102"/><a contenteditable="false" data-primary="" data-startref="ch07.html1035" data-type="indexterm" id="id3103"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="IComparer and Comparer" data-type="sect2"><div class="sect2" id="icomparer_and_comparer">
<h2>IComparer and Comparer</h2>
<p>Comparers are used to switch in custom ordering logic for sorted dictionaries and collections.</p>
<p>Note that a comparer is useless to the unsorted dictionaries such as <code>Dictionary</code> and <code>Hashtable</code>—these require an <code>IEqualityComparer</code> to get hashcodes. Similarly, an equality comparer is useless for sorted dictionaries and collections.</p>
<p>Here are the <code>IComparer</code> interface definitions:</p>
<pre data-type="programlisting">public interface IComparer
{
  int Compare(object x, object y);
}
public interface IComparer &lt;in T&gt;
{
  int Compare(T x, T y);
}</pre>
<p>As with equality comparers, there’s an abstract class that you can subtype instead of implementing the interfaces:</p>
<pre data-type="programlisting">public abstract class Comparer&lt;T&gt; : IComparer, IComparer&lt;T&gt;
{
   public static Comparer&lt;T&gt; Default { get; }

   <strong>public abstract int Compare (T x, T y);</strong>       // Implemented <em>by</em> you
   int IComparer.Compare (object x, object y);   // Implemented <em>for</em> you
}</pre>
<p>The following example illustrates a class that describes a wish as well as a comparer that sorts wishes by priority:</p>
<pre data-type="programlisting">class Wish
{
  public string Name;
  public int Priority;

  public Wish (string name, int priority)
  {
    Name = name;
    Priority = priority;
  }
}

class PriorityComparer : Comparer&lt;Wish&gt;
{
  public override int Compare (Wish x, Wish y)
  {
    if (object.Equals (x, y)) return 0;    // Optimization
    if (x == null) return -1;
    if (y == null) return 1;
    return x.Priority.CompareTo (y.Priority);
  }
}</pre>
<p>The <code>object.Equals</code> check ensures that we can never contradict the <code>Equals</code> method. Calling the static <code>object.Equals</code> method in this case is better than calling <code>x.Equals</code> because it still works if <code>x</code> is null!</p>
<p>Here’s how our <code>PriorityComparer</code> is used to sort a <code>List</code>:</p>
<pre data-type="programlisting">var wishList = new List&lt;Wish&gt;();
wishList.Add (new Wish ("Peace", 2));
wishList.Add (new Wish ("Wealth", 3));
wishList.Add (new Wish ("Love", 2));
wishList.Add (new Wish ("3 more wishes", 1));

wishList.Sort (new PriorityComparer());
foreach (Wish w in wishList) Console.Write (w.Name + " | ");

// OUTPUT: 3 more wishes | Love | Peace | Wealth |</pre>
<p>In the next example, <code>SurnameComparer</code> allows you to sort surname strings in an order suitable for a phonebook listing:</p>
<pre data-type="programlisting">class SurnameComparer : Comparer &lt;string&gt;
{
  string Normalize (string s)
  {
    s = s.Trim().ToUpper();
    if (s.StartsWith ("MC")) s = "MAC" + s.Substring (2);
    return s;
  }

  public override int Compare (string x, string y)
    =&gt; Normalize (x).CompareTo (Normalize (y));
}</pre>
<p>Here’s <code>SurnameComparer</code> in use in a sorted dictionary:</p>
<pre data-type="programlisting">var dic = new SortedDictionary&lt;string,string&gt; (new SurnameComparer());
dic.Add ("MacPhail", "second!");
dic.Add ("MacWilliam", "third!");
dic.Add ("McDonald", "first!");

foreach (string s in dic.Values)
  Console.Write (s + " ");              // first! second! third!</pre>
</div></section>
<section data-pdf-bookmark="StringComparer" data-type="sect2"><div class="sect2" id="stringcomparer">
<h2>StringComparer</h2>
<p><a contenteditable="false" data-primary="collections" data-secondary="StringComparer" data-type="indexterm" id="id3104"/><a contenteditable="false" data-primary="String..." data-secondary="StringComparer" data-type="indexterm" id="id3105"/><code>StringComparer</code> is a predefined plug-in class for equating and comparing strings, allowing you to specify language and case sensitivity. <code>StringComparer</code> implements both <code>IEqualityComparer</code> and <code>IComparer</code> (and their generic versions), so you can use it with any type of dictionary or sorted collection.</p>
<p>Because <code>StringComparer</code> is abstract, you obtain instances via its static properties. <code>StringComparer.Ordinal</code> mirrors the default behavior for string equality comparison and <code>StringComparer.CurrentCulture</code> for order comparison. Here are all of its static members:</p>
<pre data-type="programlisting">public static StringComparer CurrentCulture { get; }
public static StringComparer CurrentCultureIgnoreCase { get; }
public static StringComparer InvariantCulture { get; }
public static StringComparer InvariantCultureIgnoreCase { get; }
public static StringComparer Ordinal { get; }
public static StringComparer OrdinalIgnoreCase { get; }
public static StringComparer Create (CultureInfo culture,
                                       bool ignoreCase);</pre>
<p>In the following example, an ordinal case-insensitive dictionary is created such that <code>dict["Joe"]</code> and <code>dict["JOE"]</code> mean the same thing:</p>
<pre data-type="programlisting">var dict = new Dictionary&lt;string, int&gt; (StringComparer.OrdinalIgnoreCase);</pre>
<p>In the next example, an array of names is sorted, using Australian English:</p>
<pre data-type="programlisting">string[] names = { "Tom", "HARRY", "sheila" };
CultureInfo ci = new CultureInfo ("en-AU");
Array.Sort&lt;string&gt; (names, StringComparer.Create (ci, false));</pre>
<p>The final example is a culture-aware version of the <code>SurnameComparer</code> we wrote in the previous section (to compare names suitable for a phonebook listing):</p>
<pre data-type="programlisting">class SurnameComparer : Comparer&lt;string&gt;
{
  StringComparer strCmp;

  public SurnameComparer (CultureInfo ci)
  {
    // Create a case-sensitive, culture-sensitive string comparer
    strCmp = StringComparer.Create (ci, false);
  }

  string Normalize (string s)
  {
    s = s.Trim();
    if (s.ToUpper().StartsWith ("MC")) s = "MAC" + s.Substring (2);
    return s;
  }

  public override int Compare (string x, string y)
  {
    // Directly call Compare on our culture-aware StringComparer
    return strCmp.Compare (Normalize (x), Normalize (y));
  }
}</pre>
</div></section>
<section data-pdf-bookmark="IStructuralEquatable and IStructuralComparable" data-type="sect2"><div class="sect2" id="istructuralequatable_and_istructuralcom">
<h2>IStructuralEquatable and IStructuralComparable</h2>
<p><a contenteditable="false" data-primary="collections" data-secondary="IStructuralEquatable and IStructuralComparable" data-type="indexterm" id="id3106"/><a contenteditable="false" data-primary="IStructuralComparable" data-type="indexterm" id="id3107"/><a contenteditable="false" data-primary="IStructuralEquatable" data-type="indexterm" id="id3108"/><a contenteditable="false" data-primary="structural comparison" data-type="indexterm" id="id3109"/>As we discussed in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>, structs implement <em>structural comparison</em> by default: two structs are equal if all of their fields are equal. Sometimes, however, structural equality and order comparison are useful as plug-in options on other types, as well—such as arrays. The following interfaces help with this:</p>
<pre data-type="programlisting">public interface IStructuralEquatable
{
  bool Equals (object other, IEqualityComparer comparer);
  int GetHashCode (IEqualityComparer comparer);
}

public interface IStructuralComparable
{
  int CompareTo (object other, IComparer comparer);
}</pre>
<p>The <code>IEqualityComparer</code>/<code>IComparer</code> that you pass in are applied to each individual element in the composite object. We can demonstrate this by using arrays. In the following example, we compare two arrays for equality, first using the default <code>Equals</code> method, then using <code>IStructuralEquatable</code>’s version:</p>
<pre data-type="programlisting">int[] a1 = { 1, 2, 3 };
int[] a2 = { 1, 2, 3 };
IStructuralEquatable se1 = a1;
Console.Write (a1.Equals (a2));                                  // False
Console.Write (se1.Equals (a2, EqualityComparer&lt;int&gt;.Default));  // True</pre>
<p>Here’s another example:<a contenteditable="false" data-primary="" data-startref="ch07.html1034" data-type="indexterm" id="id3110"/><a contenteditable="false" data-primary="" data-startref="ch07.html100" data-type="indexterm" id="id3111"/></p>
<pre data-type="programlisting">string[] a1 = "the quick brown fox".Split();
string[] a2 = "THE QUICK BROWN FOX".Split();
IStructuralEquatable se1 = a1;
bool <strong>isTrue</strong> = se1.Equals (a2, StringComparer.InvariantCultureIgnoreCase);</pre>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn6"><sup><a href="ch07.html#ch01fn6-marker">1</a></sup> There’s also a functionally identical nongeneric version of this called <code>SortedList</code>.</p></div></div></section></body></html>