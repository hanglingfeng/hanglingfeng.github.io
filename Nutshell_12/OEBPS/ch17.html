<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Assemblies</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Assemblies" data-pdf-bookmark="Chapter 17. Assemblies" data-type="chapter" epub:type="chapter"><div class="chapter" id="assemblies">
<h1><span class="label">Chapter 17. </span>Assemblies</h1>

<p><a contenteditable="false" data-primary="assemblies" data-type="indexterm" id="ch17.html0"/>An <em>assembly</em> is the basic unit of deployment in .NET and is also the container for all types. An assembly contains compiled types with their Intermediate Language (IL) code, runtime resources, and information to assist with versioning and referencing other assemblies. An assembly also defines a boundary for type resolution. In .NET, an assembly comprises a single file with a <em>.dll</em> extension.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you build an executable application in .NET, you end up with two files: an assembly (<em>.dll</em>) and an executable launcher (<em>.exe</em>) appropriate to the platform you’re targeting.</p>

<p><a contenteditable="false" data-primary="PE (portable executable) assembly" data-type="indexterm" id="id4036"/><a contenteditable="false" data-primary="portable executable (PE) assembly" data-type="indexterm" id="id4037"/>This differs from what happens in .NET Framework, which generates a <em>portable executable</em> (PE) assembly. A PE has an <em>.exe</em> extension and acts both as an assembly and an application launcher. A PE can simultaneously target 32- and 64-bit versions of Windows.</p>
</div>

<p>Most of the types in this chapter come from the following namespaces:</p>

<pre data-type="programlisting">
System.Reflection
System.Resources
System.Globalization</pre>

<section data-pdf-bookmark="What’s in an Assembly" data-type="sect1"><div class="sect1" id="whatapostrophes_in_an_assembly">
<h1>What’s in an Assembly</h1>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="components" data-type="indexterm" id="ch17.html1"/>An assembly contains four kinds of things:</p>

<dl>
	<dt>An assembly manifest</dt>
	<dd>Provides information to the CLR, such as the assembly’s name, version, and other assemblies that it references</dd>
	<dt>An application manifest</dt>
	<dd>Provides information to the operating system, such as how the assembly should be deployed and whether administrative elevation is required</dd>
	<dt>Compiled types</dt>
	<dd>The compiled IL code and metadata of the types defined within the assembly</dd>
	<dt>Resources</dt>
	<dd>Other data embedded within the assembly, such as images and localizable text</dd>
</dl>

<p>Of these, only the <em>assembly manifest</em> is mandatory, although an assembly nearly always contains compiled types (unless it’s a resource assembly. See <a data-type="xref" href="#resources_and_satellite_assemblies">“Resources and Satellite Assemblies”</a>).</p>

<section data-pdf-bookmark="The Assembly Manifest" data-type="sect2"><div class="sect2" id="the_assembly_manifest">
<h2>The Assembly Manifest</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="assembly manifest" data-type="indexterm" id="id4038"/>The assembly manifest serves two purposes:</p>

<ul>
	<li>
	<p>It describes the assembly to the managed hosting environment.</p>
	</li>
	<li>
	<p>It acts as a directory to the modules, types, and resources in the assembly.</p>
	</li>
</ul>

<p>Assemblies are thus <em>self-describing</em>. A consumer can discover all of an assembly’s data, types, and functions—without needing additional files.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An assembly manifest is not something you add explicitly to an assembly—it’s automatically embedded into an assembly as part of compilation.</p>
</div>

<p>Here’s a summary of the functionally significant data stored in the manifest:</p>

<ul>
	<li>
	<p>The simple name of the assembly</p>
	</li>
	<li>
	<p>A version number (<code>AssemblyVersion</code>)</p>
	</li>
	<li>
	<p>A public key and signed hash of the assembly, if strongly named</p>
	</li>
	<li>
	<p>A list of referenced assemblies, including their version and public key</p>
	</li>
	<li>
	<p>A list of types defined in the assembly</p>
	</li>
	<li>
	<p>The culture it targets, if a satellite assembly (<code>AssemblyCulture</code>)</p>
	</li>
</ul>

<p>The manifest can also store the following informational data:</p>

<ul>
	<li>
	<p>A full title and description (<code>AssemblyTitle</code> and <code>AssemblyDescription</code>)</p>
	</li>
	<li>
	<p>Company and copyright information (<code>AssemblyCompany</code> and <code>AssemblyCopyright</code>)</p>
	</li>
	<li>
	<p>A display version (<code>AssemblyInformationalVersion</code>)</p>
	</li>
	<li>
	<p>Additional attributes for custom data</p>
	</li>
</ul>

<p>Some of this data is derived from arguments given to the compiler, such as the list of referenced assemblies or the public key with which to sign the assembly. The rest comes from assembly attributes, indicated in parentheses.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can view the contents of an assembly’s manifest with the .NET tool <em>ildasm.exe</em>. In <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>, we describe how to use reflection to do the same programmatically.</p>
</div>

<section data-pdf-bookmark="Specifying assembly attributes" data-type="sect3"><div class="sect3" id="specifying_assembly_attributes">
<h3>Specifying assembly attributes</h3>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="specifying attributes" data-type="indexterm" id="id4039"/>Commonly used assembly attributes can be specified in Visual Studio on the project’s Properties page, on the Package tab. The settings on that tab are added to the project file (<em>.csproj</em>).</p>

<p>To specify attributes not supported by the Package tab, or if not working with a <em>.csproj</em> file, you can specify assembly attributes in source code (this is often done in a file called <em>AssemblyInfo.cs</em>).</p>

<p>A dedicated attributes file contains only <code>using</code> statements and assembly attribute declarations. For example, to expose internally scoped types to a unit test project, you would do this:</p>

<pre data-type="programlisting">
using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("MyUnitTestProject")]</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="The Application Manifest (Windows)" data-type="sect2"><div class="sect2" id="the_application_manifest_left_parenthes">
<h2>The Application Manifest (Windows)</h2>

<p><a contenteditable="false" data-primary="application manifest" data-type="indexterm" id="id4040"/><a contenteditable="false" data-primary="assemblies" data-secondary="application manifest" data-type="indexterm" id="id4041"/><a contenteditable="false" data-primary="Windows" data-secondary="application manifest" data-type="indexterm" id="id4042"/>An application manifest is an XML file that communicates information about the assembly to the OS. An application manifest is embedded into the startup executable as a Win32 resource during the build process. If present, the manifest is read and processed before the CLR loads the assembly—and can influence how Windows launches the application’s process.</p>

<p>A .NET application manifest has a root element called <code>assembly</code> in the XML namespace <code>urn:schemas-microsoft-com:asm.v1</code>:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
  &lt;!-- contents of manifest --&gt;
&lt;/assembly&gt;</pre>

<p>The following manifest instructs the OS to request administrative elevation:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
  &lt;trustInfo xmlns="urn:schemas-microsoft-com:asm.v2"&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        <strong>&lt;requestedExecutionLevel level="requireAdministrator" /&gt;</strong>
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/trustInfo&gt;
&lt;/assembly&gt;</pre>

<p>(UWP applications have a far more elaborate manifest, described in the <em>Package​.appxmanifest</em> file. This includes a declaration of the program’s capabilities, which determine permissions granted by the OS. The easiest way to edit this file is with Visual Studio, which displays a dialog when you double-click the manifest file.)</p>

<section data-pdf-bookmark="Deploying an application manifest" data-type="sect3"><div class="sect3" id="deploying_an_application_manifest">
<h3>Deploying an application manifest</h3>

<p>You can add an application manifest to a .NET project in Visual Studio by right-clicking your project in Solution Explorer, selecting Add, then New Item, and then choosing Application Manifest File. Upon building, the manifest will be embedded into the output assembly.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The .NET tool <em>ildasm.exe</em> is blind to the presence of an embedded application manifest. Visual Studio, however, indicates whether an embedded application manifest is present if you double-click the assembly in Solution Explorer.</p>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Modules" data-type="sect2"><div class="sect2" id="modules">
<h2>Modules</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="modules" data-type="indexterm" id="id4043"/><a contenteditable="false" data-primary="modules, assembly" data-type="indexterm" id="id4044"/>The contents of an assembly are actually packaged within an intermediate container, called a <em>module</em>. A module corresponds to a file containing the contents of an assembly. The reason for this extra layer of containership is to allow an assembly to span multiple files, a feature present in .NET Framework but absent in .NET 5+ and .NET Core. <a data-type="xref" href="#single_file_assembly">Figure 17-1</a> illustrates the relationship.</p>

<figure><div class="figure" id="single_file_assembly"><img alt="Single-file assembly" src="assets/cn10_1701.png"/>
<h6><span class="label">Figure 17-1. </span>Single-file assembly</h6>
</div></figure>

<p>Although .NET does not support multifile assemblies, at times you need to be aware of the extra level of containership that modules impose. The main scenario is with reflection (see <a data-type="xref" href="ch18.html#reflecting_assemblies">“Reflecting Assemblies”</a> and <a data-type="xref" href="ch18.html#emitting_assemblies_and_types">“Emitting Assemblies and Types”</a>).</p>
</div></section>

<section data-pdf-bookmark="The Assembly Class" data-type="sect2"><div class="sect2" id="the_assembly_class">
<h2>The Assembly Class</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="Assembly class" data-type="indexterm" id="id4045"/><a contenteditable="false" data-primary="Assembly..." data-secondary="Assembly class" data-type="indexterm" id="id4046"/><a contenteditable="false" data-primary="System..." data-secondary="System.Reflection" data-type="indexterm" id="id4047"/>The <code>Assembly</code> class in <code>System.Reflection</code> is a gateway to accessing assembly metadata at runtime. There are a number of ways to obtain an assembly object: the simplest is via a <code>Type</code>’s <code>Assembly</code> property:</p>

<pre data-type="programlisting">
Assembly a = typeof (Program).Assembly;</pre>

<p>You can also obtain an <code>Assembly</code> object by calling one of <code>Assembly</code>’s static methods:</p>

<dl>
	<dt><code>GetExecutingAssembly</code></dt>
	<dd>Returns the assembly of the type that defines the currently executing function</dd>
	<dt><code>GetCallingAssembly</code></dt>
	<dd>Does the same as <code>GetExecutingAssembly</code> but for the function that called the currently executing function</dd>
	<dt><code>GetEntryAssembly</code></dt>
	<dd>Returns the assembly defining the application’s original entry method</dd>
</dl>

<p>After you have an <code>Assembly</code> object, you can use its properties and methods to query the assembly’s metadata and reflect upon its types. <a data-type="xref" href="#assembly_members">Table 17-1</a> shows a summary of these functions.<a contenteditable="false" data-primary="" data-startref="ch17.html1" data-type="indexterm" id="id4048"/></p>

<table class="border" id="assembly_members">
	<caption><span class="label">Table 17-1. </span>Assembly members</caption>
	<thead>
		<tr>
			<th>Functions</th>
			<th>Purpose</th>
			<th>See the section...</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>FullName</code>, <span class="keep-together"><code>GetName</code></span></td>
			<td>Returns the fully qualified name or an <code>AssemblyName</code> object</td>
			<td><a data-type="xref" href="#assembly_names">“Assembly Names”</a></td>
		</tr>
		<tr>
			<td><code>CodeBase</code>, <span class="keep-together"><code>Location</code></span></td>
			<td>Location of the assembly file</td>
			<td><a data-type="xref" href="#loadingcomma_resolvingcomma_and_isolati">“Loading, Resolving, and Isolating Assemblies”</a></td>
		</tr>
		<tr>
			<td><code>Load</code>, <code>LoadFrom</code>, <span class="keep-together"><code>LoadFile</code></span></td>
			<td>Manually loads an assembly into memory</td>
			<td><a data-type="xref" href="#loadingcomma_resolvingcomma_and_isolati">“Loading, Resolving, and Isolating Assemblies”</a></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>GetSatelliteAssembly</code></span></td>
			<td>Locates the satellite assembly of a given culture</td>
			<td><a data-type="xref" href="#resources_and_satellite_assemblies">“Resources and Satellite Assemblies”</a></td>
		</tr>
		<tr>
			<td><code>GetType</code>, <span class="keep-together"><code>GetTypes</code></span></td>
			<td>Returns a type, or all types, defined in the assembly</td>
			<td><a data-type="xref" href="ch18.html#reflecting_and_activating_types">“Reflecting and Activating Types”</a></td>
		</tr>
		<tr>
			<td><code>EntryPoint</code></td>
			<td>Returns the application’s entry method, as a <code>MethodInfo</code></td>
			<td><a data-type="xref" href="ch18.html#reflecting_and_invoking_members">“Reflecting and Invoking Members”</a></td>
		</tr>
		<tr>
			<td><code>GetModule</code>, <span class="keep-together"><code>GetModules</code></span>, <span class="keep-together"><code>ManifestModule</code></span></td>
			<td>Returns all modules, or the main module, of an assembly</td>
			<td><a data-type="xref" href="ch18.html#reflecting_assemblies">“Reflecting Assemblies”</a></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>GetCustomAttribute</code></span>, <span class="keep-together"><code>GetCustomAttributes</code></span></td>
			<td>Returns the assembly’s attributes</td>
			<td><a data-type="xref" href="ch18.html#working_with_attributes">“Working with Attributes”</a></td>
		</tr>
	</tbody>
</table>
</div></section>
</div></section>

<section data-pdf-bookmark="Strong Names and Assembly Signing" data-type="sect1"><div class="sect1" id="strong_names_and_assembly_signing">
<h1>Strong Names and Assembly Signing</h1>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="assemblies" data-secondary="strong names and assembly signing" data-type="indexterm" id="id4049"/><a contenteditable="false" data-primary="strongly named assemblies" data-type="indexterm" id="id4050"/>Strongly naming an assembly was important in .NET Framework for two reasons:</p>

<ul>
	<li>
	<p>It allowed the assembly to be loaded into the “Global assembly cache.”</p>
	</li>
	<li>
	<p>It allowed the assembly to by referenced by other strongly named assemblies.</p>
	</li>
</ul>

<p>Strong naming is much less important in .NET 5+ and .NET Core, because these runtimes do not have a global assembly cache, nor do they impose the second restriction.</p>
</div>

<p>A <em>strongly named</em> assembly has a unique identity. It works by adding two bits of metadata to the manifest:</p>

<ul>
	<li>
	<p>A <em>unique number</em> that belongs to the authors of the assembly</p>
	</li>
	<li>
	<p>A <em>signed hash</em> of the assembly, proving that the unique number holder produced the assembly</p>
	</li>
</ul>

<p>This requires a public/private key pair. The <em>public key</em> provides the unique identifying number, and the <em>private key</em> facilitates signing.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Strong-name</em>-signing is not the same as <em>Authenticode</em>-signing. We cover Authenticode later in this chapter.</p>
</div>

<p>The public key is valuable in guaranteeing the uniqueness of assembly references: a strongly named assembly incorporates the public key into its identity.</p>

<p>In .NET Framework, the private key protects your assembly from tampering, in that without your private key, no one can release a modified version of the assembly without the signature breaking. In practice, this is of use when loading an assembly into .NET Framework’s global assembly cache. In .NET 5+ and .NET Core, the signature is of little use because it’s never checked.</p>

<p>Adding a strong name to a previously “weak” named assembly changes its identity. For this reason, it pays to strong-name an assembly from the outset if you think the assembly might need a strong name in the future.</p>

<section data-pdf-bookmark="How to Strongly Name an Assembly" data-type="sect2"><div class="sect2" id="how_to_strongly_name_an_assembly">
<h2>How to Strongly Name an Assembly</h2>

<p>To give an assembly a strong name, first generate a public/private key pair with the <em>sn.exe</em> utility:</p>

<pre data-type="programlisting">
sn.exe -k MyKeyPair.snk</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Visual Studio installs a shortcut called <em>Developer Command Prompt for VS</em>, which starts a command prompt whose <code>PATH</code> contains development tools such as <em>sn.exe</em>.</p>
</div>

<p>This manufactures a new key pair and stores it to a file called <em>MyKeyPair.snk</em>. If you subsequently lose this file, you will permanently lose the ability to recompile your assembly with the same identity.</p>

<p>You can sign an assembly with this file by updating your project file. From Visual Studio, go to the Project Properties window, and then, on the <em>Signing</em> tab, select the “Sign the assembly” checkbox and select your <em>.snk</em> file.</p>

<p>The same key pair can sign multiple assemblies—they’ll still have distinct identities if their simple names differ.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Assembly Names" data-type="sect1"><div class="sect1" id="assembly_names">
<h1>Assembly Names</h1>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="names" data-type="indexterm" id="ch17.html2"/>An assembly’s “identity” comprises four pieces of metadata from its manifest:</p>

<ul>
	<li>
	<p>Its simple name</p>
	</li>
	<li>
	<p>Its version (“0.0.0.0” if not present)</p>
	</li>
	<li>
	<p>Its culture (“neutral” if not a satellite)</p>
	</li>
	<li>
	<p>Its public key token (“null” if not strongly named)</p>
	</li>
</ul>

<p>The simple name comes not from any attribute, but from the name of the file to which it was originally compiled (less any extension). So, the simple name of the <em>System.Xml.dll</em> assembly is “System.Xml.” Renaming a file doesn’t change the assembly’s simple name.</p>

<p>The version number comes from the <code>AssemblyVersion</code> attribute. It’s a string divided into four parts as follows:</p>

<pre data-type="programlisting">
<em>major</em>.<em>minor</em>.<em>build</em>.<em>revision</em></pre>

<p>You can specify a version number as follows:</p>

<pre data-type="programlisting">
[assembly: AssemblyVersion ("2.5.6.7")]</pre>

<p>The culture comes from the <code>AssemblyCulture</code> attribute and applies to satellite assemblies, described later in the section <a data-type="xref" href="#resources_and_satellite_assemblies">“Resources and Satellite Assemblies”</a>.</p>

<p>The public key token comes from the strong name supplied at compile time, as we discussed in the preceding section.</p>

<section data-pdf-bookmark="Fully Qualified Names" data-type="sect2"><div class="sect2" id="fully_qualified_names">
<h2>Fully Qualified Names</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="fully qualified names" data-type="indexterm" id="id4051"/><a contenteditable="false" data-primary="fully qualified names" data-type="indexterm" id="id4052"/>A fully qualified assembly name is a string that includes all four identifying components, in this format:</p>

<pre data-type="programlisting">
<em>simple-name</em>, Version=<em>version</em>, Culture=<em>culture</em>, PublicKeyToken=<em>public-key</em></pre>

<p>For example, the fully qualified name of <em>System.Private.CoreLib.dll</em> is <em>System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e</em>.</p>

<p>If the assembly has no <code>AssemblyVersion</code> attribute, the version appears as <code>0.0.0.0</code>. If it is unsigned, its public key token appears as <code>null</code>.</p>

<p>An <code>Assembly</code> object’s <code>FullName</code> property returns its fully qualified name. The compiler always uses fully qualified names when recording assembly references in the manifest.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A fully qualified assembly name does not include a directory path to assist in locating it on disk. Locating an assembly residing in another directory is an entirely separate matter that we pick up in <a data-type="xref" href="#loadingcomma_resolvingcomma_and_isolati">“Loading, Resolving, and Isolating Assemblies”</a>.</p>
</div>
</div></section>

<section data-pdf-bookmark="The AssemblyName Class" data-type="sect2"><div class="sect2" id="the_assemblyname_class">
<h2>The AssemblyName Class</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="AssemblyName class" data-type="indexterm" id="id4053"/><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyName" data-type="indexterm" id="id4054"/><code>AssemblyName</code> is a class with a typed property for each of the four components of a fully qualified assembly name. <code>AssemblyName</code> has two purposes:</p>

<ul>
	<li>
	<p>It parses or builds a fully qualified assembly name.</p>
	</li>
	<li>
	<p>It stores some extra data to assist in resolving (finding) the assembly.</p>
	</li>
</ul>

<p>You can obtain an <code>AssemblyName</code> object in any of the following ways:</p>

<ul>
	<li>
	<p>Instantiate an <code>AssemblyName</code>, providing a fully qualified name.</p>
	</li>
	<li>
	<p>Call <code>GetName</code> on an existing <code>Assembly</code>.</p>
	</li>
	<li>
	<p>Call <code>AssemblyName.GetAssemblyName</code>, providing the path to an assembly file on disk.</p>
	</li>
</ul>

<p>You can also instantiate an <code>AssemblyName</code> object without any arguments and then set each of its properties to build a fully qualified name. An <code>AssemblyName</code> is mutable when constructed in this manner.</p>

<p>Here are its essential properties and methods:</p>

<pre data-type="programlisting">
string      FullName    { get; }            // Fully qualified name
string      Name        { get; set; }       // Simple name
Version     Version     { get; set; }       // Assembly version
CultureInfo CultureInfo { get; set; }       // For satellite assemblies
string      CodeBase    { get; set; }       // Location

byte[]      GetPublicKey();                 // 160 bytes
void        SetPublicKey (byte[] key);
byte[]      GetPublicKeyToken();            // 8-byte version
void        SetPublicKeyToken (byte[] publicKeyToken);</pre>

<p><code>Version</code> is itself a strongly typed representation, with properties for <code>Major</code>, <code>Minor</code>, <code>Build</code>, and <code>Revision</code> numbers. <code>GetPublicKey</code> returns the full cryptographic public key; <code>GetPublicKeyToken</code> returns the last eight bytes used in establishing identity.</p>

<p>To use <code>AssemblyName</code> to obtain the simple name of an assembly:</p>

<pre data-type="programlisting">
Console.WriteLine (typeof (string).Assembly.GetName().Name);
// System.Private.CoreLib</pre>

<p>To get an assembly version:</p>

<pre data-type="programlisting">
string v = myAssembly.GetName().Version.ToString();</pre>
</div></section>

<section data-pdf-bookmark="Assembly Informational and File Versions" data-type="sect2"><div class="sect2" id="assembly_informational_and_file_version">
<h2>Assembly Informational and File Versions</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="informational/file versions" data-type="indexterm" id="id4055"/>Two further assembly attributes are available for expressing version-related information. Unlike <code>AssemblyVersion</code>, the following two attributes do not affect an assembly’s identity and so have no effect on what happens at compile-time or at runtime:</p>

<dl>
	<dt><code>AssemblyInformationalVersion</code></dt>
	<dd><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyInformationalVersion" data-type="indexterm" id="id4056"/>The version as displayed to the end user. This is visible in the Windows File Properties dialog box as Product Version. Any string can go here, such as “5.1 Beta 2.” Typically, all of the assemblies in an application would be assigned the same informational version number.</dd>
	<dt><code>AssemblyFileVersion</code></dt>
	<dd><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyFileVersion" data-type="indexterm" id="id4057"/>This is intended to refer to the build number for that assembly. This is visible in the Windows File Properties dialog box as File Version. As with <code>AssemblyVersion</code>, it must contain a string consisting of up to four numbers separated by periods.<a contenteditable="false" data-primary="" data-startref="ch17.html2" data-type="indexterm" id="id4058"/></dd>
</dl>
</div></section>
</div></section>

<section data-pdf-bookmark="Authenticode Signing" data-type="sect1"><div class="sect1" id="authenticode_signing">
<h1>Authenticode Signing</h1>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="Authenticode signing" data-type="indexterm" id="ch17.html3"/><a contenteditable="false" data-primary="Authenticode" data-type="indexterm" id="ch17.html4"/><a contenteditable="false" data-primary="Authenticode" data-secondary="assembly signing" data-type="indexterm" id="ch17.html5"/><em>Authenticode</em> is a code-signing system whose purpose is to prove the identity of the publisher. Authenticode and <em>strong-name</em> signing are independent: you can sign an assembly with either or both systems.</p>

<p>Although strong-name signing can prove that assemblies A, B, and C came from the same party (assuming the private key hasn’t been leaked), it can’t tell you who that party was. To know that the party was Joe Albahari—or Microsoft Corporation—you need Authenticode.</p>

<p>Authenticode is useful when downloading programs from the internet, because it provides assurance that a program came from whoever was named by the Certificate Authority and was not modified in transit. It also prevents the “Unknown Publisher” warning when running a downloaded application for the first time. Authenticode signing is also a requirement when submitting apps to the Windows Store.</p>

<p>Authenticode works with not only .NET assemblies, but also unmanaged executables and binaries such as <em>.msi</em> deployment files. Of course, Authenticode doesn’t guarantee that a program is free from malware—although it does make it less likely. A person or entity has been willing to put its name (backed by a passport or company document) behind the executable or library.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The CLR does not treat an Authenticode signature as part of an assembly’s identity. However, it can read and validate Authenticode signatures on demand, as you’ll see soon.</p>
</div>

<p>Signing with Authenticode requires that you contact a <em>Certificate Authority</em> (CA) with evidence of your personal identity or company’s identity (articles of incorporation, etc.). After the CA has checked your documents, it will issue an X.509 code-signing certificate that is typically valid for one to five years. This enables you to sign assemblies with the <em>signtool</em> utility. You can also make a certificate yourself with the <em>makecert</em> utility; however, it will be recognized only on computers on which the certificate is explicitly installed.</p>

<p>The fact that (non-self-signed) certificates can work on any computer relies on <span class="keep-together">public key</span> infrastructure. Essentially, your certificate is signed with another certificate belonging to a CA. The CA is trusted because all CAs are loaded into the OS. (<span class="keep-together">To see them</span>, go to the Windows Control Panel and then, in the search box, type <span class="keep-together"><code><strong>certificate</strong></code></span>. In the Administrative Tools section, click “Manage computer certificates.” This launches the Certificate Manager. Open the node Trusted Root Certification Authorities and click Certificates.) A CA can revoke a publisher’s certificate if leaked, so verifying an Authenticode signature requires periodically asking the CA for an up-to-date list of certification revocations.</p>

<p>Because Authenticode uses cryptographic signing, an Authenticode signature is invalid if someone subsequently tampers with the file. We discuss cryptography, hashing, and signing in <a data-type="xref" href="ch20.html#cryptography-id00013">Chapter 20</a>.</p>

<section data-pdf-bookmark="How to Sign with Authenticode" data-type="sect2"><div class="sect2" id="how_to_sign_with_authenticode">
<h2>How to Sign with Authenticode</h2>

<section data-pdf-bookmark="Obtaining and installing a certificate" data-type="sect3"><div class="sect3" id="obtaining_and_installing_a_certificate">
<h3>Obtaining and installing a certificate</h3>

<p><a contenteditable="false" data-primary="Authenticode" data-secondary="signing with" data-type="indexterm" id="id4059"/><a contenteditable="false" data-primary="CA (Certificate Authority)" data-type="indexterm" id="id4060"/><a contenteditable="false" data-primary="Certificate Authority (CA)" data-type="indexterm" id="id4061"/>The first step is to obtain a code-signing certificate from a CA (see the sidebar that follows). You can then either work with the certificate as a password-protected file or load the certificate into the computer’s certificate store. The benefit of doing the latter is that you can sign without needing to specify a password. This is advantageous because it prevents having a password visible in automated build scripts or batch files.</p>

<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="where_to_get_a_code_signing_certificate">
<h1>Where to Get a Code-Signing Certificate</h1>

<p><a contenteditable="false" data-primary="Authenticode" data-secondary="code-signing certificate" data-type="indexterm" id="id4062"/>Just a handful of code-signing CAs are preloaded into Windows as root certification authorities. These include Comodo, GoDaddy, GlobalSign, DigiCert, Thawte, and Symantec.</p>

<p>There are also resellers such as K Software that offer discounted code-signing certificates from the aforementioned authorities.</p>

<p>The Authenticode certificates issued by K Software, Comodo, GoDaddy, and GlobalSign are advertised as less restrictive in that they will also sign non-Microsoft programs. Aside from this, the products from all vendors are functionally <span class="keep-together">equivalent</span>.</p>

<p>Note that a certificate for SSL cannot generally be used for Authenticode signing (despite using the same X.509 infrastructure). This is, in part, because a certificate for SSL is about proving ownership of a domain; Authenticode is about proving who you are.</p>
</div></aside>

<p>To load a certificate into the computer’s certificate store, open the Certificate Manager as described earlier. Open the Personal folder, right-click its Certificates folder, and then pick All Tasks/Import. An import wizard guides you through the process. After the import is complete, click the View button on the certificate, go to the Details tab, and copy the certificate’s <em>thumbprint</em>. This is the SHA-256 hash that you’ll subsequently need to identify the certificate when signing.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you also want to strong-name-sign your assembly, you must do so <em>before</em> Authenticode signing. This is because the CLR knows about Authenticode signing, but not vice versa. So, if you strong-name-sign an assembly <em>after</em> Authenticode-signing it, the latter will see the addition of the CLR’s strong name as an unauthorized modification and consider the assembly <span class="keep-together">tampered</span>.</p>
</div>
</div></section>

<section data-pdf-bookmark="Signing with signtool.exe" data-type="sect3"><div class="sect3" id="signing_with_signtooldotexe">
<h3>Signing with signtool.exe</h3>

<p><a contenteditable="false" data-primary="Authenticode" data-secondary="signing with signtool.exe" data-type="indexterm" id="id4063"/><a contenteditable="false" data-primary="signtool.exe" data-type="indexterm" id="id4064"/>You can Authenticode-sign your programs with the <em>signtool</em> utility that comes with Visual Studio (look in the <em>Microsoft SDKs\ClickOnce\SignTool</em> folder under <em>Program Files</em>). The following signs a file called <em>LINQPad.exe</em> with the certificate located in the computer’s <em>My Store</em> called “Joseph Albahari,” using the secure SHA256 hashing algorithm:</p>

<pre data-type="programlisting">
signtool sign /n "Joseph Albahari" /fd sha256 LINQPad.exe</pre>

<p>You can also specify a description and product URL with <code>/d</code> and <code>/du</code>:</p>

<pre data-type="programlisting">
 ... <strong>/d</strong> LINQPad <strong>/du</strong> <em>http://www.linqpad.net</em></pre>

<p>In most cases, you will also want to specify a <em>time-stamping server</em>.</p>
</div></section>

<section data-pdf-bookmark="Time stamping" data-type="sect3"><div class="sect3" id="time_stamping">
<h3>Time stamping</h3>

<p><a contenteditable="false" data-primary="Authenticode" data-secondary="time stamping" data-type="indexterm" id="id4065"/><a contenteditable="false" data-primary="time-stamping server" data-type="indexterm" id="id4066"/>After your certificate expires, you’ll no longer be able to sign programs. However, programs that you signed <em>before</em> its expiry will still be valid—if you specified a <em>time-stamping server</em> with the <code>/tr</code> switch when signing. The CA will provide you with a URI for this purpose: the following is for Comodo (or K Software):</p>

<pre data-type="programlisting">
 ... <strong>/tr</strong> <em>http://timestamp.comodoca.com/authenticode</em> /td SHA256</pre>
</div></section>

<section data-pdf-bookmark="Verifying that a program has been signed" data-type="sect3"><div class="sect3" id="verifying_that_a_program_has_been_signe">
<h3>Verifying that a program has been signed</h3>

<p>The easiest way to view an Authenticode signature on a file is to view the file’s properties in Windows Explorer (look in the Digital Signatures tab). The <em>signtool</em> utility also provides an option for this.<a contenteditable="false" data-primary="" data-startref="ch17.html5" data-type="indexterm" id="id4067"/><a contenteditable="false" data-primary="" data-startref="ch17.html4" data-type="indexterm" id="id4068"/><a contenteditable="false" data-primary="" data-startref="ch17.html3" data-type="indexterm" id="id4069"/></p>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Resources and Satellite Assemblies" data-type="sect1"><div class="sect1" id="resources_and_satellite_assemblies">
<h1>Resources and Satellite Assemblies</h1>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="resources" data-type="indexterm" id="ch17.html6"/><a contenteditable="false" data-primary="resources, in assemblies" data-type="indexterm" id="ch17.html7"/>An application typically contains not only executable code, but also content such as text, images, or XML files. Such content can be represented in an assembly through a <em>resource</em>. There are two overlapping use cases for resources:</p>

<ul>
	<li>
	<p>Incorporating data that cannot go into source code, such as images</p>
	</li>
	<li>
	<p>Storing data that might need translation in a multilingual application</p>
	</li>
</ul>

<p>An assembly resource is ultimately a byte stream with a name. You can think of an assembly as containing a dictionary of byte arrays keyed by string. You can see this in <em>ildasm</em> if you disassemble an assembly that contains a resource called <em>banner.jpg</em> and a resource called <em>data.xml</em>:</p>

<pre data-type="programlisting">
.mresource public <strong>banner.jpg</strong>
{
  // Offset: 0x00000F58 Length: 0x000004F6
}
.mresource public <strong>data.xml</strong>
{
  // Offset: 0x00001458 Length: 0x0000027E
}</pre>

<p>In this case, <em>banner.jpg</em> and <em>data.xml</em> were included directly in the assembly—each as its own embedded resource. This is the simplest way to work.</p>

<p>.NET also lets you add content through intermediate <em>.resources</em> containers. These are designed for holding content that might require translation into different languages. Localized <em>.resources</em> can be packaged as individual satellite assemblies that are automatically picked up at runtime, based on the user’s OS language.</p>

<p><a data-type="xref" href="#resources">Figure 17-2</a> illustrates an assembly that contains two directly embedded resources, plus a <em>.resources</em> container called <em>welcome.resources</em>, for which we’ve created two localized satellites.</p>

<figure><div class="figure" id="resources"><img alt="Resources" src="assets/cn10_1702.png"/>
<h6><span class="label">Figure 17-2. </span>Resources</h6>
</div></figure>

<section data-pdf-bookmark="Directly Embedding Resources" data-type="sect2"><div class="sect2" id="directly_embedding_resources">
<h2>Directly Embedding Resources</h2>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="resources, in assemblies" data-secondary="directly embedding" data-type="indexterm" id="id4070"/>Embedding resources into assemblies is not supported in Windows Store apps. Instead, add any extra files to your deployment package, and access them by reading from your application <code>StorageFolder</code> (<code>Package.Cur⁠rent​.Installed​Location</code>).</p>
</div>

<p>To directly embed a resource using Visual Studio:</p>

<ul>
	<li>
	<p>Add the file to your project.</p>
	</li>
	<li>
	<p>Set its build action to Embedded Resource.</p>
	</li>
</ul>

<p>Visual Studio always prefixes resource names with the project’s default namespace, plus the names of any subfolders in which the file is contained. So, if your project’s default namespace was <code>Westwind.Reports</code> and your file was called <em>banner.jpg</em> in the folder <em>pictures</em>, the resource name would be <em>Westwind.Reports.pictures.banner.jpg</em>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Resource names are case sensitive. This makes project subfolder names in Visual Studio that contain resources effectively case sensitive.</p>
</div>

<p>To retrieve a resource, you call <code>GetManifestResourceStream</code> on the assembly containing the resource. This returns a stream, which you can then read as any other:</p>

<pre data-type="programlisting">
Assembly a = Assembly.GetEntryAssembly();

<strong>using (Stream s = a.GetManifestResourceStream ("TestProject.data.xml"))</strong>
using (XmlReader r = XmlReader.Create (s))
  ...

System.Drawing.Image image;
<strong>using (Stream s = a.GetManifestResourceStream ("TestProject.banner.jpg"))</strong>
  image = System.Drawing.Image.FromStream (s);</pre>

<p>The stream returned is seekable, so you can also do this:</p>

<pre data-type="programlisting">
byte[] data;
using (Stream s = a.GetManifestResourceStream ("TestProject.banner.jpg"))
  data = new BinaryReader (s).ReadBytes ((int) s.Length);</pre>

<p>If you’ve used Visual Studio to embed the resource, you must remember to include the namespace-based prefix. To help avoid error, you can specify the prefix in a separate argument, using a <em>type</em>. The type’s namespace is used as the prefix:</p>

<pre data-type="programlisting">
using (Stream s = a.GetManifestResourceStream (<strong>typeof (X),</strong> "data.xml"))</pre>

<p><code>X</code> can be any type with the desired namespace of your resource (typically, a type in the same project folder).</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Setting a project item’s build action in Visual Studio to Resource within a Windows Presentation Foundation (WPF) application is <em>not</em> the same as setting its build action to Embedded Resource. The former actually adds the item to a <em>.resources</em> file called <em>&lt;AssemblyName&gt;.g.resources</em>, whose content you access through WPF’s <code>Application</code> class, using a URI as a key.</p>

<p>To add to the confusion, WPF further overloads the term “resource.” <em>Static resources</em> and <em>dynamic resources</em> are both unrelated to assembly resources!</p>
</div>

<p><code>GetManifestResourceNames</code> returns the names of all resources in the assembly.</p>
</div></section>

<section data-pdf-bookmark=".resources Files" data-type="sect2"><div class="sect2" id="dotresources_files">
<h2>.resources Files</h2>

<p><a contenteditable="false" data-primary=".resources files" data-primary-sortas="resources files" data-type="indexterm" id="ch17.html8"/><a contenteditable="false" data-primary="resources, in assemblies" data-secondary=".resources files" data-secondary-sortas="resources files" data-type="indexterm" id="ch17.html9"/><em>.resources</em> files are containers for potentially localizable content. A <em>.resources</em> file ends up as an embedded resource within an assembly—just like any other kind of file. The difference is that you must do the following:</p>

<ul>
	<li>
	<p>Package your content into the <em>.resources</em> file to begin with</p>
	</li>
	<li>
	<p>Access its content through a <code>ResourceManager</code> or <em>pack URI</em> rather than a <code>Get​ManifestResourceStream</code></p>
	</li>
</ul>

<p><em>.resources</em> files are structured in binary and so are not human-editable; therefore, you must rely on tools provided by .NET and Visual Studio to work with them. The standard approach with strings or simple data types is to use the <em>.resx</em> format, which can be converted to a <em>.resources</em> file either by Visual Studio or the <code>resgen</code> tool. The <em>.resx</em> format is also suitable for images intended for a Windows Forms or ASP.NET application.</p>

<p>In a WPF application, you must use Visual Studio’s “Resource” build action for images or similar content needing to be referenced by URI. This applies whether localization is needed or not.</p>

<p>We describe how to do each of these in the following sections.</p>
</div></section>

<section data-pdf-bookmark=".resx Files" data-type="sect2"><div class="sect2" id="dotresx_files">
<h2>.resx Files</h2>

<p><a contenteditable="false" data-primary=".resx files" data-primary-sortas="resx files" data-type="indexterm" id="id4071"/><a contenteditable="false" data-primary="resources, in assemblies" data-secondary=".resx files" data-secondary-sortas="resx files" data-type="indexterm" id="id4072"/>A <em>.resx</em> file is a design-time format for producing <em>.resources</em> files. A <em>.resx</em> file uses XML and is structured with name/value pairs as follows:</p>

<pre data-type="programlisting">
&lt;root&gt;
  &lt;data name="Greeting"&gt;
    &lt;value&gt;hello&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="DefaultFontSize" type="System.Int32, mscorlib"&gt;
    &lt;value&gt;10&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;</pre>

<p>To create a <em>.resx</em> file in Visual Studio, add a project item of type Resources File. The rest of the work is done automatically:</p>

<ul>
	<li>
	<p>The correct header is created.</p>
	</li>
	<li>
	<p>A designer is provided for adding strings, images, files, and other kinds of data.</p>
	</li>
	<li>
	<p>The <em>.resx</em> file is automatically converted to the <em>.resources</em> format and embedded into the assembly upon compilation.</p>
	</li>
	<li>
	<p>A class is written to help you access the data later on.</p>
	</li>
</ul>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The resource designer adds images as typed <code>Image</code> objects (<em>System.Drawing.dll</em>) rather than as byte arrays, making them unsuitable for WPF applications.</p>
</div>

<section data-pdf-bookmark="Reading .resources files" data-type="sect3"><div class="sect3" id="reading_dotresources_files">
<h3>Reading .resources files</h3>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you create a <em>.resx</em> file in Visual Studio, a class of the same name is generated automatically with properties to retrieve each of its items.</p>
</div>

<p><a contenteditable="false" data-primary="ResourceManager class" data-type="indexterm" id="ch17.html10"/>The <code>ResourceManager</code> class reads <em>.resources</em> files embedded within an assembly:</p>

<pre data-type="programlisting">
ResourceManager r = new ResourceManager ("welcome",
                                         Assembly.GetExecutingAssembly());</pre>

<p>(The first argument must be namespace-prefixed if the resource was compiled in Visual Studio.)</p>

<p>You can then access what’s inside by calling <code>GetString</code> or <code>GetObject</code> with a cast:</p>

<pre data-type="programlisting">
string greeting = r.GetString ("Greeting");
int fontSize = (int) r.GetObject ("DefaultFontSize");
Image image = (Image) r.GetObject ("flag.png");      </pre>

<p>To enumerate the contents of a <em>.resources</em> file:<a contenteditable="false" data-primary="" data-startref="ch17.html10" data-type="indexterm" id="id4073"/><a contenteditable="false" data-primary="" data-startref="ch17.html9" data-type="indexterm" id="id4074"/></p>

<pre data-type="programlisting">
ResourceManager r = new ResourceManager (...);
ResourceSet set = r.GetResourceSet (CultureInfo.CurrentUICulture,
                                    true, true);
foreach (System.Collections.DictionaryEntry entry in set)
  Console.WriteLine (entry.Key);</pre>
</div></section>

<section data-pdf-bookmark="Creating a pack URI resource in Visual Studio" data-type="sect3"><div class="sect3" id="creating_a_pack_uri_resource_in_visual">
<h3>Creating a pack URI resource in Visual Studio</h3>

<p><a contenteditable="false" data-primary="Extensible Application Markup Language (XAML) files" data-type="indexterm" id="id4075"/><a contenteditable="false" data-primary="resources, in assemblies" data-secondary="creating a pack URI resource in Visual Studio" data-type="indexterm" id="id4076"/><a contenteditable="false" data-primary="XAML (Extensible Application Markup Language) files" data-type="indexterm" id="id4077"/>In a WPF application, XAML files need to be able to access resources by URI. For instance:</p>

<pre data-type="programlisting">
&lt;Button&gt;
  &lt;Image Height="50" Source="flag.png"/&gt;
&lt;/Button&gt;</pre>

<p>Or, if the resource is in another assembly:</p>

<pre data-type="programlisting">
&lt;Button&gt;
  &lt;Image Height="50" Source="UtilsAssembly;Component/flag.png"/&gt;
&lt;/Button&gt;</pre>

<p>(<code>Component</code> is a literal keyword.)</p>

<p>To create resources that can be loaded in this manner, you cannot use <em>.resx</em> files. Instead, you must add the files to your project and set their build action to Resource (not Embedded Resource). Visual Studio then compiles them into a <em>.resources</em> file called <em>&lt;AssemblyName&gt;.g.resources</em>—also the home of compiled XAML (<em>.baml</em>) files.</p>

<p>To load a URI-keyed resource programmatically, call <code>Application.GetResource​Stream</code>:</p>

<pre data-type="programlisting">
Uri u = new Uri ("flag.png", UriKind.Relative);
using (Stream s = Application.GetResourceStream (u).Stream)</pre>

<p>Notice we used a relative URI. You can also use an absolute URI in exactly the following format (the three commas are not a typo):</p>

<pre data-type="programlisting">
Uri u = new Uri ("pack://application:,,,/flag.png");</pre>

<p>If you’d rather specify an <code>Assembly</code> object, you can retrieve content instead with a <code>ResourceManager</code>:</p>

<pre data-type="programlisting">
Assembly a = Assembly.GetExecutingAssembly();
ResourceManager r = new ResourceManager (a.GetName().Name + ".g", a);
using (Stream s = r.GetStream ("flag.png"))
  ...</pre>

<p>A <code>ResourceManager</code> also lets you enumerate the content of a <em>.g.resources</em> container within a given assembly.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Satellite Assemblies" data-type="sect2"><div class="sect2" id="satellite_assemblies">
<h2>Satellite Assemblies</h2>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="satellite assemblies" data-type="indexterm" id="ch17.html11"/><a contenteditable="false" data-primary="satellite assemblies" data-type="indexterm" id="ch17.html12"/>Data embedded in <em>.resources</em> is localizable.</p>

<p>Resource localization is relevant when your application runs on a version of Windows built to display everything in a different language. For consistency, your application should use that same language, too.</p>

<p>A typical setup is as follows:</p>

<ul>
	<li>
	<p>The main assembly contains <em>.resources</em> for the default, or <em>fallback</em>, language.</p>
	</li>
	<li>
	<p>Separate <em>satellite assemblies</em> contain localized <em>.resources</em> translated to different languages.</p>
	</li>
</ul>

<p><a contenteditable="false" data-primary="CultureInfo.CurrentUICulture" data-type="indexterm" id="id4078"/>When your application runs, .NET examines the language of the current OS (from <code>CultureInfo.CurrentUICulture</code>). Whenever you request a resource using <code>Resour⁠ce​Manager</code>, the runtime looks for a localized satellite assembly. If one’s available—and it contains the resource key you requested—it’s used in place of the main assembly’s version.</p>

<p>This means that you can enhance language support simply by adding new satellites—without changing the main assembly.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A satellite assembly cannot contain executable code, only resources.</p>
</div>

<p>Satellite assemblies are deployed in subdirectories of the assembly’s folder, as <span class="keep-together">follows</span>:</p>

<pre data-type="programlisting">
programBaseFolder\MyProgram.exe
                 \MyLibrary.exe
                 \<em>XX</em>\MyProgram.resources.dll
                 \<em>XX</em>\MyLibrary.resources.dll</pre>

<p><code><em>XX</em></code> refers to the two-letter language code (such as “de” for German) or a language and region code (such as “en-GB” for English in Great Britain). This naming system allows the CLR to find and load the correct satellite assembly automatically.</p>

<section data-pdf-bookmark="Building satellite assemblies" data-type="sect3"><div class="sect3" id="building_satellite_assemblies">
<h3>Building satellite assemblies</h3>

<p><a contenteditable="false" data-primary="satellite assemblies" data-secondary="building" data-type="indexterm" id="id4079"/>Recall our previous <em>.resx</em> example, which included the following:</p>

<pre data-type="programlisting">
&lt;root&gt;
  ...
  &lt;data name="Greeting"
    &lt;value&gt;hello&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;</pre>

<p>We then retrieved the greeting at runtime as follows:</p>

<pre data-type="programlisting">
ResourceManager r = new ResourceManager ("welcome",
                                         Assembly.GetExecutingAssembly());
Console.Write (r.GetString ("Greeting"));</pre>

<p>Suppose that we want this to instead write “hallo” if running on the German version of Windows. The first step is to add another <em>.resx</em> file named <em>welcome.de.resx</em> that substitutes <em>hello</em> for <em>hallo</em>:</p>

<pre data-type="programlisting">
&lt;root&gt;
  &lt;data name="Greeting"&gt;
    &lt;value&gt;hallo&lt;value&gt;
  &lt;/data&gt;
&lt;/root&gt;</pre>

<p>In Visual Studio, this is all you need to do—when you rebuild, a satellite assembly called <em>MyApp.resources.dll</em> is automatically created in a subdirectory called <em>de</em>.</p>
</div></section>

<section data-pdf-bookmark="Testing satellite assemblies" data-type="sect3"><div class="sect3" id="testing_satellite_assemblies">
<h3>Testing satellite assemblies</h3>

<p><a contenteditable="false" data-primary="satellite assemblies" data-secondary="testing" data-type="indexterm" id="id4080"/>To simulate running on an OS with a different language, you must change the <code>CurrentUICulture</code> using the <code>Thread</code> class:</p>

<pre data-type="programlisting">
System.Threading.Thread.CurrentThread.CurrentUICulture
  = new System.Globalization.CultureInfo ("de");</pre>

<p><code>CultureInfo.CurrentUICulture</code> is a read-only version of the same property.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A useful testing strategy is to ℓѻ¢αℓïʐɘ into words that can still be read as English but do not use the standard Roman Unicode characters.</p>
</div>
</div></section>

<section data-pdf-bookmark="Visual Studio designer support" data-type="sect3"><div class="sect3" id="visual_studio_designer_support">
<h3>Visual Studio designer support</h3>

<p><a contenteditable="false" data-primary="satellite assemblies" data-secondary="Visual Studio designer support" data-type="indexterm" id="id4081"/>The designers in Visual Studio provide extended support for localizing components and visual elements. The WPF designer has its own workflow for localization; other <code>Component</code>-based designers use a design-time-only property to make it appear that a component or Windows Forms control has a <code>Language</code> property. To customize for another language, simply change the <code>Language</code> property and then start modifying the component. All properties of controls that are attributed as <code>Localizable</code> will be saved to a <em>.resx</em> file for that language. You can switch between languages at any time just by changing the <code>Language</code> property.<a contenteditable="false" data-primary="" data-startref="ch17.html12" data-type="indexterm" id="id4082"/><a contenteditable="false" data-primary="" data-startref="ch17.html11" data-type="indexterm" id="id4083"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Cultures and Subcultures" data-type="sect2"><div class="sect2" id="cultures_and_subcultures">
<h2>Cultures and Subcultures</h2>

<p><a contenteditable="false" data-primary="cultures and subcultures" data-type="indexterm" id="id4084"/><a contenteditable="false" data-primary="satellite assemblies" data-secondary="cultures and subcultures" data-type="indexterm" id="id4085"/><a contenteditable="false" data-primary="subcultures" data-type="indexterm" id="id4086"/>Cultures are split into cultures and subcultures. A culture represents a particular language; a subculture represents a regional variation of that language. The .NET runtime follows the <code>RFC1766</code> standard, which represents cultures and subcultures with two-letter codes. Here are the codes for English and German cultures:</p>

<pre data-type="programlisting">
En
de</pre>

<p class="pagebreak-before">Here are the codes for the Australian English and Austrian German subcultures:</p>

<pre data-type="programlisting">
en-AU
de-AT</pre>

<p><a contenteditable="false" data-primary="System..." data-secondary="System.Globalization.CultureInfo" data-type="indexterm" id="id4087"/>A culture is represented in .NET with the <code>System.Globalization.CultureInfo</code> class. You can examine the current culture of your application, as follows:</p>

<pre data-type="programlisting">
Console.WriteLine (System.Threading.Thread.CurrentThread.CurrentCulture);
Console.WriteLine (System.Threading.Thread.CurrentThread.CurrentUICulture);</pre>

<p>Running this on a computer localized for Australia illustrates the difference between the two:</p>

<pre data-type="programlisting">
en-AU
en-US</pre>

<p><code>CurrentCulture</code> reflects the regional settings of the Windows Control Panel, whereas <code>CurrentUICulture</code> reflects the language of the OS.</p>

<p>Regional settings include such things as time zone and the formatting of currency and dates. <code>CurrentCulture</code> determines the default behavior of such functions as <code>DateTime.Parse</code>. Regional settings can be customized to the point where they no longer resemble any particular culture.</p>

<p><code>CurrentUICulture</code> determines the language in which the computer communicates with the user. Australia doesn’t need a separate version of English for this purpose, so it just uses the US one. If I spent a couple of months working in Austria, I would go to the Control Panel and change my <code>CurrentCulture</code> to Austrian-German. However, given that I can’t speak German, my <code>CurrentUICulture</code> would remain US English.</p>

<p><code>ResourceManager</code>, by default, uses the current thread’s <code>CurrentUICulture</code> property to determine the correct satellite assembly to load. <code>ResourceManager</code> uses a fallback mechanism when loading resources. If a subculture assembly is defined, that one is used; otherwise, it falls back to the generic culture. If the generic culture is not present, it falls back to the default culture in the main assembly<a contenteditable="false" data-primary="" data-startref="ch17.html8" data-type="indexterm" id="id4088"/>.<a contenteditable="false" data-primary="" data-startref="ch17.html7" data-type="indexterm" id="id4089"/><a contenteditable="false" data-primary="" data-startref="ch17.html6" data-type="indexterm" id="id4090"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Loading, Resolving, and Isolating Assemblies" data-type="sect1"><div class="sect1" id="loadingcomma_resolvingcomma_and_isolati">
<h1>Loading, Resolving, and Isolating Assemblies</h1>

<p><a contenteditable="false" data-primary="assemblies" data-secondary="loading/resolving/isolating" data-type="indexterm" id="ch17.html13"/>Loading an assembly from a known location is a relatively simple process. We refer to this as <em>assembly loading</em>.</p>

<p><a contenteditable="false" data-primary="assembly resolution" data-type="indexterm" id="id4091"/>More commonly, however, you (or the CLR) will need to load an assembly knowing only its full (or simple) name. This is called <em>assembly resolution</em>. Assembly resolution differs from loading in that the assembly must first be located.</p>

<p>Assembly resolution is triggered in two scenarios:</p>

<ul>
	<li>
	<p>By the CLR, when it needs to resolve a dependency</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="Assembly..." data-secondary="Assembly.Load" data-type="indexterm" id="id4092"/>Explicitly, when you call a method such as <code>Assembly.Load(AssemblyName)</code></p>
	</li>
</ul>

<p>To illustrate the first scenario, consider an application comprising a main assembly plus a set of statically referenced library assemblies (dependencies), as shown in this example:</p>

<pre data-type="programlisting">
AdventureGame.dll    // Main assembly
Terrain.dll          // Referenced assembly
UIEngine.dll         // Referenced assembly</pre>

<p>By “statically referenced,” we mean that <em>AdventureGame.dll</em> was compiled with references to <em>Terrain.dll</em> and <em>UIEngine.dll</em>. The compiler itself does not need to perform assembly resolution, because it’s told (either explicitly or by MSBuild) where to find <em>Terrain.dll</em> and <em>UIEngine.dll</em>. During compilation, it writes the <em>full names</em> of the Terrain and UIEngine assemblies into the metadata of <em>AdventureGame.dll</em> but no information on where to find them. So, at runtime, the Terrain and UIEngine assemblies must be <em>resolved</em>.</p>

<p><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyLoadContext" data-type="indexterm" id="id4093"/>Assembly loading and resolution is handled by an <em>assembly load context</em> (ALC); <a contenteditable="false" data-primary="System..." data-secondary="System.Runtime.Loader" data-type="indexterm" id="id4094"/>specifically, an instance of the <code>AssemblyLoadContext</code> class in <code>System.Runtime.Loader</code>. Because <em>AdventureGame.dll</em> is the main assembly for the application, the CLR uses the <em>default ALC</em> (<code>AssemblyLoadContext.Default</code>) to resolve its dependencies. The default ALC resolves dependencies first by looking for and examining a file called <em>AdventureGame.deps.json</em> (which describes where to find dependencies), or if not present, it looks in the application base folder, where it will find <em>Terrain.dll</em> and <em>UIEngine.dll</em>. (The default ALC also resolves the .NET runtime assemblies.)</p>

<p>As a developer, you can dynamically load additional assemblies during the execution of your program. For example, you might want to package optional features in assemblies that you deploy only when those features have been purchased. In such a case, you could load the extra assemblies, when present, by calling <code>Assembly</code>​.<code>Load(AssemblyName)</code>.</p>

<p>A more complex example would be implementing a plug-in system whereby the user can provide third-party assemblies that your application detects and loads at runtime to extend your application’s functionality. The complexity arises because each plug-in assembly might have its own dependencies that must also be resolved.</p>

<p>By subclassing <code>AssemblyLoadContext</code> and overriding its assembly resolution method (<code>Load</code>), you can control how a plug-in finds its dependencies. For example, you might decide that each plug-in should reside in its own folder, and its dependencies should also reside in that folder.</p>

<p>ALCs have another purpose: by instantiating a separate <code>AssemblyLoadContext</code> for each (plug-in + dependencies), you can keep each isolated, ensuring that their dependencies load in parallel and do not interfere with one another (nor the host application). Each, for instance, can have its own version of JSON.NET. Hence, in addition to <em>loading</em> and <em>resolution</em>, ALCs also provide a mechanism for <em>isolation</em>. Under certain conditions, ALCs can even be <em>unloaded</em>, freeing their memory.</p>

<p class="pagebreak-before">In this section, we elaborate on each of these principles and describe the following:</p>

<ul>
	<li>
	<p>How ALCs handle loading and resolution</p>
	</li>
	<li>
	<p>The role of the default ALC</p>
	</li>
	<li>
	<p><code>Assembly.Load</code> and contextual ALCs</p>
	</li>
	<li>
	<p>How to use <code>AssemblyDependencyResolver</code></p>
	</li>
	<li>
	<p>How to load and resolve unmanaged libraries</p>
	</li>
	<li>
	<p>Unloading ALCs</p>
	</li>
	<li>
	<p>The legacy assembly loading methods</p>
	</li>
</ul>

<p>Then, we put the theory to work and demonstrate how to write a plug-in system with ALC isolation.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>AssemblyLoadContext</code> class is new to .NET 5+ and .NET Core. In .NET Framework, ALCs were present but restricted and hidden: the only way to create and interact with them was indirectly via the <code>LoadFile(string)</code>, <code>LoadFrom(string)</code>, and <code>Load(byte[])</code> static methods on the <code>Assembly</code> class. Compared to the ALC API, these methods are inflexible, and their use can lead to surprises (particularly when handling dependencies). For this reason, it’s best to favor explicit use of the <code>AssemblyLoadContext</code> API in .NET 5+ and .NET Core.</p>
</div>

<section data-pdf-bookmark="Assembly Load Contexts" data-type="sect2"><div class="sect2" id="assembly_load_contexts">
<h2>Assembly Load Contexts</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-type="indexterm" id="ch17.html14"/>As we just discussed, the <code>AssemblyLoadContext</code> class is responsible for loading and resolving assemblies as well as providing a mechanism for isolation.</p>

<p>Every .NET <code>Assembly</code> object belongs to exactly one <code>AssemblyLoadContext</code>. You can obtain the ALC for an assembly, as follows:</p>

<pre data-type="programlisting">
Assembly assem = Assembly.GetExecutingAssembly();
AssemblyLoadContext context = AssemblyLoadContext.<strong>GetLoadContext</strong> (assem);
Console.WriteLine (context.Name);</pre>

<p>Conversely, you can think of an ALC as “containing” or “owning” assemblies, which you can obtain via its <code>Assemblies</code> property. Following on from the previous <span class="keep-together">example</span>:</p>

<pre data-type="programlisting">
foreach (Assembly a in context.Assemblies)
  Console.WriteLine (a.FullName);</pre>

<p>The <code>AssemblyLoadContext</code> class also has a static <code>All</code> property that enumerates all ALCs.</p>

<p>You can create a new ALC just by instantiating <code>AssemblyLoadContext</code> and providing a name (the name is helpful when debugging), although more commonly, you’d first subclass <code>AssemblyLoadContext</code> so that you can implement logic to <em>resolve</em> dependencies; in other words, load an assembly from its <em>name</em>.</p>

<section data-pdf-bookmark="Loading assemblies" data-type="sect3"><div class="sect3" id="loading_assemblies">
<h3>Loading assemblies</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="loading assemblies" data-type="indexterm" id="id4095"/><code>AssemblyLoadContext</code> provides the following methods to explicitly load an assembly into its context:</p>

<pre data-type="programlisting">
public Assembly LoadFromAssemblyPath (string assemblyPath);
public Assembly LoadFromStream (Stream assembly, Stream assemblySymbols);</pre>

<p>The first method loads an assembly from a file path, whereas the second method loads it from a <code>Stream</code> (which can come directly from memory). The second parameter is optional and corresponds to the contents of the project debug (<em>.pdb</em>) file, which allows stack traces to include source code information when code executes (useful in exception reporting).</p>

<p>With both of these methods, no <em>resolution</em> takes place.</p>

<p>The following loads the assembly <em>c:\temp\foo.dll</em> into its own ALC:</p>

<pre data-type="programlisting">
var alc = new AssemblyLoadContext ("Test");
Assembly assem = alc.LoadFromAssemblyPath (@"c:\temp\foo.dll");</pre>

<p>If the assembly is valid, loading will always succeed, subject to one important rule: an assembly’s <em>simple name</em> must be unique within its ALC. This means that you cannot load multiple versions of the same-named assembly into a single ALC; to do this, you must create additional ALCs. We could load another copy of <em>foo.dll</em>, as <span class="keep-together">follows</span>:</p>

<pre data-type="programlisting">
var alc2 = new AssemblyLoadContext ("Test 2");
Assembly assem2 = alc2.LoadFromAssemblyPath (@"c:\temp\foo.dll");</pre>

<p>Note that types that originate from different <code>Assembly</code> objects are incompatible even if the assemblies are otherwise identical. In our example, the types in <code>assem</code> are incompatible with the types in <code>assem2</code>.</p>

<p>After an assembly is loaded, it cannot be unloaded except by unloading its ALC (see <a data-type="xref" href="#unloading_alcs">“Unloading ALCs”</a>). The CLR maintains a lock of the file for the duration that it’s loaded.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can avoid locking the file by loading the assembly via a byte array:</p>

<pre data-type="programlisting">
bytes[] bytes = File.ReadAllBytes (@"c:\temp\foo.dll");
var ms = new MemoryStream (bytes);
var assem = alc.LoadFromStream (ms);</pre>

<p>This has two drawbacks:</p>

<ul>
	<li>
	<p>The assembly’s <code>Location</code> property will end up blank. Sometimes, it’s useful to know where an assembly was loaded from (and some APIs rely on it being populated).</p>
	</li>
	<li>
	<p>Private memory consumption must increase immediately to accommodate the full size of the assembly. If you instead load from a filename, the CLR uses a memory-mapped file, which enables lazy loading and process sharing. Also, should memory run low, the OS can release its memory and reload as required without writing to a page file.</p>
	</li>
</ul>
</div>
</div></section>

<section data-pdf-bookmark="LoadFromAssemblyName" data-type="sect3"><div class="sect3" id="loadfromassemblyname">
<h3>LoadFromAssemblyName</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="LoadFromAssemblyName" data-type="indexterm" id="id4096"/><a contenteditable="false" data-primary="Load..." data-secondary="LoadFromAssemblyName method" data-type="indexterm" id="id4097"/><code>AssemblyLoadContext</code> also provides the following method, which loads an assembly by <em>name</em>:</p>

<pre data-type="programlisting">
public Assembly LoadFromAssemblyName (AssemblyName assemblyName);</pre>

<p>Unlike the two methods just discussed, you don’t pass in any information to indicate where the assembly is located; instead you’re instructing the ALC to <em>resolve</em> the assembly.</p>
</div></section>

<section data-pdf-bookmark="Resolving assemblies" data-type="sect3"><div class="sect3" id="resolving_assemblies">
<h3>Resolving assemblies</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="resolving assemblies" data-type="indexterm" id="ch17.html15"/><a contenteditable="false" data-primary="assembly resolution" data-type="indexterm" id="ch17.html16"/>The preceding method triggers <em>assembly resolution</em>. The CLR also triggers assembly resolution when loading dependencies. For example, suppose that assembly A statically references assembly B. To resolve reference B, the CLR triggers assembly resolution on whichever <em>ALC assembly A was loaded into.</em></p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The CLR resolves dependencies by triggering assembly resolution—whether the triggering assembly is in the default or a custom ALC. The difference is that with the default ALC, the resolution rules are hardcoded, whereas with a custom ALC, you write the rules yourself.</p>
</div>

<p>Here’s what then happens:</p>

<ol>
	<li>
	<p>The CLR first checks whether an identical resolution has already taken place in that ALC (with a matching full assembly name); if so, it returns the <code>Assembly</code> it returned before.</p>
	</li>
	<li>
	<p>Otherwise, it calls the ALC’s (virtual protected) <code>Load</code> method, which does the work of locating and loading the assembly. The default ALC’s <code>Load</code> method applies the rules we describe in <a data-type="xref" href="#the_default_alc">“The Default ALC”</a>. With a custom ALC, it’s entirely up to you how you locate the assembly. For instance, you might look in some folder and then call <code>LoadFromAssemblyPath</code> when you find the assembly. It’s also perfectly legal to return an already-loaded assembly from the same or another ALC (we demonstrate this in <a data-type="xref" href="#writing_a_plug_in_system">“Writing a Plug-In System”</a>).</p>
	</li>
	<li>
	<p>If Step 2 returns null, the CLR then calls the <code>Load</code> method on the default ALC (this serves as a useful “fallback” for resolving .NET runtime and common application assemblies).</p>
	</li>
	<li>
	<p>If Step 3 returns null, the CLR then fires the <code>Resolving</code> events on both ALCs—first, on the default ALC and then on the original ALC.</p>
	</li>
	<li>
	<p>(For compatibility with .NET Framework): If the assembly still hasn’t been resolved, the <code>AppDomain.CurrentDomain.AssemblyResolve</code> event fires.</p>

	<div data-type="note" epub:type="note"><h6>Note</h6>
	<p>After this process completes, the CLR does a “sanity check” to ensure that whatever assembly was loaded has a name that’s compatible with what was requested. The simple name must match; the public key token must match <em>if specified</em>. The version need not match—it can be higher or lower than what was requested.</p>
	</div>
	</li>
</ol>

<p>From this, we can see that there are two ways to implement assembly resolution in a custom ALC:</p>

<ul>
	<li>
	<p>Override the ALC’s <code>Load</code> method. This gives your ALC “first say” over what happens, which is usually desirable (and essential when you need isolation).</p>
	</li>
	<li>
	<p>Handle the ALC’s <code>Resolving</code> event. This fires only <em>after</em> the default ALC has failed to resolve assembly.</p>
	</li>
</ul>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you attach multiple event handlers to the <code>Resolving</code> event, the first to return a non-null value wins.</p>
</div>

<p>To illustrate, let’s assume that we want to load an assembly that our main application knew nothing about at compile time, called <em>foo.dll</em>, located in <em>c:\temp</em> (which is different from our application folder). We’ll also assume that <em>foo.dll</em> has a private dependency on <em>bar.dll</em>. We want to ensure that when we load <em>c:\temp\foo.dll</em> and execute its code, <em>c:\temp\bar.dll</em> can correctly resolve. We also want to ensure that <code>foo</code> and its private dependency, <code>bar</code>, do not interfere with the main application.</p>

<p>Let’s begin by writing a custom ALC that overrides <code>Load</code>:</p>

<pre data-type="programlisting">
using System.IO;
using System.Runtime.Loader;

class FolderBasedALC : AssemblyLoadContext
{
  readonly string _folder;
  public FolderBasedALC (string folder) =&gt; _folder = folder;

  <strong>protected override Assembly Load (AssemblyName assemblyName)</strong>
  {
    // Attempt to find the assembly:
    string targetPath = Path.Combine (_folder, assemblyName.Name + ".dll");

    if (File.Exists (targetPath))
      return <strong>LoadFromAssemblyPath (targetPath);</strong>   // Load the assembly

    return null;    // We can’t find it: it could be a .NET runtime assembly
  }
}</pre>

<p>Notice that in the <code>Load</code> method, we return <code>null</code> if the assembly file is not present. This check is important because <em>foo.dll</em> will also have dependencies on the .NET BCL assemblies; hence, the <code>Load</code> method will be called on assemblies such as <code>System.Runtime</code>. By returning null, we allow the CLR to fall back to the default ALC, which will correctly resolve these assemblies.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Notice that we didn’t attempt to load the .NET runtime BCL assemblies into our own ALC. These system assemblies are not designed to run outside the default ALC, and attempts to load them into your own ALC can result in incorrect <span class="keep-together">behavior, performance</span> degradation, and unexpected type incompatibility.</p>
</div>

<p>Here’s how we could use our custom ALC to load the <em>foo.dll</em> assembly in <em>c:\temp</em>:</p>

<pre data-type="programlisting">
var alc = new FolderBasedALC (@"c:\temp");
Assembly foo = alc.LoadFromAssemblyPath (@"c:\temp\foo.dll");
...</pre>

<p>When we subsequently begin calling code in the <code>foo</code> assembly, the CLR will at some point need to resolve the dependency on <em>bar.dll</em>. This is when the custom ALC’s <code>Load</code> method will fire and successfully locate the <em>bar.dll</em> assembly in <em>c:\temp</em>.</p>

<p>In this case, our <code>Load</code> method is also capable of resolving <em>foo.dll</em>, so we could simplify our code to this:</p>

<pre data-type="programlisting">
var alc = new FolderBasedALC (@"c:\temp");
Assembly foo = alc.LoadFromAssembly<strong>Name</strong> (new AssemblyName ("foo"));
...</pre>

<p>Now, let’s consider an alternative solution: instead of subclassing <code>AssemblyLoad​Con⁠text</code> and overriding <code>Load</code>, we could instantiate a plain <code>AssemblyLoadContext</code> and handle its <code>Resolving</code> event:</p>

<pre data-type="programlisting">
var alc = new AssemblyLoadContext ("test");
alc.<strong>Resolving</strong> += (loadContext, assemblyName) =&gt;
{
  string targetPath = Path.Combine (@"c:\temp", assemblyName.Name + ".dll");
  return alc.<strong>LoadFromAssemblyPath (targetPath);</strong>   // Load the assembly
};
Assembly foo = alc.LoadFromAssembly<strong>Name</strong> (new AssemblyName ("foo"));</pre>

<p>Notice now that we don’t need to check whether the assembly exists. Because the <code>Resolving</code> event fires <em>after</em> the default ALC has had a chance to resolve the assembly (and only when it fails), our handler won’t fire for the .NET BCL assemblies. This makes this solution simpler, although there’s a disadvantage. Remember that in our scenario, the main application knew nothing about <em>foo.dll</em> or <em>bar.dll</em> at compile time. This means that it’s possible for the main application to itself depend on assemblies called <em>foo.dll</em> or <em>bar.dll</em>. If this were to occur, the <code>Resolving</code> event would never fire, and the application’s <code>foo</code> and <code>bar</code> assemblies would load instead. In other words, we would fail to achieve <em>isolation</em>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Our <code>FolderBasedALC</code> class is good for illustrating the concept of assembly resolution, but it’s of less use in real life because it cannot handle platform-specific and (for library projects) development-time NuGet dependencies. In <a data-type="xref" href="#assemblydependencyresolver">“AssemblyDependencyResolver”</a>, we describe the solution to this problem, and in <a data-type="xref" href="#writing_a_plug_in_system">“Writing a Plug-In System”</a>, we give a detailed example.<a contenteditable="false" data-primary="" data-startref="ch17.html16" data-type="indexterm" id="id4098"/><a contenteditable="false" data-primary="" data-startref="ch17.html15" data-type="indexterm" id="id4099"/></p>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="The Default ALC" data-type="sect2"><div class="sect2" id="the_default_alc">
<h2>The Default ALC</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="default ALC" data-type="indexterm" id="id4100"/>When an application starts, the CLR assigns a special ALC to the static <code>AssemblyLoadContext</code>.<code>Default</code> property. The default ALC is where your startup assembly loads, along with its statically referenced dependencies and the .NET runtime BCL assemblies.</p>

<p>The default ALC looks first in the <em>default probing</em> paths to automatically resolve assemblies (see <a data-type="xref" href="#default_probing">“Default probing”</a>); this normally equates to the locations indicated in the application’s <em>.deps.json</em> and <em>.runtimeconfig.json</em> files.</p>

<p>If the ALC cannot find an assembly in its default probing paths, its <code>Resolving</code> event fires. Handling this event lets you load the assembly from other locations, which means that you can deploy an application’s dependencies to additional locations, such as subfolders, shared folders, or even as a binary resource inside the host assembly:</p>

<pre data-type="programlisting">
AssemblyLoadContext.Default.Resolving += (loadContext, assemblyName) =&gt;
{
  // Try to locate assemblyName, returning an Assembly object or null.
  // Typically you’d call LoadFromAssemblyPath after finding the file.
  // ...
};</pre>

<p>The <code>Resolving</code> event in the default ALC also fires when a custom ALC fails to resolve (in other words, when its <code>Load</code> method returns <code>null</code>) and the default ALC is unable to resolve the assembly.</p>

<p>You can also load assemblies into the default ALC from outside the <code>Resolving</code> event. Before proceeding, however, you should first determine whether you can solve the problem better by using a separate ALC or with the approaches we describe in the following section (which use the <em>executing</em> and <em>contextual</em> ALCs). Hardcoding to the default ALC makes your code brittle because it cannot as a whole be isolated (for instance, by unit testing frameworks or by LINQPad).</p>

<p>If you still want to proceed, it’s preferable to call a <em>resolution method</em> (i.e., <code>LoadFrom​AssemblyName</code>) rather than a <em>loading method</em> (such as <code>LoadFromAssemblyPath</code>)—especially if your assembly is statically referenced. This is because it’s possible that the assembly might already be loaded, in which case <code>LoadFromAssemblyName</code> will return the already-loaded assembly, whereas <code>LoadFromAssemblyPath</code> will throw an exception.</p>

<p>(With <code>LoadFromAssemblyPath</code>, you can also run the risk of loading the assembly from a place that’s inconsistent with where the ALC’s default resolution mechanism would find it.)</p>

<p>If the assembly is in a place where the ALC won’t automatically find it, you can still follow this procedure and additionally handle the ALC’s <code>Resolving</code> event.</p>

<p>Note that when calling <code>LoadFromAssemblyName</code>, you don’t need to provide the full name; the simple name will do (and is valid even if the assembly is strongly named):</p>

<pre data-type="programlisting">
AssemblyLoadContext.Default.LoadFromAssemblyName ("System.Xml");</pre>

<p>However, if you include the public key token in the name, it must match with what’s loaded.</p>

<section data-pdf-bookmark="Default probing" data-type="sect3"><div class="sect3" id="default_probing">
<h3>Default probing</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="default probing" data-type="indexterm" id="id4101"/>The default probing paths normally comprise the following:</p>

<ul>
	<li>
	<p>Paths specified in <em>AppName.deps.json</em> (where <em>AppName</em> is the name of your application’s main assembly). If this file is not present, the application base folder is used instead.</p>
	</li>
	<li>
	<p>Folders containing the .NET runtime system assemblies (if your application is Framework-dependent).</p>
	</li>
</ul>

<p>MSBuild automatically generates a file called <em>AppName.deps.json</em>, which describes where to find all of its dependencies. These include platform-agnostic assemblies, which are placed in the application base folder, and platform-specific assemblies, which are placed in the <em>runtimes\</em> subdirectory under a subfolder such as <em>win</em> or <em>unix</em>.</p>

<p>The paths specified in the generated <em>.deps.json</em> file are relative to the application base folder—or any additional folders that you specify in the <code>additionalProbingPaths</code> section of the <em>AppName.runtimeconfig.json</em> and/or <em>AppName.runtimeconfig.dev.json</em> configuration files (the latter is intended only for the development environment).</p>
</div></section>
</div></section>

<section data-pdf-bookmark="The “Current” ALC" data-type="sect2"><div class="sect2" id="the_quotation_markcurrentquotation_mark">
<h2>The “Current” ALC</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="current ALC" data-type="indexterm" id="id4102"/>In the preceding section, we cautioned against explicitly loading assemblies into the default ALC. What you usually want, instead, is to load/resolve into the “current” ALC.</p>

<p>In most cases, the “current” ALC is the one containing the currently executing assembly:</p>

<pre data-type="programlisting">
var executingAssem = <strong>Assembly.GetExecutingAssembly()</strong>;
var alc = AssemblyLoadContext.GetLoadContext (executingAssem);

Assembly assem = alc.LoadFromAssemblyName (...);  // to resolve by name
        // OR: = alc.LoadFromAssemblyPath (...);  // to load by path</pre>

<p>Here’s a more flexible and explicit way to obtain the ALC:</p>

<pre data-type="programlisting">
var myAssem = <strong>typeof (SomeTypeInMyAssembly).Assembly</strong>;
var alc = AssemblyLoadContext.GetLoadContext (myAssem);
...</pre>

<p>Sometimes, it’s impossible to infer the “current” ALC. For example, suppose that you were responsible for writing the .NET binary serializer (we describe serialization in the online supplement at <a href="http://www.albahari.com/nutshell"><em>http://www.albahari.com/nutshell</em></a>). A serializer such as this writes the full names of the types that it serializes (including their assembly names), which must be <em>resolved</em> during deserialization. The question is, which ALC should you use? The problem with relying on the executing assembly is that it will return whatever assembly contains the deserializer, not the assembly that’s <em>calling</em> the deserializer.</p>

<p>The best solution is not to guess but to ask:</p>

<pre data-type="programlisting">
public object Deserialize (Stream stream, <strong>AssemblyLoadContext alc</strong>)
{
  ...
}</pre>

<p>Being explicit maximizes flexibility and minimizes the chance of making mistakes. The caller can now decide what should count as the “current” ALC:</p>

<pre data-type="programlisting">
var assem = <strong>typeof (SomeTypeThatIWillBeDeserializing).Assembly</strong>;
var alc = AssemblyLoadContext.GetLoadContext (assem);
var object = Deserialize (someStream, <strong>alc</strong>);</pre>
</div></section>

<section data-pdf-bookmark="Assembly.Load and Contextual ALCs" data-type="sect2"><div class="sect2" id="assemblydotload_and_contextual_alcs">
<h2>Assembly.Load and Contextual ALCs</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="Assembly.Load and contextual ALCs" data-type="indexterm" id="ch17.html17"/><a contenteditable="false" data-primary="Assembly..." data-secondary="Assembly.Load" data-type="indexterm" id="ch17.html18"/>To help with the common case of loading an assembly into the currently executing ALC; that is:</p>

<pre data-type="programlisting">
var executingAssem = <strong>Assembly.GetExecutingAssembly()</strong>;
var alc = AssemblyLoadContext.GetLoadContext (executingAssem);
Assembly assem = alc.LoadFromAssemblyName (...);</pre>

<p>Microsoft has defined the following method in the <code>Assembly</code> class:</p>

<pre data-type="programlisting">
public static Assembly Load (string assemblyString);</pre>

<p>as well as a functionally identical version that accepts an <code>AssemblyName</code> object:</p>

<pre data-type="programlisting">
public static Assembly Load (AssemblyName assemblyRef);</pre>

<p>(Don’t confuse these methods with the legacy <code>Load(byte[])</code> method, which behaves in a totally different manner—see <a data-type="xref" href="#the_legacy_loading_methods">“The Legacy Loading Methods”</a>.)</p>

<p>As with <code>LoadFromAssemblyName</code>, you have a choice of specifying the assembly’s simple, partial, or full name:</p>

<pre data-type="programlisting">
Assembly a = Assembly.Load ("System.Private.Xml");</pre>

<p>This loads the <code>System.Private.Xml</code> assembly into whatever ALC the <em>executing code’s assembly</em> is loaded in.</p>

<p>In this case, we specified a simple name. The following strings would also be valid, and all would have the same result in .NET:</p>

<pre data-type="programlisting">
"System.Private.Xml, PublicKeyToken=cc7b13ffcd2ddd51"
"System.Private.Xml, Version=4.0.1.0"
"System.Private.Xml, Version=4.0.1.0, PublicKeyToken=cc7b13ffcd2ddd51"</pre>

<p>If you choose to specify a public key token, it must match with what’s loaded.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Microsoft Developer Network (MSDN) cautions against loading an assembly from a partial name, recommending that you specify the exact version and public key token. Their rationale is based on factors relevant to .NET Framework, such as the effects of the Global Assembly Cache and Code Access Security. In .NET 5+ and .NET Core, these factors aren’t present, and it’s generally safe to load from a simple or partial name.</p>
</div>

<p>Both of these methods are strictly for <em>resolution</em>, so you cannot specify a file path. (If you populate the <code>CodeBase</code> property in the <code>AssemblyName</code> object, it will be ignored.)</p>

<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Don’t fall into the trap of using <code>Assembly.Load</code> to load a statically referenced assembly. All you need do in this case is refer to a type in the assembly and obtain the assembly from that:</p>

<pre data-type="programlisting">
Assembly a = typeof (System.Xml.Formatting).Assembly;</pre>

<p>Or, you could even do this:</p>

<pre data-type="programlisting">
Assembly a = System.Xml.Formatting.Indented.GetType().Assembly;</pre>

<p>This prevents hardcoding the assembly name (which you might change in the future) while triggering assembly resolution on the <em>executing code’s</em> ALC (as would happen with <span class="keep-together"><code>Assembly.Load</code></span>).</p>
</div>

<p>If you were to write the <code>Assembly</code>.<code>Load</code> method yourself, it would (almost) look like this:</p>

<pre data-type="programlisting">
[MethodImpl(MethodImplOptions.NoInlining)]
Assembly Load (string name)
{
  Assembly callingAssembly = Assembly.<strong>GetCallingAssembly()</strong>;
  var callingAlc = AssemblyLoadContext.GetLoadContext (callingAssembly);
  return callingAlc.<strong>LoadFromAssemblyName</strong> (new AssemblyName (name));
}</pre>

<section data-pdf-bookmark="EnterContextualReflection" data-type="sect3"><div class="sect3" id="entercontextualreflection">
<h3>EnterContextualReflection</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="EnterContextualReflection" data-type="indexterm" id="ch17.html19"/><a contenteditable="false" data-primary="EnterContextualReflection" data-type="indexterm" id="ch17.html20"/><code>Assembly</code>.<code>Load</code>’s strategy of using the calling assembly’s ALC context fails when <code>Assembly</code>.<code>Load</code> is called via an intermediary, such as a deserializer or unit test runner. If the intermediary is defined in a different assembly, the intermediary’s load context is used instead of the caller’s load context.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We described this scenario earlier, when we talked about how you might write a deserializer. In such cases, the ideal solution is to force the caller to specify an ALC rather than inferring it with <code>Assembly.Load(string)</code>.</p>

<p>But because .NET 5+ and .NET Core evolved from .NET Framework—where isolation was accomplished with application domains rather than ALCs—the ideal solution is not prevalent, and <code>Assembly.Load(string)</code> is sometimes used inappropriately in scenarios in which the ALC cannot be reliably inferred. An example is the .NET binary serializer.</p>
</div>

<p>To allow <code>Assembly</code>.<code>Load</code> to still work in such scenarios, Microsoft has added a method to <code>AssemblyLoadContext</code> called <code>EnterContextualReflection</code>. This assigns an ALC to <code>AssemblyLoadContext</code>.<code>CurrentContextualReflectionContext</code>. Although this is a static property, its value is stored in an <code>AsyncLocal</code> variable, so it can hold separate values on different threads (but still be preserved throughout asynchronous operations).</p>

<p>If this property is non-null, <code>Assembly</code>.<code>Load</code> automatically uses it in preference to the calling ALC:</p>

<pre data-type="programlisting">
Method1();

var myALC = new AssemblyLoadContext ("test");
using (myALC.<strong>EnterContextualReflection()</strong>)
{
   Console.WriteLine (
     AssemblyLoadContext.CurrentContextualReflectionContext.Name);  // test

   Method2();
}

// Once disposed, EnterContextualReflection() no longer has an effect.
Method3();

void Method1() =&gt; Assembly.Load ("...");    // Will use calling ALC
void Method2() =&gt; Assembly.Load ("...");    // Will use myALC
void Method3() =&gt; Assembly.Load ("...");    // Will use calling ALC</pre>

<p>We previously demonstrated how you could write a method that’s functionally similar to <code>Assembly</code>.<code>Load</code>. Here’s a more accurate version that takes the contextual reflection context into account:</p>

<pre data-type="programlisting">
[MethodImpl(MethodImplOptions.NoInlining)]
Assembly Load (string name)
{
  var alc = <strong>AssemblyLoadContext.CurrentContextualReflectionContext</strong>
     ?? AssemblyLoadContext.GetLoadContext (Assembly.GetCallingAssembly());

  return alc.<strong>LoadFromAssemblyName</strong> (new AssemblyName (name));
}</pre>

<p>Even though the contextual reflection context can be useful in allowing legacy code to run, a more robust solution (as we described earlier) is to modify the code that calls <code>Assembly.Load</code> so that it instead calls <code>LoadFromAssemblyName</code> on an ALC that’s passed in by the caller.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>.NET Framework has no equivalent of <code>EnterContextualReflection</code>—and does not need it—despite having the same <code>Assembly</code>.<code>Load</code> methods. This is because with .NET Framework, isolation is accomplished primarily with <em>application domains</em> rather than ALCs. Application domains provide a stronger isolation model whereby each application domain has its own default load context, so isolation can still work even when only the default load context is used<a contenteditable="false" data-primary="" data-startref="ch17.html20" data-type="indexterm" id="id4103"/><a contenteditable="false" data-primary="" data-startref="ch17.html19" data-type="indexterm" id="id4104"/>.<a contenteditable="false" data-primary="" data-startref="ch17.html18" data-type="indexterm" id="id4105"/><a contenteditable="false" data-primary="" data-startref="ch17.html17" data-type="indexterm" id="id4106"/></p>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Loading and Resolving Unmanaged Libraries" data-type="sect2"><div class="sect2" id="loading_and_resolving_unmanaged_librari">
<h2>Loading and Resolving Unmanaged Libraries</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="loading/resolving unmanaged libraries" data-type="indexterm" id="id4107"/>ALCs can also load and resolve native libraries. Native resolution is triggered when you call an external method that’s marked with the <code>[DllImport]</code> attribute:</p>

<pre data-type="programlisting">
[DllImport ("SomeNativeLibrary.dll")]
static extern int SomeNativeMethod (string text);</pre>

<p>Because we didn’t specify a full path in the <code>[DllImport]</code> attribute, calling <code>Some​Nati⁠veMethod</code> triggers a resolution in whatever ALC contains the assembly in which <code>SomeNativeMethod</code> is defined.</p>

<p>The virtual <em>resolving</em> method in the ALC is called <code>LoadUnmanagedDll</code>, and the <em>loading</em> method is called <code>LoadUnmanagedDllFromPath</code>:</p>

<pre data-type="programlisting">
protected override IntPtr <strong>LoadUnmanagedDll</strong> (string unmanagedDllName)
{
  // Locate the full path of unmanagedDllName...
  string fullPath = ...
  return <strong>LoadUnmanagedDllFromPath (fullPath)</strong>;    // Load the DLL
}</pre>

<p>If you’re unable to locate the file, you can return <code>IntPtr.Zero</code>. The CLR will then fire the ALC’s <code>ResolvingUnmanagedDll</code> event.</p>

<p>Interestingly, the <code>LoadUnmanagedDllFromPath</code> method is protected, so you won’t usually be able to call it from a <code>ResolvingUnmanagedDll</code> event handler. However, you can achieve the same result by calling the static <code>NativeLibrary.Load</code>:</p>

<pre data-type="programlisting">
someALC.ResolvingUnmanagedDll += (requestingAssembly, unmanagedDllName) =&gt;
{
  return NativeLibrary.Load ("(full path to unmanaged DLL)");
};</pre>

<p>Although native libraries are typically resolved and loaded by ALCs, they don’t “belong” to an ALC. After it’s loaded, a native library stands on its own and takes responsibility for resolving any transitive dependencies that it might have. Furthermore, native libraries are global to the process, so it’s not possible to load two different versions of a native library if they have the same filename.</p>
</div></section>

<section data-pdf-bookmark="AssemblyDependencyResolver" data-type="sect2"><div class="sect2" id="assemblydependencyresolver">
<h2>AssemblyDependencyResolver</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="AssemblyDependencyResolver" data-type="indexterm" id="id4108"/><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyDependencyResolver" data-type="indexterm" id="id4109"/>In <a data-type="xref" href="#default_probing">“Default probing”</a>, we said that the default ALC reads the <em>.deps.json</em> and <em>.runtimeconfig.json</em> files, if present, in determining where to look to resolve platform-specific and development-time NuGet dependencies.</p>

<p>If you want to load an assembly into a custom ALC that has platform-specific or NuGet dependencies, you’ll need to somehow reproduce this logic. You could accomplish this by parsing the configuration files and carefully following the rules on platform-specific monikers, but doing so is not only difficult, but the code that you write will break if the rules change in a later version of .NET.</p>

<p>The <code>AssemblyDependencyResolver</code> class solves this problem. To use it, you instantiate it with the path of the assembly whose dependencies you want to probe:</p>

<pre data-type="programlisting">
var resolver = new AssemblyDependencyResolver (@"c:\temp\foo.dll");</pre>

<p>Then, to find the path of a dependency, you call the <code>ResolveAssemblyToPath</code> method:</p>

<pre data-type="programlisting">
string path = resolver.ResolveAssemblyToPath (new AssemblyName ("bar"));</pre>

<p>In the absence of a <em>.deps.json</em> file (or if the .<em>deps.json</em> doesn’t contain anything relevant to <em>bar.dll</em>), this will evaluate to <em>c:\temp\bar.dll</em>.</p>

<p>You can similarly resolve unmanaged dependencies by calling <code>ResolveUnmana⁠ged​DllToPath</code>.</p>

<p>A great way to illustrate a more complex scenario is to create a new Console project called <code>ClientApp</code> and then add a NuGet reference to <em>Microsoft.Data.SqlClient</em>. Add the following class:</p>

<pre data-type="programlisting">
using Microsoft.Data.SqlClient;

namespace ClientApp
{
  public class Program
  {
    public static SqlConnection GetConnection() =&gt; new SqlConnection();
    static void Main() =&gt; GetConnection();   // Test that it resolves
  }
}</pre>

<p>Now build the application and look in the output folder: you’ll see a file called <em>Microsoft.Data.SqlClient.dll</em>. However, this file <em>never loads</em> when run, and attempting to explicitly load it throws an exception. The assembly that actually loads is located in the <em>runtimes\win</em> (or <em>runtimes/unix</em>) subfolder; the default ALC knows to load it because it parses the <em>ClientApp.deps.json</em> file.</p>

<p>If you were to try to load the <em>ClientApp.dll</em> assembly from another application, you’d need to write an ALC that can resolve its dependency, <em>Microsoft.Data.SqlClient.dll</em>. In doing so, it would be insufficient to merely look in the folder where <em>ClientApp.dll</em> is located (as we did in <a data-type="xref" href="#resolving_assemblies">“Resolving assemblies”</a>). Instead, you’d need to use <code>AssemblyDependencyResolver</code> to determine where that file is located for the platform in use:</p>

<pre data-type="programlisting">
string path = @"C:\source\ClientApp\bin\Debug\netcoreapp3.0\ClientApp.dll";
var resolver = <strong>new AssemblyDependencyResolver (path)</strong>;
var sqlClient = new AssemblyName ("Microsoft.Data.SqlClient");
Console.WriteLine (<strong>resolver.ResolveAssemblyToPath (sqlClient)</strong>);</pre>

<p>On a Windows machine, this outputs the following:</p>

<pre data-type="programlisting">C:\source\ClientApp\bin\Debug\netcoreapp3.0\runtimes\win\lib\netcoreapp2.1
\Microsoft.Data.SqlClient.dll</pre>

<p>We give a complete example in <a data-type="xref" href="#writing_a_plug_in_system">“Writing a Plug-In System”</a>.</p>
</div></section>

<section data-pdf-bookmark="Unloading ALCs" data-type="sect2"><div class="sect2" id="unloading_alcs">
<h2>Unloading ALCs</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="unloading" data-type="indexterm" id="id4110"/>In simple cases, it’s possible to unload a nondefault <code>AssemblyLoadContext</code>, freeing memory and releasing file locks on the assemblies it loaded. For this to work, the ALC must have been instantiated with the <code>isCollectible</code> parameter <code>true</code>:</p>

<pre data-type="programlisting">
var alc = new AssemblyLoadContext ("test", isCollectible:true);</pre>

<p>You can then call the <code>Unload</code> method on the ALC to initiate the unload process.</p>

<p>The unload model is cooperative rather than preemptive. If any methods in any of the ALC’s assemblies are executing, the unload will be deferred until those methods finish.</p>

<p>The actual unload takes place during garbage collection; it will not take place if anything from outside the ALC has any (nonweak) reference to anything inside the ALC (including objects, types, and assemblies). It’s not uncommon for APIs (including those in the .NET BCL) to cache objects in static fields or dictionaries—or subscribe to events—and this makes it easy to create references that will prevent an unload, especially if code in the ALC uses APIs outside its ALC in a nontrivial way. Determining the cause of a failed unload is difficult and requires the use of tools such as WinDbg.</p>
</div></section>

<section data-pdf-bookmark="The Legacy Loading Methods" data-type="sect2"><div class="sect2" id="the_legacy_loading_methods">
<h2>The Legacy Loading Methods</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="legacy loading methods" data-type="indexterm" id="ch17.html21"/>If you’re still using .NET Framework (or writing a library that targets .NET Standard and want to support .NET Framework), you won’t be able to use the <span class="keep-together"><code>AssemblyLoadContext</code></span> class. Loading is accomplished instead by using the following methods:</p>

<pre data-type="programlisting">
public static Assembly LoadFrom (string assemblyFile);
public static Assembly LoadFile (string path);
public static Assembly Load (byte[] rawAssembly);</pre>

<p><code>LoadFile</code> and <code>Load(byte[])</code> provide isolation, whereas <code>LoadFrom</code> does not.</p>

<p>Resolution is accomplished by handling the application domain’s <code>AssemblyResolve</code> event, which works like the default ALC’s <code>Resolving</code> event.</p>

<p>The <code>Assembly.Load(string)</code> method is also available to trigger resolution and works in a similar way.</p>

<section data-pdf-bookmark="LoadFrom" data-type="sect3"><div class="sect3" id="loadfrom">
<h3>LoadFrom</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="LoadFrom method" data-type="indexterm" id="id4111"/><a contenteditable="false" data-primary="Load..." data-secondary="LoadFrom method" data-type="indexterm" id="id4112"/><code>LoadFrom</code> loads an assembly from a given path into the default ALC. It’s a bit like calling <code>AssemblyLoadContext.Default.LoadFromAssemblyPath</code> except for the <span class="keep-together">following</span>:</p>

<ul>
	<li>
	<p>If an assembly with the same simple name is already present in the default ALC, <code>LoadFrom</code> returns that assembly rather than throwing an exception.</p>
	</li>
	<li>
	<p>If an assembly with the same simple name is <em>not</em> already present in the default ALC and a load takes place, the assembly is given a special “LoadFrom” status. This status affects the default ALC’s resolution logic, in that should that assembly have any dependencies in the <em>same folder</em>, those dependencies will resolve automatically.</p>
	</li>
</ul>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>.NET Framework has a <em>Global Assembly Cache</em> (GAC). If the assembly is present in the GAC, the CLR will always load from there instead. This applies to all three loading methods.</p>
</div>

<p><code>LoadFrom</code>’s ability to automatically resolve transitive same-folder dependencies can be convenient—until it loads an assembly that it shouldn’t. Because such scenarios can be difficult to debug, it can be better to use <code>Load(string)</code> or <code>LoadFile</code> and resolve transitive dependencies by handling the application domain’s <code>AssemblyResolve</code> event. This gives you the power to decide how to resolve each assembly and allows for debugging (by creating a breakpoint inside the event handler).</p>
</div></section>

<section data-pdf-bookmark="LoadFile and Load(byte[])" data-type="sect3"><div class="sect3" id="loadfile_and_loadleft_parenthesisbytele">
<h3>LoadFile and Load(byte[])</h3>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="LoadFile and Load(byte[])" data-type="indexterm" id="id4113"/><a contenteditable="false" data-primary="Load..." data-secondary="Load(byte[]) method" data-type="indexterm" id="id4114"/><a contenteditable="false" data-primary="Load..." data-secondary="LoadFile method" data-type="indexterm" id="id4115"/><code>LoadFile</code> and <code>Load(byte[])</code> load an assembly from a given file path or byte array into a new ALC. Unlike <code>LoadFrom</code>, these methods provide isolation and let you load multiple versions of the same assembly. However, there are two caveats:</p>

<ul>
	<li>
	<p>Calling <code>LoadFile</code> again with the identical path will return the previously loaded assembly.</p>
	</li>
	<li>
	<p>In .NET Framework, both methods first check the GAC and load from there instead if the assembly is present.</p>
	</li>
</ul>

<p>With <code>LoadFile</code> and <code>Load(byte[])</code>, you end up with a separate ALC per assembly (caveats aside). This enables isolation, although it can make it more awkward to manage.</p>

<p>To resolve dependencies, you handle the <code>AppDomain</code>’s <code>Resolving</code> event, which fires on all ALCs:</p>

<pre data-type="programlisting">
AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt;
{
  string fullAssemblyName = args.Name;
  // return an Assembly object or null
  ...
};</pre>

<p>The <code>args</code> variable also includes a property called <code>RequestingAssembly</code>, which tells you which assembly triggered the resolution.</p>

<p>After locating the assembly, you can then call <code>Assembly</code>.<code>LoadFile</code> to load it.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can enumerate all of the assemblies that have been loaded into the current application domain with <code>AppDomain.CurrentDomain.GetAssemblies()</code>. This works in .NET 5+, too, where it’s equivalent to the following:<a contenteditable="false" data-primary="" data-startref="ch17.html21" data-type="indexterm" id="id4116"/></p>

<pre data-type="programlisting">
AssemblyLoadContext.All.SelectMany (a =&gt; a.Assemblies)</pre>
</div>
</div></section>
</div></section>

<section data-pdf-bookmark="Writing a Plug-In System" data-type="sect2"><div class="sect2" id="writing_a_plug_in_system">
<h2>Writing a Plug-In System</h2>

<p><a contenteditable="false" data-primary="assembly load context (ALC)" data-secondary="writing a plug-in system" data-type="indexterm" id="ch17.html22"/>To fully demonstrate the concepts that we’ve covered in this section, let’s write a plug-in system that uses unloadable ALCs to isolate each plug-in.</p>

<p>Our demo system will initially comprise three .NET projects:</p>

<dl>
	<dt>Plugin.Common (library)</dt>
	<dd>Defines an interface that plug-ins will implement</dd>
	<dt>Capitalizer (library)</dt>
	<dd>A plug-in that capitalizes text</dd>
	<dt>Plugin.Host (console application)</dt>
	<dd>Locates and invokes plug-ins</dd>
</dl>

<p>Let’s assume that the projects reside in the following directories:</p>

<pre data-type="programlisting">
c:\source\PluginDemo\Plugin.Common
c:\source\PluginDemo\Capitalizer
c:\source\PluginDemo\Plugin.Host</pre>

<p>All projects will reference the Plugin.Common library, and there will be no other interproject references.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If Plugin.Host were to reference Capitalizer, we wouldn’t be writing a plug-in system; the central idea is that the plug-ins are written by third parties after Plugin.Host and Plugin.Common have been published.</p>

<p>If you’re using Visual Studio, it can be convenient to put all three projects into a single solution for the sake of this demo. If you do so, right-click the Plugin.Host project, choose Build Dependencies &gt; Project Dependencies, and then tick the Capitalizer project. This forces Capitalizer to build when you run the Plugin.Host project, without adding a reference.</p>
</div>

<section data-pdf-bookmark="Plugin.Common" data-type="sect3"><div class="sect3" id="plugindotcommon">
<h3>Plugin.Common</h3>

<p><a contenteditable="false" data-primary="Plugin.Common" data-type="indexterm" id="id4117"/>Let’s begin with Plugin.Common. Our plug-ins will perform a very simple task, which is to transform a string. Here’s how we’ll define the interface:</p>

<pre data-type="programlisting">
namespace Plugin.Common
{
  public interface ITextPlugin
  {
    string TransformText (string input);
  }
}</pre>

<p>That’s all there is to Plugin.Common.</p>
</div></section>

<section data-pdf-bookmark="Capitalizer (plug-in)" data-type="sect3"><div class="sect3" id="capitalizer_left_parenthesisplug_inrigh">
<h3>Capitalizer (plug-in)</h3>

<p><a contenteditable="false" data-primary="Capitalizer (plug-in)" data-type="indexterm" id="id4118"/>Our Capitalizer plug-in will reference Plugin.Common and contain a single class. For now, we’ll keep the logic simple so that the plug-in has no extra dependencies:</p>

<pre data-type="programlisting">
public class CapitalizerPlugin : Plugin.Common.ITextPlugin
{
  public string TransformText (string input) =&gt; input.ToUpper();
}</pre>

<p>If you build both projects and look in Capitalizer’s output folder, you’ll see the following two assemblies:</p>

<pre data-type="programlisting">
Capitalizer.dll      // Our plug-in assembly
Plugin.Common.dll    // Referenced assembly</pre>
</div></section>

<section data-pdf-bookmark="Plugin.Host" data-type="sect3"><div class="sect3" id="plugindothost">
<h3>Plugin.Host</h3>

<p><a contenteditable="false" data-primary="Plugin.Host" data-type="indexterm" id="ch17.html23"/>Plugin.Host is a console application with two classes. The first class is a custom ALC to load the plug-ins:</p>

<pre data-type="programlisting">
class PluginLoadContext : AssemblyLoadContext
{
  AssemblyDependencyResolver _resolver;

  public PluginLoadContext (string pluginPath, bool collectible)
    // Give it a friendly name to help with debugging:
    : base (name: Path.GetFileName (pluginPath), collectible)
  {
    // Create a resolver to help us find dependencies.
    _resolver = new AssemblyDependencyResolver (pluginPath);
  }

  protected override Assembly Load (AssemblyName assemblyName)
  {
    // See below
    <strong>if (assemblyName.Name == typeof (ITextPlugin).Assembly.GetName().Name)</strong>
      <strong>return null;</strong>

    string target = _resolver.ResolveAssemblyToPath (assemblyName);

    if (target != null)
      return LoadFromAssemblyPath (target);

    // Could be a BCL assembly. Allow the default context to resolve.
    return null;   
  }

  protected override IntPtr LoadUnmanagedDll (string unmanagedDllName)
  {
    string path = _resolver.ResolveUnmanagedDllToPath (unmanagedDllName);

    return path == null
      ? IntPtr.Zero
      : LoadUnmanagedDllFromPath (path);
  }
}</pre>

<p>In the constructor, we pass in the path to the main plug-in assembly as well as a flag to indicate whether we’d like the ALC to be collectible (so that it can be unloaded).</p>

<p>The <code>Load</code> method is where we handle dependency resolution. All plug-ins must reference Plugin.Common so that they can implement <code>ITextPlugin</code>. This means that the <code>Load</code> method will fire at some point to resolve Plugin.Common. We need to be careful because the plug-in’s output folder is likely to contain not only <em>Capitalizer.dll</em> but also its own copy of <em>Plugin.Common.dll</em>. If we were to load this copy of <em>Plugin.Common.dll</em> into the <code>PluginLoadContext</code>, we’d end up with two copies of the assembly: one in the host’s default context and one in the plug-in’s <code>PluginLoad​Con⁠text</code>. The assemblies would be incompatible, and the host would complain that the plug-in does not implement <code>ITextPlugin</code>!</p>

<p>To solve this, we check explicitly for this condition:</p>

<pre data-type="programlisting">
    if (assemblyName.Name == typeof (ITextPlugin).Assembly.GetName().Name)
      return null;</pre>

<p>Returning null allows the host’s default ALC to instead resolve the assembly.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Instead of returning null, we could return <code>typeof(ITextPlugin).Assembly</code>, and it would also work correctly. How can we be certain that <code>ITextPlugin</code> will resolve on the host’s ALC and not on our <code>PluginLoadContext</code>? Remember that our <code>PluginLoadContext</code> class is defined in the <code>Plugin.Host</code> assembly. Therefore, any types that you statically reference from this class will trigger an assembly resolution on the ALC into which <em>its assembly</em>, <code>Plugin.Host</code>, was loaded.</p>
</div>

<p>After checking for the common assembly, we use <code>AssemblyDependencyResolver</code> to locate any private dependencies that the plug-in might have. (Right now, there will be none.)</p>

<p>Notice that we also override the <code>LoadUnamangedDll</code> method. This ensures that if the plug-in has any unmanaged dependencies, these will load correctly, too.</p>

<p>The second class to write in Plugin.Host is the main program itself. For simplicity, let’s hardcode the path to our Capitalizer plug-in (in real life, you might discover the paths of plug-ins by looking for DLLs in known locations or reading from a configuration file):</p>

<pre data-type="programlisting">
class Program
{
  const bool UseCollectibleContexts = true;

  static void Main()
  {
    const string capitalizer = @"C:\source\PluginDemo\"
      + @"Capitalizer\bin\Debug\netcoreapp3.0\Capitalizer.dll";

    Console.WriteLine (TransformText ("big apple", capitalizer));
  }

  static string TransformText (string text, string pluginPath)
  {
    var alc = new PluginLoadContext (pluginPath, UseCollectibleContexts);
    try
    {
      Assembly assem = alc.LoadFromAssemblyPath (pluginPath);

      // Locate the type in the assembly that implements ITextPlugin:
      Type pluginType = assem.ExportedTypes.Single (t =&gt; 
                        typeof (ITextPlugin).IsAssignableFrom (t));

      // Instantiate the ITextPlugin implementation:
      var plugin = (ITextPlugin)Activator.CreateInstance (pluginType);

      // Call the TransformText method
      return plugin.TransformText (text);
    }
    finally
    {
      if (UseCollectibleContexts) alc.Unload();    // unload the ALC
    }  
  }
}</pre>

<p>Let’s look at the <code>TransformText</code> method. We first instantiate a new ALC for our plug-in and then ask it to load the main plug-in assembly. Next, we use Reflection to locate the type that implements <code>ITextPlugin</code> (we cover this in detail in <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>). Then, we instantiate the plug-in, call the <code>TransformText</code> method, and unload the ALC.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you needed to call the <code>TransformText</code> method repeatedly, a better approach would be to cache the ALC rather than unloading it after each call.<a contenteditable="false" data-primary="" data-startref="ch17.html23" data-type="indexterm" id="id4119"/></p>
</div>

<p>Here’s the output:</p>

<pre data-type="programlisting">
BIG APPLE</pre>
</div></section>

<section data-pdf-bookmark="Adding dependencies" data-type="sect3"><div class="sect3" id="adding_dependencies">
<h3>Adding dependencies</h3>

<p>Our code is fully capable of resolving and isolating dependencies. To illustrate, let’s first add a NuGet reference to <em>Humanizer.Core</em>, version 2.6.2. You can do this via the Visual Studio UI or by adding the following element to the <em>Capitalizer.csproj</em> file:</p>

<pre data-type="programlisting">
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Humanizer.Core" Version="2.6.2" /&gt;
  &lt;/ItemGroup&gt;</pre>

<p>Now, modify <code>CapitalizerPlugin</code>, as follows:</p>

<pre data-type="programlisting">
<strong>using Humanizer;</strong>
namespace Capitalizer
{
  public class CapitalizerPlugin : Plugin.Common.ITextPlugin
  {
    public string TransformText (string input) =&gt; <strong>input.Pascalize()</strong>;
  }
}</pre>

<p>If you rerun the program, the output will now be this:</p>

<pre data-type="programlisting">
BigApple</pre>

<p>Next, we create another plug-in called Pluralizer. Create a new .NET library project and add a NuGet reference to <em>Humanizer.Core</em>, version 2.7.9:</p>

<pre data-type="programlisting">
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Humanizer.Core" Version="<strong>2.7.9</strong>" /&gt;
  &lt;/ItemGroup&gt;</pre>

<p>Now, add a class called <code>PluralizerPlugin</code>. This will be similar to <code>Capitalizer​Plu⁠gIn</code>, but we call the <code>Pluralize</code> method instead:</p>

<pre data-type="programlisting">
<strong>using Humanizer;</strong>
namespace Pluralizer
{
  public class PluralizerPlugin : Plugin.Common.ITextPlugin
  {
    public string TransformText (string input) =&gt; <strong>input.Pluralize()</strong>;
  }
}</pre>

<p>Finally, we need to add code to the Plugin.Host’s <code>Main</code> method to load and run the Pluralizer plug-in:</p>

<pre data-type="programlisting">
  static void Main()
  {
    const string capitalizer = @"C:\source\PluginDemo\"
      + @"Capitalizer\bin\Debug\netcoreapp3.0\Capitalizer.dll";

    Console.WriteLine (TransformText ("big apple", capitalizer));

<strong>    const string pluralizer = @"C:\source\PluginDemo\"</strong>
<strong>      + @"Pluralizer\bin\Debug\netcoreapp3.0\Pluralizer.dll";</strong>

<strong>    Console.WriteLine (TransformText ("big apple", pluralizer));</strong>
  <strong>}</strong></pre>

<p>The output will now be like this:</p>

<pre data-type="programlisting">
BigApple
big apples</pre>

<p>To fully see what’s going on, change the <code>UseCollectibleContexts</code> constant to false and add the following code to the <code>Main</code> method to enumerate the ALCs and their assemblies:</p>

<pre data-type="programlisting">
foreach (var context in AssemblyLoadContext.All)
{
  Console.WriteLine ($"Context: {context.GetType().Name} {context.Name}");

  foreach (var assembly in context.Assemblies)
      Console.WriteLine ($"  Assembly: {assembly.FullName}");
}</pre>

<p>In the output, you can see two different versions of Humanizer, each loaded into its own ALC:</p>

<pre data-type="programlisting">
Context: PluginLoadContext Capitalizer.dll
  Assembly: Capitalizer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=...
  Assembly: <strong>Humanizer, Version=2.6.0.0</strong>, Culture=neutral, PublicKeyToken=...
Context: PluginLoadContext Pluralizer.dll
  Assembly: Pluralizer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=...
  Assembly: <strong>Humanizer, Version=2.7.0.0</strong>, Culture=neutral, PublicKeyToken=...
Context: DefaultAssemblyLoadContext Default
  Assembly: System.Private.CoreLib, Version=4.0.0.0, Culture=neutral,...
  Assembly: Host, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
  ...</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Even if both plug-ins were to use the same version of Humanizer, the isolation of separate assemblies can still be beneficial because each will have its <a contenteditable="false" data-primary="" data-startref="ch17.html22" data-type="indexterm" id="id4120"/>own <a contenteditable="false" data-primary="" data-startref="ch17.html14" data-type="indexterm" id="id4121"/>static variables<a contenteditable="false" data-primary="" data-startref="ch17.html13" data-type="indexterm" id="id4122"/>.<a contenteditable="false" data-primary="" data-startref="ch17.html0" data-type="indexterm" id="id4123"/></p>
</div>
</div></section>
</div></section>
</div></section>
</div></section></body></html>