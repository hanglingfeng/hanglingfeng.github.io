<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Streams and I/O</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Streams and I/O" data-pdf-bookmark="Chapter 15. Streams and I/O" data-type="chapter" epub:type="chapter"><div class="chapter" id="streams_and_isoliduso">
<h1><span class="label">Chapter 15. </span>Streams and I/O</h1>
<p><a contenteditable="false" data-primary="streams and I/O" data-type="indexterm" id="ch15.html100"/>This chapter describes the fundamental types for input and output in .NET, with emphasis on the following topics:</p>
<ul>
<li><p>The .NET stream architecture and how it provides a consistent programming interface for reading and writing across a variety of I/O types</p></li>
<li><p>Classes for manipulating files and directories on disk</p></li>
<li><p>Specialized streams for compression, named pipes, and memory-mapped files</p></li>
</ul>
<p>This chapter concentrates on the types in the <code>System.IO</code> namespace, the home of lower-level I/O functionality.</p>
<section data-pdf-bookmark="Stream Architecture" data-type="sect1"><div class="sect1" id="stream_architecture-id00041">
<h1>Stream Architecture</h1>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="stream architecture" data-type="indexterm" id="ch15.html101"/>The .NET stream architecture centers on three concepts: backing stores, decorators, and adapters, as shown in <a data-type="xref" href="#stream_architecture-id00092">Figure 15-1</a>.</p>

<p>A <em>backing store</em> is the endpoint that makes input and output useful, such as a file or network connection. Precisely, it is either or both of the following:</p>
<ul>
<li><p>A source from which bytes can be sequentially read</p></li>
<li><p>A destination to which bytes can be sequentially written</p></li>
</ul>

<figure><div class="figure" id="stream_architecture-id00092">
<img alt="Stream architecture" src="assets/cn10_1501.png"/>
<h6><span class="label">Figure 15-1. </span>Stream architecture</h6>
</div></figure>
<p><a contenteditable="false" data-primary="Stream..." data-secondary="Stream class" data-type="indexterm" id="id3828"/>A backing store is of no use, though, unless exposed to the programmer. A <code>Stream</code> is the standard .NET class for this purpose; it exposes a standard set of methods for reading, writing, and positioning. Unlike an array, for which all the backing data exists in memory at once, a stream deals with data serially—either one byte at a time or in blocks of a manageable size. Hence, a stream can use a small, fixed amount of memory regardless of the size of its backing store.</p>
<p>Streams fall into two categories:</p>
<dl>
<dt>Backing store streams</dt>
<dd>These are hardwired to a particular type of backing store, such as <code>FileStream</code> or <code>NetworkStream</code>.</dd>
<dt>Decorator streams</dt>
<dd>These feed off another stream, transforming the data in some way, such as <code>DeflateStream</code> or <code>CryptoStream</code>.</dd>
</dl>
<p>Decorator streams have the following architectural benefits:</p>
<ul>
<li><p>They liberate backing store streams from needing to implement such features as compression and encryption themselves.</p></li>
<li><p>Streams don’t suffer a change of interface when decorated.</p></li>
<li><p>You connect decorators at runtime.</p></li>
<li><p>You can chain decorators together (e.g., a compressor followed by an <span class="keep-together">encryptor</span>).</p></li>
</ul>
<p>Both backing store and decorator streams deal exclusively in bytes. Although this is flexible and efficient, applications often work at higher levels such as text or XML. <em>Adapters</em> bridge this gap by wrapping a stream in a class with specialized methods typed to a particular format. For example, a text reader exposes a <code>ReadLine</code> method; an XML writer exposes a <code>WriteAttributes</code> method.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An adapter wraps a stream, just like a decorator. Unlike a decorator, however, an adapter is not <em>itself</em> a stream; it typically hides the byte-oriented methods completely.</p>
</div>
<p>To summarize, backing store streams provide the raw data; decorator streams provide transparent binary transformations such as encryption; adapters offer typed methods for dealing in higher-level types such as strings and XML.</p>

<p><a data-type="xref" href="#stream_architecture-id00092">Figure 15-1</a> illustrates their associations. To compose a chain, you simply pass one object into another’s constructor.<a contenteditable="false" data-primary="" data-startref="ch15.html101" data-type="indexterm" id="id3829"/></p>
</div></section>
<section data-pdf-bookmark="Using Streams" data-type="sect1"><div class="sect1" id="using_streams">
<h1>Using Streams</h1>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="using streams" data-type="indexterm" id="ch15.html102"/>The abstract <code>Stream</code> class is the base for all streams. It defines methods and properties for three fundamental operations: <em>reading</em>, <em>writing</em>, and <em>seeking</em>, as well as for administrative tasks such as closing, flushing, and configuring timeouts (see <a data-type="xref" href="#stream_class_members">Table 15-1</a>).</p>
<table class="border" id="stream_class_members">
<caption><span class="label">Table 15-1. </span>Stream class members</caption>
<thead>
<tr>
<th>Category</th>
<th>Members</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reading</td>
<td><code>public abstract bool CanRead { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract int Read (byte[] buffer, int offset, int count)</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual int ReadByte();</code></td>
</tr>
<tr>
<td>Writing</td>
<td><code>public abstract bool CanWrite { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract void Write (byte[] buffer, int offset, int count);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual void WriteByte (byte value);</code></td>
</tr>
<tr>
<td>Seeking</td>
<td><code>public abstract bool CanSeek { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract long Position { get; set; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract void SetLength (long value);</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract long Length { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract long Seek (long offset, SeekOrigin origin);</code></td>
</tr>
<tr>
<td>Closing/flushing</td>
<td><code>public virtual void Close();</code></td>
</tr>
<tr>
<td/>
<td><code>public void Dispose();</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract void Flush();</code></td>
</tr>
<tr>
<td>Timeouts</td>
<td><code>public virtual bool CanTimeout { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual int ReadTimeout { get; set; }</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual int WriteTimeout { get; set; }</code></td>
</tr>
<tr>
<td>Other</td>
<td><code>public static readonly Stream Null; // "Null" stream</code></td>
</tr>
<tr>
<td/>
<td><code>public static Stream Synchronized (Stream stream);</code></td>
</tr>
</tbody>
</table>
<p>There are also asynchronous versions of the <code>Read</code> and <code>Write</code> methods, both of which return <code>Task</code>s and optionally accept a cancellation token, and overloads that work with <code>Span&lt;T&gt;</code> and <code>Memory&lt;T&gt;</code> types that we describe in <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>.</p>
<p>In the following example, we use a file stream to read, write, and seek:</p>
<pre data-type="programlisting">using System;
using System.IO;

// Create a file called test.txt in the current directory:
using (Stream s = new FileStream ("test.txt", FileMode.Create))
{
  Console.WriteLine (s.CanRead);       // True
  Console.WriteLine (s.CanWrite);      // True
  Console.WriteLine (s.CanSeek);       // True

  s.WriteByte (101);
  s.WriteByte (102);
  byte[] block = { 1, 2, 3, 4, 5 };
  s.Write (block, 0, block.Length);     // Write block of 5 bytes

  Console.WriteLine (s.Length);         // 7
  Console.WriteLine (s.Position);       // 7
  s.Position = 0;                       // Move back to the start

  Console.WriteLine (s.ReadByte());     // 101
  Console.WriteLine (s.ReadByte());     // 102

  // Read from the stream back into the block array:
  Console.WriteLine (s.Read (block, 0, block.Length));   // 5

  // Assuming the last Read returned 5, we'll be at
  // the end of the file, so Read will now return 0:
  Console.WriteLine (s.Read (block, 0, block.Length));   // 0
}</pre>
<p>Reading or writing asynchronously is simply a question of calling <code>ReadAsync</code>/<code>WriteAsync</code> instead of <code>Read</code>/<code>Write</code>, and <code>await</code>ing the expression (we must also add the <code>async</code> keyword to the calling method, as we described in <a data-type="xref" href="ch14.html#concurrency_and_asynchron">Chapter 14</a>):</p>
<pre data-type="programlisting"><strong>async</strong> static void AsyncDemo()
{
  using (Stream s = new FileStream ("test.txt", FileMode.Create))
  {
    byte[] block = { 1, 2, 3, 4, 5 };
    <strong>await</strong> s.WriteAsync (block, 0, block.Length);    // Write asychronously

    s.Position = 0;                       // Move back to the start

    // Read from the stream back into the block array:
    Console.WriteLine (<strong>await</strong> s.ReadAsync (block, 0, block.Length));   // 5
  }
}</pre>
<p>The asynchronous methods make it easy to write responsive and scalable applications that work with potentially slow streams (particularly network streams), without tying up a thread.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For the sake of brevity, we’ll continue to use synchronous methods for most of the examples in this chapter; however, we recommend the asynchronous <code>Read</code>/<code>Write</code> operations as preferable in most scenarios involving network I/O.</p>
</div>
<section data-pdf-bookmark="Reading and Writing" data-type="sect2"><div class="sect2" id="reading_and_writing">
<h2>Reading and Writing</h2>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="reading and writing" data-type="indexterm" id="id3830"/>A stream can support reading, writing, or both. If <code>CanWrite</code> returns <code>false</code>, the stream is read-only; if <code>CanRead</code> returns <code>false</code>, the stream is write-only.</p>
<p><code>Read</code> receives a block of data from the stream into an array. It returns the number of bytes received, which is always either less than or equal to the <code>count</code> argument. If it’s less than <code>count</code>, it means that either the end of the stream has been reached or the stream is giving you the data in smaller chunks (as is often the case with network streams). In either case, the balance of bytes in the array will remain unwritten, their previous values preserved.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>With <code>Read</code>, you can be certain you’ve reached the end of the stream only when the method returns <code>0</code>. So, if you have a 1,000-byte stream, the following code might fail to read it all into memory:</p>
<pre data-type="programlisting">// Assuming <strong>s</strong> is a stream:
byte[] data = new byte [1000];
s.Read (data, 0, data.Length);</pre>
<p>The <code>Read</code> method could read anywhere from 1 to 1,000 bytes, leaving the balance of the stream unread.</p>
</div>
<p>Here’s the correct way to read a 1,000-byte stream via the <code>Read</code> method:</p>
<pre data-type="programlisting">byte[] data = new byte [1000];

// bytesRead will always end up at 1000, unless the stream is
// itself smaller in length:

int bytesRead = 0;
int chunkSize = 1;
while (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; 0)
  bytesRead +=
    chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);</pre>
<p>To make this easier, from .NET 7, the <code>Stream</code> class includes helper methods called <code>ReadExactly</code> and <code>ReadAtLeast</code> (and async versions of each). The following reads exactly 1,000 bytes from the stream (throwing an exception if the stream ends before then):</p>
<pre data-type="programlisting">byte[] data = new byte [1000];
s.ReadExactly (data);   // Reads exactly 1000 bytes</pre>
<p>The last line is equivalent to:</p>
<pre data-type="programlisting">s.ReadExactly (data, offset:0, count:1000);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>BinaryReader</code> type provides another solution:</p>
<pre data-type="programlisting">byte[] data = new BinaryReader (s).ReadBytes (1000);</pre>
<p>If the stream is less than 1,000 bytes long, the byte array returned reflects the actual stream size. If the stream is seekable, you can read its entire contents by replacing <code>1000</code> with <code>(int)s.Length</code>.</p>
<p>We describe the <code>BinaryReader</code> type further in <a data-type="xref" href="#stream_adapters">“Stream Adapters”</a>.</p>
</div>
<p>The <code>ReadByte</code> method is simpler: it reads just a single byte, returning −1 to indicate the end of the stream. <code>ReadByte</code> actually returns an <code>int</code> rather than a <code>byte</code> because the latter cannot return −1.</p>
<p>The <code>Write</code> and <code>WriteByte</code> methods send data to the stream. If they are unable to send the specified bytes, an exception is thrown.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>In the <code>Read</code> and <code>Write</code> methods, the <code>offset</code> argument refers to the index in the <code>buffer</code> array at which reading or writing begins, not the position within the stream.</p>
</div>
</div></section>
<section data-pdf-bookmark="Seeking" data-type="sect2"><div class="sect2" id="seeking">
<h2>Seeking</h2>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="seeking" data-type="indexterm" id="id3831"/>A stream is seekable if <code>CanSeek</code> returns <code>true</code>. With a seekable stream (such as a file stream), you can query or modify its <code>Length</code> (by calling <code>SetLength</code>) and at any time change the <code>Position</code> at which you’re reading or writing. The <code>Position</code> property is relative to the beginning of the stream; the <code>Seek</code> method, however, allows you to move relative to the current position or the end of the stream.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Changing the <code>Position</code> on a <code>FileStream</code> typically takes a few microseconds. If you’re doing this millions of times in a loop, the <code>MemoryMappedFile</code> class might be a better choice than a <code>FileStream</code> (see <a data-type="xref" href="#memory_mapped_files">“Memory-Mapped Files”</a>).</p>
</div>
<p>With a nonseekable stream (such as an encryption stream), the only way to determine its length is to read it completely through. Furthermore, if you need to reread a previous section, you must close the stream and start afresh with a new one.</p>
</div></section>
<section data-pdf-bookmark="Closing and Flushing" data-type="sect2"><div class="sect2" id="closing_and_flushing">
<h2>Closing and Flushing</h2>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="closing and flushing" data-type="indexterm" id="id3832"/>Streams must be disposed after use to release underlying resources such as file and socket handles. A simple way to guarantee this is by instantiating streams within <code>using</code> blocks. In general, streams follow standard disposal semantics:</p>
<ul>
<li><p><code>Dispose</code> and <code>Close</code> are identical in function.</p></li>
<li><p>Disposing or closing a stream repeatedly causes no error.</p></li>
</ul>
<p>Closing a decorator stream closes both the decorator and its backing store stream. With a chain of decorators, closing the outermost decorator (at the head of the chain) closes the whole lot.</p>
<p>Some streams internally buffer data to and from the backing store to lessen round-tripping and so improve performance (file streams are a good example of this). This means that data you write to a stream might not hit the backing store immediately; it can be delayed as the buffer fills up. The <code>Flush</code> method forces any internally buffered data to be written immediately. <code>Flush</code> is called automatically when a stream is closed, so you never need to do the following:</p>
<pre data-type="programlisting">s.Flush(); s.Close();</pre>
</div></section>
<section data-pdf-bookmark="Timeouts" data-type="sect2"><div class="sect2" id="timeouts">
<h2>Timeouts</h2>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="timeouts" data-type="indexterm" id="id3833"/><a contenteditable="false" data-primary="timeouts" data-type="indexterm" id="id3834"/>A stream supports read and write timeouts if <code>CanTimeout</code> returns <code>true</code>. Network streams support timeouts; file and memory streams do not. For streams that support timeouts, the <code>ReadTimeout</code> and <code>WriteTimeout</code> properties determine the desired timeout in milliseconds, where <code>0</code> means no timeout. The <code>Read</code> and <code>Write</code> methods indicate that a timeout has occurred by throwing an exception.</p>
<p>The asynchronous <code>ReadAsync</code>/<code>WriteAsync</code> methods do not support timeouts; instead you can pass a cancellation token into these methods.</p>
</div></section>
<section data-pdf-bookmark="Thread Safety" data-type="sect2"><div class="sect2" id="thread_safety">
<h2>Thread Safety</h2>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="thread safety" data-type="indexterm" id="id3835"/><a contenteditable="false" data-primary="thread safety" data-type="indexterm" id="id3836"/>As a rule, streams are not thread-safe, meaning that two threads cannot concurrently read or write to the same stream without possible error. The <code>Stream</code> class offers a simple workaround via the static <code>Synchronized</code> method. This method accepts a stream of any type and returns a thread-safe wrapper. The wrapper works by obtaining an exclusive lock around each read, write, or seek, ensuring that only one thread can perform such an operation at a time. In practice, this allows multiple threads to simultaneously append data to the same stream—other kinds of activities (such as concurrent reading) require additional locking to ensure that each thread accesses the desired portion of the stream. We discuss thread safety fully in <a data-type="xref" href="ch21.html#advanced_threadin">Chapter 21</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From .NET 6, you can use the <code>RandomAccess</code> class for performant thread-safe file I/O operations. <code>RandomAccess</code> also lets you pass in multiple buffers to improve performance.</p>
</div>
</div></section>
<section data-pdf-bookmark="Backing Store Streams" data-type="sect2"><div class="sect2" id="backing_store_streams-id00002">
<h2>Backing Store Streams</h2>
<p><a contenteditable="false" data-primary="backing store streams" data-type="indexterm" id="id3837"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="backing store streams" data-type="indexterm" id="id3838"/><a data-type="xref" href="#backing_store_streams-id00053">Figure 15-2</a> shows the key backing store streams provided by .NET. A “null stream” is also available via the <code>Stream</code>’s static <code>Null</code> field. Null streams can be useful when writing unit tests.</p>
<figure><div class="figure" id="backing_store_streams-id00053">
<img alt="Backing store streams" src="assets/cn10_1502.png"/>
<h6><span class="label">Figure 15-2. </span>Backing store streams</h6>
</div></figure>
<p>In the following sections, we describe <code>FileStream</code> and <code>MemoryStream</code>; in the final section in this chapter, we describe <code>IsolatedStorageStream</code>. In <a data-type="xref" href="ch16.html#networking-id00041">Chapter 16</a>, we cover <code>NetworkStream</code>.</p>
</div></section>
<section data-pdf-bookmark="FileStream" data-type="sect2"><div class="sect2" id="filestream">
<h2>FileStream</h2>
<p><a contenteditable="false" data-primary="FileStream" data-type="indexterm" id="ch15.html103"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="FileStream" data-type="indexterm" id="ch15.html104"/>Earlier in this section, we demonstrated the basic use of a <code>FileStream</code> to read and write bytes of data. Let’s now examine the special features of this class.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re still using Universal Windows Platform [UWP], you can also do file I/O with the types in <code>Windows.Storage</code>. We describe this in the online supplement at <a href="http://www.albahari.com/nutshell"><em class="hyperlink">http://www.albahari.com/nutshell</em></a>.</p>
</div>
<section data-pdf-bookmark="Constructing a FileStream" data-type="sect3"><div class="sect3" id="constructing_a_filestream">
<h3>Constructing a FileStream</h3>
<p><a contenteditable="false" data-primary="FileStream" data-secondary="constructing" data-type="indexterm" id="id3839"/>The simplest way to instantiate a <code>FileStream</code> is to use one of the following static façade methods on the <code>File</code> class:</p>
<pre data-type="programlisting">FileStream fs1 = File.OpenRead  ("readme.bin");            // Read-only
FileStream fs2 = File.OpenWrite ("writeme.tmp");           // Write-only
FileStream fs3 = File.Create    ("readwrite.tmp");         // Read/write</pre>
<p class="pagebreak-before"><code>OpenWrite</code> and <code>Create</code> differ in behavior if the file already exists. <code>Create</code> truncates any existing content; <code>OpenWrite</code> leaves existing content intact with the stream positioned at zero. If you write fewer bytes than were previously in the file, <code>OpenWrite</code> leaves you with a mixture of old and new content.</p>
<p>You can also directly instantiate a <code>FileStream</code>. Its constructors provide access to every feature, allowing you to specify a filename or low-level file handle, file creation and access modes, and options for sharing, buffering, and security. The following opens an existing file for read/write access without overwriting it (the <code>using</code> keyword ensures it is disposed when <code>fs</code> exits scope):</p>
<pre data-type="programlisting">using var fs = new FileStream ("readwrite.tmp", FileMode.Open);</pre>
<p>We look closer at <code>FileMode</code> shortly.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="shortcut_methods_on_the_file_class">
<h1>Shortcut Methods on the File Class</h1>
<p><a contenteditable="false" data-primary="File class" data-secondary="shortcut methods" data-type="indexterm" id="id3840"/>The following static methods read an entire file into memory in one step:</p>
<ul>
<li><p><code>File.ReadAllText</code> (returns a string)</p></li>
<li><p><code>File.ReadAllLines</code> (returns an array of strings)</p></li>
<li><p><code>File.ReadAllBytes</code> (returns a byte array)</p></li>
</ul>
<p>The following static methods write an entire file in one step:</p>
<ul>
<li><p><code>File.WriteAllText</code></p></li>
<li><p><code>File.WriteAllLines</code></p></li>
<li><p><code>File.WriteAllBytes</code></p></li>
<li><p><code>File.AppendAllText</code> (great for appending to a log file)</p></li>
</ul>
<p>There’s also a static method called <code>File.ReadLines</code>: this is like <code>ReadAllLines</code> except that it returns a lazily evaluated <code>IEnumerable&lt;string&gt;</code>. This is more efficient because it doesn’t load the entire file into memory at once. LINQ is ideal for consuming the results: the following calculates the number of lines greater than 80 characters in length:</p>
<pre data-type="programlisting">int longLines = File.ReadLines ("<em>filePath</em>")
                    .Count (l =&gt; l.Length &gt; 80);</pre>
</div></aside>
</div></section>
<section data-pdf-bookmark="Specifying a filename" data-type="sect3"><div class="sect3" id="specifying_a_filename">
<h3>Specifying a filename</h3>
<p><a contenteditable="false" data-primary="filenames, specifying" data-type="indexterm" id="id3841"/><a contenteditable="false" data-primary="FileStream" data-secondary="specifying a filename" data-type="indexterm" id="id3842"/>A filename can be either absolute (e.g., <em>c:\temp\test.txt—or in Unix, /tmp/test.txt</em>) or relative to the current directory (e.g., <em>test.txt</em> or <em>temp\test.txt</em>). You can access or change the current directory via the static <code>Environment.CurrentDirectory</code> <span class="keep-together">property</span>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When a program starts, the current directory might or might not coincide with that of the program’s executable. For this reason, you should never rely on the current directory for locating additional runtime files packaged along with your executable.</p>
</div>
<p><a contenteditable="false" data-primary="AppDomain.CurrentDomain.BaseDirectory" data-type="indexterm" id="id3843"/><a contenteditable="false" data-primary="application base directory" data-type="indexterm" id="id3844"/><code>AppDomain.CurrentDomain.BaseDirectory</code> returns the <em>application base directory</em>, which in normal cases is the folder containing the program’s executable. To specify a filename relative to this directory, you can call <code>Path.Combine</code>:</p>
<pre data-type="programlisting">string baseFolder = AppDomain.CurrentDomain.BaseDirectory;
string logoPath = Path.Combine (baseFolder, "logo.jpg");
Console.WriteLine (File.Exists (logoPath));</pre>
<p>You can read and write across a Windows network via a Universal Naming Convention (UNC) path, such as <em>\\JoesPC\PicShare\pic.jpg</em> or <em>\\10.1.1.2\PicShare\pic.jpg</em>. (To access a Windows file share from macOS or Unix, mount it to your filesystem following instructions specific to your OS, and then open it using an ordinary path from C#).</p>
</div></section>
<section data-pdf-bookmark="Specifying a FileMode" data-type="sect3"><div class="sect3" id="specifying_a_filemode">
<h3>Specifying a FileMode</h3>
<p><a contenteditable="false" data-primary="FileMode" data-type="indexterm" id="id3845"/><a contenteditable="false" data-primary="FileStream" data-secondary="specifying a FileMode" data-type="indexterm" id="id3846"/>All of <code>FileStream</code>’s constructors that accept a filename also require a <code>FileMode</code> enum argument. <a data-type="xref" href="#choosing_a_filemode">Figure 15-3</a> shows how to choose a <code>FileMode</code>, and the choices yield results akin to calling a static method on the <code>File</code> class.</p>
<figure><div class="figure" id="choosing_a_filemode">
<img alt="Choosing a FileMode" src="assets/cn10_1503.png"/>
<h6><span class="label">Figure 15-3. </span>Choosing a FileMode</h6>
</div></figure>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><code>File.Create</code> and <code>FileMode.Create</code> will throw an exception if used on hidden files. To overwrite a hidden file, you must delete and re-create it:</p>
<pre data-type="programlisting">File.Delete ("hidden.txt");
using var file = File.Create ("hidden.txt");
...</pre>
</div>
<p>Constructing a <code>FileStream</code> with just a filename and <code>FileMode</code> gives you (with just one exception) a readable writable stream. You can request a downgrade if you also supply a <code>FileAccess</code> argument:</p>
<pre data-type="programlisting">[Flags]
public enum FileAccess { Read = 1, Write = 2, ReadWrite = 3 }</pre>
<p>The following returns a read-only stream, equivalent to calling <code>File.OpenRead</code>:</p>
<pre data-type="programlisting">using var fs = new FileStream ("x.bin", FileMode.Open, FileAccess.Read);
...</pre>
<p><code>FileMode.Append</code> is the odd one out: with this mode, you get a <em>write-only</em> stream. To append with read-write support, you must instead use <code>FileMode.Open</code> or <code>FileMode.OpenOrCreate</code> and then seek the end of the stream:</p>
<pre data-type="programlisting">using var fs = new FileStream ("myFile.bin", FileMode.Open);

fs.Seek (0, SeekOrigin.End);
...</pre>
</div></section>
<section data-pdf-bookmark="Advanced FileStream features" data-type="sect3"><div class="sect3" id="advanced_filestream_features">
<h3>Advanced FileStream features</h3>
<p><a contenteditable="false" data-primary="FileStream" data-secondary="advanced features" data-type="indexterm" id="id3847"/>Here are other optional arguments you can include when constructing a <code>FileStream</code>:</p>
<ul>
<li><p>A <code>FileShare</code> enum describing how much access to grant other processes wanting to dip into the same file before you’ve finished (<code>None</code>, <code>Read</code> [default], <code>ReadWrite</code>, or <code>Write</code>).</p></li>
<li><p>The size, in bytes, of the internal buffer (default is currently 4 KB).</p></li>
<li><p>A flag indicating whether to defer to the operating system for asynchronous I/O.</p></li>
<li><p>A <code>FileOptions</code> flags enum for requesting operating system encryption (<code>Encrypted</code>), automatic deletion upon closure for temporary files (<code>DeleteOnClose</code>), and optimization hints (<code>RandomAccess</code> and <code>SequentialScan</code>). There is also a <code>WriteThrough</code> flag that requests that the OS disable write-behind caching; this is for transactional files or logs. Flags not supported by the underlying OS are silently ignored.</p></li>
</ul>
<p>Opening a file with <code>FileShare.ReadWrite</code> allows other processes or users to simultaneously read and write to the same file. To avoid chaos, you can all agree to lock specified portions of the file before reading or writing, using these methods:</p>
<pre data-type="programlisting">// Defined on the FileStream class:
public virtual void Lock   (long position, long length);
public virtual void Unlock (long position, long length);</pre>
<p><code>Lock</code> throws an exception if part or all of the requested file section has already been locked.<a contenteditable="false" data-primary="" data-startref="ch15.html104" data-type="indexterm" id="id3848"/><a contenteditable="false" data-primary="" data-startref="ch15.html103" data-type="indexterm" id="id3849"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="MemoryStream" data-type="sect2"><div class="sect2" id="memorystream">
<h2>MemoryStream</h2>
<p><a contenteditable="false" data-primary="MemoryStream" data-type="indexterm" id="id3850"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="MemoryStream" data-type="indexterm" id="id3851"/><code>MemoryStream</code> uses an array as a backing store. This partly defeats the purpose of having a stream because the entire backing store must reside in memory at once. <code>MemoryStream</code> is still useful when you need random access to a nonseekable stream. If you know the source stream will be of a manageable size, you can copy it into a <code>MemoryStream</code> as follows:</p>
<pre data-type="programlisting">var ms = new MemoryStream();
sourceStream.CopyTo (ms);</pre>
<p>You can convert a <code>MemoryStream</code> to a byte array by calling <code>ToArray</code>. The <code>GetBuffer</code> method does the same job more efficiently by returning a direct reference to the underlying storage array; unfortunately, this array is usually longer than the stream’s real length.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Closing and flushing a <code>MemoryStream</code> is optional. If you close a <code>MemoryStream</code>, you can no longer read or write to it, but you are still permitted to call <code>ToArray</code> to obtain the underlying data. <code>Flush</code> does absolutely nothing on a memory stream.</p>
</div>
<p>You can find further <code>MemoryStream</code> examples in <a data-type="xref" href="#compression_streams">“Compression Streams”</a> and in <a data-type="xref" href="ch20.html#overview-id00067">“Overview”</a>.</p>
</div></section>
<section data-pdf-bookmark="PipeStream" data-type="sect2"><div class="sect2" id="pipestream">
<h2>PipeStream</h2>
<p><a contenteditable="false" data-primary="PipeStream class" data-type="indexterm" id="ch15.html105"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="PipeStream class" data-type="indexterm" id="ch15.html106"/><code>PipeStream</code> provides a simple means by which one process can communicate with another through the operating system’s <em>pipes</em> protocol. There are two kinds of pipe:</p>
<dl>
<dt>Anonymous pipe (faster)</dt>
<dd>Allows one-way communication between a parent and child process on the same computer</dd>
<dt>Named pipe (more flexible)</dt>
<dd>Allows two-way communication between arbitrary processes on the same computer or different computers across a network</dd>
</dl>
<p><a contenteditable="false" data-primary="interprocess communication (IPC)" data-type="indexterm" id="id3852"/><a contenteditable="false" data-primary="IPC (interprocess communication)" data-type="indexterm" id="id3853"/>A pipe is good for interprocess communication (IPC) on a single computer: it doesn’t rely on a network transport, which means no network protocol overhead, and it has no issues with firewalls.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Pipes are stream-based, so one process waits to receive a series of bytes while another process sends them. An alternative is for processes to communicate via a block of shared memory; we describe how to do this in <a data-type="xref" href="#memory_mapped_files">“Memory-Mapped Files”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="anonymous pipes" data-type="indexterm" id="id3854"/><code>PipeStream</code> is an abstract class with four concrete subtypes. Two are used for anonymous pipes and the other two for named pipes:</p>
<dl>
<dt>Anonymous pipes</dt>
<dd><code>AnonymousPipeServerStream</code> and <code>AnonymousPipeClientStream</code></dd>
<dt>Named pipes</dt>
<dd><code>NamedPipeServerStream</code> and <code>NamedPipeClientStream</code></dd>
</dl>
<p>Named pipes are simpler to use, so we describe them first.</p>
<section data-pdf-bookmark="Named pipes" data-type="sect3"><div class="sect3" id="named_pipes">
<h3>Named pipes</h3>
<p><a contenteditable="false" data-primary="named pipes" data-type="indexterm" id="ch15.html107"/><a contenteditable="false" data-primary="PipeStream class" data-secondary="named pipes" data-type="indexterm" id="ch15.html108"/>With named pipes, the parties communicate through a pipe of the same name. The protocol defines two distinct roles: the client and server. Communication happens between the client and server as follows:</p>
<ul>
<li><p>The server instantiates a <code>NamedPipeServerStream</code> and then calls <code>WaitForConnection</code>.</p></li>
<li><p>The client instantiates a <code>NamedPipeClientStream</code> and then calls <code>Connect</code> (with an optional timeout).</p></li>
</ul>
<p>The two parties then read and write the streams to communicate.</p>
<p>The following example demonstrates a server that sends a single byte (100) and then waits to receive a single byte:</p>
<pre data-type="programlisting">using var s = new NamedPipeServerStream ("pipedream");

s.WaitForConnection();
s.WriteByte (100);                // Send the value 100.
Console.WriteLine (s.ReadByte());</pre>
<p>Here’s the corresponding client code:</p>
<pre data-type="programlisting">using var s = new NamedPipeClientStream ("pipedream");

s.Connect();
Console.WriteLine (s.ReadByte());
s.WriteByte (200);                 // Send the value 200 back.</pre>
<p>Named pipe streams are bidirectional by default, so either party can read or write their stream. This means that the client and server must agree on some protocol to coordinate their actions, so both parties don’t end up sending or receiving at once.</p>
<p>There also needs to be agreement on the length of each transmission. Our example was trivial in this regard, because we bounced just a single byte in each direction. To help with messages longer than one byte, pipes provide a <em>message</em> transmission mode (Windows only). If this is enabled, a party calling <code>Read</code> can know when a message is complete by checking the <code>IsMessageComplete</code> property. To demonstrate, we begin by writing a helper method that reads a whole message from a message-enabled <code>PipeStream</code>—in other words, reads until <code>IsMessageComplete</code> is true:</p>
<pre data-type="programlisting">static byte[] ReadMessage (PipeStream s)
{
  MemoryStream ms = new MemoryStream();
  byte[] buffer = new byte [0x1000];      // Read in 4 KB blocks

  do    { ms.Write (buffer, 0, s.Read (buffer, 0, buffer.Length)); }
  while (!s.<strong>IsMessageComplete</strong>);

  return ms.ToArray();
}</pre>
<p>(To make this asynchronous, replace “<code>s.Read</code>” with “<code>await s.ReadAsync</code>”.)</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>You cannot determine whether a <code>PipeStream</code> has finished reading a message simply by waiting for <code>Read</code> to return 0. This is because, unlike most other stream types, pipe streams and network streams have no definite end. Instead, they temporarily “dry up” between message transmissions.</p>
</div>
<p>Now we can activate message transmission mode. On the server, this is done by specifying <code>PipeTransmissionMode.Message</code> when constructing the stream:</p>
<pre data-type="programlisting">using var s = new NamedPipeServerStream ("pipedream", PipeDirection.InOut,
                                          1, <strong>PipeTransmissionMode.Message</strong>);

s.WaitForConnection();

byte[] msg = Encoding.UTF8.GetBytes ("Hello");
s.Write (msg, 0, msg.Length);

Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));</pre>
<p>On the client, we activate message transmission mode by setting <code>ReadMode</code> after calling <code>Connect</code>:</p>
<pre data-type="programlisting">using var s = new NamedPipeClientStream ("pipedream");

s.Connect();
<strong>s.ReadMode = PipeTransmissionMode.Message;</strong>

Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));

byte[] msg = Encoding.UTF8.GetBytes ("Hello right back!");
s.Write (msg, 0, msg.Length);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Message mode is supported only on Windows. Other platforms throw <code>PlatformNotSupportedException</code>.<a contenteditable="false" data-primary="" data-startref="ch15.html108" data-type="indexterm" id="id3855"/><a contenteditable="false" data-primary="" data-startref="ch15.html107" data-type="indexterm" id="id3856"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Anonymous pipes" data-type="sect3"><div class="sect3" id="anonymous_pipes">
<h3>Anonymous pipes</h3>
<p><a contenteditable="false" data-primary="anonymous pipes" data-type="indexterm" id="ch15.html109"/><a contenteditable="false" data-primary="PipeStream class" data-secondary="anonymous pipes" data-type="indexterm" id="ch15.html1010"/>An anonymous pipe provides a one-way communication stream between a parent and child process. Instead of using a system-wide name, anonymous pipes tune in through a private handle.</p>
<p>As with named pipes, there are distinct client and server roles. The system of communication is a little different, however, and proceeds as follows:</p>
<ol>
<li><p>The server instantiates an <code>AnonymousPipeServerStream</code>, committing to a <code>PipeDirection</code> of <code>In</code> or <code>Out</code>.</p></li>
<li><p>The server calls <code>GetClientHandleAsString</code> to obtain an identifier for the pipe, which it then passes to the client (typically as an argument when starting the child process).</p></li>
<li><p>The child process instantiates an <code>AnonymousPipeClientStream</code>, specifying the opposite <code>PipeDirection</code>.</p></li>
<li><p>The server releases the local handle that was generated in Step 2, by calling <code>DisposeLocalCopyOfClientHandle</code>.</p></li>
<li><p>The parent and child processes communicate by reading/writing the stream.</p></li>
</ol>
<p>Because anonymous pipes are unidirectional, a server must create two pipes for bidirectional communication. The following Console program creates two pipes (input and output) and then starts up a child process. It then sends a single byte to the child process, and receives a single byte in return:</p>
<pre data-type="programlisting">class Program
{
  static void Main (string[] args)
  {
    if (args.Length == 0)
      // No arguments signals server mode
      AnonymousPipeServer();
    else
      // We pass in the pipe handle IDs as arguments to signal client mode
      AnonymousPipeClient (args [0], args [1]);
  }

  static void AnonymousPipeClient (string rxID, string txID)
  {
    using var rx = new AnonymousPipeClientStream (PipeDirection.In, rxID);
    using var tx = new AnonymousPipeClientStream (PipeDirection.Out, txID);

    Console.WriteLine ("Client received: " + rx.ReadByte ());
    tx.WriteByte (200);
  }

  static void AnonymousPipeServer ()
  {
    using var tx = new AnonymousPipeServerStream (
                     PipeDirection.Out, HandleInheritability.Inheritable);
    using var rx = new AnonymousPipeServerStream (
                     PipeDirection.In, HandleInheritability.Inheritable);

    string txID = tx.GetClientHandleAsString ();
    string rxID = rx.GetClientHandleAsString ();

    // Create and start up a child process.
    // We'll use the same Console executable, but pass in arguments:
    string thisAssembly = Assembly.GetEntryAssembly().Location;
    string thisExe = Path.ChangeExtension (thisAssembly, ".exe");
    var args = $"{txID} {rxID}";
    var startInfo = new ProcessStartInfo (thisExe, args);

    startInfo.UseShellExecute = false;       // Required for child process
    Process p = Process.Start (startInfo);

    tx.DisposeLocalCopyOfClientHandle ();    // Release unmanaged
    rx.DisposeLocalCopyOfClientHandle ();    // handle resources.

    tx.WriteByte (100);    // Send a byte to the child process

    Console.WriteLine ("Server received: " + rx.ReadByte ());

    p.WaitForExit ();
  }
}</pre>
<p>As with named pipes, the client and server must coordinate their sending and receiving and agree on the length of each transmission. Anonymous pipes don’t, unfortunately, support message mode, so you must implement your own protocol for message length agreement. One solution is to send, in the first four bytes of each transmission, an integer value defining the length of the message to follow. The <code>BitConverter</code> class provides methods for converting between an integer and an array of four bytes.<a contenteditable="false" data-primary="" data-startref="ch15.html1010" data-type="indexterm" id="id3857"/><a contenteditable="false" data-primary="" data-startref="ch15.html109" data-type="indexterm" id="id3858"/><a contenteditable="false" data-primary="" data-startref="ch15.html106" data-type="indexterm" id="id3859"/><a contenteditable="false" data-primary="" data-startref="ch15.html105" data-type="indexterm" id="id3860"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="BufferedStream" data-type="sect2"><div class="sect2" id="bufferedstream">
<h2>BufferedStream</h2>
<p><a contenteditable="false" data-primary="BufferedStream class" data-type="indexterm" id="id3861"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="BufferedStream" data-type="indexterm" id="id3862"/><code>BufferedStream</code> decorates, or wraps, another stream with buffering capability, and it is one of a number of decorator stream types in .NET, all of which are illustrated in <a data-type="xref" href="#decorator_streams">Figure 15-4</a>.</p>
<figure><div class="figure" id="decorator_streams">
<img alt="Decorator streams" src="assets/cn10_1504.png"/>
<h6><span class="label">Figure 15-4. </span>Decorator streams</h6>
</div></figure>
<p>Buffering improves performance by reducing round trips to the backing store. Here’s how we wrap a <code>FileStream</code> in a 20 KB <code>BufferedStream</code>:</p>
<pre data-type="programlisting">// Write 100K to a file:
File.WriteAllBytes ("myFile.bin", new byte [100000]);

using FileStream fs = File.OpenRead ("myFile.bin");
using BufferedStream bs = new BufferedStream (fs, 20000);  //20K buffer

bs.ReadByte();
Console.WriteLine (fs.Position);         // 20000</pre>
<p>In this example, the underlying stream advances 20,000 bytes after reading just one byte, thanks to the read-ahead buffering. We could call <code>ReadByte</code> another 19,999 times before the <code>FileStream</code> would be hit again.</p>
<p>Coupling a <code>BufferedStream</code> to a <code>FileStream</code>, as in this example, is of limited value because <code>FileStream</code> already has built-in buffering. Its only use might be in enlarging the buffer on an already constructed <code>FileStream</code>.</p>
<p>Closing a <code>BufferedStream</code> automatically closes the underlying backing store stream.<a contenteditable="false" data-primary="" data-startref="ch15.html102" data-type="indexterm" id="id3863"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Stream Adapters" data-type="sect1"><div class="sect1" id="stream_adapters">
<h1>Stream Adapters</h1>
<p><a contenteditable="false" data-primary="stream adapters" data-type="indexterm" id="ch15.html1011"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="stream adapters" data-type="indexterm" id="ch15.html1012"/>A <code>Stream</code> deals only in bytes; to read or write data types such as strings, integers, or XML elements, you must plug in an adapter. Here’s what .NET provides:</p>
<dl>
<dt>Text adapters (for string and character data)</dt>
<dd><code>TextReader</code>, <code>TextWriter</code></dd>
<dd><code>StreamReader</code>, <code>StreamWriter</code></dd>
<dd><code>StringReader</code>, <code>StringWriter</code></dd>
<dt>Binary adapters (for primitive types such as <code>int</code>, <code>bool</code>, <code>string</code>, and <code>float</code>)</dt>
<dd><code>BinaryReader</code>, <code>BinaryWriter</code></dd>
<dt>XML adapters (covered in <a data-type="xref" href="ch11.html#other_xml_and_json_technologies">Chapter 11</a>)</dt>
<dd><code>XmlReader</code>, <code>XmlWriter</code></dd>
</dl>
<p><a data-type="xref" href="#readers_and_writers">Figure 15-5</a> illustrates the relationships between these types.</p>
<figure><div class="figure" id="readers_and_writers">
<img alt="Readers and writers" src="assets/cn10_1505.png"/>
<h6><span class="label">Figure 15-5. </span>Readers and writers</h6>
</div></figure>
<section data-pdf-bookmark="Text Adapters" data-type="sect2"><div class="sect2" id="text_adapters">
<h2>Text Adapters</h2>
<p><a contenteditable="false" data-primary="stream adapters" data-secondary="text adapters" data-type="indexterm" id="ch15.html1013"/><a contenteditable="false" data-primary="text adapters" data-type="indexterm" id="ch15.html1014"/><code>TextReader</code> and <code>TextWriter</code> are the abstract base classes for adapters that deal exclusively with characters and strings. Each has two general-purpose implementations in .NET:</p>
<dl>
<dt><code>StreamReader</code>/<code>StreamWriter</code></dt>
<dd>Uses a <code>Stream</code> for its raw data store, translating the stream’s bytes into characters or strings</dd>
<dt><code>StringReader</code>/<code>StringWriter</code></dt>
<dd>Implements <code>TextReader</code>/<code>TextWriter</code> using in-memory strings</dd>
</dl>
<p><a data-type="xref" href="#textreader_members">Table 15-2</a> lists <code>TextReader</code>’s members by category. <code>Peek</code> returns the next character in the stream without advancing the position. Both <code>Peek</code> and the zero-argument version of <code>Read</code> return −1 if at the end of the stream; otherwise, they return an integer that can be cast directly to a <code>char</code>. The overload of <code>Read</code> that accepts a <code>char[]</code> buffer is identical in functionality to the <code>ReadBlock</code> method. <code>ReadLine</code> reads until reaching either a CR (character 13) or LF (character 10), or a CR+LF pair in sequence. It then returns a string, discarding the CR/LF characters.</p>
<table class="border" id="textreader_members">
<caption><span class="label">Table 15-2. </span>TextReader members</caption>
<thead>
<tr>
<th>Category</th>
<th>Members</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reading one char</td>
<td><code>public virtual int Peek(); // Cast the result to a char</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual int Read(); // Cast the result to a char</code></td>
</tr>
<tr>
<td>Reading many chars</td>
<td><code>public virtual int Read (char[] buffer, int index, int count);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual int ReadBlock (char[] buffer, int index, int count);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual string ReadLine();</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual string ReadToEnd();</code></td>
</tr>
<tr>
<td>Closing</td>
<td><code>public virtual void Close();</code></td>
</tr>
<tr>
<td/>
<td><code>public void Dispose(); // Same as Close</code></td>
</tr>
<tr>
<td>Other</td>
<td><code>public static readonly TextReader Null;</code></td>
</tr>
<tr>
<td/>
<td><code>public static TextReader Synchronized (TextReader reader);</code></td>
</tr>
</tbody>
</table>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Environment.NewLine</code> returns the new-line sequence for the current OS.</p>
<p>On Windows, this is <code>"\r\n"</code> (think “ReturN”) and is loosely modeled on a mechanical typewriter: a CR (character 13) followed by an LF (character 10). Reverse the order and you’ll get either two new lines or none!</p>
<p>On Unix and macOS, it’s simply <code>"\n"</code>.</p>
</div>
<p><code>TextWriter</code> has analogous methods for writing, as shown in <a data-type="xref" href="#textwriter_members">Table 15-3</a>. The <code>Write</code> and <code>WriteLine</code> methods are additionally overloaded to accept every primitive type, plus the <code>object</code> type. These methods simply call the <code>ToString</code> method on whatever is passed in (optionally through an <code>IFormatProvider</code> specified either when calling the method or when constructing the <code>TextWriter</code>).</p>
<table class="border" id="textwriter_members">
<caption><span class="label">Table 15-3. </span>TextWriter members</caption>
<thead>
<tr>
<th>Category</th>
<th>Members</th>
</tr>
</thead>
<tbody>
<tr>
<td>Writing one char</td>
<td><code>public virtual void Write (char value);</code></td>
</tr>
<tr>
<td>Writing many chars</td>
<td><code>public virtual void Write (string value);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual void Write (char[] buffer, int index, int count);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual void Write (string format, params object[] arg);</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual void WriteLine (string value);</code></td>
</tr>
<tr>
<td>Closing and flushing</td>
<td><code>public virtual void Close();</code></td>
</tr>
<tr>
<td/>
<td><code>public void Dispose(); // Same as Close</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual void Flush();</code></td>
</tr>
<tr>
<td>Formatting and encoding</td>
<td><code>public virtual IFormatProvider FormatProvider { get; }</code></td>
</tr>
<tr>
<td/>
<td><code>public virtual string NewLine { get; set; }</code></td>
</tr>
<tr>
<td/>
<td><code>public abstract Encoding Encoding { get; }</code></td>
</tr>
<tr>
<td>Other</td>
<td><code>public static readonly TextWriter Null;</code></td>
</tr>
<tr>
<td/>
<td><code>public static TextWriter Synchronized (TextWriter writer);</code></td>
</tr>
</tbody>
</table>
<p><code>WriteLine</code> simply appends the given text with <code>Environment.NewLine</code>. You can change this via the <code>NewLine</code> property (this can be useful for interoperability with Unix file formats).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As with <code>Stream</code>, <code>TextReader</code> and <code>TextWriter</code> offer task-based asynchronous versions of their read/write methods.</p>
</div>
<section data-pdf-bookmark="StreamReader and StreamWriter" data-type="sect3"><div class="sect3" id="streamreader_and_streamwriter">
<h3>StreamReader and StreamWriter</h3>
<p><a contenteditable="false" data-primary="Stream..." data-secondary="StreamReader" data-type="indexterm" id="id3864"/><a contenteditable="false" data-primary="Stream..." data-secondary="StreamWriter" data-type="indexterm" id="id3865"/><a contenteditable="false" data-primary="text adapters" data-secondary="StreamReader and StreamWriter" data-type="indexterm" id="id3866"/>In the following example, a <code>StreamWriter</code> writes two lines of text to a file, and then a <code>StreamReader</code> reads the file back:</p>
<pre data-type="programlisting">using (FileStream fs = File.Create ("test.txt"))
using (TextWriter writer = new StreamWriter (fs))
{
  writer.WriteLine ("Line1");
  writer.WriteLine ("Line2");
}

using (FileStream fs = File.OpenRead ("test.txt"))
using (TextReader reader = new StreamReader (fs))
{
  Console.WriteLine (reader.ReadLine());       // Line1
  Console.WriteLine (reader.ReadLine());       // Line2
}</pre>
<p>Because text adapters are so often coupled with files, the <code>File</code> class provides the static methods <code>CreateText</code>, <code>AppendText</code>, and <code>OpenText</code> to shortcut the process:</p>
<pre data-type="programlisting">using (TextWriter writer = File.CreateText ("test.txt"))
{
  writer.WriteLine ("Line1");
  writer.WriteLine ("Line2");
}


using (TextWriter writer = File.AppendText ("test.txt"))
  writer.WriteLine ("Line3");

using (TextReader reader = File.OpenText ("test.txt"))
  while (reader.Peek() &gt; -1)
    Console.WriteLine (reader.ReadLine());     // Line1
                                               // Line2
                                               // Line3</pre>
<p>This also illustrates how to test for the end of a file (viz. <code>reader.Peek()</code>). Another option is to read until <code>reader.ReadLine</code> returns null.</p>
<p>You can also read and write other types such as integers, but because <code>TextWriter</code> invokes <code>ToString</code> on your type, you must parse a string when reading it back:</p>
<pre data-type="programlisting">using (TextWriter w = File.CreateText ("data.txt"))
{
  w.WriteLine (123);          // Writes "123"
  w.WriteLine (true);         // Writes the word "true"
}

using (TextReader r = File.OpenText ("data.txt"))
{
  int myInt = int.Parse (r.ReadLine());     // myInt == 123
  bool yes = bool.Parse (r.ReadLine());     // yes == true
}</pre>
</div></section>
<section data-pdf-bookmark="Character encodings" data-type="sect3"><div class="sect3" id="character_encodings">
<h3>Character encodings</h3>
<p><a contenteditable="false" data-primary="text adapters" data-secondary="character encodings" data-type="indexterm" id="id3867"/><code>TextReader</code> and <code>TextWriter</code> are by themselves just abstract classes with no connection to a stream or backing store. The <code>StreamReader</code> and <code>StreamWriter</code> types, however, are connected to an underlying byte-oriented stream, so they must convert between characters and bytes. They do so through an <code>Encoding</code> class from the <code>System.Text</code> namespace, which you choose when constructing the <code>StreamReader</code> or <code>StreamWriter</code>. If you choose none, the default UTF-8 encoding is used.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you explicitly specify an encoding, <code>StreamWriter</code> will, by default, write a prefix to the start of the stream to identity the encoding. This is usually undesirable, and you can prevent it by constructing the encoding as follows:</p>
<pre data-type="programlisting">var encoding = new UTF8Encoding (
  encoderShouldEmitUTF8Identifier:false,
  throwOnInvalidBytes:true);</pre>
<p>The second argument tells the <code>StreamWriter</code> (or <code>StreamReader</code>) to throw an exception if it encounters bytes that do not have a valid string translation for their encoding, which matches its default behavior if you do not specify an encoding.</p>
</div>
<p>The simplest of the encodings is ASCII because each character is represented by one byte. The ASCII encoding maps the first 127 characters of the Unicode set into its single byte, covering what you see on a US-style keyboard. Most other characters, including specialized symbols and non-English characters, cannot be represented and are converted to the □ character. The default UTF-8 encoding can map all allocated Unicode characters, but it is more complex. The first 127 characters encode to a single byte, for ASCII compatibility; the remaining characters encode to a variable number of bytes (most commonly two or three). Consider the following:</p>
<pre data-type="programlisting">using (TextWriter w = File.CreateText ("but.txt"))    // Use default UTF-8
  w.WriteLine ("but-");                               // encoding.

using (Stream s = File.OpenRead ("but.txt"))
  for (int b; (b = s.ReadByte()) &gt; -1;)
    Console.WriteLine (b);</pre>
<p>The word “but” is followed not by a stock-standard hyphen but by the longer em dash (—) character, U+2014. This is the one that won’t get you into trouble with your book editor! Let’s examine the output:</p>
<pre data-type="programlisting">98     // b
117    // u
116    // t
226    // em dash byte 1       Note that the byte values
128    // em dash byte 2       are &gt;= 128 for each part
148    // em dash byte 3       of the multibyte sequence.
13     // &lt;CR&gt;
10     // &lt;LF&gt;</pre>
<p>Because the em dash is outside the first 127 characters of the Unicode set, it requires more than a single byte to encode in UTF-8 (in this case, three). UTF-8 is efficient with the Western alphabet as most popular characters consume just one byte. It also downgrades easily to ASCII simply by ignoring all bytes above 127. Its disadvantage is that seeking within a stream is troublesome because a character’s position does not correspond to its byte position in the stream. An alternative is UTF-16 (labeled just “Unicode” in the <code>Encoding</code> class). Here’s how we write the same string with UTF-16:</p>
<pre data-type="programlisting">using (Stream s = File.Create ("but.txt"))
using (TextWriter w = new StreamWriter (s, Encoding.Unicode))
  w.WriteLine ("but-");

foreach (byte b in File.ReadAllBytes ("but.txt"))
  Console.WriteLine (b);</pre>
<p>And here’s the output:</p>
<pre data-type="programlisting">255    // Byte-order mark 1
254    // Byte-order mark 2
98     // 'b' byte 1
0      // 'b' byte 2
117    // 'u' byte 1
0      // 'u' byte 2
116    // 't' byte 1
0      // 't' byte 2
20     // '--' byte 1
32     // '--' byte 2
13     // &lt;CR&gt; byte 1
0      // &lt;CR&gt; byte 2
10     // &lt;LF&gt; byte 1
0      // &lt;LF&gt; byte 2</pre>
<p>Technically, UTF-16 uses either two or four bytes per character (there are close to a million Unicode characters allocated or reserved, so two bytes is not always enough). However, because the C# <code>char</code> type is itself only 16 bits wide, a UTF-16 encoding will always use exactly two bytes per .NET <code>char</code>. This makes it easy to jump to a particular character index within a stream.</p>
<p>UTF-16 uses a two-byte prefix to identify whether the byte pairs are written in a “little-endian” or “big-endian” order (the least significant byte first or the most significant byte first). The default little-endian order is standard for Windows-based systems.</p>
</div></section>
<section data-pdf-bookmark="StringReader and StringWriter" data-type="sect3"><div class="sect3" id="stringreader_and_stringwriter">
<h3>StringReader and StringWriter</h3>
<p><a contenteditable="false" data-primary="String..." data-secondary="StringReader" data-type="indexterm" id="id3868"/><a contenteditable="false" data-primary="String..." data-secondary="StringWriter" data-type="indexterm" id="id3869"/><a contenteditable="false" data-primary="text adapters" data-secondary="StringReader and StringWriter" data-type="indexterm" id="id3870"/>The <code>StringReader</code> and <code>StringWriter</code> adapters don’t wrap a stream at all; instead, they use a string or <code>StringBuilder</code> as the underlying data source. This means no byte translation is required—in fact, the classes do nothing you couldn’t easily achieve with a string or <code>StringBuilder</code> coupled with an index variable. Their advantage, though, is that they share a base class with <code>StreamReader</code>/<code>StreamWriter</code>. For instance, suppose that we have a string containing XML and want to parse it with an <code>XmlReader</code>. The <code>XmlReader.Create</code> method accepts one of the following:</p>
<ul>
<li><p>A <code>URI</code></p></li>
<li><p>A <code>Stream</code></p></li>
<li><p>A <code>TextReader</code></p></li>
</ul>
<p>So, how do we XML-parse our string? Because <code>StringReader</code> is a subclass of <code>TextReader</code>, we’re in luck. We can instantiate and pass in a <code>StringReader</code> as follows:<a contenteditable="false" data-primary="" data-startref="ch15.html1014" data-type="indexterm" id="id3871"/><a contenteditable="false" data-primary="" data-startref="ch15.html1013" data-type="indexterm" id="id3872"/></p>
<pre data-type="programlisting">XmlReader r = XmlReader.Create (new StringReader (myString));</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Binary Adapters" data-type="sect2"><div class="sect2" id="binary_adapters">
<h2>Binary Adapters</h2>
<p><a contenteditable="false" data-primary="binary adapters" data-type="indexterm" id="id3873"/><a contenteditable="false" data-primary="stream adapters" data-secondary="binary adapters" data-type="indexterm" id="id3874"/><code>BinaryReader</code> and <code>BinaryWriter</code> read and write native data types: <code>bool</code>, <code>byte</code>, <code>char</code>, <code>decimal</code>, <code>float</code>, <code>double</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>sbyte</code>, <code>ushort</code>, <code>uint</code>, and <code>ulong</code>, as well as <code>string</code>s and arrays of the primitive data types.</p>
<p>Unlike <code>StreamReader</code> and <code>StreamWriter</code>, binary adapters store primitive data types efficiently because they are represented in memory. So, an <code>int</code> uses four bytes; a <code>double</code> uses eight bytes. Strings are written through a text encoding (as with <code>StreamReader</code> and <code>StreamWriter</code>) but are length-prefixed in order to make it possible to read back a series of strings without needing special delimiters.</p>
<p>Imagine that we have a simple type, defined as follows:</p>
<pre class="pagebreak-before" data-type="programlisting">public class Person
{
  public string Name;
  public int    Age;
  public double Height;
}</pre>
<p>We can add the following methods to <code>Person</code> to save/load its data to/from a stream using binary adapters:</p>
<pre data-type="programlisting">public void SaveData (Stream s)
{
  var w = new BinaryWriter (s);
  w.Write (Name);
  w.Write (Age);
  w.Write (Height);
  w.Flush();         // Ensure the BinaryWriter buffer is cleared.
                     // We won't dispose/close it, so more data
}                    // can be written to the stream.

public void LoadData (Stream s)
{
  var r = new BinaryReader (s);
  Name   = r.ReadString();
  Age    = r.ReadInt32();
  Height = r.ReadDouble();
}</pre>
<p><code>BinaryReader</code> can also read into byte arrays. The following reads the entire contents of a seekable stream:</p>
<pre data-type="programlisting">byte[] data = new BinaryReader (s).ReadBytes ((int) s.Length);</pre>
<p>This is more convenient than reading directly from a stream because it doesn’t require a loop to ensure that all data has been read.</p>
</div></section>
<section data-pdf-bookmark="Closing and Disposing Stream Adapters" data-type="sect2"><div class="sect2" id="closing_and_disposing_stream_adapters">
<h2>Closing and Disposing Stream Adapters</h2>
<p><a contenteditable="false" data-primary="stream adapters" data-secondary="closing and disposing" data-type="indexterm" id="id3875"/>You have four choices in tearing down stream adapters:</p>
<ol>
<li><p>Close the adapter only</p></li>
<li><p>Close the adapter and then close the stream</p></li>
<li><p>(For writers) Flush the adapter and then close the stream</p></li>
<li><p>(For readers) Close just the stream</p></li>
</ol>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Close</code> and <code>Dispose</code> are synonymous with adapters, just as they are with streams.</p>
</div>
<p>Options 1 and 2 are semantically identical because closing an adapter automatically closes the underlying stream. Whenever you nest <code>using</code> statements, you’re implicitly taking option 2:</p>
<pre data-type="programlisting">using (FileStream fs = File.Create ("test.txt"))
using (TextWriter writer = new StreamWriter (fs))
  writer.WriteLine ("Line");</pre>
<p>Because the nest disposes from the inside out, the adapter is first closed, and then the stream. Furthermore, if an exception is thrown within the adapter’s constructor, the stream still closes. It’s hard to go wrong with nested <code>using</code> statements!</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Never close a stream before closing or flushing its writer—you’ll amputate any data that’s buffered in the adapter.</p>
</div>
<p>Options 3 and 4 work because adapters are in the unusual category of <em>optionally</em> disposable objects. An example of when you might choose not to dispose an adapter is when you’ve finished with the adapter but you want to leave the underlying stream open for subsequent use:</p>
<pre data-type="programlisting">using (FileStream fs = new FileStream ("test.txt", FileMode.Create))
{
  StreamWriter writer = new StreamWriter (fs);
  writer.WriteLine ("Hello");
  writer.Flush();

  fs.Position = 0;
  Console.WriteLine (fs.ReadByte());
}</pre>
<p>Here, we write to a file, reposition the stream, and then read the first byte before closing the stream. If we disposed the <code>StreamWriter</code>, it would also close the underlying <code>FileStream</code>, causing the subsequent read to fail. The proviso is that we call <code>Flush</code> to ensure that the <code>StreamWriter</code>’s buffer is written to the underlying stream.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Stream adapters—with their optional disposal semantics—do not implement the extended disposal pattern where the finalizer calls <code>Dispose</code>. This allows an abandoned adapter to evade automatic disposal when the garbage collector catches up with it.</p>
</div>
<p><a contenteditable="false" data-primary="stream adapters" data-secondary="closing and disposing" data-type="indexterm" id="id3876"/>There’s also a constructor on <code>StreamReader</code>/<code>StreamWriter</code> that instructs it to keep the stream open after disposal. Consequently, we can rewrite the preceding example as follows:<a contenteditable="false" data-primary="" data-startref="ch15.html1012" data-type="indexterm" id="id3877"/><a contenteditable="false" data-primary="" data-startref="ch15.html1011" data-type="indexterm" id="id3878"/></p>
<pre data-type="programlisting">using (var fs = new FileStream ("test.txt", FileMode.Create))
{
  using (var writer = new StreamWriter (fs, new UTF8Encoding (false, true),
                                       0x400, <strong>true</strong>))
    writer.WriteLine ("Hello");

  fs.Position = 0;
  Console.WriteLine (fs.ReadByte());
  Console.WriteLine (fs.Length);
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Compression Streams" data-type="sect1"><div class="sect1" id="compression_streams">
<h1>Compression Streams</h1>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.IO.Compression" data-type="indexterm" id="id3879"/><a contenteditable="false" data-primary="compression streams" data-type="indexterm" id="ch15.html1015"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="compression streams" data-type="indexterm" id="ch15.html1016"/>Two general-purpose compression streams are provided in the <code>System.IO.Compression</code> namespace: <a contenteditable="false" data-primary="DeflateStream" data-type="indexterm" id="ch15.html1017"/><code>DeflateStream</code> and <a contenteditable="false" data-primary="GZipStream" data-type="indexterm" id="id3880"/><code>GZipStream</code>. Both use a popular compression algorithm similar to that of the ZIP format. They differ in that <code>GZipStream</code> writes an additional protocol at the start and end—including a CRC to detect errors. <code>GZipStream</code> also conforms to a standard recognized by other software.</p>
<p><a contenteditable="false" data-primary="BrotliStream" data-type="indexterm" id="id3881"/>.NET also includes <code>BrotliStream</code>, which implements the <em>Brotli</em> compression algorithm. <code>BrotliStream</code> is more than 10 times slower than <code>DeflateStream</code> and <code>GZipStream</code> but achieves a better compression ratio. (The performance hit applies only to compression—decompression performs very well.)</p>
<p>All three streams allow reading and writing, with the following provisos:</p>
<ul>
<li><p>You always <em>write</em> to the stream when compressing.</p></li>
<li><p>You always <em>read</em> from the stream when decompressing.</p></li>
</ul>
<p><code>DeflateStream</code>, <code>GZipStream</code>, and <code>BrotliStream</code> are decorators; they compress or decompress data from another stream that you supply in construction. In the following example, we compress and decompress a series of bytes using a <code>FileStream</code> as the backing store:</p>
<pre data-type="programlisting">using (Stream s = File.Create ("compressed.bin"))
using (Stream ds = new DeflateStream (s, CompressionMode.Compress))
  for (byte i = 0; i &lt; 100; i++)
    ds.WriteByte (i);

using (Stream s = File.OpenRead ("compressed.bin"))
using (Stream ds = new DeflateStream (s, CompressionMode.Decompress))
  for (byte i = 0; i &lt; 100; i++)
    Console.WriteLine (ds.ReadByte());     // Writes 0 to 99</pre>
<p>With <code>DeflateStream</code>, the compressed file is 102 bytes: slightly larger than the original (<code>BrotliStream</code> would compress it to 73 bytes). Compression works poorly with “dense,” nonrepetitive binary data (and worst of all with encrypted data, which lacks regularity by design). It works well with most text files; in the next example, we compress and decompress a text stream composed of 1,000 words chosen randomly from a small sentence with the <em>Brotli</em> algorithm. This also demonstrates chaining a backing store stream, a decorator stream, an adapter (as depicted at the start of the chapter in <a data-type="xref" href="#stream_architecture-id00092">Figure 15-1</a>), and the use of asynchronous methods:</p>
<pre data-type="programlisting">string[] words = "The quick brown fox jumps over the lazy dog".Split();
Random rand = new Random (0);   // Give it a seed for consistency

using (Stream s = File.Create ("compressed.bin"))
using (Stream ds = new BrotliStream (s, CompressionMode.Compress))
using (TextWriter w = new StreamWriter (ds))
  for (int i = 0; i &lt; 1000; i++)
    await w.WriteAsync (words [rand.Next (words.Length)] + " ");

Console.WriteLine (new FileInfo ("compressed.bin").Length);      // 808

using (Stream s = File.OpenRead ("compressed.bin"))
using (Stream ds = new BrotliStream (s, CompressionMode.Decompress))
using (TextReader r = new StreamReader (ds))
  Console.Write (await r.ReadToEndAsync());  // Output below:

lazy lazy the fox the quick The brown fox jumps over fox over fox The
brown brown brown over brown quick fox brown dog dog lazy fox dog brown
over fox jumps lazy lazy quick The jumps fox jumps The over jumps dog...</pre>
<p>In this case, <code>BrotliStream</code> compresses efficiently to 808 bytes—less than one byte per word. (For comparison, <code>DeflateStream</code> compresses the same data to 885 bytes.)</p>
<section data-pdf-bookmark="Compressing in Memory" data-type="sect2"><div class="sect2" id="compressing_in_memory">
<h2>Compressing in Memory</h2>
<p><a contenteditable="false" data-primary="compression streams" data-secondary="compressing in memory" data-type="indexterm" id="id3882"/>Sometimes, you need to compress entirely in memory. Here’s how to use a <code>MemoryStream</code> for this purpose:</p>
<pre data-type="programlisting">byte[] data = new byte[1000];          // We can expect a good compression
                                       // ratio from an empty array!
var ms = new MemoryStream();
using (Stream ds = new DeflateStream (ms, CompressionMode.Compress))
  ds.Write (data, 0, data.Length);

byte[] compressed = ms.ToArray();
Console.WriteLine (compressed.Length);       // 11

// Decompress back to the data array:
ms = new MemoryStream (compressed);
using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))
  for (int i = 0; i &lt; 1000; i += ds.Read (data, i, 1000 - i));</pre>
<p>The <code>using</code> statement around the <code>DeflateStream</code> closes it in a textbook fashion, flushing any unwritten buffers in the process. This also closes the <code>MemoryStream</code> it wraps—meaning we must then call <code>ToArray</code> to extract its data.</p>
<p>Here’s an alternative that avoids closing the <code>MemoryStream</code> and uses the asynchronous read and write methods:</p>
<pre data-type="programlisting">byte[] data = new byte[1000];

MemoryStream ms = new MemoryStream();
using (Stream ds = new DeflateStream (ms, CompressionMode.Compress, <strong>true</strong>))
  await ds.WriteAsync (data, 0, data.Length);

Console.WriteLine (ms.Length);             // 113
<strong>ms.Position = 0;</strong>
using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))
  for (int i = 0; i &lt; 1000; i += await ds.ReadAsync (data, i, 1000 - i));</pre>
<p>The additional flag sent to <code>DeflateStream</code>’s constructor instructs it to not follow the usual protocol of taking the underlying stream with it in disposal. In other words, the <code>MemoryStream</code> is left open, allowing us to position it back to zero and reread it.<a contenteditable="false" data-primary="" data-startref="ch15.html1017" data-type="indexterm" id="id3883"/></p>
</div></section>
<section data-pdf-bookmark="Unix gzip File Compression" data-type="sect2"><div class="sect2" id="unix_gzip_file_compression">
<h2>Unix gzip File Compression</h2>
<p><a contenteditable="false" data-primary="Unix" data-secondary="gzip file compression" data-type="indexterm" id="id3884"/><a contenteditable="false" data-primary="file compression" data-type="indexterm" id="id3885"/><a contenteditable="false" data-primary="gzip file compression" data-type="indexterm" id="id3886"/><a contenteditable="false" data-primary="Unix gzip file compression" data-type="indexterm" id="id3887"/><code>GZipStream</code>’s compression algorithm is popular on Unix systems as a file compression format. Each source file is compressed into a separate target file with a <em>.gz</em> extension.</p>
<p>The following methods do the work of the Unix command-line gzip and gunzip utilities:</p>
<pre data-type="programlisting">async Task GZip (string sourcefile, bool deleteSource = true)
{
  var gzip = $"{sourcefile}.gz";
  if (File.Exists (gzip))
    throw new Exception ("Gzip file already exists");

  // Compress
  using (FileStream inStream = File.Open (sourcefile, FileMode.Open))
  using (FileStream outStream = new FileStream (gzip, FileMode.CreateNew))
  using (GZipStream gzipStream = 
    new GZipStream (outStream, CompressionMode.Compress))
    await inStream.CopyToAsync (gzipStream); 
  
  if (deleteSource) File.Delete(sourcefile);
}

async Task GUnzip (string gzipfile, bool deleteGzip = true)
{
  if (Path.GetExtension (gzipfile) != ".gz") 
    throw new Exception ("Not a gzip file");

  var uncompressedFile = gzipfile.Substring (0, gzipfile.Length - 3);
  if (File.Exists (uncompressedFile)) 
    throw new Exception ("Destination file already exists");

  // Uncompress
  using (FileStream uncompressToStream = 
         File.Open (uncompressedFile, FileMode.Create))
  using (FileStream zipfileStream = File.Open (gzipfile, FileMode.Open))
  using (var unzipStream = 
         new GZipStream (zipfileStream, CompressionMode.Decompress))
    await unzipStream.CopyToAsync (uncompressToStream);
    
  if (deleteGzip) File.Delete (gzipfile);
}</pre>
<p>The following compresses a file:</p>
<pre data-type="programlisting">await GZip ("/tmp/myfile.txt");      // Creates /tmp/myfile.txt.gz</pre>
<p class="pagebreak-before">And the following decompresses it:<a contenteditable="false" data-primary="" data-startref="ch15.html1016" data-type="indexterm" id="id3888"/><a contenteditable="false" data-primary="" data-startref="ch15.html1015" data-type="indexterm" id="id3889"/></p>
<pre data-type="programlisting">await GUnzip ("/tmp/myfile.txt.gz")  // Creates /tmp/myfile.txt</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Working with ZIP Files" data-type="sect1"><div class="sect1" id="working_with_zip_files">
<h1>Working with ZIP Files</h1>
<p><a contenteditable="false" data-primary="streams and I/O" data-secondary="ZIP files" data-type="indexterm" id="id3890"/><a contenteditable="false" data-primary="System..." data-secondary="System.IO.Compression" data-type="indexterm" id="id3891"/><a contenteditable="false" data-primary="ZIP files" data-type="indexterm" id="id3892"/><a contenteditable="false" data-primary="ZipArchive class" data-type="indexterm" id="id3893"/><a contenteditable="false" data-primary="ZipFile class" data-type="indexterm" id="id3894"/>The <code>ZipArchive</code> and <code>ZipFile</code> classes in <code>System.IO.Compression</code> support the ZIP compression format. The advantage of the ZIP format over <code>DeflateStream</code> and <code>GZipStream</code> is that it also acts as a container for multiple files and is compatible with ZIP files created with Windows Explorer.</p>
<p><code>ZipArchive</code> works with streams, whereas <code>ZipFile</code> addresses the more common scenario of working with files. (<code>ZipFile</code> is a static helper class for <code>ZipArchive</code>.)</p>
<p><code>ZipFile</code>’s <code>CreateFromDirectory</code> method adds all the files in a specified directory into a ZIP file:</p>
<pre data-type="programlisting">ZipFile.CreateFromDirectory (@"d:\MyFolder", @"d:\archive.zip");</pre>
<p><code>ExtractToDirectory</code> does the opposite and extracts a ZIP file to a directory:</p>
<pre data-type="programlisting">ZipFile.ExtractToDirectory (@"d:\archive.zip", @"d:\MyFolder");</pre>
<p>(From .NET 8, you can also specify a <code>Stream</code> instead of a zip file path.)</p>
<p>When compressing, you can specify whether to optimize for file size or speed as well as whether to include the name of the source directory in the archive. Enabling the latter option in our example would create a subdirectory in the archive called <em>MyFolder</em> into which the compressed files would go.</p>
<p><code>ZipFile</code> has an <code>Open</code> method for reading/writing individual entries. This returns a <code>ZipArchive</code> object (which you can also obtain by instantiating <code>ZipArchive</code> with a <code>Stream</code> object). When calling <code>Open</code>, you must specify a filename and indicate whether you want to <code>Read</code>, <code>Create</code>, or <code>Update</code> the archive. You can then enumerate existing entries via the <code>Entries</code> property or find a particular file by calling <code>GetEntry</code>:</p>
<pre data-type="programlisting">using (ZipArchive zip = ZipFile.Open (@"d:\zz.zip", ZipArchiveMode.Read))

  foreach (ZipArchiveEntry entry in zip.Entries)
    Console.WriteLine (entry.FullName + " " + entry.Length);</pre>
<p><code>ZipArchiveEntry</code> also has a <code>Delete</code> method, an <code>ExtractToFile</code> method (this is actually an extension method in the <code>ZipFileExtensions</code> class), and an <code>Open</code> method that returns a readable/writable <code>Stream</code>. You can create new entries by calling <code>CreateEntry</code> (or the <code>CreateEntryFromFile</code> extension method) on the <code>ZipArchive</code>. The following creates the archive <em>d:\zz.zip</em>, to which it adds <em>foo.dll</em>, under a directory structure within the archive called <em>bin\X86</em>:</p>
<pre data-type="programlisting">byte[] data = File.ReadAllBytes (@"d:\foo.dll"); 
using (ZipArchive zip = ZipFile.Open (@"d:\zz.zip", ZipArchiveMode.Update))
  zip.CreateEntry (@"bin\X64\foo.dll").Open().Write (data, 0, data.Length);</pre>
<p>You could do the same thing entirely in memory by constructing <code>ZipArchive</code> with a <code>MemoryStream</code>.</p>
</div></section>
<section data-pdf-bookmark="Working with Tar Files" data-type="sect1"><div class="sect1" id="working_with_tar_files">
<h1>Working with Tar Files</h1>
<p><a contenteditable="false" data-primary=".tar files" data-primary-sortas="tar files" data-type="indexterm" id="id3895"/><a contenteditable="false" data-primary="streams and I/O" data-secondary=".tar files" data-secondary-sortas="tar files" data-type="indexterm" id="id3896"/>The types in the <code>System.Formats.Tar</code> namespace (from .NET 7) support the <em>.tar</em> archive format, popular on Unix systems for bundling multiple files. To create a <em>.tar</em> file (a <em>tarball</em>), call <code>TarFile.CreateFromDirectory</code>:</p>
<pre data-type="programlisting">TarFile.CreateFromDirectory ("/tmp/testfolder", "/tmp/test.tar", false);</pre>
<p>(The third argument indicates whether to include the base directory name in the archive entries.)</p>
<p>To extract a tarball, call <code>TarFile.ExtractToDirectory</code>:</p>
<pre data-type="programlisting">TarFile.ExtractToDirectory ("/tmp/test.tar", "/tmp/testfolder", true);</pre>
<p>(The third argument indicates whether to overwrite existing files.)</p>
<p>Both of these methods let you specify a <code>Stream</code> instead of a <em>.tar</em> filepath. In the following example, we write the tarball to a memory stream, and then use <code>GZipStream</code> to compress that stream to a <em>.tar.gz</em> file:</p>
<pre data-type="programlisting">var ms = new MemoryStream();
TarFile.CreateFromDirectory ("/tmp/testfolder", ms, false);
ms.Position = 0;    // So that we can re-use the stream for reading.
using (var fs = File.Create ("/tmp/test.tar.gz"))
using (var gz = new GZipStream (fs, CompressionMode.Compress))
  ms.CopyTo (gz);</pre>
<p>(Compressing a <em>.tar</em> into a <em>.tar.gz</em> is useful because the <em>.tar</em> format does not itself incorporate compression, unlike the <em>.zip</em> format.) We can extract the <em>.tar.gz</em> file as follows:</p>
<pre data-type="programlisting">using (var fs = File.OpenRead ("/tmp/test.tar.gz"))
using (var gz = new GZipStream (fs, CompressionMode.Decompress))
  TarFile.ExtractToDirectory (gz, "/tmp/testfolder", true);</pre>
<p>You can also access the API at a more granular level with the <code>TarReader</code> and <code>TarWriter</code> classes. The following illustrates the use of <code>TarReader</code>:</p>
<pre data-type="programlisting">using (FileStream archiveStream = File.OpenRead ("/tmp/test.tar "))
using (TarReader reader = new (archiveStream))
  while (true)
  {
    TarEntry entry = reader.GetNextEntry();
    if (entry == null) break;   // No more entries
    Console.WriteLine (
      $"Entry {entry.Name} is {entry.DataStream.Length} bytes long");
    entry.ExtractToFile (
      Path.Combine ("/tmp/testfolder", entry.Name), true);
  }</pre>
</div></section>
<section data-pdf-bookmark="File and Directory Operations" data-type="sect1"><div class="sect1" id="file_and_directory_operations">
<h1>File and Directory Operations</h1>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.IO" data-type="indexterm" id="id3897"/> <a contenteditable="false" data-primary="file and directory operations" data-type="indexterm" id="ch15.html1018"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="file and directory operations" data-type="indexterm" id="ch15.html1019"/>The <code>System.IO</code> namespace provides a set of types for performing “utility” file and directory operations, such as copying and moving, creating directories, and setting file attributes and permissions. For most features, you can choose between either of two classes, one offering static methods and the other instance methods:</p>
<dl>
<dt>Static classes</dt>
<dd><code>File</code> and <code>Directory</code></dd>
<dt>Instance-method classes (constructed with a file or directory name)</dt>
<dd><code>FileInfo</code> and <code>DirectoryInfo</code></dd>
</dl>
<p>Additionally, there’s a static class called <code>Path</code>. This does nothing to files or directories; instead, it provides string manipulation methods for filenames and directory paths. <code>Path</code> also assists with temporary files.</p>
<section data-pdf-bookmark="The File Class" data-type="sect2"><div class="sect2" id="the_file_class">
<h2>The File Class</h2>
<p><a contenteditable="false" data-primary="file and directory operations" data-secondary="File class" data-type="indexterm" id="ch15.html1020"/><code>File</code> is a static class whose methods all accept a filename. The filename can be either relative to the current directory or fully qualified with a directory. Here are its methods (all <code>public</code> and <code>static</code>):</p>
<pre data-type="programlisting">bool Exists (string path);      // Returns true if the file is present

void Delete  (string path);
void Copy    (string sourceFileName, string destFileName);
void Move    (string sourceFileName, string destFileName);
void Replace (string sourceFileName, string destinationFileName,
                                     string destinationBackupFileName);

FileAttributes GetAttributes (string path);
void SetAttributes           (string path, FileAttributes fileAttributes);

void Decrypt (string path);
void Encrypt (string path);

DateTime GetCreationTime   (string path);      // UTC versions are
DateTime GetLastAccessTime (string path);      // also provided.
DateTime GetLastWriteTime  (string path);

void SetCreationTime   (string path, DateTime creationTime);
void SetLastAccessTime (string path, DateTime lastAccessTime);
void SetLastWriteTime  (string path, DateTime lastWriteTime);

FileSecurity GetAccessControl (string path);
FileSecurity GetAccessControl (string path,
                               AccessControlSections includeSections);
void SetAccessControl (string path, FileSecurity fileSecurity);</pre>
<p><code>Move</code> throws an exception if the destination file already exists; <code>Replace</code> does not. Both methods allow the file to be renamed as well as moved to another directory.</p>
<p><code>Delete</code> throws an <code>UnauthorizedAccessException</code> if the file is marked read-only; you can tell this in advance by calling <code>GetAttributes</code>. It also throws that exception if the OS denies delete permission for that file to your process. Here are all the members of the <code>FileAttribute</code> enum that <code>GetAttributes</code> returns:</p>
<pre data-type="programlisting">Archive, Compressed, Device, Directory, Encrypted,
Hidden, IntegritySystem, Normal, NoScrubData, NotContentIndexed, 
Offline, ReadOnly, ReparsePoint, SparseFile, System, Temporary</pre>
<p>Members in this enum are combinable. Here’s how to toggle a single file attribute without upsetting the rest:</p>
<pre data-type="programlisting">string filePath = "test.txt";

FileAttributes fa = File.GetAttributes (filePath);
if ((fa &amp; FileAttributes.ReadOnly) != 0)
{
    // Use the exclusive-or operator (^) to toggle the ReadOnly flag
    fa ^= FileAttributes.ReadOnly;
    File.SetAttributes (filePath, fa);
}

// Now we can delete the file, for instance:
File.Delete (filePath);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>FileInfo</code> offers an easier way to change a file’s read-only flag:</p>
<pre data-type="programlisting">new FileInfo ("test.txt").IsReadOnly = false;</pre>
</div>
<section data-pdf-bookmark="Compression and encryption attributes" data-type="sect3"><div class="sect3" id="compression_and_encryption_attributes">
<h3>Compression and encryption attributes</h3>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="File class" data-secondary="compression and encryption attributes" data-type="indexterm" id="id3898"/><a contenteditable="false" data-primary="System..." data-secondary="System.Management" data-type="indexterm" id="id3899"/>This feature is Windows-only and requires the NuGet package <code>System.Management</code>.</p>
</div>
<p><a contenteditable="false" data-primary="Compressed file attribute" data-type="indexterm" id="id3900"/><a contenteditable="false" data-primary="Encrypted file attribute" data-type="indexterm" id="id3901"/>The <code>Compressed</code> and <code>Encrypted</code> file attributes correspond to the compression and encryption checkboxes on a file or directory’s Properties dialog box in Windows Explorer. This type of compression and encryption is <em>transparent</em> in that the OS does all the work behind the scenes, allowing you to read and write plain data.</p>
<p>You cannot use <code>SetAttributes</code> to change a file’s <code>Compressed</code> or <code>Encrypted</code> attributes—it fails silently if you try! The workaround is simple in the latter case: you instead call the <code>Encrypt()</code> and <code>Decrypt()</code> methods in the <code>File</code> class. <a contenteditable="false" data-primary="Windows Management Instrumentation (WMI) API" data-type="indexterm" id="id3902"/><a contenteditable="false" data-primary="WMI (Windows Management Instrumentation) API" data-type="indexterm" id="id3903"/>With compression, it’s more complicated; one solution is to use the Windows Management Instrumentation (WMI) API in <code>System.Management</code>. The following method compresses a directory, returning <code>0</code> if successful (or a WMI error code if not):</p>
<pre data-type="programlisting">static uint CompressFolder (string folder, bool recursive)
{
  string path = "Win32_Directory.Name='" + folder + "'";
  using (ManagementObject dir = new ManagementObject (path))
  using (ManagementBaseObject p = dir.GetMethodParameters ("CompressEx"))
  {
    p ["Recursive"] = recursive;
    using (ManagementBaseObject result = dir.InvokeMethod ("CompressEx",
                                                             p, null))
      return (uint) result.Properties ["ReturnValue"].Value;
  }
}</pre>
<p>To uncompress, replace <code>CompressEx</code> with <code>UncompressEx</code>.</p>
<p>Transparent encryption relies on a key seeded from the logged-in user’s password. The system is robust to password changes performed by the authenticated user, but if a password is reset via an administrator, data in encrypted files is unrecoverable.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Transparent encryption and compression require special filesystem support. NTFS (used most commonly on hard drives) supports these features; CDFS (on CD-ROMs) and FAT (on removable media cards) do not.</p>
</div>
<p>You can determine whether a volume supports compression and encryption with Win32 interop:</p>
<pre data-type="programlisting">using System;
using System.IO;
using System.Text;
using System.ComponentModel;
using System.Runtime.InteropServices;

class SupportsCompressionEncryption
{
  const int SupportsCompression = 0x10;
  const int SupportsEncryption = 0x20000;

  [DllImport ("Kernel32.dll", SetLastError = true)]
  extern static bool GetVolumeInformation (string vol, StringBuilder name,
    int nameSize, out uint serialNum, out uint maxNameLen, out uint flags,
    StringBuilder fileSysName, int fileSysNameSize);

  static void Main()
  {
    uint serialNum, maxNameLen, flags;
    bool ok = GetVolumeInformation (@"C:\", null, 0, out serialNum,
                                    out maxNameLen, out flags, null, 0);
    if (!ok)
      throw new Win32Exception();

    bool canCompress = (flags &amp; SupportsCompression) != 0;
    bool canEncrypt = (flags &amp; SupportsEncryption) != 0;
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Windows file security" data-type="sect3"><div class="sect3" id="windows_file_security">
<h3>Windows file security</h3>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="File class" data-secondary="Windows file security" data-type="indexterm" id="id3904"/><a contenteditable="false" data-primary="FileSecurity class" data-type="indexterm" id="id3905"/><a contenteditable="false" data-primary="Windows" data-secondary="file security" data-type="indexterm" id="id3906"/>This feature is Windows-only and requires the NuGet package <code>System.IO.FileSystem.AccessControl</code>.</p>
</div>
<p>The <code>FileSecurity</code> class allow you to query and change the OS permissions assigned to users and roles (namespace <code>System.Security.AccessControl</code>).</p>
<p>In this example, we list a file’s existing permissions and then assign Write permission to the “Users” group:</p>
<pre data-type="programlisting">using System;
using System.IO;
using System.Security.AccessControl;
using System.Security.Principal;

void ShowSecurity (FileSecurity sec)
{
  AuthorizationRuleCollection rules = sec.GetAccessRules (true, true,
                                                       typeof (NTAccount));
  foreach (FileSystemAccessRule r in rules.Cast&lt;FileSystemAccessRule&gt;()
    .OrderBy (rule =&gt; rule.IdentityReference.Value))
  {
    // e.g., MyDomain/Joe
    Console.WriteLine ($"  {r.IdentityReference.Value}");
    // Allow or Deny: e.g., FullControl
    Console.WriteLine ($"    {r.FileSystemRights}: {r.AccessControlType}");
  }
}

var file = "sectest.txt";
File.WriteAllText (file, "File security test.");

var sid = new SecurityIdentifier (WellKnownSidType.BuiltinUsersSid, null);
string usersAccount = sid.Translate (typeof (NTAccount)).ToString();

Console.WriteLine ($"User: {usersAccount}");

FileSecurity sec = new FileSecurity (file,
                          AccessControlSections.Owner |
                          AccessControlSections.Group |
                          AccessControlSections.Access);

Console.WriteLine ("AFTER CREATE:");
ShowSecurity(sec); // BUILTIN\Users doesn't have Write permission

sec.ModifyAccessRule (AccessControlModification.Add,
    new FileSystemAccessRule (usersAccount, FileSystemRights.Write, 
                              AccessControlType.Allow),
    out bool modified);

Console.WriteLine ("AFTER MODIFY:");
ShowSecurity (sec); // BUILTIN\Users has Write permission</pre>
<p>We give another example, later, in <a data-type="xref" href="#special_folders">“Special Folders”</a>.</p>
</div></section>
<section data-pdf-bookmark="Unix file security" data-type="sect3"><div class="sect3" id="unix_file_security">
<h3>Unix file security</h3>
<p><a contenteditable="false" data-primary="File class" data-secondary="Unix file security" data-type="indexterm" id="id3907"/><a contenteditable="false" data-primary="Unix" data-secondary="file security" data-type="indexterm" id="id3908"/>From .NET 7, the <code>File</code> class includes the methods <code>GetUnix​Fi⁠leMode</code> and <code>SetUnix​Fi⁠leMode</code> to get and set file permissions on Unix systems. The <code>Directory.CreateDirectory</code> method is also now overloaded to accept a Unix file mode, and it’s possible to specify a file mode when creating a file, as follows: <a contenteditable="false" data-primary="" data-startref="ch15.html1020" data-type="indexterm" id="id3909"/></p>
<pre data-type="programlisting">var fs = new FileStream ("test.txt",
  new FileStreamOptions
  {
    Mode = FileMode.Create,
    UnixCreateMode = UnixFileMode.UserRead | UnixFileMode.UserWrite
  });</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="The Directory Class" data-type="sect2"><div class="sect2" id="the_directory_class">
<h2>The Directory Class</h2>
<p><a contenteditable="false" data-primary="Directory class" data-type="indexterm" id="id3910"/><a contenteditable="false" data-primary="file and directory operations" data-secondary="Directory class" data-type="indexterm" id="id3911"/>The static <code>Directory</code> class provides a set of methods analogous to those in the <code>File</code> class—for checking whether a directory exists (<code>Exists</code>), moving a directory (<code>Move</code>), deleting a directory (<code>Delete</code>), getting/setting times of creation or last access, and getting/setting security permissions. Furthermore, <code>Directory</code> exposes the following static methods:</p>
<pre data-type="programlisting">string GetCurrentDirectory ();
void   SetCurrentDirectory (string path);

DirectoryInfo CreateDirectory  (string path);
DirectoryInfo GetParent        (string path);
string        GetDirectoryRoot (string path);

string[] GetLogicalDrives(); // Gets mount points on Unix

// The following methods all return full paths:

string[] GetFiles             (string path);
string[] GetDirectories       (string path);
string[] GetFileSystemEntries (string path);

IEnumerable&lt;string&gt; EnumerateFiles             (string path);
IEnumerable&lt;string&gt; EnumerateDirectories       (string path);
IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The last three methods are potentially more efficient than the <code>Get*</code> variants because they’re lazily evaluated—fetching data from the file system as you enumerate the sequence. They’re particularly well suited to LINQ queries.</p>
</div>
<p>The <code>Enumerate*</code> and <code>Get*</code> methods are overloaded to also accept <code>search​Pat⁠tern</code> (string) and <code>searchOption</code> (enum) parameters. If you specify <code>SearchOp⁠tion​.SearchAllSubDirectories</code>, a recursive subdirectory search is performed. The <code>*FileSystemEntries</code> methods combine the results of <code>*Files</code> with <code>*Directories</code>.</p>
<p>Here’s how to create a directory if it doesn’t already exist:</p>
<pre data-type="programlisting">if (!Directory.Exists (@"d:\test"))
  Directory.CreateDirectory (@"d:\test");</pre>
</div></section>
<section data-pdf-bookmark="FileInfo and DirectoryInfo" data-type="sect2"><div class="sect2" id="fileinfo_and_directoryinfo">
<h2>FileInfo and DirectoryInfo</h2>
<p><a contenteditable="false" data-primary="DirectoryInfo class" data-type="indexterm" id="id3912"/><a contenteditable="false" data-primary="file and directory operations" data-secondary="FileInfo and DirectoryInfo" data-type="indexterm" id="id3913"/><a contenteditable="false" data-primary="FileInfo class" data-type="indexterm" id="id3914"/>The static methods on <code>File</code> and <code>Directory</code> are convenient for executing a single file or directory operation. If you need to call a series of methods in a row, the <code>FileInfo</code> and <code>DirectoryInfo</code> classes provide an object model that makes the job easier.</p>
<p><code>FileInfo</code> offers most of the <code>File</code>’s static methods in instance form—with some additional properties such as <code>Extension</code>, <code>Length</code>, <code>IsReadOnly</code>, and <code>Directory</code>—for returning a <code>DirectoryInfo</code> object. For example:</p>
<pre data-type="programlisting">static string TestDirectory =&gt; 
  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)
    ? @"C:\Temp" 
    : "/tmp"; 

Directory.CreateDirectory (TestDirectory);

FileInfo fi = new FileInfo (Path.Combine (TestDirectory, "FileInfo.txt"));

Console.WriteLine (fi.Exists);         // false

using (TextWriter w = fi.CreateText())
  w.Write ("Some text");

Console.WriteLine (fi.Exists);         // false (still)
fi.Refresh();
Console.WriteLine (fi.Exists);         // true

Console.WriteLine (fi.Name);           // FileInfo.txt
Console.WriteLine (fi.FullName);       // c:\temp\FileInfo.txt (Windows)
                                       // /tmp/FileInfo.txt (Unix)
Console.WriteLine (fi.DirectoryName);  // c:\temp (Windows)
                                       // /tmp (Unix)
Console.WriteLine (fi.Directory.Name); // temp
Console.WriteLine (fi.Extension);      // .txt
Console.WriteLine (fi.Length);         // 9

fi.Encrypt();
fi.Attributes ^= FileAttributes.Hidden;   // (Toggle hidden flag)
fi.IsReadOnly = true;

Console.WriteLine (fi.Attributes);    // ReadOnly,Archive,Hidden,Encrypted
Console.WriteLine (fi.CreationTime);  // 3/09/2019 1:24:05 PM

fi.MoveTo (Path.Combine (TestDirectory, "FileInfoX.txt")); 

DirectoryInfo di = fi.Directory;
Console.WriteLine (di.Name);             // temp or tmp
Console.WriteLine (di.FullName);         // c:\temp or /tmp
Console.WriteLine (di.Parent.FullName);  // c:\ or /
di.CreateSubdirectory ("SubFolder");</pre>
<p>Here’s how to use <code>DirectoryInfo</code> to enumerate files and subdirectories:</p>
<pre data-type="programlisting">DirectoryInfo di = new DirectoryInfo (@"e:\photos");

foreach (FileInfo fi in di.GetFiles ("*.jpg"))
  Console.WriteLine (fi.Name);

foreach (DirectoryInfo subDir in di.GetDirectories())
  Console.WriteLine (subDir.FullName);</pre>
</div></section>
<section data-pdf-bookmark="Path" data-type="sect2"><div class="sect2" id="path">
<h2>Path</h2>
<p><a contenteditable="false" data-primary="file and directory operations" data-secondary="Path class" data-type="indexterm" id="ch15.html1021"/><a contenteditable="false" data-primary="Path class" data-type="indexterm" id="ch15.html1022"/>The static <code>Path</code> class defines methods and fields for working with paths and <span class="keep-together">filenames</span>.</p>
<p>Assuming this setup code:</p>
<pre data-type="programlisting">string dir  = @"c:\mydir";    // or /mydir
string file = "myfile.txt";
string path = @"c:\mydir\myfile.txt";    // or /mydir/myfile.txt

Directory.SetCurrentDirectory (@"k:\demo");    // or /demo</pre>
<p>we can demonstrate <code>Path</code>’s methods and fields with the following expressions:</p>
<table class="border">
<thead>
<tr>
<th>Expression</th>
<th>Result (Windows, then Unix)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Directory.GetCurrentDirectory()</code></td>
<td><code>k:\demo\</code> or <code>/demo</code></td>
</tr>
<tr>
<td><code>Path.IsPathRooted (file)</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>Path.IsPathRooted (path)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>Path.GetPathRoot (path)</code></td>
<td><code>c:\</code> or <code>/</code></td>
</tr>
<tr>
<td><code>Path.GetDirectoryName (path)</code></td>
<td><code>c:\mydir</code> or <code>/mydir</code></td>
</tr>
<tr>
<td><code>Path.GetFileName (path)</code></td>
<td><code>myfile.txt</code></td>
</tr>
<tr>
<td><code>Path.GetFullPath (file)</code></td>
<td><code>k:\demo\myfile.txt</code> or <code>/demo/myfile.txt</code></td>
</tr>
<tr>
<td><code>Path.Combine (dir, file)</code></td>
<td><code>c:\mydir\myfile.txt</code> or <code>/mydir/myfile.txt</code></td>
</tr>
<tr>
<td><strong>File extensions:</strong></td>
<td/>
</tr>
<tr>
<td><code>Path.HasExtension (file)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>Path.GetExtension (file)</code></td>
<td><code>.txt</code></td>
</tr>
<tr>
<td><span class="keep-together"><code>Path.GetFileNameWithoutExtension (file)</code></span></td>
<td><code>myfile</code></td>
</tr>
<tr>
<td><span class="keep-together"><code>Path.ChangeExtension (file, ".log")</code></span></td>
<td><code>myfile.log</code></td>
</tr>
<tr>
<td><strong>Separators and characters:</strong></td>
<td/>
</tr>
<tr>
<td><code>Path.DirectorySeparatorChar</code></td>
<td><code>\</code> or <code>/</code></td>
</tr>
<tr>
<td><code>Path.AltDirectorySeparatorChar</code></td>
<td><code>/</code></td>
</tr>
<tr>
<td><code>Path.PathSeparator</code></td>
<td><code>;</code> or<code>:</code></td>
</tr>
<tr>
<td><code>Path.VolumeSeparatorChar</code></td>
<td><code>:</code> or <code>/</code></td>
</tr>
<tr>
<td><code>Path.GetInvalidPathChars()</code></td>
<td>chars 0 to 31 and <code>"&lt;&gt;|</code>eor 0</td>
</tr>
<tr>
<td><code>Path.GetInvalidFileNameChars()</code></td>
<td>chars 0 to 31 and <code>"&lt;&gt;|:*?\/</code> or 0 and <code>/</code></td>
</tr>
<tr>
<td><strong>Temporary files:</strong></td>
<td/>
</tr>
<tr>
<td><code>Path.GetTempPath()</code></td>
<td><em>&lt;local user folder&gt;</em>\<code>Temp</code> or <em>/tmp/</em> </td>
</tr>
<tr>
<td><code>Path.GetRandomFileName()</code></td>
<td><code><em>d2dwuzjf.dnp</em></code></td>
</tr>
<tr>
<td><code>Path.GetTempFileName()</code></td>
<td><em>&lt;local user folder&gt;</em>\<code>Temp</code>\<code><em>tmp14B.tmp</em></code> or <em>/tmp/</em><code><em>tmpubSUYO.tmp</em></code></td>
</tr>
</tbody>
</table>
<p><code>Combine</code> is particularly useful: it allows you to combine a directory and filename—or two directories—without first having to check whether a trailing path separator is present, and it automatically uses the correct path separator for the OS. It provides overloads that accept up to four directory and/or filenames.</p>
<p><code>GetFullPath</code> converts a path relative to the current directory to an absolute path. It accepts values such as <em>..\..\file.txt</em>.</p>
<p><code>GetRandomFileName</code> returns a genuinely unique 8.3-character filename, without actually creating any file. <code>GetTempFileName</code> generates a temporary filename using an autoincrementing counter that repeats every 65,000 files. It then creates a zero-byte file of this name in the local temporary directory.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>You must delete the file generated by <code>GetTempFileName</code> when you’re done; otherwise, it will eventually throw an exception (after your 65,000th call to <code>GetTempFileName</code>). If this is a problem, you can instead <code>Combine GetTempPath</code> with <code>GetRandomFileName</code>. Just be careful not to fill up the user’s hard drive!<a contenteditable="false" data-primary="" data-startref="ch15.html1022" data-type="indexterm" id="id3915"/><a contenteditable="false" data-primary="" data-startref="ch15.html1021" data-type="indexterm" id="id3916"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Special Folders" data-type="sect2"><div class="sect2" id="special_folders">
<h2>Special Folders</h2>
<p><a contenteditable="false" data-primary="file and directory operations" data-secondary="special folders" data-type="indexterm" id="id3917"/>One thing missing from <code>Path</code> and <code>Directory</code> is a means to locate folders such as <em>My Documents</em>, <em>Program Files</em>, <em>Application Data</em>, and so on. This is provided instead by the <code>GetFolderPath</code> method in the <code>System.Environment</code> class:</p>
<pre data-type="programlisting">string myDocPath = Environment.GetFolderPath
  (Environment.SpecialFolder.MyDocuments);</pre>
<p><a contenteditable="false" data-primary="Environment.SpecialFolder" data-type="indexterm" id="id3918"/><code>Environment.SpecialFolder</code> is an enum whose values encompass all special directories in Windows, such as <code>AdminTools</code>, <code>ApplicationData</code>, <code>Fonts</code>, <code>History</code>, <code>SendTo</code>, <code>StartMenu</code>, and so on. Everything is covered here except the .NET runtime directory, which you can obtain as follows:</p>
<pre data-type="programlisting">System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Most of the special folders have no path assigned on Unix systems. The following have paths on Ubuntu Linux 18.04 Desktop: <code>ApplicationData</code>, <code>CommonApplicationData</code>, <code>Desktop</code>, <code>DesktopDirectory</code>, <code>LocalApplicationData</code>, <code>MyDocuments</code>, <code>MyMusic</code>, <code>MyPictures</code>, <code>MyVideos</code>, <code>Templates</code>, and <code>UserProfile</code>.</p>
</div>
<p><a contenteditable="false" data-primary="ApplicationData directory" data-type="indexterm" id="id3919"/>Of particular value on Windows systems is <code>ApplicationData</code>, where you can store settings that travel with a user across a network (if roaming profiles are enabled on the network domain); <a contenteditable="false" data-primary="LocalApplicationData" data-type="indexterm" id="id3920"/><code>LocalApplicationData</code>, which is for nonroaming data (specific to the logged-in user); <a contenteditable="false" data-primary="CommonApplicationData" data-type="indexterm" id="id3921"/>and <code>CommonApplicationData</code>, which is shared by every user of the computer. Writing application data to these folders is considered preferable to using the Windows Registry. The standard protocol for storing data in these folders is to create a subdirectory with the name of your application:</p>
<pre data-type="programlisting">string localAppDataPath = Path.Combine (
  Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData),
  "MyCoolApplication");

if (!Directory.Exists (localAppDataPath))
  Directory.CreateDirectory (localAppDataPath);</pre>
<p>There’s a horrible trap when using <code>CommonApplicationData</code>: if a user starts your program with administrative elevation and your program then creates folders and files in <code>CommonApplicationData</code>, that user might lack permissions to replace those files later, when run under a restricted Windows login. (A similar problem exists when switching between restricted-permission accounts.) You can work around it by creating the desired folder (with permissions assigned to everyone) as part of your setup.</p>
<p><a contenteditable="false" data-primary="AppDomain.CurrentDomain.BaseDirectory" data-type="indexterm" id="id3922"/>Another place to write configuration and log files is to the application’s base directory, which you can obtain with <code>AppDomain.CurrentDomain.BaseDirectory</code>. This is not recommended, however, because the OS is likely to deny your application permissions to write to this folder after initial installation (without administrative elevation).</p>
</div></section>
<section data-pdf-bookmark="Querying Volume Information" data-type="sect2"><div class="sect2" id="querying_volume_information">
<h2>Querying Volume Information</h2>
<p><a contenteditable="false" data-primary="DriveInfo class" data-type="indexterm" id="id3923"/><a contenteditable="false" data-primary="file and directory operations" data-secondary="querying volume information" data-type="indexterm" id="id3924"/><a contenteditable="false" data-primary="volume information, querying" data-type="indexterm" id="id3925"/>You can query the drives on a computer with the <code>DriveInfo</code> class:</p>
<pre data-type="programlisting">DriveInfo c = new DriveInfo ("C");       // Query the C: drive.
                                         // On Unix: /

long totalSize = c.TotalSize;            // Size in bytes.
long freeBytes = c.TotalFreeSpace;       // Ignores disk quotas.
long freeToMe  = c.AvailableFreeSpace;   // Takes quotas into account.

foreach (DriveInfo d in DriveInfo.GetDrives())  // All defined drives.
                                                // On Unix: mount points
{
  Console.WriteLine (d.Name);             // C:\
  Console.WriteLine (d.DriveType);        // Fixed
  Console.WriteLine (d.RootDirectory);    // C:\

  if (d.IsReady)   // If the drive is not ready, the following two
                   // properties will throw exceptions:
  {
    Console.WriteLine (d.VolumeLabel);    // The Sea Drive
    Console.WriteLine (d.DriveFormat);    // NTFS
  }
}</pre>
<p>The static <code>GetDrives</code> method returns all mapped drives, including CD-ROMs, media cards, and network connections. <code>DriveType</code> is an enum with the following values:</p>
<pre data-type="programlisting">Unknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram</pre>
</div></section>
<section data-pdf-bookmark="Catching Filesystem Events" data-type="sect2"><div class="sect2" id="catching_filesystem_events">
<h2>Catching Filesystem Events</h2>
<p><a contenteditable="false" data-primary="file and directory operations" data-secondary="catching filesystem events" data-type="indexterm" id="id3926"/><a contenteditable="false" data-primary="FileSystemWatcher class" data-type="indexterm" id="id3927"/>The <code>FileSystemWatcher</code> class lets you monitor a directory (and optionally, subdirectories) for activity. <code>FileSystemWatcher</code> has events that fire when files or subdirectories are created, modified, renamed, and deleted, as well as when their attributes change. These events fire regardless of the user or process performing the change. Here’s an example:</p>
<pre data-type="programlisting">Watch (GetTestDirectory(), "*.txt", true);

void Watch (string path, string filter, bool includeSubDirs)
{
  using (var watcher = new FileSystemWatcher (path, filter))
  {
    watcher.Created += FileCreatedChangedDeleted;
    watcher.Changed += FileCreatedChangedDeleted;
    watcher.Deleted += FileCreatedChangedDeleted;
    watcher.Renamed += FileRenamed;
    watcher.Error   += FileError;

    watcher.IncludeSubdirectories = includeSubDirs;
    watcher.EnableRaisingEvents = true;

    Console.WriteLine ("Listening for events - press &lt;enter&gt; to end");
    Console.ReadLine();
  }
  // Disposing the FileSystemWatcher stops further events from firing.
}

void FileCreatedChangedDeleted (object o, FileSystemEventArgs e)
  =&gt; Console.WriteLine ("File {0} has been {1}", e.FullPath, e.ChangeType);

void FileRenamed (object o, RenamedEventArgs e)
  =&gt; Console.WriteLine ("Renamed: {0}-&gt;{1}", e.OldFullPath, e.FullPath);

void FileError (object o, ErrorEventArgs e)
  =&gt; Console.WriteLine ("Error: " + e.GetException().Message);

string GetTestDirectory() =&gt;
  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)
    ? @"C:\Temp"
    : "/tmp";</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Because <code>FileSystemWatcher</code> raises events on a separate thread, you must exception-handle the event handling code to prevent an error from taking down the application. For more information, see <a data-type="xref" href="ch14.html#exception_handling">“Exception Handling”</a>.</p>
</div>
<p>The <code>Error</code> event does not inform you of filesystem errors; instead, it indicates that the <code>FileSystemWatcher</code>’s event buffer overflowed because it was overwhelmed by <code>Changed</code>, <code>Created</code>, <code>Deleted</code>, or <code>Renamed</code> events. You can change the buffer size via the <code>InternalBufferSize</code> property.</p>
<p><code>IncludeSubdirectories</code> applies recursively. So, if you create a <code>FileSystemWatcher</code> on <em>C:\</em> with <code>IncludeSubdirectories true</code>, its events will fire when a file or directory changes anywhere on the hard drive.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A trap in using <code>FileSystemWatcher</code> is to open and read newly created or updated files before the file has been fully populated or updated. If you’re working in conjunction with some other software that’s creating files, you might need to consider some strategy to mitigate this, such as creating files with an unwatched extension and then renaming them after they’re fully written.<a contenteditable="false" data-primary="" data-startref="ch15.html1019" data-type="indexterm" id="id3928"/><a contenteditable="false" data-primary="" data-startref="ch15.html1018" data-type="indexterm" id="id3929"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="OS Security" data-type="sect1"><div class="sect1" id="os_security">
<h1>OS Security</h1>
<p><a contenteditable="false" data-primary="OS security" data-type="indexterm" id="ch15.html1028"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="OS security" data-type="indexterm" id="ch15.html1029"/>All applications are subject to OS restrictions, based on the user’s login privileges. These restrictions affect file I/O as well as other capabilities, such as access to the Windows Registry.</p>
<p>In Windows and Unix, there are two types of accounts:</p>
<ul>
<li><p>An administrative/superuser account that imposes no restrictions in accessing the local computer</p></li>
<li><p>A limited permissions account that restricts administrative functions and visibility of other users’ data</p></li>
</ul>
<p><a contenteditable="false" data-primary="UAC (User Account Control)" data-type="indexterm" id="id3930"/><a contenteditable="false" data-primary="User Account Control (UAC)" data-type="indexterm" id="id3931"/><a contenteditable="false" data-primary="Windows" data-secondary="OS security" data-type="indexterm" id="id3932"/>On Windows, a feature called User Account Control (UAC) means that administrators receive two tokens or “hats” when logging in: an administrative hat and an ordinary user hat. By default, programs run wearing the ordinary user hat—with restricted permissions—unless the program requests <em>administrative elevation</em>. The user must then approve the request in the dialog box that’s presented.</p>
<p><a contenteditable="false" data-primary="Unix, OS security" data-type="indexterm" id="id3933"/>On Unix, users typically log in with restricted accounts. That is also true for administrators to lessen the probability of inadvertently damaging the system. When a user needs to run a command that requires elevated permissions, they precede the command with <code>sudo</code> (short for “super-user do”).</p>
<p><em>By default</em>, your application will run with restricted user privileges. This means that you must either:</p>
<ul>
<li><p>Write your application such that it can run without administrative privileges.</p></li>
<li><p>Demand administrative elevation in the application manifest (Windows only), or detect the lack of required privileges and alert the user to restart the application as an administrator/super-user.</p></li>
</ul>
<p>The first option is safer and more convenient for the user. Designing your program to run without administrative privileges is easy in most cases.</p>
<p>You can find out whether you’re running under an administrative account as <span class="keep-together">follows</span>:</p>
<pre data-type="programlisting">[DllImport("libc")]
public static extern uint getuid();

static bool IsRunningAsAdmin()
{
  if (RuntimeInformation.IsOSPlatform (OSPlatform.Windows))
  {
    using var identity = WindowsIdentity.GetCurrent();
    var principal = new WindowsPrincipal (identity);
    return principal.IsInRole (WindowsBuiltInRole.Administrator);
  }
  return getuid() == 0;
}</pre>
<p>With UAC enabled on Windows, this returns <code>true</code> only if the current process has administrative elevation. On Linux, it returns <code>true</code> only if the current process is running as super-user (e.g., <em>sudo myapp</em>).</p>
<section data-pdf-bookmark="Running in a Standard User Account" data-type="sect2"><div class="sect2" id="running_in_a_standard_user_account">
<h2>Running in a Standard User Account</h2>
<p><a contenteditable="false" data-primary="OS security" data-secondary="running in a standard user account" data-type="indexterm" id="id3934"/>Here are the key things that you <em>cannot</em> do in a standard user account:</p>
<ul>
<li><p>Write to the following directories:</p>
<ul>
<li><p>The OS folder (typically <em>\Windows</em> or <em>/bin, /sbin, ...</em>) and subdirectories</p></li>
<li><p>The program files folder (<em>\Program Files</em> or <em>/usr/bin, /opt</em>) and <span class="keep-together">subdirectories</span></p></li>
<li><p>The root of the OS drive (e.g., <em>C:\</em> or <em>/</em>)</p></li>
</ul></li>
<li><p>Write to the HKEY_LOCAL_MACHINE branch of the Registry (Windows)</p></li>
<li><p>Read performance monitoring (WMI) data (Windows)</p></li>
</ul>
<p>Additionally, as an ordinary Windows user (or even as an administrator), you might be refused access to files or resources that belong to other users. <a contenteditable="false" data-primary="access control lists (ACLs)" data-type="indexterm" id="id3935"/><a contenteditable="false" data-primary="ACLs (access control lists)" data-type="indexterm" id="id3936"/>Windows uses a system of Access Control Lists (ACLs) to protect such resources—you <a contenteditable="false" data-primary="System..." data-secondary="System.Security.AccessControl" data-type="indexterm" id="id3937"/>can query and assert your own rights in the ACLs via types in <code>System.Security.AccessControl</code>. ACLs can also be applied to cross-process wait handles, described in <a data-type="xref" href="ch21.html#advanced_threadin">Chapter 21</a>.</p>
<p>If you’re refused access to anything as a result of OS security, the CLR detects the failure and throws an <code>UnauthorizedAccessException</code>  (rather than failing silently).</p>
<p>In most cases, you can deal with standard user restrictions as follows:</p>
<ul>
<li><p>Write files to their recommended locations.</p></li>
<li><p>Avoid using the Registry for information that can be stored in files (aside from the HKEY_CURRENT_USER hive, which you will have read/write access to on Windows only).</p></li>
<li><p>Register ActiveX or COM components during setup (Windows only).</p></li>
</ul>
<p>The recommended location for user documents is <code>SpecialFolder.MyDocuments</code>:</p>
<pre data-type="programlisting">string docsFolder = Environment.GetFolderPath
                    (Environment.SpecialFolder.MyDocuments);

string path = Path.Combine (docsFolder, "test.txt");</pre>
<p>The recommended location for configuration files that a user might need to modify outside of your application is <code>SpecialFolder.ApplicationData</code> (current user only) or <code>SpecialFolder.CommonApplicationData</code> (all users). You typically create subdirectories within these folders, based on your organization and product name.</p>
</div></section>
<section data-pdf-bookmark="Administrative Elevation and Virtualization" data-type="sect2"><div class="sect2" id="administrative_elevation_and_virtualiza">
<h2>Administrative Elevation and Virtualization</h2>
<p><a contenteditable="false" data-primary="administrative elevation" data-type="indexterm" id="id3938"/><a contenteditable="false" data-primary="application manifest" data-type="indexterm" id="id3939"/><a contenteditable="false" data-primary="OS security" data-secondary="administrative elevation and virtualization" data-type="indexterm" id="id3940"/><a contenteditable="false" data-primary="virtualization" data-type="indexterm" id="id3941"/>With an <em>application manifest</em>, you can request that Windows prompt the user for administrative elevation whenever running your program (Linux ignores this request):</p>
<pre data-type="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
  &lt;trustInfo xmlns="urn:schemas-microsoft-com:asm.v2"&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        <strong>&lt;requestedExecutionLevel level="requireAdministrator" /&gt;</strong>
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/trustInfo&gt;
&lt;/assembly&gt;</pre>
<p>(We describe application manifests in more detail in <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>.)</p>
<p>If you replace <code>requireAdministrator</code> with <code>asInvoker</code>, it instructs Windows that administrative elevation is <em>not</em> required. The effect is almost the same as not having an application manifest at all—except that <em>virtualization</em> is disabled. Virtualization is a temporary measure introduced with Windows Vista to help old applications run correctly without administrative privileges. The absence of an application manifest with a <code>requestedExecutionLevel</code> element activates this backward-compatibility feature.</p>
<p>Virtualization comes into play when an application writes to the <em>Program Files</em> or <em>Windows</em> directory, or the HKEY_LOCAL_MACHINE area of the Registry. Instead of throwing an exception, changes are redirected to a separate location on the hard disk where they can’t affect the original data. This prevents the application from interfering with the OS—or other well-behaved applications.<a contenteditable="false" data-primary="" data-startref="ch15.html1029" data-type="indexterm" id="id3942"/><a contenteditable="false" data-primary="" data-startref="ch15.html1028" data-type="indexterm" id="id3943"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Memory-Mapped Files" data-type="sect1"><div class="sect1" id="memory_mapped_files">
<h1>Memory-Mapped Files</h1>
<p><a contenteditable="false" data-primary="memory-mapped files" data-type="indexterm" id="ch15.html1030"/><a contenteditable="false" data-primary="streams and I/O" data-secondary="memory-mapped files" data-type="indexterm" id="ch15.html1031"/><em>Memory-mapped files</em> provide two key features:</p>
<ul>
<li><p>Efficient random access to file data</p></li>
<li><p>The ability to share memory between different processes on the same computer</p></li>
</ul>
<p>The types for memory-mapped files reside in the <code>System.IO.MemoryMappedFiles</code> namespace. Internally, they work by wrapping the operating system’s API for memory-mapped files.</p>
<section data-pdf-bookmark="Memory-Mapped Files and Random File I/O" data-type="sect2"><div class="sect2" id="memory_mapped_files_and_random_file_iso">
<h2>Memory-Mapped Files and Random File I/O</h2>
<p><a contenteditable="false" data-primary="memory-mapped files" data-secondary="random file I/O and" data-type="indexterm" id="id3944"/>Although an ordinary <code>FileStream</code> allows random file I/O (by setting the stream’s <code>Position</code> property), it’s optimized for sequential I/O. As a rough rule of thumb:</p>
<ul>
<li><p><code>FileStream</code>s are approximately 10 times faster than memory-mapped files for sequential I/O.</p></li>
<li><p>Memory-mapped files are approximately 10 times faster than <code>FileStream</code>s for random I/O.</p></li>
</ul>
<p>Changing a <code>FileStream</code>’s <code>Position</code> can cost several microseconds—which adds up if done within a loop. A <code>FileStream</code> is also unsuitable for multithreaded access—because its position changes as it is read or written.</p>
<p>To create a memory-mapped file:</p>
<ol>
<li><p>Obtain a <code>FileStream</code> as you would ordinarily.</p></li>
<li><p>Instantiate a <code>MemoryMappedFile</code>, passing in the file stream.</p></li>
<li><p>Call <code>CreateViewAccessor</code> on the memory-mapped file object.</p></li>
</ol>
<p>The last step gives you a <code>MemoryMappedViewAccessor</code> object that provides methods for randomly reading and writing simple types, structures, and arrays (more on this in <a data-type="xref" href="#working_with_view_accessors">“Working with View Accessors”</a>).</p>
<p class="pagebreak-before">The following creates a one million–byte file and then uses the memory-mapped file API to read and then write a byte at position 500,000:</p>
<pre data-type="programlisting">File.WriteAllBytes ("long.bin", new byte [1000000]);

using MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile ("long.bin");
using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();

accessor.Write (500000, (byte) 77);
Console.WriteLine (accessor.ReadByte (500000));   // 77</pre>
<p>You can also specify a map name and capacity when calling <code>CreateFromFile</code>. Specifying a non-null map name allows the memory block to be shared with other processes (see the following section); specifying a capacity automatically enlarges the file to that value. The following creates a 1,000-byte file:</p>
<pre data-type="programlisting">File.WriteAllBytes ("short.bin", new byte [1]);
using (var mmf = MemoryMappedFile.CreateFromFile
                 ("short.bin", FileMode.Create, null, <strong>1000</strong>))
  ...</pre>
</div></section>
<section data-pdf-bookmark="Memory-Mapped Files and Shared Memory (Windows)" data-type="sect2"><div class="sect2" id="memory_mapped_files_and_shared_memory_l">
<h2>Memory-Mapped Files and Shared Memory (Windows)</h2>
<p><a contenteditable="false" data-primary="memory-mapped files" data-secondary="shared memory (Windows)" data-type="indexterm" id="id3945"/><a contenteditable="false" data-primary="Windows" data-secondary="memory-mapped files and shared memory" data-type="indexterm" id="id3946"/>Under Windows, you can also use memory-mapped files as a means of sharing memory between processes on the same computer. One process creates a shared memory block by calling <code>MemoryMappedFile.CreateNew</code>, and then other processes subscribe to that same memory block by calling <code>MemoryMappedFile.OpenExisting</code> with the same name. Although it’s still referred to as a memory-mapped “file,” it resides entirely in memory and has no disk presence.</p>
<p>The following code creates a 500-byte shared memory-mapped file and writes the integer 12345 at position 0:</p>
<pre data-type="programlisting">using (MemoryMappedFile mmFile = MemoryMappedFile.CreateNew ("Demo", 500))
using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())
{
  accessor.Write (0, 12345);
  Console.ReadLine();   // Keep shared memory alive until user hits Enter.
}</pre>
<p>The following code opens that memory-mapped file and reads that integer:</p>
<pre data-type="programlisting">// This can run in a separate executable:
using (MemoryMappedFile mmFile = MemoryMappedFile.OpenExisting ("Demo"))
using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())
  Console.WriteLine (accessor.ReadInt32 (0));   // 12345</pre>
</div></section>
<section data-pdf-bookmark="Cross-Platform Interprocess Shared Memory" data-type="sect2"><div class="sect2" id="cross_platform_interprocess_shared_memo">
<h2>Cross-Platform Interprocess Shared Memory</h2>
<p><a contenteditable="false" data-primary="memory-mapped files" data-secondary="cross-platform interprocess shared memory" data-type="indexterm" id="id3947"/>Both Windows and Unix allow multiple processes to memory-map the same file. You must exercise care to ensure appropriate file sharing settings:</p>
<pre data-type="programlisting">static void Writer()
{
  var file = Path.Combine (TestDirectory, "interprocess.bin");
  File.WriteAllBytes (file, new byte [100]);

  using FileStream fs = 
    new FileStream (file, FileMode.Open, FileAccess.ReadWrite, 
                    FileShare.ReadWrite);
                    
  using MemoryMappedFile mmf = MemoryMappedFile
    .CreateFromFile (fs, null, fs.Length, MemoryMappedFileAccess.ReadWrite,
                     HandleInheritability.None, true);
  using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();
    
  accessor.Write (0, 12345);

  Console.ReadLine();   // Keep shared memory alive until user hits Enter.

  File.Delete (file);
}

static void Reader()
{
  // This can run in a separate executable:
  var file = Path.Combine (TestDirectory, "interprocess.bin");
  using FileStream fs = 
    new FileStream (file, FileMode.Open, FileAccess.ReadWrite, 
                    FileShare.ReadWrite);
  using MemoryMappedFile mmf = MemoryMappedFile
    .CreateFromFile (fs, null, fs.Length, MemoryMappedFileAccess.ReadWrite, 
                      HandleInheritability.None, true);
  using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();
  
  Console.WriteLine (accessor.ReadInt32 (0));   // 12345
}
  
static string TestDirectory =&gt;
  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)
    ?  @"C:\Test"
    : "/tmp";</pre>
</div></section>
<section data-pdf-bookmark="Working with View Accessors" data-type="sect2"><div class="sect2" id="working_with_view_accessors">
<h2>Working with View Accessors</h2>
<p><a contenteditable="false" data-primary="CreateViewAccessor method" data-type="indexterm" id="id3948"/><a contenteditable="false" data-primary="memory-mapped files" data-secondary="working with view accessors" data-type="indexterm" id="id3949"/><a contenteditable="false" data-primary="view accessors" data-type="indexterm" id="id3950"/>Calling <code>CreateViewAccessor</code> on a <code>MemoryMappedFile</code> gives you a view accessor that lets you read/write values at random positions.</p>
<p>The <code>Read*</code>/<code>Write*</code> methods accept numeric types, <code>bool</code>, and <code>char</code>, as well as arrays and structs that contain value-type elements or fields. Reference types—and arrays or structs that contain reference types—are prohibited because they cannot map into unmanaged memory. So, if you want to write a string, you must encode it into an array of bytes:</p>
<pre data-type="programlisting">byte[] data = Encoding.UTF8.GetBytes ("This is a test");
accessor.Write (0, data.Length);
accessor.WriteArray (4, data, 0, data.Length);</pre>
<p>Notice that we wrote the length first. This means we know how many bytes to read back later:</p>
<pre data-type="programlisting">byte[] data = new byte [accessor.ReadInt32 (0)];
accessor.ReadArray (4, data, 0, data.Length);
Console.WriteLine (Encoding.UTF8.GetString (data));   // This is a test</pre>
<p>Here’s an example of reading/writing a struct:</p>
<pre data-type="programlisting">struct Data { public int X, Y; }
...
var data = new Data { X = 123, Y = 456 };
accessor.Write (0, ref data);
accessor.Read (0, out data);
Console.WriteLine (data.X + " " + data.Y);   // 123 456</pre>
<p>The <code>Read</code> and <code>Write</code> methods are surprisingly slow. You can get much better performance by directly accessing the underlying unmanaged memory via a pointer. Following on from the previous example:</p>
<pre data-type="programlisting">unsafe
{
  byte* pointer = null;
  try
  {
    accessor.SafeMemoryMappedViewHandle.AcquirePointer (ref pointer);
    int* intPointer = (int*) pointer;
    Console.WriteLine (*intPointer);               // 123
  }
  finally
  {
    if (pointer != null)
      accessor.SafeMemoryMappedViewHandle.ReleasePointer();
  }
}</pre>
<p>Your project must be configured to allow unsafe code. You can do that by editing your <code>.csproj</code> file:</p>
<pre data-type="programlisting">  &lt;PropertyGroup&gt;
    <strong>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</strong>
  &lt;/PropertyGroup&gt;</pre>
<p>The performance advantage of pointers is even more pronounced when working with large structures because they let you work directly with the raw data rather than using <code>Read</code>/<code>Write</code> to <em>copy</em> data between managed and unmanaged memory. We explore this further in <a data-type="xref" href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>.<a contenteditable="false" data-primary="" data-startref="ch15.html1031" data-type="indexterm" id="id3951"/><a contenteditable="false" data-primary="" data-startref="ch15.html1030" data-type="indexterm" id="id3952"/><a contenteditable="false" data-primary="" data-startref="ch15.html100" data-type="indexterm" id="id3953"/></p>
</div></section>
</div></section>
</div></section></body></html>