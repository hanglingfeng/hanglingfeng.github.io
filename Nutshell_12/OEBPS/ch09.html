<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>LINQ Operators</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="LINQ Operators" data-pdf-bookmark="Chapter 9. LINQ Operators" data-type="chapter" epub:type="chapter"><div class="chapter" id="linq_operators">
<h1><span class="label">Chapter 9. </span>LINQ Operators</h1>

<p><a contenteditable="false" data-primary="LINQ operators" data-type="indexterm" id="ch09.html0"/>This chapter describes each of the LINQ query operators. As well as serving as a reference, two of the sections, <a data-type="xref" href="#projecting-id00076">“Projecting”</a> and <a data-type="xref" href="#joining">“Joining”</a>, cover a number of conceptual areas:</p>

<ul>
	<li>
	<p>Projecting object hierarchies</p>
	</li>
	<li>
	<p>Joining with <code>Select</code>, <code>SelectMany</code>, <code>Join</code>, and <code>GroupJoin</code></p>
	</li>
	<li>
	<p>Query expressions with multiple range variables</p>
	</li>
</ul>

<p>All of the examples in this chapter assume that a <code>names</code> array is defined as follows:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };</pre>

<p>Examples that query a database assume that a variable called <code>dbContext</code> is instantiated as</p>

<pre data-type="programlisting">
var dbContext = new NutshellContext();</pre>

<p>where <code>NutshellContext</code> is defined as follows:</p>

<pre data-type="programlisting">
public class NutshellContext : DbContext
{
  public DbSet&lt;Customer&gt; Customers { get; set; }
  public DbSet&lt;Purchase&gt; Purchases { get; set; }

  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
    modelBuilder.Entity&lt;Customer&gt;(entity =&gt;
    {
      entity.ToTable("Customer");
      entity.Property(e =&gt; e.Name).IsRequired();  // Column is not nullable
    });
    modelBuilder.Entity&lt;Purchase&gt;(entity =&gt;
    {
      entity.ToTable("Purchase");
      entity.Property(e =&gt; e.Date).IsRequired();     
      entity.Property(e =&gt; e.Description).IsRequired();     
    });
  }
}

public class Customer
{
  public int ID { get; set; }
  public string Name { get; set; }

  public virtual List&lt;Purchase&gt; Purchases { get; set; }
    = new List&lt;Purchase&gt;();
}

public class Purchase
{        
  public int ID { get; set; }
  public int? CustomerID { get; set; }
  public DateTime Date { get; set; }
  public string Description { get; set; }
  public decimal Price { get; set; }

  public virtual Customer Customer { get; set; }
}</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All of the examples in this chapter are preloaded into LINQPad, along with a sample database with a matching schema. You can download LINQPad from <a href="http://www.linqpad.net"><em>http://www.linqpad.net</em></a>.</p>
</div>

<p>Here are corresponding SQL Server table definitions:</p>

<pre data-type="programlisting">
CREATE TABLE Customer (
  ID int NOT NULL IDENTITY PRIMARY KEY,
  Name nvarchar(30) NOT NULL
)

CREATE TABLE Purchase (
  ID int NOT NULL IDENTITY PRIMARY KEY,
  CustomerID int NOT NULL REFERENCES Customer(ID),
  Date datetime NOT NULL,
  Description nvarchar(30) NOT NULL,
  Price decimal NOT NULL
)</pre>

<section data-pdf-bookmark="Overview" data-type="sect1"><div class="sect1" id="overview">
<h1>Overview</h1>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="overview" data-type="indexterm" id="ch09.html1"/>In this section, we provide an overview of the standard query operators. They fall into three categories:</p>

<ul>
	<li>
	<p>Sequence in, sequence out (sequence→sequence)</p>
	</li>
	<li>
	<p>Sequence in, single element or scalar value out</p>
	</li>
	<li>
	<p>Nothing in, sequence out (<em>generation</em> methods)</p>
	</li>
</ul>

<p>We first present each of the three categories and the query operators they include, and then we take up each individual query operator in detail.</p>

<section data-pdf-bookmark="Sequence→Sequence" data-type="sect2"><div class="sect2" id="sd">
<h2>Sequence→Sequence</h2>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="sequence to sequence" data-type="indexterm" id="ch09.html2"/>Most query operators fall into this category—accepting one or more sequences as input and emitting a single output sequence. <a data-type="xref" href="#shape_changing_operators">Figure 9-1</a> illustrates those operators that restructure the shape of the sequences.</p>

<figure><div class="figure" id="shape_changing_operators"><img alt="Shape-changing operators" src="assets/cn10_0901.png"/>
<h6><span class="label">Figure 9-1. </span>Shape-changing operators</h6>
</div></figure>

<section data-pdf-bookmark="Filtering" data-type="sect3"><div class="sect3" id="filtering-id00021">
<h3>Filtering</h3>

<p><code>IEnumerable&lt;TSource&gt;</code> →<code>IEnumerable&lt;TSource&gt;</code></p>

<p>Returns a subset of the original elements.</p>

<pre data-type="programlisting">
Where, Take, TakeLast, TakeWhile, Skip, SkipLast, SkipWhile, 
Distinct, DistinctBy</pre>
</div></section>

<section data-pdf-bookmark="Projecting" data-type="sect3"><div class="sect3" id="projecting-id00076">
<h3>Projecting</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<p>Transforms each element with a lambda function. <code>SelectMany</code> flattens nested sequences; <code>Select</code> and <code>SelectMany</code> perform inner joins, left outer joins, cross joins, and non-equi joins with EF Core.</p>

<pre data-type="programlisting">
Select, SelectMany</pre>
</div></section>

<section data-pdf-bookmark="Joining" data-type="sect3"><div class="sect3" id="joining">
<h3>Joining</h3>

<p><code>IEnumerable&lt;TOuter&gt;</code>, <code>IEnumerable&lt;TInner&gt;</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<p>Meshes elements of one sequence with another. <code>Join</code> and <code>GroupJoin</code> operators are designed to be efficient with local queries and support inner and left outer joins. The <code>Zip</code> operator enumerates two sequences in step, applying a function over each element pair. Rather than naming the type arguments <code>TOuter</code> and <code>TInner</code>, the <code>Zip</code> operator names them <code>TFirst</code> and <code>TSecond</code>:</p>

<p><code>IEnumerable&lt;TFirst&gt;</code>, <code>IEnumerable&lt;TSecond&gt;</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<pre data-type="programlisting">
Join, GroupJoin, Zip</pre>
</div></section>

<section data-pdf-bookmark="Ordering" data-type="sect3"><div class="sect3" id="ordering-id00051">
<h3>Ordering</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code>IOrderedEnumerable&lt;TSource&gt;</code></p>

<p>Returns a reordering of a sequence.</p>

<pre data-type="programlisting">
OrderBy, OrderByDescending, ThenBy, ThenByDescending, Reverse</pre>
</div></section>

<section data-pdf-bookmark="Grouping" data-type="sect3"><div class="sect3" id="grouping-id00031">
<h3>Grouping</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;IGrouping&lt;TKey,TElement&gt;&gt;</code></p>
<p><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TElement[]&gt;</code></p>

<p>Groups a sequence into subsequences.</p>

<pre data-type="programlisting">
GroupBy, Chunk</pre>
</div></section>

<section data-pdf-bookmark="Set operators" data-type="sect3"><div class="sect3" id="set_operators-id00632">
<h3>Set operators</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>, <code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TSource&gt;</code></p>

<p>Takes two same-typed sequences and returns their commonality, sum, or difference.</p>

<pre data-type="programlisting">
Concat, Union, UnionBy, Intersect, IntersectBy, Except, ExceptBy</pre>
</div></section>

<section data-pdf-bookmark="Conversion methods: Import" data-type="sect3"><div class="sect3" id="conversion_methods_import">
<h3>Conversion methods: Import</h3>

<p><code>IEnumerable</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<pre data-type="programlisting">
OfType, Cast</pre>
</div></section>

<section data-pdf-bookmark="Conversion methods: Export" data-type="sect3"><div class="sect3" id="conversion_methods_export">
<h3>Conversion methods: Export</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→An array, list, dictionary, lookup, or sequence<a contenteditable="false" data-primary="" data-startref="ch09.html2" data-type="indexterm" id="id3220"/></p>

<pre data-type="programlisting">
ToArray, ToList, ToDictionary, ToLookup, AsEnumerable, AsQueryable</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Sequence→Element or Value" data-type="sect2"><div class="sect2" id="sequence_or_value">
<h2>Sequence→Element or Value</h2>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="sequence to element or value" data-type="indexterm" id="id3221"/>The following query operators accept an input sequence and emit a single element or value.</p>

<section data-pdf-bookmark="Element operators" data-type="sect3"><div class="sect3" id="element_operators-id00610">
<h3>Element operators</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code>TSource</code></p>

<p>Picks a single element from a sequence.</p>

<pre data-type="programlisting">
First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault,
ElementAt, ElementAtOrDefault, MinBy, MaxBy, DefaultIfEmpty</pre>
</div></section>

<section data-pdf-bookmark="Aggregation methods" data-type="sect3"><div class="sect3" id="aggregation_methods">
<h3>Aggregation methods</h3>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code><em>scalar</em></code></p>

<p>Performs a computation across a sequence, returning a scalar value (typically a number).</p>

<pre data-type="programlisting">
Aggregate, Average, Count, LongCount, Sum, Max, Min</pre>
</div></section>

<section data-pdf-bookmark="Quantifiers" data-type="sect3"><div class="sect3" id="quantifiers-id00081">
<h3>Quantifiers</h3>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="quantifiers" data-type="indexterm" id="id3222"/><a contenteditable="false" data-primary="quantifiers" data-secondary="LINQ" data-type="indexterm" id="id3223"/><code>IEnumerable&lt;TSource&gt;</code>→<code><em>bool</em></code></p>

<p>An aggregation returning <code>true</code> or <code>false</code>.</p>

<pre data-type="programlisting">
All, Any, Contains, SequenceEqual</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Void→Sequence" data-type="sect2"><div class="sect2" id="void">
<h2>Void→Sequence</h2>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="void to sequence" data-type="indexterm" id="id3224"/>In the third and final category are query operators that produce an output sequence from scratch.</p>

<section data-pdf-bookmark="Generation methods" data-type="sect3"><div class="sect3" id="generation_methods-id00613">
<h3>Generation methods</h3>

<p><code>void</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<p>Manufactures a simple sequence.<a contenteditable="false" data-primary="" data-startref="ch09.html1" data-type="indexterm" id="id3225"/></p>

<pre data-type="programlisting">
Empty, Range, Repeat</pre>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Filtering" data-type="sect1"><div class="sect1" id="filtering">
<h1>Filtering</h1>

<p><a contenteditable="false" data-primary="filtering" data-type="indexterm" id="ch09.html3"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="filtering" data-type="indexterm" id="ch09.html4"/><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TSource&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Where</code></td>
			<td>Returns a subset of elements that satisfy a given condition</td>
			<td><code>WHERE</code></td>
		</tr>
		<tr>
			<td><code>Take</code></td>
			<td>Returns the first <code>count</code> elements and discards the rest</td>
			<td><span class="keep-together"><code>WHERE ROW_NUMBER()...</code></span><br/>
			<em>or</em> <code>TOP <em>n</em></code> subquery</td>
		</tr>
		<tr>
			<td><code>Skip</code></td>
			<td>Ignores the first <code>count</code> elements and returns the rest</td>
			<td><span class="keep-together"><code>WHERE ROW_NUMBER()...</code></span><br/>
			<em>or</em> <span class="keep-together"><code>NOT IN (SELECT TOP <em>n</em>...)</code></span></td>
		</tr>
		<tr>
		<td><code>TakeLast</code></td>
		 <td>Takes only the last <code>count</code> elements</td>
		 <td>Exception thrown</td>
		</tr>
		<tr>
		 <td><code>SkipLast</code></td>
		 <td>Ignores the last <code>count</code> element</td>
		 <td>Exception thrown</td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>TakeWhile</code></span></td>
			<td>Emits elements from the input sequence until the predicate is false</td>
			<td>Exception thrown</td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>SkipWhile</code></span></td>
			<td>Ignores elements from the input sequence until the predicate is false, and then emits the rest</td>
			<td>Exception thrown</td>
		</tr>
		<tr>
			<td><code>Distinct</code>, <code>DistinctBy</code></td>
			<td>Returns a sequence that excludes duplicates</td>
			<td><code>SELECT DISTINCT...</code></td>
		</tr>
	</tbody>
</table>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The “SQL equivalents” column in the reference tables in this chapter do not necessarily correspond to what an <code>IQueryable</code> implementation such as EF Core will produce. Rather, it indicates what you’d typically use to do the same job if you were writing the SQL query yourself. Where there is no simple translation, the column is left blank. Where there is no translation at all, the column reads “Exception thrown.”</p>

<p><code>Enumerable</code> implementation code, when shown, excludes checking for null arguments and indexing predicates.</p>
</div>

<p>With each of the filtering methods, you always end up with either the same number or fewer elements than you started with. You can never get more! The elements are also <a contenteditable="false" data-primary="filtering" data-secondary="Where" data-type="indexterm" id="ch09.html5"/><a contenteditable="false" data-primary="Where clause" data-type="indexterm" id="ch09.html6"/>identical when they come out; they are not transformed in any way.</p>

<section data-pdf-bookmark="Where" data-type="sect2"><div class="sect2" id="where">
<h2>Where</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Predicate</td>
			<td><code>TSource =&gt; bool or (TSource,int) =&gt; bool</code><sup><a data-type="noteref" href="ch09.html#ch01fn8" id="ch01fn8-marker">a</a></sup></td>
		</tr>
	</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="ch01fn8"><sup><a href="ch09.html#ch01fn8-marker">a</a></sup> Prohibited with LINQ to SQL and Entity Framework</p></td></tr></tbody></table>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00092">
<h3>Query syntax</h3>

<pre data-type="programlisting">
where <em>bool-expression</em></pre>
</div></section>

<section data-pdf-bookmark="Enumerable.Where implementation" data-type="sect3"><div class="sect3" id="enumerabledotwhere_implementation">
<h3>Enumerable.Where implementation</h3>

<p><a contenteditable="false" data-primary="Enumerable..." data-secondary="Enumerable.Where" data-type="indexterm" id="id3226"/><a contenteditable="false" data-primary="Where clause" data-secondary="Enumerable.Where implementation" data-type="indexterm" id="id3227"/>The internal implementation of <code>Enumerable.Where</code>, null checking aside, is functionally equivalent to the following:</p>

<pre data-type="programlisting">
<strong>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;</strong>
  (this IEnumerable&lt;TSource&gt; source, Func &lt;TSource, bool&gt; predicate)
{
  foreach (TSource element in source)
    if (predicate (element))
      yield return element;
}</pre>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00061">
<h3 class="less_space">Overview</h3>

<p><code>Where</code> returns the elements from the input sequence that satisfy the given predicate.</p>

<p>For instance:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
<strong>IEnumerable&lt;string&gt; query = names.Where (name =&gt; name.EndsWith ("y"));</strong>

<em>// Harry</em>
<em>// Mary</em>
<em>// Jay</em></pre>

<p>In query syntax:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = from n in names
                            <strong>where n.EndsWith ("y")</strong>
                            select n;</pre>

<p>A <code>where</code> clause can appear more than once in a query and be interspersed with <code>let</code>, <code>orderby</code>, and <code>join</code> clauses:</p>

<pre data-type="programlisting">
from n in names
<strong>where n.Length &gt; 3</strong>
let u = n.ToUpper()
<strong>where u.EndsWith ("Y")</strong>
select u;           
  
<em>// HARRY</em>
<em>// MARY</em></pre>

<p>Standard C# scoping rules apply to such queries. In other words, you cannot refer to a variable prior to declaring it with a range variable or a <code>let</code> clause.</p>
</div></section>

<section data-pdf-bookmark="Indexed filtering" data-type="sect3"><div class="sect3" id="indexed_filtering">
<h3>Indexed filtering</h3>

<p><a contenteditable="false" data-primary="indexed filtering" data-type="indexterm" id="id3228"/><a contenteditable="false" data-primary="Where clause" data-secondary="indexed filtering" data-type="indexterm" id="id3229"/><code>Where</code>’s predicate optionally accepts a second argument, of type <code>int</code>. This is fed with the position of each element within the input sequence, allowing the predicate to use this information in its filtering decision. For example, the following skips every second element:</p>

<pre data-type="programlisting">
<strong>IEnumerable&lt;string&gt; query = names.Where ((n, i) =&gt; i % 2 == 0);</strong>

<em>// Tom</em>
<em>// Harry</em>
<em>// Jay</em></pre>

<p>An exception is thrown if you use indexed filtering in EF Core.</p>
</div></section>

<section data-pdf-bookmark="SQL LIKE comparisons in EF Core" data-type="sect3"><div class="sect3" id="sql_like_comparisons_in_ef_core">
<h3>SQL LIKE comparisons in EF Core</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="SQL LIKE comparisons" data-type="indexterm" id="id3230"/><a contenteditable="false" data-primary="filtering" data-secondary="SQL LIKE comparisons in EF Core" data-type="indexterm" id="id3231"/><a contenteditable="false" data-primary="LIKE operator" data-type="indexterm" id="id3232"/>The following methods on <code>string</code> translate to SQL’s <code>LIKE</code> operator:</p>

<pre data-type="programlisting">
Contains, StartsWith, EndsWith</pre>

<p>For instance, <code>c.Name.Contains ("abc")</code> translates to <code>customer.Name LIKE '%abc%'</code> (or more accurately, a parameterized version of this). <code>Contains</code> lets you compare only against a locally evaluated expression; to compare against another column, you must use the <code>EF.Functions.Like</code> method:</p>

<pre data-type="programlisting">
... where EF.Functions.Like (c.Description, "%" + c.Name + "%")</pre>

<p><code>EF.Functions.Like</code> also lets you perform more complex comparisons (e.g., <code>LIKE 'abc%def%'</code>).</p>
</div></section>

<section data-pdf-bookmark="&lt; and &gt; string comparisons in EF Core" data-type="sect3"><div class="sect3" id="less_than_and_greater_than_string_compa">
<h3>&lt; and &gt; string comparisons in EF Core</h3>

<p><a contenteditable="false" data-primary="CompareTo" data-type="indexterm" id="id3233"/><a contenteditable="false" data-primary="EF Core" data-secondary="string comparisons in" data-type="indexterm" id="id3234"/><a contenteditable="false" data-primary="filtering" data-secondary="&lt; and  &gt; string comparisons in EF Core" data-type="indexterm" id="id3235"/>You can perform <em>order</em> comparison on strings with <code>string</code>’s <code>CompareTo</code> method; this maps to SQL’s <code>&lt;</code> and <code>&gt;</code> operators:</p>

<pre data-type="programlisting">
dbContext.Purchases.Where (p =&gt; p.Description.<strong>CompareTo ("C")</strong> &lt; <strong>0</strong>)</pre>
</div></section>

<section data-pdf-bookmark="WHERE x IN (…, …, …) in EF Core" data-type="sect3"><div class="sect3" id="where_x_in_left_parenthesis_parenthesis">
<h3>WHERE x IN (…, …, …) in EF Core</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="WHERE x IN (…,…,…)" data-type="indexterm" id="id3236"/><a contenteditable="false" data-primary="filtering" data-secondary="WHERE x IN (…,…,…) in EF Core" data-type="indexterm" id="id3237"/><a contenteditable="false" data-primary="WHERE x IN (…,…,…)" data-type="indexterm" id="id3238"/>With EF Core, you can apply the <code>Contains</code> operator to a local collection within a filter predicate. For instance:</p>

<pre data-type="programlisting">
<strong>string[] chosenOnes = { "Tom", "Jay" };</strong>

from c in dbContext.Customers
<strong>where chosenOnes.Contains (c.Name)</strong>
...</pre>

<p>This maps to SQL’s <code>IN</code> operator. In other words:</p>

<pre data-type="programlisting">
WHERE customer.Name <strong>IN ("Tom", "Jay")</strong></pre>

<p>If the local collection is an array of entities or nonscalar types, EF Core might instead emit an <code>EXISTS</code> clause.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Take, TakeLast, Skip, SkipLast" data-type="sect2"><div class="sect2" id="take_and_skip">
<h2>Take, TakeLast, Skip, SkipLast</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Number of elements to take or skip</td>
			<td><code>int</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="filtering" data-secondary="Take and Skip" data-type="indexterm" id="id3239"/><a contenteditable="false" data-primary="Skip operator" data-type="indexterm" id="id3240"/><a contenteditable="false" data-primary="Take operator" data-type="indexterm" id="id3241"/><code>Take</code> emits the first <em>n</em> elements and discards the rest; <code>Skip</code> discards the first <em>n</em> elements and emits the rest. The two methods are useful together when implementing a web page allowing a user to navigate through a large set of matching records. For instance, suppose that a user searches a book database for the term “mercury”, and there are 100 matches. The following returns the first 20:</p>

<pre data-type="programlisting">
IQueryable&lt;Book&gt; query = dbContext.Books
  .Where   (b =&gt; b.Title.Contains ("mercury"))
  .OrderBy (b =&gt; b.Title)
  <strong>.Take (20);</strong></pre>

<p>The next query returns books 21 to 40:</p>

<pre data-type="programlisting">
IQueryable&lt;Book&gt; query = dbContext.Books
  .Where   (b =&gt; b.Title.Contains ("mercury"))
  .OrderBy (b =&gt; b.Title)
  <strong>.Skip (20).Take (20);</strong></pre>

<p>EF Core translates <code>Take</code> and <code>Skip</code> to the <code>ROW_NUMBER</code> function in SQL Server 2005, or a <code>TOP</code> <em>n</em> subquery in earlier versions of SQL Server.</p>

<p>The <code>TakeLast</code> and <code>SkipLast</code> methods take or skip the last <em>n</em> elements.</p>

<p>From .NET 6, the <code>Take</code> method is overloaded to accept a <code>Range</code> variable. This overload can subsume the functionality of all four methods; for instance, <code>Take(5..)</code> is equivalent to <code>Skip(5)</code>, and <code>Take(..^5)</code> is equivalent to <code>SkipLast(5)</code>.</p>
</div></section>

<section data-pdf-bookmark="TakeWhile and SkipWhile" data-type="sect2"><div class="sect2" id="takewhile_and_skipwhile">
<h2>TakeWhile and SkipWhile</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Predicate</td>
			<td><code>TSource =&gt; bool</code> or <code>(TSource,int) =&gt; bool</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="filtering" data-secondary="TakeWhile and SkipWhile" data-type="indexterm" id="id3242"/><a contenteditable="false" data-primary="TakeWhile operator" data-type="indexterm" id="id3243"/><code>TakeWhile</code> enumerates the input sequence, emitting each item until the given predicate is false. It then ignores the remaining elements:</p>

<pre data-type="programlisting">
int[] numbers      = { 3, 5, 2, 234, 4, 1 };
<strong>var takeWhileSmall = numbers.TakeWhile (n =&gt; n &lt; 100);   // { 3, 5, 2 }</strong></pre>

<p><a contenteditable="false" data-primary="SkipWhile operator" data-type="indexterm" id="id3244"/><code>SkipWhile</code> enumerates the input sequence, ignoring each item until the given predicate is false. It then emits the remaining elements:</p>

<pre data-type="programlisting">
int[] numbers      = { 3, 5, 2, 234, 4, 1 };
<strong>var skipWhileSmall = numbers.SkipWhile (n =&gt; n &lt; 100);   // { 234, 4, 1 }</strong></pre>

<p><code>TakeWhile</code> and <code>SkipWhile</code> have no translation to SQL and throw an exception if used in an EF Core query.</p>
</div></section>

<section data-pdf-bookmark="Distinct and DistinctBy" data-type="sect2"><div class="sect2" id="distinct">
<h2>Distinct and DistinctBy</h2>

<p><a contenteditable="false" data-primary="Distinct operator" data-type="indexterm" id="id3245"/><a contenteditable="false" data-primary="filtering" data-secondary="Distinct operator" data-type="indexterm" id="id3246"/><code>Distinct</code> returns the input sequence, stripped of duplicates. You can optionally pass in a custom equality comparer. The following returns distinct letters in a string:</p>

<pre data-type="programlisting">
<strong>char[] distinctLetters = "HelloWorld".Distinct().ToArray();</strong>
string s = new string (distinctLetters);                     // HeloWrd</pre>

<p>We can call LINQ methods directly on a string because <code>string</code> implements <span class="keep-together"><code>IEnumerable&lt;char&gt;</code></span><a contenteditable="false" data-primary="" data-startref="ch09.html6" data-type="indexterm" id="id3247"/><a contenteditable="false" data-primary="" data-startref="ch09.html5" data-type="indexterm" id="id3248"/>.<a contenteditable="false" data-primary="" data-startref="ch09.html4" data-type="indexterm" id="id3249"/><a contenteditable="false" data-primary="" data-startref="ch09.html3" data-type="indexterm" id="id3250"/></p>

<p>The <code>DistinctBy</code> method was introduced in .NET 6 and lets you specify a key selector to be applied before performing equality comparison. The result of the following expression is <code>{1,2,3}</code>:</p>

<pre data-type="programlisting">new[] { 1.0, 1.1, 2.0, 2.1, 3.0, 3.1 }.DistinctBy (n =&gt; Math.Round (n, 0))</pre>

</div></section>
</div></section>

<section data-pdf-bookmark="Projecting" data-type="sect1"><div class="sect1" id="projecting-id00078">
<h1>Projecting</h1>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="projecting" data-type="indexterm" id="ch09.html7"/><a contenteditable="false" data-primary="projecting" data-secondary="LINQ operators" data-type="indexterm" id="ch09.html8"/><code>IEnumerable&lt;TSource&gt;</code>→ <code>IEnumerable&lt;TResult&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Select</code></td>
			<td>Transforms each input element with the given lambda expression</td>
			<td><code>SELECT</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>SelectMany</code></span></td>
			<td>Transforms each input element, and then flattens and concatenates the resultant subsequences</td>
			<td><code>INNER JOIN</code>,<br/>
			<code>LEFT OUTER JOIN</code>,<br/>
			<code>CROSS JOIN</code></td>
		</tr>
	</tbody>
</table>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When querying a database, <code>Select</code> and <code>SelectMany</code> are the most versatile joining constructs; for local queries, <code>Join</code> and <code>GroupJoin</code> are the most <em>efficient</em> joining constructs.</p>
</div>

<section data-pdf-bookmark="Select" data-type="sect2"><div class="sect2" id="select">
<h2>Select</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Result selector</td>
			<td><code>TSource =&gt; TResult</code> or <code>(TSource,int) =&gt; TResult</code><sup><a data-type="noteref" href="ch09.html#ch01fn9" id="ch01fn9-marker">a</a></sup></td>
		</tr>
	</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="ch01fn9"><sup><a href="ch09.html#ch01fn9-marker">a</a></sup> Prohibited with EF Core</p></td></tr></tbody></table>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00093">
<h3>Query syntax</h3>

<pre data-type="programlisting">
select <em>projection-expression</em></pre>
</div></section>

<section data-pdf-bookmark="Enumerable implementation" data-type="sect3"><div class="sect3" id="enumerable_implementation-id00121">
<h3>Enumerable implementation</h3>

<pre data-type="programlisting">
<strong>public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;</strong>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)
{
  foreach (TSource element in source)
    yield return selector (element);
}</pre>
</div></section>

<section data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00062">
<h3>Overview</h3>

<p><a contenteditable="false" data-primary="projecting" data-secondary="Select method" data-type="indexterm" id="ch09.html9"/><a contenteditable="false" data-primary="Select method" data-type="indexterm" id="ch09.html10"/>With <code>Select</code>, you always get the same number of elements that you started with. Each element, however, can be transformed in any manner by the lambda function.</p>

<p>The following selects the names of all fonts installed on the computer (from <span class="keep-together"><code>System.Drawing</code></span>):</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = from f in FontFamily.Families
                            <strong>select f.Name;</strong>

foreach (string name in query) Console.WriteLine (name);</pre>

<p>In this example, the <code>select</code> clause converts a <code>FontFamily</code> object to its name. Here’s the lambda equivalent:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = FontFamily.Families.Select (f =&gt; f.Name);</pre>

<p><code>Select</code> statements are often used to project into anonymous types:</p>

<pre data-type="programlisting">
var query =
  from f in FontFamily.Families
  <strong>select new { f.Name, LineSpacing = f.GetLineSpacing (FontStyle.Bold) };</strong></pre>

<p>A projection with no transformation is sometimes used with query syntax to satisfy the requirement that the query end in a <code>select</code> or <code>group</code> clause. The following selects fonts supporting strikeout:</p>

<pre data-type="programlisting">
IEnumerable&lt;FontFamily&gt; query =
  from f in FontFamily.Families
  where f.IsStyleAvailable (FontStyle.Strikeout)
  <strong>select f;</strong>

foreach (FontFamily ff in query) Console.WriteLine (ff.Name);</pre>

<p>In such cases, the compiler omits the projection when translating to fluent syntax.</p>
</div></section>

<section data-pdf-bookmark="Indexed projection" data-type="sect3"><div class="sect3" id="indexed_projection">
<h3>Indexed projection</h3>

<p><a contenteditable="false" data-primary="Select method" data-secondary="indexed projection" data-type="indexterm" id="id3251"/>The <code>selector</code> expression can optionally accept an integer argument, which acts as an indexer, providing the expression with the position of each input in the input sequence. This works only with local queries:</p>

<pre data-type="programlisting">
string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

IEnumerable&lt;string&gt; query = names
  .Select ((s,i) =&gt; i + "=" + s);     //  { "0=Tom", "1=Dick", ... }</pre>
</div></section>

<section data-pdf-bookmark="Select subqueries and object hierarchies" data-type="sect3"><div class="sect3" id="select_subqueries_and_object_hierarchie">
<h3>Select subqueries and object hierarchies</h3>

<p><a contenteditable="false" data-primary="Select method" data-secondary="select subqueries and object hierarchies" data-type="indexterm" id="id3252"/><a contenteditable="false" data-primary="subqueries" data-secondary="select subqueries and object hierarchies" data-type="indexterm" id="id3253"/>You can nest a subquery in a <code>select</code> clause to build an object hierarchy. The following example returns a collection describing each directory under <code>Path.GetTempPath()</code>, with a subcollection of files under each directory:</p>

<pre data-type="programlisting">
string tempPath = Path.GetTempPath();
DirectoryInfo[] dirs = new DirectoryInfo (tempPath).GetDirectories();

var query =
  from d in dirs
  where (d.Attributes &amp; FileAttributes.System) == 0
  select new
  {
    DirectoryName = d.FullName,
    Created = d.CreationTime,

    <strong>Files = from f in d.GetFiles()</strong>
<strong>            where (f.Attributes &amp; FileAttributes.Hidden) == 0</strong>
<strong>            select new { FileName = f.Name, f.Length, }</strong>
  };

foreach (var dirFiles in query)
{
  Console.WriteLine ("Directory: " + dirFiles.DirectoryName);
  foreach (var file in dirFiles.Files)
    Console.WriteLine ("  " + file.FileName + " Len: " + file.Length);
}</pre>

<p><a contenteditable="false" data-primary="correlated subquery" data-type="indexterm" id="id3254"/>The inner portion of this query can be called a <em>correlated subquery</em>. A subquery is correlated if it references an object in the outer query—in this case, it references <code>d</code>, the directory being enumerated.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A subquery inside a <code>Select</code> allows you to map one object hierarchy to another, or map a relational object model to a hierarchical object model.</p>
</div>

<p>With local queries, a subquery within a <code>Select</code> causes double-deferred execution. In our example, the files aren’t filtered or projected until the inner <code>foreach</code> statement enumerates.</p>
</div></section>

<section data-pdf-bookmark="Subqueries and joins in EF Core" data-type="sect3"><div class="sect3" id="subqueries_and_joins_in_ef_core">
<h3>Subqueries and joins in EF Core</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="subqueries and joins in" data-type="indexterm" id="id3255"/><a contenteditable="false" data-primary="Select method" data-secondary="subqueries and joins in EF Core" data-type="indexterm" id="id3256"/><a contenteditable="false" data-primary="subqueries" data-secondary="subqueries and joins in EF Core" data-type="indexterm" id="id3257"/>Subquery projections work well in EF Core, and you can use them to do the work of SQL-style joins. Here’s how we retrieve each customer’s name along with their high-value purchases:</p>

<pre data-type="programlisting">
var query =
  from c in dbContext.Customers
  select new {
               c.Name,
<strong>               Purchases = (from p in dbContext.Purchases</strong>
 <strong>                          where p.CustomerID == c.ID &amp;&amp; p.Price &gt; 1000</strong>
<strong>                           select new { p.Description, p.Price })</strong>
<strong>                           .ToList()</strong>
             };

foreach (var namePurchases in query)
{
  Console.WriteLine ("Customer: " + namePurchases.Name);
  foreach (var purchaseDetail in namePurchases.Purchases)
    Console.WriteLine ("  - $$$: " + purchaseDetail.Price);
}</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note the use of <code>ToList</code> in the subquery. EF Core 3 cannot create queryables from the subquery result when that subquery references the <code>DbContext</code>. This issue is being tracked by the EF Core team and might be resolved in a future release.</p>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This style of query is ideally suited to interpreted queries. The outer query and subquery are processed as a unit, preventing unnecessary round-tripping. With local queries, however, it’s inefficient because every combination of outer and inner elements must be enumerated to get the few matching combinations. A better choice for local queries is <code>Join</code> or <code>GroupJoin</code>, described in the following sections.</p>
</div>

<p>This query matches up objects from two disparate collections, and it can be thought of as a “join.” The difference between this and a conventional database join (or subquery) is that we’re not flattening the output into a single two-dimensional result set. We’re mapping the relational data to hierarchical data, rather than to flat data.</p>

<p>Here’s the same query simplified by using the <code>Purchases</code> collection navigation property on the <code>Customer</code> entity:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
select new
{
  c.Name,
  <strong>Purchases = from p in c.Purchases    // Purchases is List&lt;Purchase&gt;</strong>
              where p.Price &gt; 1000
              select new { p.Description, p.Price }
};</pre>

<p>(EF Core 3 does not require <code>ToList</code> when performing the subquery on a navigation property.)</p>

<p>Both queries are analogous to a left outer join in SQL in the sense that we get all customers in the outer enumeration, regardless of whether they have any purchases. To emulate an inner join—whereby customers without high-value purchases are excluded—we would need to add a filter condition on the purchases collection:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>where c.Purchases.Any (p =&gt; p.Price &gt; 1000)</strong>
select new {
             c.Name,
             Purchases = from p in c.Purchases
                         where p.Price &gt; 1000
                         select new { p.Description, p.Price }
           };</pre>

<p>This is slightly untidy, however, in that we’ve written the same predicate (<code>Price &gt; 1000</code>) twice. We can avoid this duplication with a <code>let</code> clause:</p>

<pre class="pre" data-type="programlisting">
from c in dbContext.Customers
<strong>let highValueP = from p in c.Purchases</strong>
<strong>                 where p.Price &gt; 1000</strong>
<strong>                 select new { p.Description, p.Price }</strong>
where <strong>highValueP.</strong>Any()
select new { c.Name, Purchases = highValueP };</pre>

<p class="pagebreak-before">This style of query is flexible. By changing <code>Any</code> to <code>Count</code>, for instance, we can modify the query to retrieve only customers with at least two high-value purchases:</p>

<pre data-type="programlisting">
...
<strong>where highValueP.Count() &gt;= 2</strong>
select new { c.Name, Purchases = highValueP };</pre>
</div></section>

<section data-pdf-bookmark="Projecting into concrete types" data-type="sect3"><div class="sect3" id="projecting_into_concrete_types">
<h3>Projecting into concrete types</h3>

<p><a contenteditable="false" data-primary="Select method" data-secondary="projecting into concrete types" data-type="indexterm" id="id3258"/>In the examples so far, we’ve instantiated anonymous types in the output. It can also be useful to instantiate (ordinary) named classes, which you populate with object initializers. Such classes can include custom logic and can be passed between methods and assemblies without using type information.</p>

<p>A typical example is a custom business entity. A custom business entity is simply a class that you write with some properties but is designed to hide lower-level (database-related) details. You might exclude foreign key fields from business-entity classes, for instance. Assuming that we wrote custom entity classes called <code>CustomerEntity</code> and <code>PurchaseEntity</code>, here’s how we could project into them:</p>

<pre data-type="programlisting">
IQueryable&lt;CustomerEntity&gt; query =
  from c in dbContext.Customers
  <strong>select new CustomerEntity</strong>
  {
    Name = c.Name,
    Purchases =
      (from p in c.Purchases
       where p.Price &gt; 1000
<strong>       select new PurchaseEntity {</strong>
<strong>                                   Description = p.Description,</strong>
<strong>                                   Value = p.Price</strong>
<strong>                                 }</strong>
      ).ToList()
  };

// Force query execution, converting output to a more convenient List:
List&lt;CustomerEntity&gt; result = query.ToList();</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="data transfer object (DTO)" data-type="indexterm" id="id3259"/><a contenteditable="false" data-primary="DTO (data transfer object)" data-type="indexterm" id="id3260"/>When created to transfer data between tiers in a program or between separate systems, custom business entity classes are often called data transfer objects (DTO). DTOs contain no business logic.</p>
</div>

<p>Notice that so far, we’ve not had to use a <code>Join</code> or <code>SelectMany</code> statement. This is because we’re maintaining the hierarchical shape of the data, as illustrated in <a data-type="xref" href="#projecting_an_object_hierarchy">Figure 9-2</a>. With LINQ, you can often avoid the traditional SQL approach of flattening tables into a two-dimensional result set.<a contenteditable="false" data-primary="" data-startref="ch09.html10" data-type="indexterm" id="id3261"/><a contenteditable="false" data-primary="" data-startref="ch09.html9" data-type="indexterm" id="id3262"/></p>

<figure><div class="figure" id="projecting_an_object_hierarchy"><img alt="Projecting an object hierarchy" src="assets/cn10_0902.png"/>
<h6><span class="label">Figure 9-2. </span>Projecting an object hierarchy</h6>
</div></figure>
</div></section>
</div></section>

<section data-pdf-bookmark="SelectMany" data-type="sect2"><div class="sect2" id="selectmany">
<h2>SelectMany</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Result selector</td>
			<td><code>TSource =&gt; IEnumerable&lt;TResult&gt;</code><br/>
			or <code>(TSource,int) =&gt; IEnumerable&lt;TResult&gt;</code><sup><a data-type="noteref" href="ch09.html#ch01fn10" id="ch01fn10-marker">a</a></sup></td>
		</tr>
	</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="ch01fn10"><sup><a href="ch09.html#ch01fn10-marker">a</a></sup> Prohibited with EF Core</p></td></tr></tbody></table>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00095">
<h3>Query syntax</h3>

<pre data-type="programlisting">
from <em>identifier1</em> in <em>enumerable-expression1</em>
from <em>identifier2</em> in <em>enumerable-expression2</em>
...</pre>
</div></section>

<section data-pdf-bookmark="Enumerable implementation" data-type="sect3"><div class="sect3" id="enumerable_implementation">
<h3>Enumerable implementation</h3>

<pre data-type="programlisting">
public static IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt;
  (IEnumerable&lt;TSource&gt; source,
   Func &lt;TSource,IEnumerable&lt;TResult&gt;&gt; selector)
{
  foreach (TSource element in source)
    foreach (TResult subElement in selector (element))
      yield return subElement;
}</pre>
</div></section>

<section data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00063">
<h3>Overview</h3>

<p><a contenteditable="false" data-primary="projecting" data-secondary="SelectMany" data-type="indexterm" id="ch09.html11"/><a contenteditable="false" data-primary="SelectMany" data-type="indexterm" id="ch09.html12"/><code>SelectMany</code> concatenates subsequences into a single flat output sequence.</p>

<p>Recall that for each input element, <code>Select</code> yields exactly one output element. In contrast, <code>SelectMany</code> yields <em>0..n</em> output elements. The <em>0..n</em> elements come from a subsequence or child sequence that the lambda expression must emit.</p>

<p>You can use <code>SelectMany</code> to expand child sequences, flatten nested collections, and join two collections into a flat output sequence. Using the conveyor belt analogy, <code>SelectMany</code> funnels fresh material onto a conveyor belt. With <code>SelectMany</code>, each input element is the <em>trigger</em> for the introduction of fresh material. The fresh material is emitted by the <code>selector</code> lambda expression and must be a sequence. In other words, the lambda expression must emit a <em>child sequence</em> per input <em>element</em>. The final result is a concatenation of the child sequences emitted for each input element.</p>

<p>Starting with a simple example, suppose that we have the following array of names,</p>

<pre data-type="programlisting">
string[] fullNames = { "Anne Williams", "John Fred Smith", "Sue Green" };</pre>

<p>that we want to convert to a single flat collection of words—in other words:</p>

<pre data-type="programlisting">
"Anne", "Williams", "John", "Fred", "Smith", "Sue", Green"</pre>

<p><code>SelectMany</code> is ideal for this task, because we’re mapping each input element to a variable number of output elements. All we must do is come up with a <code>selector</code> expression that converts each input element to a child sequence. <code>string.Split</code> does the job nicely: it takes a string and splits it into words, emitting the result as an array:</p>

<pre data-type="programlisting">
string testInputElement = "Anne Williams";
string[] childSequence  = testInputElement.Split();

// childSequence is { "Anne", "Williams" };</pre>

<p>So, here’s our <code>SelectMany</code> query and the result:</p>

<pre data-type="programlisting">
<strong>IEnumerable&lt;string&gt; query = fullNames.SelectMany (name =&gt; name.Split());</strong>

foreach (string name in query)
  Console.Write (name + "|");  // Anne|Williams|John|Fred|Smith|Sue|Green|</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you replace <code>SelectMany</code> with <code>Select</code>, you get the same results in hierarchical form. The following emits a sequence <span class="keep-together">of string</span> <em>arrays</em>, requiring nested <code>foreach</code> statements to <span class="keep-together">enumerate</span>:</p>

<pre data-type="programlisting">
IEnumerable&lt;string[]&gt; query =
  fullNames.Select (name =&gt; name.Split());

foreach (string[] stringArray in query)
  foreach (string name in stringArray)
    Console.Write (name + "|");</pre>

<p>The benefit of <code>SelectMany</code> is that it yields a single <em>flat</em> result sequence.</p>
</div>

<p><code>SelectMany</code> is supported in query syntax and is invoked by having an <em>additional generator</em>—in other words, an extra <code>from</code> clause in the query. The <code>from</code> keyword has two meanings in query syntax. At the start of a query, it introduces the original range variable and input sequence. <em>Anywhere else</em> in the query, it translates to <code>SelectMany</code>. Here’s our query in query syntax:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from fullName in fullNames
  <strong>from name in fullName.Split()     // Translates to SelectMany</strong>
  select name;</pre>

<p>Note that the additional generator introduces a new range variable—in this case, <code>name</code>. The old range variable stays in scope, however, and we can subsequently access both.</p>
</div></section>

<section data-pdf-bookmark="Multiple range variables" data-type="sect3"><div class="sect3" id="multiple_range_variables">
<h3>Multiple range variables</h3>

<p><a contenteditable="false" data-primary="SelectMany" data-secondary="multiple range variables" data-type="indexterm" id="id3263"/>In the preceding example, both <code>name</code> and <code>fullName</code> remain in scope until the query either ends or reaches an <code>into</code> clause. The extended scope of these variables is <em>the</em> killer scenario for query syntax over fluent syntax.</p>

<p>To illustrate, we can take the preceding query and include <code>fullName</code> in the final <span class="keep-together">projection</span>:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from fullName in fullNames
  from name in fullName.Split()
  <strong>select name + " came from " + fullName;</strong>

<em>Anne came from Anne Williams</em>
<em>Williams came from Anne Williams</em>
<em>John came from John Fred Smith</em>
...</pre>

<p>Behind the scenes, the compiler must pull some tricks to let you access both variables. A good way to appreciate this is to try writing the same query in fluent syntax. It’s tricky! It becomes yet more difficult if you insert a <code>where</code> or <code>orderby</code> clause before projecting:</p>

<pre data-type="programlisting">
from fullName in fullNames
from name in fullName.Split()
<strong>orderby fullName, name</strong>
select name + " came from " + fullName;</pre>

<p>The problem is that <code>SelectMany</code> emits a flat sequence of child elements—in our case, a flat collection of words. The original “outer” element from which it came (<code>fullName</code>) is lost. The solution is to “carry” the outer element with each child, in a temporary anonymous type:</p>

<pre data-type="programlisting">
from fullName in fullNames
from x in fullName.Split()<strong>.Select (name =&gt; new { name, fullName } )</strong>
orderby x.fullName, x.name
select x.name + " came from " + x.fullName;</pre>

<p>The only change here is that we’re wrapping each child element (<code>name</code>) in an anonymous type that also contains its <code>fullName</code>. This is similar to how a <code>let</code> clause is resolved. Here’s the final conversion to fluent syntax:</p>

<pre class="pagebreak-before" data-type="programlisting">
IEnumerable&lt;string&gt; query = fullNames
  .SelectMany (fName =&gt; fName.Split()
                             <strong>.Select (name =&gt; new { name, fName } ))</strong>
  .OrderBy (x =&gt; x.fName)
  .ThenBy  (x =&gt; x.name)
  .Select  (x =&gt; x.name + " came from " + x.fName);</pre>
</div></section>

<section data-pdf-bookmark="Thinking in query syntax" data-type="sect3"><div class="sect3" id="thinking_in_query_syntax">
<h3>Thinking in query syntax</h3>

<p><a contenteditable="false" data-primary="SelectMany" data-secondary="thinking in query syntax" data-type="indexterm" id="id3264"/>As we just demonstrated, there are good reasons to use query syntax if you need multiple range variables. In such cases, it helps to not only use query syntax but also to think directly in its terms.</p>

<p>There are two basic patterns when writing additional generators. The first is <em>expanding and flattening subsequences</em>. To do this, you call a property or method on an existing range variable in your additional generator. We did this in the previous example:</p>

<pre data-type="programlisting">
from fullName in fullNames
from name in <strong>fullName</strong>.Split()</pre>

<p>Here, we’ve expanded from enumerating full names to enumerating words. An analogous EF Core query is when you expand collection navigation properties. The following query lists all customers along with their purchases:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = from c in dbContext.Customers
                            from p in <strong>c.Purchases</strong>
                            select c.Name + " bought a " + p.Description;


<em>Tom bought a Bike</em>
<em>Tom bought a Holiday</em>
<em>Dick bought a Phone</em>
<em>Harry bought a Car</em>
<em>...</em></pre>

<p>Here, we’ve expanded each customer into a subsequence of purchases.</p>

<p><a contenteditable="false" data-primary="cartesian product" data-type="indexterm" id="id3265"/><a contenteditable="false" data-primary="cross join" data-type="indexterm" id="id3266"/>The second pattern is performing a <em>cartesian product</em>, or <em>cross join</em>, in which every element of one sequence is matched with every element of another. To do this, introduce a generator whose <code>selector</code> expression returns a sequence unrelated to a range variable:</p>

<pre data-type="programlisting">
int[] numbers = { 1, 2, 3 };  string[] letters = { "a", "b" };

IEnumerable&lt;string&gt; query = from n in numbers
                            <strong>from l in letters</strong>
                            select n.ToString() + l;

// RESULT: { "1a", "1b", "2a", "2b", "3a", "3b" }</pre>

<p>This style of query is the basis of <code>SelectMany</code>-style <em>joins</em>.</p>
</div></section>

<section data-pdf-bookmark="Joining with SelectMany" data-type="sect3"><div class="sect3" id="joining_with_selectmany">
<h3>Joining with SelectMany</h3>

<p><a contenteditable="false" data-primary="joining" data-secondary="SelectMany" data-type="indexterm" id="id3267"/><a contenteditable="false" data-primary="SelectMany" data-secondary="joining with" data-type="indexterm" id="id3268"/>You can use <code>SelectMany</code> to join two sequences simply by filtering the results of a cross product. For instance, suppose that we want to match players for a game. We could start as follows:</p>

<pre data-type="programlisting">
string[] players = { "Tom", "Jay", "Mary" };

IEnumerable&lt;string&gt; query = from name1 in players
                            <strong>from name2 in players</strong>
                            select name1 + " vs " + name2;

//RESULT: { "Tom vs Tom", "Tom vs Jay", "Tom vs Mary",
//          "Jay vs Tom", "Jay vs Jay", "Jay vs Mary",
//          "Mary vs Tom", "Mary vs "Jay", "Mary vs Mary" }</pre>

<p>The query reads “For every player, reiterate every player, selecting player 1 versus player 2.” Although we got what we asked for (a cross join), the results are not useful until we add a filter:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = from name1 in players
                            from name2 in players
                            <strong>where name1.CompareTo (name2) &lt; 0</strong>
                            orderby name1, name2
                            select name1 + " vs " + name2;

//RESULT: { "Jay vs Mary", "Jay vs Tom", "Mary vs Tom" }</pre>

<p>The filter predicate constitutes the <em>join condition</em>. Our query can be called a <em>non-equi join</em> because the join condition doesn’t use an equality operator.</p>
</div></section>

<section data-pdf-bookmark="SelectMany in EF Core" data-type="sect3"><div class="sect3" id="selectmany_in_ef_core">
<h3>SelectMany in EF Core</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="SelectMany in" data-type="indexterm" id="id3269"/><a contenteditable="false" data-primary="SelectMany" data-secondary="in EF Core" data-type="indexterm" id="id3270"/><code>SelectMany</code> in EF Core can perform cross joins, non-equi joins, inner joins, and left outer joins. You can use <code>SelectMany</code> with both predefined associations and ad hoc relationships—just as with <code>Select</code>. The difference is that <code>SelectMany</code> returns a flat rather than a hierarchical result set.</p>

<p>An EF Core cross join is written just as in the preceding section. The following query matches every customer to every purchase (a cross join):</p>

<pre data-type="programlisting">
var query = from c in dbContext.Customers
            <strong>from p in dbContext.Purchases</strong>
            select c.Name + " might have bought a " + p.Description;</pre>

<p>More typically, though, you’d want to match customers to only their own purchases. You achieve this by adding a <code>where</code> clause with a joining predicate. This results in a standard SQL-style equi-join:</p>

<pre data-type="programlisting">
var query = from c in dbContext.Customers
            from p in dbContext.Purchases
            <strong>where c.ID == p.CustomerID</strong>
            select c.Name + " bought a " + p.Description;</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This translates well to SQL. In the next section, we see how it extends to support outer joins. Reformulating such queries with LINQ’s <code>Join</code> operator actually makes them <em>less</em> extensible—LINQ is opposite to SQL in this sense.</p>
</div>

<p>If you have collection navigation properties in your entities, you can express the same query by expanding the subcollection instead of filtering the cross product:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>from p in c.Purchases</strong>
select new { c.Name, p.Description };</pre>

<p>The advantage is that we’ve eliminated the joining predicate. We’ve gone from filtering a cross product to expanding and flattening.</p>

<p>You can add <code>where</code> clauses to such a query for additional filtering. For instance, if we want only customers whose names started with “T”, we could filter as follows:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>where c.Name.StartsWith ("T")</strong>
from p in c.Purchases
select new { c.Name, p.Description };</pre>

<p>This EF Core query would work equally well if the <code>where</code> clause were moved one line down because the same SQL is generated in both cases. If it is a local query, however, moving the <code>where</code> clause down would make it less efficient. With local queries, you should filter <em>before</em> joining.</p>

<p>You can introduce new tables into the mix with additional <code>from</code> clauses. For instance, if each purchase had purchase item child rows, you could produce a flat result set of customers with their purchases, each with their purchase detail lines as follows:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
from p in c.Purchases
<strong>from pi in p.PurchaseItems</strong>
select new { c.Name, p.Description, pi.Detail };</pre>

<p>Each <code>from</code> clause introduces a new <em>child</em> table. To include data from a <em>parent</em> table (via a navigation property), you don’t add a <code>from</code> clause—you simply navigate to the property. For example, if each customer has a salesperson whose name you want to query, just do this:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
select new { Name = c.Name, SalesPerson = <strong>c.SalesPerson.Name</strong> };</pre>

<p>You don’t use <code>SelectMany</code> in this case because there’s no subcollection to flatten. Parent navigation properties return a single item.</p>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Outer joins with SelectMany" data-type="sect3"><div class="sect3" id="outer_joins_with_selectmany">
<h3 class="less_space">Outer joins with SelectMany</h3>

<p><a contenteditable="false" data-primary="outer joins" data-secondary="SelectMany" data-type="indexterm" id="id3271"/><a contenteditable="false" data-primary="SelectMany" data-secondary="outer joins with" data-type="indexterm" id="id3272"/>We saw previously that a <code>Select</code> subquery yields a result analogous to a left outer join:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
select new {
             c.Name,
             Purchases = from p in c.Purchases
                         where p.Price &gt; 1000
                         select new { p.Description, p.Price }
           };</pre>

<p>In this example, every outer element (customer) is included, regardless of whether the customer has any purchases. But suppose that we rewrite this query with <code>SelectMany</code> so that we can obtain a single flat collection rather than a hierarchical result set:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>from p in c.Purchases</strong>
where p.Price &gt; 1000
select new { c.Name, p.Description, p.Price };</pre>

<p>In the process of flattening the query, we’ve switched to an inner join: customers are now included only for whom one or more high-value purchases exist. To get a left outer join with a flat result set, we must apply the <code>DefaultIfEmpty</code> query operator on the inner sequence. This method returns a sequence with a single null element if its input sequence has no elements. Here’s such a query, price predicate aside:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>from p in c.Purchases.DefaultIfEmpty()</strong>
select new { c.Name, p.Description, Price = (decimal?) p.Price };</pre>

<p>This works perfectly with EF Core, returning all customers—even if they have no purchases. But if we were to run this as a local query, it would crash because when <code>p</code> is null, <code>p.Description</code> and <code>p.Price</code> throw a <code>NullReferenceException</code>. We can make our query robust in either scenario, as follows:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
from p in c.Purchases.DefaultIfEmpty()
select new {
             c.Name,
             <strong>Descript = p == null ? null : p.Description,</strong>
             <strong>Price = p == null ? (decimal?) null : p.Price</strong>
           };</pre>

<p>Let’s now reintroduce the price filter. We cannot use a <code>where</code> clause as we did before, because it would execute <em>after</em> <code>DefaultIfEmpty</code>:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
from p in c.Purchases.DefaultIfEmpty()
<strong>where p.Price &gt; 1000...</strong></pre>

<p class="pagebreak-before">The correct solution is to splice the <code>Where</code> clause <em>before</em> <code>DefaultIfEmpty</code> with a <span class="keep-together">subquery</span>:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>from p in c.Purchases.Where (p =&gt; p.Price &gt; 1000).DefaultIfEmpty()</strong>
select new {
             c.Name,
             <strong>Descript = p == null ? null : p.Description,</strong>
             <strong>Price = p == null ? (decimal?) null : p.Price</strong>
           };</pre>

<p>EF Core translates this to a left outer join. This is an effective pattern for writing such queries.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re used to writing outer joins in SQL, you might be tempted to overlook the simpler option of a <code>Select</code> subquery for this style of query in favor of the awkward but familiar SQL-centric flat approach. The hierarchical result set from a <code>Select</code> subquery is often better suited to outer join–style queries because there are no additional nulls to deal with<a contenteditable="false" data-primary="" data-startref="ch09.html12" data-type="indexterm" id="id3273"/><a contenteditable="false" data-primary="" data-startref="ch09.html11" data-type="indexterm" id="id3274"/>.<a contenteditable="false" data-primary="" data-startref="ch09.html8" data-type="indexterm" id="id3275"/><a contenteditable="false" data-primary="" data-startref="ch09.html7" data-type="indexterm" id="id3276"/></p>
</div>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Joining" data-type="sect1"><div class="sect1" id="joining-id00041">
<h1>Joining</h1>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Join</code></td>
			<td>Applies a lookup strategy to match elements from two collections, emitting a flat result set</td>
			<td><code>INNER JOIN</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>GroupJoin</code></span></td>
			<td>Similar to <code>Join</code>, but emits a <em>hierarchical</em> result set</td>
			<td><code>INNER JOIN</code>,<br/>
			<code>LEFT OUTER JOIN</code></td>
		</tr>
		<tr>
			<td><code>Zip</code></td>
			<td>Enumerates two sequences in step (like a zipper), applying a function over each element pair</td>
			<td>Exception thrown</td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="Join and GroupJoin" data-type="sect2"><div class="sect2" id="join_and_groupjoin">
<h2>Join and GroupJoin</h2>

<p><a contenteditable="false" data-primary="Join operator (LINQ)" data-type="indexterm" id="ch09.html13"/><a contenteditable="false" data-primary="joining" data-type="indexterm" id="ch09.html14"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="joining" data-type="indexterm" id="ch09.html15"/><code>IEnumerable&lt;TOuter&gt;</code>, <code>IEnumerable&lt;TInner&gt;</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<section data-pdf-bookmark="Join arguments" data-type="sect3"><div class="sect3" id="join_arguments">
<h3>Join arguments</h3>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Outer sequence</td>
			<td><code>IEnumerable&lt;TOuter&gt;</code></td>
		</tr>
		<tr>
			<td>Inner sequence</td>
			<td><code>IEnumerable&lt;TInner&gt;</code></td>
		</tr>
		<tr>
			<td>Outer key selector</td>
			<td><code>TOuter =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Inner key selector</td>
			<td><code>TInner =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Result selector</td>
			<td><code>(TOuter,TInner) =&gt; TResult</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-pdf-bookmark="GroupJoin arguments" data-type="sect3"><div class="sect3" id="groupjoin_arguments">
<h3>GroupJoin arguments</h3>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Outer sequence</td>
			<td><code>IEnumerable&lt;TOuter&gt;</code></td>
		</tr>
		<tr>
			<td>Inner sequence</td>
			<td><code>IEnumerable&lt;TInner&gt;</code></td>
		</tr>
		<tr>
			<td>Outer key selector</td>
			<td><code>TOuter =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Inner key selector</td>
			<td><code>TInner =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Result selector</td>
			<td><code>(TOuter</code>,<code><strong>IEnumerable&lt;TInner&gt;</strong>) =&gt; TResult</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00096">
<h3>Query syntax</h3>

<pre data-type="programlisting">
from <em>outer-var</em> in <em>outer-enumerable</em>
join <em>inner-var</em> in <em>inner-enumerable</em> on <em>outer-key-expr</em> equals <em>inner-key-expr</em>
 [ into <em>identifier</em> ]</pre>
</div></section>

<section data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00064">
<h3>Overview</h3>

<p><a contenteditable="false" data-primary="Join operator (LINQ)" data-secondary="basics" data-type="indexterm" id="id3277"/><code>Join</code> and <code>GroupJoin</code> mesh two input sequences into a single output sequence. <code>Join</code> emits flat output; <code>GroupJoin</code> emits hierarchical output.</p>

<p><code>Join</code> and <code>GroupJoin</code> provide an alternative strategy to <code>Select</code> and <code>SelectMany</code>. The advantage of <code>Join</code> and <code>GroupJoin</code> is that they execute efficiently over local in-memory collections because they first load the inner sequence into a keyed lookup, avoiding the need to repeatedly enumerate over every inner element. The disadvantage is that they offer the equivalent of inner and left outer joins only; cross joins and non-equi joins must still be done using <code>Select</code>/<code>SelectMany</code>. With EF Core queries, <code>Join</code> and <code>GroupJoin</code> offer no real benefits over <code>Select</code> and <code>SelectMany</code>.</p>

<p><a data-type="xref" href="#joining_strategies">Table 9-1</a> summarizes the differences between each of the joining strategies.</p>

<table class="border" id="joining_strategies">
	<caption><span class="label">Table 9-1. </span>Joining strategies</caption>
	<thead>
		<tr>
			<th>Strategy</th>
			<th>Result shape</th>
			<th>Local query efficiency</th>
			<th>Inner joins</th>
			<th>Left outer joins</th>
			<th>Cross joins</th>
			<th>Non-equi joins</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><span class="keep-together"><code>Select</code> + <code>SelectMany</code></span></td>
			<td>Flat</td>
			<td>Bad</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><code>Select</code> + <code>Select</code></td>
			<td>Nested</td>
			<td>Bad</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><code>Join</code></td>
			<td>Flat</td>
			<td>Good</td>
			<td>Yes</td>
			<td>—</td>
			<td>—</td>
			<td>—</td>
		</tr>
		<tr>
			<td><code>GroupJoin</code></td>
			<td>Nested</td>
			<td>Good</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>—</td>
			<td>—</td>
		</tr>
		<tr>
			<td><code>GroupJoin</code> + <code>SelectMany</code></td>
			<td>Flat</td>
			<td>Good</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>—</td>
			<td>—</td>
		</tr>
	</tbody>
</table>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Join" data-type="sect3"><div class="sect3" id="join">
<h3 class="less_space">Join</h3>

<p>The <code>Join</code> operator performs an inner join, emitting a flat output sequence.</p>

<p>The following query lists all customers alongside their purchases without using a navigation property:</p>

<pre data-type="programlisting">
IQueryable&lt;string&gt; query =
  from c in dbContext.Customers
  <strong>join p in dbContext.Purchases on c.ID equals p.CustomerID</strong>
  select c.Name + " bought a " + p.Description;</pre>

<p>The results match what we would get from a <code>SelectMany</code>-style query:</p>

<pre data-type="programlisting">
<em>Tom bought a Bike</em>
<em>Tom bought a Holiday</em>
<em>Dick bought a Phone</em>
<em>Harry bought a Car</em></pre>

<p>To see the benefit of <code>Join</code> over <code>SelectMany</code>, we must convert this to a local query. We can demonstrate this by first copying all customers and purchases to arrays and then querying the arrays:</p>

<pre data-type="programlisting">
Customer[] customers = dbContext.Customers.ToArray();
Purchase[] purchases = dbContext.Purchases.ToArray();
var slowQuery = from c in customers
                <strong>from p in purchases where c.ID == p.CustomerID</strong>
                select c.Name + " bought a " + p.Description;

var fastQuery = from c in customers
                <strong>join p in purchases on c.ID equals p.CustomerID</strong>
                select c.Name + " bought a " + p.Description;</pre>

<p>Although both queries yield the same results, the <code>Join</code> query is considerably <span class="keep-together">faster because</span> its implementation in <code>Enumerable</code> preloads the inner collection (<span class="keep-together"><code>purchases</code></span>) into a keyed lookup.</p>

<p>The query syntax for <code>join</code> can be written in general terms, as follows:</p>

<pre data-type="programlisting">
join <em>inner-var</em> in <em>inner-sequence</em> on <em>outer-key-expr</em> equals <em>inner-key-expr</em></pre>

<p>Join operators in LINQ differentiate between the <em>outer sequence</em> and <em>inner sequence</em>. Syntactically:</p>

<ul>
	<li>
	<p>The <em>outer sequence</em> is the input sequence (<code>customers</code>, in this case).</p>
	</li>
	<li>
	<p>The <em>inner sequence</em> is the new collection you introduce (<code>purchases</code>, in this case).</p>
	</li>
</ul>

<p><code>Join</code> performs inner joins, meaning customers without purchases are excluded from the output. With inner joins, you can swap the inner and outer sequences in the query and still get the same results:</p>

<pre data-type="programlisting">
from p in purchases                                // p is now outer
<strong>join c in customers on p.CustomerID equals c.ID    // c is now inner</strong>
<strong>...</strong></pre>

<p>You can add further <code>join</code> clauses to the same query. If each purchase, for instance, has one or more purchase items, you could join the purchase items, as follows:</p>

<pre data-type="programlisting">
from c in customers
join p in purchases on c.ID equals p.CustomerID           // first join
<strong>join pi in purchaseItems on p.ID equals pi.PurchaseID     // second join</strong>
<strong>...</strong></pre>

<p><code>purchases</code> acts as the <em>inner</em> sequence in the first join and as the <em>outer</em> sequence in the second join. You could obtain the same results (inefficiently) using nested <span class="keep-together"><code>foreach</code></span> statements, as follows:</p>

<pre data-type="programlisting">
foreach (Customer c in customers)
  foreach (Purchase p in purchases)
    if (c.ID == p.CustomerID)
      foreach (PurchaseItem pi in purchaseItems)
        if (p.ID == pi.PurchaseID)
          Console.WriteLine (c.Name + "," + p.Price + "," + pi.Detail);</pre>

<p>In query syntax, variables from earlier joins remain in scope—just as they do with <code>SelectMany</code>-style queries. You’re also permitted to insert <code>where</code> and <code>let</code> clauses in between <code>join</code> clauses.</p>
</div></section>

<section data-pdf-bookmark="Joining on multiple keys" data-type="sect3"><div class="sect3" id="joining_on_multiple_keys">
<h3>Joining on multiple keys</h3>

<p><a contenteditable="false" data-primary="Join operator (LINQ)" data-secondary="joining on multiple keys" data-type="indexterm" id="id3278"/>You can join on multiple keys with anonymous types, as follows:</p>

<pre data-type="programlisting">
from x in sequenceX
join y in sequenceY on new { K1 = x.Prop1, K2 = x.Prop2 }
                equals new { K1 = y.Prop3, K2 = y.Prop4 }
...</pre>

<p>For this to work, the two anonymous types must be structured identically. The compiler then implements each with the same internal type, making the joining keys compatible.</p>
</div></section>

<section data-pdf-bookmark="Joining in fluent syntax" data-type="sect3"><div class="sect3" id="joining_in_fluent_syntax">
<h3>Joining in fluent syntax</h3>

<p><a contenteditable="false" data-primary="fluent syntax" data-secondary="joining in" data-type="indexterm" id="id3279"/><a contenteditable="false" data-primary="Join operator (LINQ)" data-secondary="joining in fluent syntax" data-type="indexterm" id="id3280"/>The following query syntax join</p>

<pre data-type="programlisting">
 from c in <strong>customers</strong>
 join p in <strong>purchases</strong> on <strong>c.ID</strong> equals <strong>p.CustomerID</strong>
 select new { c.Name, p.Description, p.Price };</pre>

<p>in fluent syntax is as follows:</p>

<pre data-type="programlisting">
 <strong>customers</strong>.Join (                // outer collection
       <strong>purchases</strong>,                // inner collection
       c =&gt; <strong>c.ID</strong>,                // outer key selector
       p =&gt; <strong>p.CustomerID</strong>,        // inner key selector
       (c, p) =&gt; new
          { c.Name, p.Description, p.Price }    // result selector
 );</pre>

<p>The result selector expression at the end creates each element in the output sequence. If you have additional clauses prior to projecting, such as <code>orderby</code> in this example:</p>

<pre data-type="programlisting">
from c in customers
join p in purchases on c.ID equals p.CustomerID
<strong>orderby p.Price</strong>
select c.Name + " bought a " + p.Description;</pre>

<p>you must manufacture a temporary anonymous type in the result selector in fluent syntax. This keeps both <code>c</code> and <code>p</code> in scope following the join:</p>

<pre data-type="programlisting">
customers.Join (                  // outer collection
      purchases,                  // inner collection
      c =&gt; c.ID,                  // outer key selector
      p =&gt; p.CustomerID,          // inner key selector
      <strong>(c, p) =&gt; new { c, p } )    // result selector</strong>
  .OrderBy (x =&gt; x.p.Price)
  .Select  (x =&gt; x.c.Name + " bought a " + x.p.Description);</pre>

<p>Query syntax is usually preferable when joining; it’s less fiddly.</p>
</div></section>

<section data-pdf-bookmark="GroupJoin" data-type="sect3"><div class="sect3" id="groupjoin">
<h3>GroupJoin</h3>

<p><a contenteditable="false" data-primary="GroupJoin operator (LINQ)" data-type="indexterm" id="ch09.html16"/><code>GroupJoin</code> does the same work as <code>Join</code>, but instead of yielding a flat result, it yields a hierarchical result, grouped by each outer element. It also allows left outer joins. <code>GroupJoin</code> is not currently supported in EF Core.</p>

<p>The query syntax for <code>GroupJoin</code> is the same as for <code>Join</code>, but is followed by the <code>into</code> keyword.</p>

<p>Here’s the most basic example, using a local query:</p>

<pre data-type="programlisting">
Customer[] customers = dbContext.Customers.ToArray();
Purchase[] purchases = dbContext.Purchases.ToArray();

IEnumerable&lt;IEnumerable&lt;Purchase&gt;&gt; query =
  from c in customers
  join p in purchases on c.ID equals p.CustomerID
  <strong>into custPurchases</strong>
  select custPurchases;   // custPurchases is a sequence</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An <code>into</code> clause translates to <code>GroupJoin</code> only when it appears directly after a <code>join</code> clause. After a <code>select</code> or <code>group</code> clause, it means <em>query continuation</em>. The two uses of the <code>into</code> keyword are quite different, although they have one feature in common: they both introduce a new range variable.</p>
</div>

<p>The result is a sequence of sequences, which we could enumerate as follows:</p>

<pre data-type="programlisting">
foreach (IEnumerable&lt;Purchase&gt; purchaseSequence in query)
  foreach (Purchase p in purchaseSequence)
    Console.WriteLine (p.Description);</pre>

<p>This isn’t very useful, however, because <code>purchaseSequence</code> has no reference to the customer. More commonly, you’d do this:</p>

<pre data-type="programlisting">
from c in customers
join p in purchases on c.ID equals p.CustomerID
<strong>into custPurchases</strong>
<strong>select new { CustName = c.Name, custPurchases };</strong></pre>

<p>This gives the same results as the following (inefficient) <code>Select</code> subquery:</p>

<pre data-type="programlisting">
from c in customers
select new
{
  CustName = c.Name,
  custPurchases = purchases.Where (p =&gt; c.ID == p.CustomerID)
};</pre>

<p>By default, <code>GroupJoin</code> does the equivalent of a left outer join. To get an inner join—whereby customers without purchases are excluded—you need to filter on <code>custPurchases</code>:</p>

<pre data-type="programlisting">
from c in customers join p in purchases on c.ID equals p.CustomerID
into custPurchases
<strong>where custPurchases.Any()</strong>
select ...</pre>

<p>Clauses after a group-join <code>into</code> operate on <em>subsequences</em> of inner child elements, not <em>individual</em> child elements. This means that to filter individual purchases, you’d need to call <code>Where</code> <em>before</em> joining:</p>

<pre data-type="programlisting">
from c in customers
join p in purchases<strong>.Where (p2 =&gt; p2.Price &gt; 1000)</strong>
  on c.ID equals p.CustomerID
into custPurchases ...</pre>

<p>You can construct lambda queries with <code>GroupJoin</code> as you would with <code>Join</code>.</p>
</div></section>

<section data-pdf-bookmark="Flat outer joins" data-type="sect3"><div class="sect3" id="flat_outer_joins">
<h3>Flat outer joins</h3>

<p><a contenteditable="false" data-primary="GroupJoin operator (LINQ)" data-secondary="flat outer joins" data-type="indexterm" id="id3281"/><a contenteditable="false" data-primary="outer joins" data-secondary="GroupJoin" data-type="indexterm" id="id3282"/>You run into a dilemma if you want both an outer join and a flat result set. <code>GroupJoin</code> gives you the outer join; <code>Join</code> gives you the flat result set. The solution is to first call <code>GroupJoin</code>, then <code>DefaultIfEmpty</code> on each child sequence, and then finally <code>SelectMany</code> on the result:</p>

<pre data-type="programlisting">
from c in customers
join p in purchases on c.ID equals p.CustomerID into custPurchases
<strong>from cp in custPurchases.DefaultIfEmpty()</strong>
select new
{
  CustName = c.Name,
  Price = cp == null ? (decimal?) null : cp.Price
};</pre>

<p><code>DefaultIfEmpty</code> emits a sequence with a single null value if a subsequence of purchases is empty. The second <code>from</code> clause translates to <code>SelectMany</code>. In this role, it <em>expands and flattens</em> all the purchase subsequences, concatenating them into a single sequence of purchase <em>elements</em>.</p>
</div></section>

<section data-pdf-bookmark="Joining with lookups" data-type="sect3"><div class="sect3" id="joining_with_lookups">
<h3>Joining with lookups</h3>

<p><a contenteditable="false" data-primary="GroupJoin operator (LINQ)" data-secondary="joining with lookups" data-type="indexterm" id="id3283"/>The <code>Join</code> and <code>GroupJoin</code> methods in <code>Enumerable</code> work in two steps. First, they load the inner sequence into a <em>lookup</em>. Second, they query the outer sequence in combination with the lookup.</p>

<p>A <em>lookup</em> is a sequence of groupings that can be accessed directly by key. Another way to think of it is as a dictionary of sequences—a dictionary that can accept many elements under each key (sometimes called a <em>multidictionary</em>). Lookups are read-only and defined by the following interface:</p>

<pre data-type="programlisting">
public interface ILookup&lt;TKey,TElement&gt; :
   IEnumerable&lt;IGrouping&lt;TKey,TElement&gt;&gt;, IEnumerable
{
  int Count { get; }
  bool Contains (TKey key);
  IEnumerable&lt;TElement&gt; this [TKey key] { get; }
}</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The joining operators—like other sequence-emitting operators—honor deferred or lazy execution semantics. This means the lookup is not built until you begin enumerating the output sequence (and then the <em>entire</em> lookup is built right then).</p>
</div>

<p>You can create and query lookups manually as an alternative strategy to using the joining operators when dealing with local collections. There are a couple of benefits to doing so:</p>

<ul>
	<li>
	<p>You can reuse the same lookup over multiple queries—as well as in ordinary imperative code.</p>
	</li>
	<li>
	<p>Querying a lookup is an excellent way of understanding how <code>Join</code> and <code>GroupJoin</code> work.</p>
	</li>
</ul>

<p>The <code>ToLookup</code> extension method creates a lookup. The following loads all purchases into a lookup—keyed by their <code>CustomerID</code>:</p>

<pre data-type="programlisting">
ILookup&lt;int?,Purchase&gt; purchLookup =
  purchases.ToLookup (p =&gt; p.CustomerID, p =&gt; p);</pre>

<p>The first argument selects the key; the second argument selects the objects that are to be loaded as values into the lookup.</p>

<p>Reading a lookup is rather like reading a dictionary except that the indexer returns a <em>sequence</em> of matching items rather than a <em>single</em> matching item. The following enumerates all purchases made by the customer whose ID is 1:</p>

<pre data-type="programlisting">
foreach (Purchase p in purchLookup [1])
  Console.WriteLine (p.Description);</pre>

<p>With a lookup in place, you can write <code>SelectMany</code>/<code>Select</code> queries that execute as efficiently as <code>Join</code>/<code>GroupJoin</code> queries. <code>Join</code> is equivalent to using <code>SelectMany</code> on a lookup:</p> 

<pre data-type="programlisting">
from c in customers
from p in purchLookup [c.ID]
select new { c.Name, p.Description, p.Price };

Tom Bike 500
Tom Holiday 2000
Dick Bike 600
Dick Phone 300
...</pre>

<p>Adding a call to <code>DefaultIfEmpty</code> makes this into an outer join:</p>

<pre data-type="programlisting">
from c in customers
from p in purchLookup [c.ID]<strong>.DefaultIfEmpty()</strong>
 select new {
              c.Name,
<strong>              Descript = p == null ? null : p.Description,</strong>
<strong>              Price = p == null ? (decimal?) null : p.Price</strong>
            };</pre>

<p><code>GroupJoin</code> is equivalent to reading the lookup inside a projection:</p>

<pre data-type="programlisting">
from c in customers
select new {
             CustName = c.Name,
             CustPurchases = purchLookup [c.ID]
           };</pre>
</div></section>

<section data-pdf-bookmark="Enumerable implementations" data-type="sect3"><div class="sect3" id="enumerable_implementatio">
<h3>Enumerable implementations</h3>

<p><a contenteditable="false" data-primary="Enumerable..." data-secondary="Enumerable.Join" data-type="indexterm" id="id3284"/><a contenteditable="false" data-primary="GroupJoin operator (LINQ)" data-secondary="enumerable implementations" data-type="indexterm" id="id3285"/>Here’s the simplest valid implementation of <code>Enumerable.Join</code>, null checking aside:</p>

<pre data-type="programlisting">
public static IEnumerable &lt;TResult&gt; Join
                                    &lt;TOuter,TInner,TKey,TResult&gt; (
  this IEnumerable &lt;TOuter&gt;     outer,
  IEnumerable &lt;TInner&gt;          inner,
  Func &lt;TOuter,TKey&gt;            outerKeySelector,
  Func &lt;TInner,TKey&gt;            innerKeySelector,
  Func &lt;TOuter,TInner,TResult&gt;  resultSelector)
{
  ILookup &lt;TKey, TInner&gt; lookup = inner.ToLookup (innerKeySelector);
  return
    from outerItem in outer
    from innerItem in lookup [outerKeySelector (outerItem)]
    select resultSelector (outerItem, innerItem);
}</pre>

<p class="pagebreak-before"><code>GroupJoin</code>’s implementation is like that of <code>Join</code> but simpler:<a contenteditable="false" data-primary="" data-startref="ch09.html16" data-type="indexterm" id="id3286"/></p>

<pre data-type="programlisting">
public static IEnumerable &lt;TResult&gt; GroupJoin
                                    &lt;TOuter,TInner,TKey,TResult&gt; (
  this IEnumerable &lt;TOuter&gt;     outer,
  IEnumerable &lt;TInner&gt;          inner,
  Func &lt;TOuter,TKey&gt;            outerKeySelector,
  Func &lt;TInner,TKey&gt;            innerKeySelector,
  Func &lt;TOuter,IEnumerable&lt;TInner&gt;,TResult&gt;  resultSelector)
{
  ILookup &lt;TKey, TInner&gt; lookup = inner.ToLookup (innerKeySelector);
  return
    from outerItem in outer
    select resultSelector
     (outerItem, lookup [outerKeySelector (outerItem)]);
}</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="The Zip Operator" data-type="sect2"><div class="sect2" id="the_zip_operator">
<h2>The Zip Operator</h2>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="Zip operator" data-type="indexterm" id="id3287"/><a contenteditable="false" data-primary="Zip operator" data-type="indexterm" id="id3288"/><code>IEnumerable&lt;TFirst&gt;</code>, <code>IEnumerable&lt;TSecond&gt;</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<p>The <code>Zip</code> operator enumerates two sequences in step (like a zipper), returning a sequence based on applying a function over each element pair. For instance, the <span class="keep-together">following</span>:</p>

<pre data-type="programlisting">
int[] numbers = { 3, 5, 7 };
string[] words = { "three", "five", "seven", "ignored" };
IEnumerable&lt;string&gt; zip = numbers.<strong>Zip (words, (n, w) =&gt; n + "=" + w)</strong>;</pre>

<p>produces a sequence with the following elements:</p>

<pre data-type="programlisting">
<em>3=three</em>
<em>5=five</em>
<em>7=seven</em></pre>

<p>Extra elements in either input sequence are ignored. <code>Zip</code> is not supported by EF Core.<a contenteditable="false" data-primary="" data-startref="ch09.html15" data-type="indexterm" id="id3289"/><a contenteditable="false" data-primary="" data-startref="ch09.html14" data-type="indexterm" id="id3290"/><a contenteditable="false" data-primary="" data-startref="ch09.html13" data-type="indexterm" id="id3291"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Ordering" data-type="sect1"><div class="sect1" id="ordering-id00052">
<h1>Ordering</h1>

<p><code>IEnumerable&lt;TSource&gt;</code>→<code>IOrderedEnumerable&lt;TSource&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>OrderBy, ThenBy</code></td>
			<td>Sorts a sequence in ascending order</td>
			<td><code>ORDER BY</code> ...</td>
		</tr>
		<tr>
			<td><code>OrderByDescending, <span class="keep-together">ThenByDescending</span></code></td>
			<td>Sorts a sequence in descending order</td>
			<td><code>ORDER BY</code> ... <code>DESC</code></td>
		</tr>
		<tr>
			<td><code>Reverse</code></td>
			<td>Returns a sequence in reverse order</td>
			<td>Exception thrown</td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="ordering" data-type="indexterm" id="ch09.html17"/><a contenteditable="false" data-primary="ordering" data-secondary="LINQ operators and" data-type="indexterm" id="ch09.html18"/>Ordering operators return the same elements in a different order.</p>

<section data-pdf-bookmark="OrderBy, OrderByDescending, ThenBy, ThenByDescending" data-type="sect2"><div class="sect2" id="orderbycomma_orderbydescendingcomma_the">
<h2>OrderBy, OrderByDescending, ThenBy, ThenByDescending</h2>

<section data-pdf-bookmark="OrderBy and OrderByDescending arguments" data-type="sect3"><div class="sect3" id="orderby_and_orderbydescending_arguments">
<h3>OrderBy and OrderByDescending arguments</h3>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Input sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Key selector</td>
			<td><code>TSource =&gt; TKey</code></td>
		</tr>
	</tbody>
</table>

<p>Return type = <code>IOrderedEnumerable&lt;TSource&gt;</code></p>
</div></section>

<section data-pdf-bookmark="ThenBy and ThenByDescending arguments" data-type="sect3"><div class="sect3" id="thenby_and_thenbydescending_arguments">
<h3>ThenBy and ThenByDescending arguments</h3>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Input sequence</td>
			<td><code>IOrderedEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Key selector</td>
			<td><code>TSource =&gt; TKey</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00098">
<h3>Query syntax</h3>

<pre data-type="programlisting">
orderby <em>expression1</em> [<em>descending</em>] [, <em>expression2</em> [descending] <em>...</em> ]</pre>
</div></section>

<section data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00065">
<h3>Overview</h3>

<p><a contenteditable="false" data-primary="OrderBy operator" data-type="indexterm" id="id3292"/><a contenteditable="false" data-primary="ordering" data-secondary="OrderBy and OrderByDescending arguments" data-type="indexterm" id="id3293"/><code>OrderBy</code> returns a sorted version of the input sequence, using the <code>keySelector</code> expression to make comparisons. The following query emits a sequence of names in alphabetical order:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s);</pre>

<p>The following sorts names by length:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s.Length);

// Result: { "Jay", "Tom", "Mary", "Dick", "Harry" };</pre>

<p><a contenteditable="false" data-primary="ThenBy operator" data-type="indexterm" id="id3294"/>The relative order of elements with the same sorting key (in this case, Jay/Tom and Mary/Dick) is indeterminate—unless you append a <code>ThenBy</code> operator:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s.Length)<strong>.ThenBy (s =&gt; s)</strong>;

// Result: { "Jay", "Tom", "Dick", "Mary", "Harry" };</pre>

<p><code>ThenBy</code> reorders only elements that had the same sorting key in the preceding sort. You can chain any number of <code>ThenBy</code> operators. The following sorts first by length, then by the second character, and finally by the first character:</p>

<pre data-type="programlisting">
names.OrderBy (s =&gt; s.Length).ThenBy (s =&gt; s[1]).ThenBy (s =&gt; s[0]);</pre>

<p class="pagebreak-before">Here’s the equivalent in query syntax:</p>

<pre data-type="programlisting">
from s in names
<strong>orderby s.Length, s[1], s[0]</strong>
select s;</pre>

<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The following variation is <em>incorrect</em>—it will actually order first by <code>s[1]</code> and then by <code>s.Length</code> (or in the case of a database query, it will order <em>only</em> by <code>s[1]</code> and discard the former <span class="keep-together">ordering</span>):</p>

<pre data-type="programlisting">
from s in names
orderby s.Length
orderby s[1]
...</pre>
</div>

<p><a contenteditable="false" data-primary="OrderByDescending operator" data-type="indexterm" id="id3295"/><a contenteditable="false" data-primary="ThenByDescending operator" data-type="indexterm" id="id3296"/>LINQ also provides <code>OrderByDescending</code> and <code>ThenByDescending</code> operators, which do the same things, emitting the results in reverse order. The following EF Core query retrieves purchases in descending order of price, with those of the same price listed alphabetically:</p>

<pre data-type="programlisting">
dbContext.Purchases.OrderByDescending (p =&gt; p.Price)
                     .ThenBy (p =&gt; p.Description);</pre>

<p>In query syntax:</p>

<pre data-type="programlisting">
from p in dbContext.Purchases
<strong>orderby p.Price descending, p.Description</strong>
select p;</pre>
</div></section>

<section data-pdf-bookmark="Comparers and collations" data-type="sect3"><div class="sect3" id="comparers_and_collations">
<h3>Comparers and collations</h3>

<p><a contenteditable="false" data-primary="IComparable interface" data-type="indexterm" id="id3297"/><a contenteditable="false" data-primary="ordering" data-secondary="comparers and collations" data-type="indexterm" id="id3298"/>In a local query, the key selector objects themselves determine the ordering algorithm via their default <code>IComparable</code> implementation (see <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a>). You can override the sorting algorithm by passing in an <code>IComparer</code> object. The following performs a case-insensitive sort:</p>

<pre data-type="programlisting">
names.OrderBy (n =&gt; n, StringComparer.CurrentCultureIgnoreCase);</pre>

<p>Passing in a comparer is not supported in query syntax or in any way by EF Core. When querying a database, the comparison algorithm is determined by the participating column’s collation. If the collation is case sensitive, you can request a case-insensitive sort by calling <code>ToUpper</code> in the key selector:</p>

<pre data-type="programlisting">
from p in dbContext.Purchases
<strong>orderby p.Description.ToUpper()</strong>
select p;</pre>
</div></section>

<section data-pdf-bookmark="IOrderedEnumerable and IOrderedQueryable" data-type="sect3"><div class="sect3" id="iorderedenumerable_and_iorderedqueryabl">
<h3>IOrderedEnumerable and IOrderedQueryable</h3>

<p><a contenteditable="false" data-primary="IOrderedEnumerable" data-type="indexterm" id="id3299"/><a contenteditable="false" data-primary="IOrderedQueryable" data-type="indexterm" id="id3300"/><a contenteditable="false" data-primary="ordering" data-secondary="IOrderedEnumerable and IOrderedQueryable" data-type="indexterm" id="id3301"/>The ordering operators return special subtypes of <code>IEnumerable&lt;T&gt;</code>. Those in <span class="keep-together"><code>Enumerable</code></span> return <code>IOrderedEnumerable&lt;TSource&gt;</code>; those in <code>Queryable</code> return <span class="keep-together"><code>IOrderedQueryable&lt;TSource&gt;</code></span>. These subtypes allow a subsequent <code>ThenBy</code> operator to refine rather than replace the existing ordering.</p>

<p>The additional members that these subtypes define are not publicly exposed, so they present like ordinary sequences. The fact that they are different types comes into play when building queries progressively:</p>

<pre data-type="programlisting">
IOrderedEnumerable&lt;string&gt; query1 = names.OrderBy (s =&gt; s.Length);
IOrderedEnumerable&lt;string&gt; query2 = query1.ThenBy (s =&gt; s);</pre>

<p>If we instead declare <code>query1</code> of type <code>IEnumerable&lt;string&gt;</code>, the second line would not compile—<code>ThenBy</code> requires an input of type <code>IOrderedEnumerable&lt;string&gt;</code>. You can avoid worrying about this by implicitly typing range variables:</p>

<pre data-type="programlisting">
var query1 = names.OrderBy (s =&gt; s.Length);
var query2 = query1.ThenBy (s =&gt; s);</pre>

<p>Implicit typing can create problems of its own, though. The following will not <span class="keep-together">compile</span>:</p>

<pre data-type="programlisting">
var query = names.OrderBy (s =&gt; s.Length);
query = query.Where (n =&gt; n.Length &gt; 3);       // Compile-time error</pre>

<p>The compiler infers <code>query</code> to be of type <code>IOrderedEnumerable&lt;string&gt;</code>, based on <code>OrderBy</code>’s output sequence type. However, the <code>Where</code> on the next line returns an ordinary <code>IEnumerable&lt;string&gt;</code>, which cannot be assigned back to <code>query</code>. You can work around this either with explicit typing or by calling <code>AsEnumerable()</code> after <code>OrderBy</code>:</p>

<pre data-type="programlisting">
var query = names.OrderBy (s =&gt; s.Length)<strong>.AsEnumerable()</strong>;
query = query.Where (n =&gt; n.Length &gt; 3);                   // OK</pre>

<p>The equivalent in interpreted queries is to call <code>AsQueryable</code>.<a contenteditable="false" data-primary="" data-startref="ch09.html18" data-type="indexterm" id="id3302"/><a contenteditable="false" data-primary="" data-startref="ch09.html17" data-type="indexterm" id="id3303"/></p>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Grouping" data-type="sect1"><div class="sect1" id="grouping">
<h1>Grouping</h1>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>GroupBy</code></td>
			<td>Groups a sequence into subsequences</td>
			<td><code>GROUP BY</code></td>
		</tr>
				<tr>
			<td><code>Chunk</code></td>
			<td>Groups a sequence into arrays of a fixed size</td>
			<td> </td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="GroupBy" data-type="sect2"><div class="sect2" id="groupby">
<h2>GroupBy</h2>

<p><a contenteditable="false" data-primary="GroupBy operator" data-type="indexterm" id="ch09.html19"/><a contenteditable="false" data-primary="grouping (LINQ)" data-type="indexterm" id="ch09.html20"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="grouping" data-type="indexterm" id="ch09.html21"/><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;IGrouping&lt;TKey,TElement&gt;&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Input sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Key selector</td>
			<td><code>TSource =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Element selector (optional)</td>
			<td><code>TSource =&gt; TElement</code></td>
		</tr>
		<tr>
			<td>Comparer (optional)</td>
			<td><code>IEqualityComparer&lt;TKey&gt;</code></td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="Query syntax" data-type="sect3"><div class="sect3" id="query_syntax-id00099">
<h3>Query syntax</h3>

<pre data-type="programlisting">
group <em>element-expression</em> by <em>key-expression</em></pre>
</div></section>

<section data-pdf-bookmark="Overview" data-type="sect3"><div class="sect3" id="overview-id00066">
<h3>Overview</h3>

<p><code>GroupBy</code> organizes a flat input sequence into sequences of <em>groups</em>. For example, the following organizes all of the files in <em>Path.GetTempPath()</em> by extension:</p>

<pre data-type="programlisting">
string[] files = Directory.GetFiles (Path.GetTempPath());

IEnumerable&lt;IGrouping&lt;string,string&gt;&gt; query =
  files.GroupBy (file =&gt; Path.GetExtension (file));</pre>

<p>Or, with implicit typing:</p>

<pre data-type="programlisting">
var query = files.GroupBy (file =&gt; Path.GetExtension (file));</pre>

<p>Here’s how to enumerate the result:</p>

<pre data-type="programlisting">
foreach (IGrouping&lt;string,string&gt; grouping in query)
{
  Console.WriteLine ("Extension: " + <strong>grouping.Key</strong>);
  foreach (string filename in <strong>grouping</strong>)
    Console.WriteLine ("   - " + filename);
}

<em>Extension: .pdf</em>
<em>  -- chapter03.pdf</em>
<em>  -- chapter04.pdf</em>
<em>Extension: .doc</em>
<em>  -- todo.doc</em>
<em>  -- menu.doc</em>
<em>  -- Copy of menu.doc</em>
<em>...</em></pre>

<p><code>Enumerable.GroupBy</code> works by reading the input elements into a temporary dictionary of lists so that all elements with the same key end up in the same sublist. It then emits a sequence of <em>groupings</em>. A grouping is a sequence with a <code>Key</code> property:</p>

<pre data-type="programlisting">
public interface IGrouping &lt;TKey,TElement&gt; : IEnumerable&lt;TElement&gt;,
                                             IEnumerable
{
  TKey Key { get; }    // Key applies to the subsequence as a whole
}</pre>

<p>By default, the elements in each grouping are untransformed input elements unless you specify an <code>elementSelector</code> argument. The following projects each input element to uppercase:</p>

<pre data-type="programlisting">
files.GroupBy (file =&gt; Path.GetExtension (file), file =&gt; file.ToUpper());</pre>

<p>An <code>elementSelector</code> is independent of the <code>keySelector</code>. In our case, this means that the <code>Key</code> on each grouping is still in its original case:</p>

<pre class="pagebreak-before" data-type="programlisting">
<strong>Extension: .pdf</strong>
  -- CHAPTER03.PDF
  -- CHAPTER04.PDF
<strong>Extension: .doc</strong>
  -- TODO.DOC</pre>

<p>Note that the subcollections are not emitted in alphabetical order of key. <code>GroupBy</code> merely <em>groups;</em> it does not <em>sort</em>. In fact, it preserves the original ordering. To sort, you must add an <code>OrderBy</code> operator:</p>

<pre data-type="programlisting">
files.GroupBy (file =&gt; Path.GetExtension (file), file =&gt; file.ToUpper())
     .OrderBy (grouping =&gt; grouping.Key);</pre>

<p><code>GroupBy</code> has a simple and direct translation in query syntax:</p>

<pre data-type="programlisting">
group <em>element-expr</em> by <em>key-expr</em></pre>

<p>Here’s our example in query syntax:</p>

<pre data-type="programlisting">
from file in files
<strong>group file.ToUpper() by Path.GetExtension (file);</strong></pre>

<p>As with <code>select</code>, <code>group</code> “ends” a query—unless you add a query continuation clause:</p>

<pre data-type="programlisting">
from file in files
group file.ToUpper() by Path.GetExtension (file) <strong>into grouping</strong>
orderby grouping.Key
select grouping;</pre>

<p>Query continuations are often useful in a <code>group by</code> query. The next query filters out groups that have fewer than five files in them:</p>

<pre data-type="programlisting">
from file in files
group file.ToUpper() by Path.GetExtension (file) into grouping
<strong>where grouping.Count() &gt;= 5</strong>
select grouping;</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <code>where</code> after a <code>group by</code> is equivalent to HAVING in SQL. It applies to each subsequence or grouping as a whole rather than the individual elements.</p>
</div>

<p>Sometimes, you’re interested purely in the result of an aggregation on a grouping and so can abandon the subsequences:</p>

<pre data-type="programlisting">
string[] votes = { "Dogs", "Cats", "Cats", "Dogs", "Dogs" };

IEnumerable&lt;string&gt; query = from vote in votes
                            group vote by vote into g
                            <strong>orderby g.Count() descending</strong>
                            <strong>select g.Key;</strong>

string winner = query.First();    // Dogs</pre>
</div></section>

<section data-pdf-bookmark="GroupBy in EF Core" data-type="sect3"><div class="sect3" id="groupby_in_ef_core">
<h3>GroupBy in EF Core</h3>

<p><a contenteditable="false" data-primary="EF Core" data-secondary="GroupBy in" data-type="indexterm" id="id3304"/>Grouping works in the same way when querying a database. If you have navigation properties set up, you’ll find, however, that the need to group arises less frequently than with standard SQL. For instance, to select customers with at least two purchases, you don’t need to <code>group</code>; the following query does the job nicely:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
<strong>where c.Purchases.Count &gt;= 2</strong>
select c.Name + " has made " + c.Purchases.Count + " purchases";</pre>

<p>An example of when you might use grouping is to list total sales by year:</p>

<pre data-type="programlisting">
from p in dbContext.Purchases
group p.Price by p.Date.Year into salesByYear
select new {
             Year       = salesByYear.Key,
             TotalValue = salesByYear.Sum()
           };</pre>

<p>LINQ’s grouping is more powerful than SQL’s GROUP BY in that you can fetch all detail rows without any aggregation:</p>

<pre data-type="programlisting">
from p in dbContext.Purchases
group p by p.Date.Year
Date.Year</pre>

<p>However, this doesn’t work in EF Core. An easy workaround is to call <code>.AsEnumerable()</code> just before grouping so that the grouping happens on the client. This is no less efficient as long as you perform any filtering <em>before</em> grouping so that you only fetch the data you need from the server.</p>

<p>Another departure from traditional SQL comes in there being no obligation to project the variables or expressions used in grouping or sorting.</p>
</div></section>

<section data-pdf-bookmark="Grouping by multiple keys" data-type="sect3"><div class="sect3" id="grouping_by_multiple_keys">
<h3>Grouping by multiple keys</h3>

<p>You can group by a composite key, using an anonymous type:</p>

<pre data-type="programlisting">
from n in names
group n by new { FirstLetter = n[0], Length = n.Length };</pre>
</div></section>

<section data-pdf-bookmark="Custom equality comparers" data-type="sect3"><div class="sect3" id="custom_equality_comparers">
<h3>Custom equality comparers</h3>

<p>You can pass a custom equality comparer into <code>GroupBy</code>, in a local query, to change the algorithm for key comparison. Rarely is this required, though, because changing the key selector expression is usually sufficient. For instance, the following creates a case-insensitive grouping:<a contenteditable="false" data-primary="" data-startref="ch09.html21" data-type="indexterm" id="id3305"/><a contenteditable="false" data-primary="" data-startref="ch09.html20" data-type="indexterm" id="id3306"/><a contenteditable="false" data-primary="" data-startref="ch09.html19" data-type="indexterm" id="id3307"/></p>

<pre data-type="programlisting">
group n by n<em>.ToUpper()</em></pre>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Chunk" data-type="sect2"><div class="sect2" id="chunk9">
<h2 class="less_space">Chunk</h2>
 <p><code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TElement[]&gt;</code></p>
 
 <table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
<tr>
 <td>Input sequence</td>
 <td><code>IEnumerable&lt;TSource&gt;</code></td>
</tr>
<tr>
 <td><code>size</code></td>
 <td><code>int</code></td>
</tr>
	</tbody>
</table>
 
<p>Introduced in .NET 6, <code>Chunk</code> groups a sequence into chunks of a given size (or fewer, if there aren’t enough elements):</p>

<pre data-type="programlisting">foreach (int[] chunk in new[] { 1, 2, 3, 4, 5, 6, 7, 8 }.Chunk (3))
  Console.WriteLine (string.Join (", ", chunk));</pre>

<p>Output:</p>

<pre data-type="programlisting">1, 2, 3
4, 5, 6
7, 8</pre>

</div></section>
</div></section>
<section data-pdf-bookmark="Set Operators" data-type="sect1"><div class="sect1" id="set_operators">
<h1>Set Operators</h1>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="set operators" data-type="indexterm" id="id3308"/><a contenteditable="false" data-primary="set operators (LINQ)" data-type="indexterm" id="id3309"/><code>IEnumerable&lt;TSource&gt;</code>, <code>IEnumerable&lt;TSource&gt;</code>→<code>IEnumerable&lt;TSource&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Concat</code></td>
			<td>Returns a concatenation of elements in each of the two sequences</td>
			<td><code>UNION ALL</code></td>
		</tr>
		<tr>
			<td><code>Union</code>, <code>UnionBy</code></td>
			<td>Returns a concatenation of elements in each of the two sequences, excluding duplicates</td>
			<td><code>UNION</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>Intersect</code></span>, <code>IntersectBy</code></td>
			<td>Returns elements present in both sequences</td>
			<td><span class="keep-together"><code>WHERE ... IN (...)</code></span></td>
		</tr>
		<tr>
			<td><code>Except</code>, <code>ExceptBy</code></td>
			<td>Returns elements present in the first but not the second sequence</td>
			<td><code>EXCEPT</code> <em>or</em> <span class="keep-together"><code>WHERE ... NOT IN (...)</code></span></td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="Concat, Union, UnionBy" data-type="sect2"><div class="sect2" id="concat_and_union">
<h2>Concat, Union, UnionBy</h2>

<p><a contenteditable="false" data-primary="Concat operator" data-type="indexterm" id="id3310"/><a contenteditable="false" data-primary="set operators (LINQ)" data-secondary="Concat and Union" data-type="indexterm" id="id3311"/><a contenteditable="false" data-primary="Union operator" data-type="indexterm" id="id3312"/><code>Concat</code> returns all the elements of the first sequence, followed by all the elements of the second. <code>Union</code> does the same but removes any duplicates:</p>

<pre data-type="programlisting">
int[] seq1 = { 1, 2, 3 }, seq2 = { 3, 4, 5 };

IEnumerable&lt;int&gt;
  concat = seq1.Concat (seq2),    //  { 1, 2, 3, 3, 4, 5 }
  union  = seq1.Union  (seq2);    //  { 1, 2, 3, 4, 5 }</pre>

<p>Specifying the type argument explicitly is useful when the sequences are differently typed but the elements have a common base type. For instance, with the reflection API (<a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>), methods and properties are represented with <code>MethodInfo</code> and <code>PropertyInfo</code> classes, which have a common base class called <code>MemberInfo</code>. We can concatenate methods and properties by stating that base class explicitly when calling <code>Concat</code>:</p>

<pre data-type="programlisting">
MethodInfo[] methods = typeof (string).GetMethods();
PropertyInfo[] props = typeof (string).GetProperties();
IEnumerable&lt;MemberInfo&gt; both = methods.Concat&lt;<strong>MemberInfo</strong>&gt; (props);</pre>

<p>In the next example, we filter the methods before concatenating:</p>

<pre data-type="programlisting">
var methods = typeof (string).GetMethods().Where (m =&gt; !m.IsSpecialName);
var props = typeof (string).GetProperties();
var both = methods.Concat&lt;MemberInfo&gt; (props);</pre>

<p>This example relies on interface type parameter variance: <code>methods</code> is of type <span class="keep-together"><code>IEnumerable&lt;MethodInfo&gt;</code></span>, which requires a covariant conversion to <code>IEnumerable​&lt;Mem⁠berInfo&gt;</code>. It’s a good illustration of how variance makes things work more like you’d expect.</p>

<p><code>UnionBy</code> (introduced in .NET 6) takes a <code>keySelector</code>, which is used in determining whether an element is a duplicate. In the following example, we perform a case-insensitive union:</p>

<pre data-type="programlisting">string[] seq1 = { "A", "b", "C" };
string[] seq2 = { "a", "B", "c" };
var union = seq1.UnionBy (seq2, x =&gt; x.ToUpperInvariant());
// union is { "A", "b", "C" }</pre>

<p>In this case, the same thing can be accomplished with <code>Union</code>, if we supply an equality comparer:</p>

<pre data-type="programlisting">var union = seq1.Union (seq2, StringComparer.InvariantCultureIgnoreCase);</pre>

</div></section>

<section data-pdf-bookmark="Intersect, Intersect By, Except, and ExceptBy" data-type="sect2"><div class="sect2" id="intersect_and_except">
<h2>Intersect, Intersect By, Except, and ExceptBy</h2>

<p><a contenteditable="false" data-primary="Except operator" data-type="indexterm" id="id3313"/><a contenteditable="false" data-primary="Intersect operator" data-type="indexterm" id="id3314"/><a contenteditable="false" data-primary="set operators (LINQ)" data-secondary="Intersect and Except" data-type="indexterm" id="id3315"/><code>Intersect</code> returns the elements that two sequences have in common. <code>Except</code> returns the elements in the first input sequence that are <em>not</em> present in the second:</p>

<pre data-type="programlisting">
int[] seq1 = { 1, 2, 3 }, seq2 = { 3, 4, 5 };

IEnumerable&lt;int&gt;
  commonality = seq1.Intersect (seq2),    //  { 3 }
  difference1 = seq1.Except    (seq2),    //  { 1, 2 }
  difference2 = seq2.Except    (seq1);    //  { 4, 5 }</pre>

<p><a contenteditable="false" data-primary="Enumerable..." data-secondary="Enumerable.Except" data-type="indexterm" id="id3316"/><code>Enumerable.Except</code> works internally by loading all of the elements in the first collection into a dictionary and then removing from the dictionary all elements present in the second sequence. The equivalent in SQL is a <code>NOT EXISTS</code> or <code>NOT IN</code> subquery:</p>

<pre data-type="programlisting">
SELECT number FROM numbers1Table
WHERE number NOT IN (SELECT number FROM numbers2Table)</pre>

<p>The <code>IntersectBy</code> and <code>ExceptBy</code> methods (from .NET 6) let you specify a key selector that’s applied before performing equality comparison (see the discussion on <code>UnionBy</code> in the preceding section).</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Conversion Methods" data-type="sect1"><div class="sect1" id="conversion_methods">
<h1>Conversion Methods</h1>

<p><a contenteditable="false" data-primary="conversions" data-secondary="LINQ methods" data-type="indexterm" id="ch09.html22"/><a contenteditable="false" data-primary="IEnumerable&lt;T&gt;" data-secondary="LINQ conversion methods and" data-type="indexterm" id="ch09.html23"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="conversion methods" data-type="indexterm" id="ch09.html24"/>LINQ deals primarily in sequences; in other words, collections of type <code>IEnumerable&lt;T&gt;</code>. The conversion methods convert to and from other types of collections:</p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>OfType</code></td>
			<td>Converts <code>IEnumerable</code> to <code>IEnumerable&lt;T&gt;</code>, discarding wrongly typed elements</td>
		</tr>
		<tr>
			<td><code>Cast</code></td>
			<td>Converts <code>IEnumerable</code> to <code>IEnumerable&lt;T&gt;</code>, throwing an exception if there are any wrongly typed elements</td>
		</tr>
		<tr>
			<td><code>ToArray</code></td>
			<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>T[]</code></td>
		</tr>
		<tr>
			<td><code>ToList</code></td>
			<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>List&lt;T&gt;</code></td>
		</tr>
		<tr>
			<td><code>ToDictionary</code></td>
			<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>Dictionary&lt;TKey,TValue&gt;</code></td>
		</tr>
		<tr>
			<td><code>ToLookup</code></td>
			<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>ILookup&lt;TKey,TElement&gt;</code></td>
		</tr>
		<tr>
			<td><code>AsEnumerable</code></td>
			<td>Upcasts to <code>IEnumerable&lt;T&gt;</code></td>
		</tr>
		<tr>
			<td><code>AsQueryable</code></td>
			<td>Casts or converts to <code>IQueryable&lt;T&gt;</code></td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="OfType and Cast" data-type="sect2"><div class="sect2" id="oftype_and_cast">
<h2>OfType and Cast</h2>

<p><a contenteditable="false" data-primary="Cast operator" data-type="indexterm" id="id3317"/><a contenteditable="false" data-primary="OfType operator" data-type="indexterm" id="id3318"/><code>OfType</code> and <code>Cast</code> accept a nongeneric <code>IEnumerable</code> collection and emit a generic <code>IEnumerable&lt;T&gt;</code> sequence that you can subsequently query:</p>

<pre data-type="programlisting">
ArrayList classicList = new ArrayList();          // in System.Collections
classicList.AddRange ( new int[] { 3, 4, 5 } );
<strong>IEnumerable&lt;int&gt; sequence1 = classicList.Cast&lt;int&gt;();</strong></pre>

<p><code>Cast</code> and <code>OfType</code> differ in their behavior when encountering an input element that’s of an incompatible type. <code>Cast</code> throws an exception; <code>OfType</code> ignores the incompatible element. Continuing the preceding example:</p>

<pre data-type="programlisting">
DateTime offender = DateTime.Now;
classicList.Add (offender);
IEnumerable&lt;int&gt;
  sequence2 = classicList.<strong>OfType</strong>&lt;int&gt;(), // OK - ignores offending DateTime
  sequence3 = classicList.<strong>Cast</strong>&lt;int&gt;();   // Throws exception</pre>

<p>The rules for element compatibility exactly follow those of C#’s <code>is</code> operator, and therefore consider only reference conversions and unboxing conversions. We can see this by examining the internal implementation of <code>OfType</code>:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; OfType &lt;TSource&gt; (IEnumerable source)
{
  foreach (object element in source)
    <strong>if (element is TSource)</strong>
      yield return (TSource)element;
}</pre>

<p><code>Cast</code> has an identical implementation, except that it omits the type compatibility test:</p>

<pre data-type="programlisting">
public static IEnumerable&lt;TSource&gt; Cast &lt;TSource&gt; (IEnumerable source)
{
  foreach (object element in source)
    yield return (TSource)element;
}</pre>

<p>A consequence of these implementations is that you cannot use <code>Cast</code> to perform numeric or custom conversions (for these, you must perform a <code>Select</code> operation instead). In other words, <code>Cast</code> is not as flexible as C#’s cast operator:</p>

<pre data-type="programlisting">
int i = 3;
<strong>long l = i</strong>;         // Implicit <em>numeric conversion</em> int-&gt;long
<strong>int i2 = (int) l</strong>;   // Explicit <em>numeric conversion</em> long-&gt;int</pre>

<p>We can demonstrate this by attempting to use <code>OfType</code> or <code>Cast</code> to convert a sequence of <code>int</code>s to a sequence of <code>long</code>s:</p>

<pre data-type="programlisting">
int[] integers = { 1, 2, 3 };

IEnumerable&lt;long&gt; test1 = integers.OfType&lt;long&gt;();
IEnumerable&lt;long&gt; test2 = integers.Cast&lt;long&gt;();</pre>

<p>When enumerated, <code>test1</code> emits zero elements and <code>test2</code> throws an exception. Examining <code>OfType</code>’s implementation, it’s fairly clear why. After substituting <code>TSource</code>, we get the following expression:</p>

<pre data-type="programlisting">
(element is long)</pre>

<p>This returns <code>false</code> for an <code>int element</code>, due to the lack of an inheritance <span class="keep-together">relationship</span>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The reason that <code>test2</code> throws an exception when enumerated is more subtle. Notice in <code>Cast</code>’s implementation that <code>element</code> is of type <code>object</code>. When <code>TSource</code> is a value type, the CLR assumes this is an <em>unboxing conversion</em> and synthesizes a method that reproduces the scenario described in the section <a data-type="xref" href="ch03.html#boxing_and_unboxing">“Boxing and Unboxing”</a>:</p>

<pre data-type="programlisting">
int value = 123;
object element = value;
long result = <strong>(long) element</strong>;  // exception</pre>

<p>Because the <code>element</code> variable is declared of type <code>object</code>, an <code>object</code>-to-<code>long</code> cast is performed (an unboxing) rather than an <code>int</code>-to-<code>long</code> numeric conversion. Unboxing operations require an exact type match, so the <code>object</code>-to-<code>long</code> unbox fails when given an <code>int</code>.</p>
</div>

<p class="pagebreak-before">As we suggested previously, the solution is to use an ordinary <code>Select</code>:</p>

<pre data-type="programlisting">
IEnumerable&lt;long&gt; castLong = integers.Select (s =&gt; (long) s);</pre>

<p><code>OfType</code> and <code>Cast</code> are also useful in downcasting elements in a generic input sequence. For instance, if you have an input sequence of type <code>IEnumerable&lt;Fruit&gt;</code>, <code>OfType&lt;Apple&gt;</code> would return just the apples. This is particularly useful in LINQ to XML (see <a data-type="xref" href="ch10.html#linq_to_xml">Chapter 10</a>).</p>

<p><code>Cast</code> has query syntax support: simply precede the range variable with a type:</p>

<pre data-type="programlisting">
from <strong>TreeNode</strong> node in myTreeView.Nodes
...</pre>
</div></section>

<section data-pdf-bookmark="ToArray, ToList, ToDictionary, ToHashSet, ToLookup" data-type="sect2"><div class="sect2" id="toarraycomma_tolistcomma_todictionaryco">
<h2>ToArray, ToList, ToDictionary, ToHashSet, ToLookup</h2>

<p><a contenteditable="false" data-primary="To..." data-secondary="ToArray operator" data-type="indexterm" id="id3319"/><a contenteditable="false" data-primary="To..." data-secondary="ToHashSet operator" data-type="indexterm" id="id3320"/><a contenteditable="false" data-primary="To..." data-secondary="ToList operator" data-type="indexterm" id="id3321"/><code>ToArray</code>, <code>ToList</code>, and <code>ToHashSet</code> emit the results into an array, <code>List&lt;T&gt;</code> or <code>HashSet&lt;T&gt;</code>. When they execute, these operators force the immediate enumeration of the input sequence. For examples, refer to <a data-type="xref" href="ch08.html#deferred_executio">“Deferred Execution”</a>.</p>

<p><a contenteditable="false" data-primary="To..." data-secondary="ToDictionary operator" data-type="indexterm" id="id3322"/><a contenteditable="false" data-primary="To..." data-secondary="ToLookup operator" data-type="indexterm" id="id3323"/><code>ToDictionary</code> and <code>ToLookup</code> accept the following arguments:</p>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Input sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Key selector</td>
			<td><code>TSource =&gt; TKey</code></td>
		</tr>
		<tr>
			<td>Element selector (optional)</td>
			<td><code>TSource =&gt; TElement</code></td>
		</tr>
		<tr>
			<td>Comparer (optional)</td>
			<td><code>IEqualityComparer&lt;TKey&gt;</code></td>
		</tr>
	</tbody>
</table>

<p><code>ToDictionary</code> also forces immediate execution of a sequence, writing the results to a generic <code>Dictionary</code>. The <code>keySelector</code> expression you provide must evaluate to a unique value for each element in the input sequence; otherwise, an exception is thrown. In contrast, <code>ToLookup</code> allows many elements of the same key. We described lookups in <a data-type="xref" href="#joining_with_lookups">“Joining with lookups”</a>.</p>
</div></section>

<section data-pdf-bookmark="AsEnumerable and AsQueryable" data-type="sect2"><div class="sect2" id="asenumerable_and_asqueryable">
<h2>AsEnumerable and AsQueryable</h2>

<p><a contenteditable="false" data-primary="AsEnumerable operator" data-type="indexterm" id="id3324"/><a contenteditable="false" data-primary="AsQueryable operator" data-type="indexterm" id="id3325"/><code>AsEnumerable</code> upcasts a sequence to <code>IEnumerable&lt;T&gt;</code>, forcing the compiler to bind subsequent query operators to methods in <code>Enumerable</code> instead of <code>Queryable</code>. For an example, see <a data-type="xref" href="ch08.html#combining_interpreted_and_local_queries">“Combining Interpreted and Local Queries”</a>.</p>

<p><code>AsQueryable</code> downcasts a sequence to <code>IQueryable&lt;T&gt;</code> if it implements that interface. Otherwise, it instantiates an <code>IQueryable&lt;T&gt;</code> wrapper over the local query.<a contenteditable="false" data-primary="" data-startref="ch09.html24" data-type="indexterm" id="id3326"/><a contenteditable="false" data-primary="" data-startref="ch09.html23" data-type="indexterm" id="id3327"/><a contenteditable="false" data-primary="" data-startref="ch09.html22" data-type="indexterm" id="id3328"/></p>
</div></section>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Element Operators" data-type="sect1"><div class="sect1" id="element_operators">
<h1 class="less_space">Element Operators</h1>

<p><a contenteditable="false" data-primary="element operators" data-type="indexterm" id="ch09.html25"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="element operators" data-type="indexterm" id="ch09.html26"/><code>IEnumerable&lt;TSource&gt;</code>→ <code>TSource</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>First, <span class="keep-together">FirstOrDefault</span></code></td>
			<td>Returns the first element in the sequence, optionally satisfying a predicate</td>
			<td><code>SELECT TOP 1</code> ... <code>ORDER BY</code> ...</td>
		</tr>
		<tr>
			<td><code>Last</code>,<br/>
			<code>LastOrDefault</code></td>
			<td>Returns the last element in the sequence, optionally satisfying a predicate</td>
			<td><code>SELECT TOP 1</code> ... <code>ORDER BY</code> ... <code>DESC</code></td>
		</tr>
		<tr>
			<td><code>Single, <span class="keep-together">SingleOrDefault</span></code></td>
			<td>Equivalent to <code>First/FirstOrDefault</code>, but throws an exception if there is more than one match</td>
			<td> </td>
		</tr>
		<tr>
			<td><code>ElementAt, <span class="keep-together">ElementAtOrDefault</span></code></td>
			<td>Returns the element at the specified position</td>
			<td>Exception thrown</td>
		</tr>
		<tr>
		 <td><code>MinBy</code>, <code>MaxBy</code></td>
		 <td>Returns the element with the smallest or largest value</td>
		 <td>Exception thrown</td>
		</tr>
		<tr>
			<td><code>DefaultIfEmpty</code></td>
			<td>Returns a single-element sequence whose value is <code>default(TSource)</code> if the sequence has no elements</td>
			<td><code>OUTER JOIN</code></td>
		</tr>
	</tbody>
</table>

<p>Methods ending in “OrDefault” return <code>default(TSource)</code> rather than throwing an exception if the input sequence is empty or if no elements match the supplied <span class="keep-together">predicate</span>.</p>

<p><code>default(TSource)</code> is <code>null</code> for reference type elements, <code>false</code> for the <code>bool</code> type, and zero for numeric types.</p>

<section data-pdf-bookmark="First, Last, and Single" data-type="sect2"><div class="sect2" id="firstcomma_lastcomma_and_single">
<h2>First, Last, and Single</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Predicate (optional)</td>
			<td><code>TSource =&gt; bool</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="First operator" data-type="indexterm" id="id3329"/><a contenteditable="false" data-primary="Last operator" data-type="indexterm" id="id3330"/>The following example demonstrates <code>First</code> and <code>Last</code>:</p>

<pre data-type="programlisting">
int[] numbers  = { 1, 2, 3, 4, 5 };
int first      = numbers.First();                      // 1
int last       = numbers.Last();                       // 5
int firstEven  = numbers.First  (n =&gt; n % 2 == 0);     // 2
int lastEven   = numbers.Last   (n =&gt; n % 2 == 0);     // 4</pre>

<p>The following demonstrates <code>First</code> versus <code>FirstOrDefault</code>:</p>

<pre data-type="programlisting">
int firstBigError  = numbers.First          (n =&gt; n &gt; 10);   // Exception
int firstBigNumber = numbers.FirstOrDefault (n =&gt; n &gt; 10);   // 0</pre>

<p><a contenteditable="false" data-primary="FirstOrDefault operator" data-type="indexterm" id="id3331"/><a contenteditable="false" data-primary="Single operator" data-type="indexterm" id="id3332"/>To prevent an exception, <code>Single</code> requires exactly one matching element; <code>SingleOrDefault</code> requires one <em>or zero</em> matching elements:</p>

<pre data-type="programlisting">
int onlyDivBy3 = numbers.Single (n =&gt; n % 3 == 0);   // 3
int divBy2Err  = numbers.Single (n =&gt; n % 2 == 0);   // Error: 2 &amp; 4 match

int singleError = numbers.Single          (n =&gt; n &gt; 10);      // Error
int noMatches   = numbers.SingleOrDefault (n =&gt; n &gt; 10);      // 0
int divBy2Error = numbers.SingleOrDefault (n =&gt; n % 2 == 0);  // Error</pre>

<p><code>Single</code> is the “fussiest” in this family of element operators. <code>FirstOrDefault</code> and <code>LastOrDefault</code> are the most tolerant.</p>

<p>In EF Core, <code>Single</code> is often used to retrieve a row from a table by primary key:</p>

<pre data-type="programlisting">
Customer cust = dataContext.Customers.Single (c =&gt; c.ID == 3);</pre>
</div></section>

<section data-pdf-bookmark="ElementAt" data-type="sect2"><div class="sect2" id="elementat">
<h2>ElementAt</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Index of element to return</td>
			<td><code>int</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="ElementAt operator" data-type="indexterm" id="id3333"/><code>ElementAt</code> picks the <em>n</em>th element from the sequence:</p>

<pre data-type="programlisting">
int[] numbers  = { 1, 2, 3, 4, 5 };
int third      = numbers.ElementAt (2);            // 3
int tenthError = numbers.ElementAt (9);            // Exception
int tenth      = numbers.ElementAtOrDefault (9);   // 0</pre>

<p><a contenteditable="false" data-primary="Enumerable..." data-secondary="Enumerable.ElementAt" data-type="indexterm" id="id3334"/><code>Enumerable.ElementAt</code> is written such that if the input sequence happens to implement <code>IList&lt;T&gt;</code>, it calls <code>IList&lt;T&gt;</code>’s indexer. Otherwise, it enumerates <em>n</em> times and then returns the next element. <code>ElementAt</code> is not supported in EF Core.</p>
</div></section>

<section data-pdf-bookmark="MinBy and MaxBy" data-type="sect2"><div class="sect2" id="minbymaxby">
 <h2>MinBy and MaxBy</h2>

<p><code>MinBy</code> and <code>MaxBy</code> (introduced in .NET 6) return the element with the smallest or largest value, as determined by a <code>keySelector</code>:</p>

<pre data-type="programlisting">string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
Console.WriteLine (names.MaxBy (n =&gt; n.Length));   // Harry</pre>

<p>In contrast, <code>Min</code> and <code>Max</code> (which we will cover in the following section) return the smallest or largest value itself:</p>

<pre data-type="programlisting">Console.WriteLine (names.Max   (n =&gt; n.Length));   // 5</pre>

<p>If two or more elements share a minimum/maximum value, <code>MinBy</code>/<code>MaxBy</code> returns the first:</p>

<pre data-type="programlisting">Console.WriteLine (names.MinBy (n =&gt; n.Length));   // Tom</pre>

<p>If the input sequence is empty, <code>MinBy</code> and <code>MaxBy</code> return null if the element type is nullable (or throw an exception if the element type is not nullable).</p>

</div></section>

<section data-pdf-bookmark="DefaultIfEmpty" data-type="sect2"><div class="sect2" id="defaultifempty">
<h2>DefaultIfEmpty</h2>

<p><a contenteditable="false" data-primary="DefaultIfEmpty operator" data-type="indexterm" id="id3335"/><code>DefaultIfEmpty</code> returns a sequence containing a single element whose value is <code>default(TSource)</code> if the input sequence has no elements; otherwise, it returns the input sequence unchanged. You use this in writing flat outer joins: see <a data-type="xref" href="#outer_joins_with_selectmany">“Outer joins with SelectMany”</a> and <a data-type="xref" href="#flat_outer_joins">“Flat outer joins”</a>.<a contenteditable="false" data-primary="" data-startref="ch09.html26" data-type="indexterm" id="id3336"/><a contenteditable="false" data-primary="" data-startref="ch09.html25" data-type="indexterm" id="id3337"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Aggregation Methods" data-type="sect1"><div class="sect1" id="aggregation_method">
<h1>Aggregation Methods</h1>

<p><a contenteditable="false" data-primary="aggregation methods" data-type="indexterm" id="ch09.html27"/><a contenteditable="false" data-primary="LINQ operators" data-secondary="aggregation methods" data-type="indexterm" id="ch09.html28"/><code>IEnumerable&lt;TSource&gt;</code>→<code><em>scalar</em></code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Count, <span class="keep-together">LongCount</span></code></td>
			<td>Returns the number of elements in the input sequence, optionally satisfying a predicate</td>
			<td><code>COUNT (...)</code></td>
		</tr>
		<tr>
			<td><code>Min, Max</code></td>
			<td>Returns the smallest or largest element in the sequence</td>
			<td><code>MIN (...), <span class="keep-together">MAX (...)</span></code></td>
		</tr>
		<tr>
			<td><code>Sum, Average</code></td>
			<td>Calculates a numeric sum or average over elements in the sequence</td>
			<td><code>SUM (...), <span class="keep-together">AVG (...)</span></code></td>
		</tr>
		<tr>
			<td><code>Aggregate</code></td>
			<td>Performs a custom aggregation</td>
			<td>Exception thrown</td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="Count and LongCount" data-type="sect2"><div class="sect2" id="count_and_longcount">
<h2>Count and LongCount</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Predicate (optional)</td>
			<td><code>TSource =&gt; bool</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="Count operator" data-type="indexterm" id="id3338"/><code>Count</code> simply enumerates over a sequence, returning the number of items:</p>

<pre data-type="programlisting">
int fullCount = new int[] { 5, 6, 7 }.Count();    // 3</pre>

<p>The internal implementation of <code>Enumerable.Count</code> tests the input sequence to see whether it happens to implement <code>ICollection&lt;T&gt;</code>. If it does, it simply calls <code>ICollection&lt;T&gt;.Count</code>; otherwise, it enumerates over every item, incrementing a counter.</p>

<p>You can optionally supply a predicate:</p>

<pre data-type="programlisting">
int digitCount = "pa55w0rd".Count (c =&gt; char.IsDigit (c));   // 3</pre>

<p><a contenteditable="false" data-primary="LongCount operator" data-type="indexterm" id="id3339"/><code>LongCount</code> does the same job as <code>Count</code> but returns a 64-bit integer, allowing for sequences of greater than two billion elements.</p>
</div></section>

<section data-pdf-bookmark="Min and Max" data-type="sect2"><div class="sect2" id="min_and_max">
<h2>Min and Max</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Result selector (optional)</td>
			<td><code>TSource =&gt; TResult</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="Max operator" data-type="indexterm" id="id3340"/><a contenteditable="false" data-primary="Min operator" data-type="indexterm" id="id3341"/><code>Min</code> and <code>Max</code> return the smallest or largest element from a sequence:</p>

<pre data-type="programlisting">
int[] numbers = { 28, 32, 14 };
int smallest = numbers.Min();  // 14;
int largest  = numbers.Max();  // 32;</pre>

<p>If you include a <code>selector</code> expression, each element is first projected:</p>

<pre data-type="programlisting">
int smallest = numbers.Max (n =&gt; n % 10);  // 8;</pre>

<p>A <code>selector</code> expression is mandatory if the items themselves are not intrinsically comparable—in other words, if they do not implement <code>IComparable&lt;T&gt;</code>:</p>

<pre data-type="programlisting">
Purchase runtimeError = dbContext.Purchases.Min ();             // Error
decimal? lowestPrice = dbContext.Purchases.Min (p =&gt; p.Price);  // OK</pre>

<p>A <code>selector</code> expression determines not only how elements are compared, but also the final result. In the preceding example, the final result is a decimal value, not a purchase object. To get the cheapest purchase, you need a subquery:</p>

<pre data-type="programlisting">
Purchase cheapest = dbContext.Purchases
  .Where (p =&gt; p.Price == dbContext.Purchases.Min (p2 =&gt; p2.Price))
  .FirstOrDefault();</pre>

<p>In this case, you could also formulate the query without an aggregation by using an <code>OrderBy</code> followed by <code>FirstOrDefault</code>.</p>
</div></section>

<section data-pdf-bookmark="Sum and Average" data-type="sect2"><div class="sect2" id="sum_and_average">
<h2>Sum and Average</h2>

<table class="border">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Source sequence</td>
			<td><code>IEnumerable&lt;TSource&gt;</code></td>
		</tr>
		<tr>
			<td>Result selector (optional)</td>
			<td><code>TSource =&gt; TResult</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="Average operator" data-type="indexterm" id="id3342"/><a contenteditable="false" data-primary="Sum operator" data-type="indexterm" id="id3343"/><code>Sum</code> and <code>Average</code> are aggregation operators that are used in a similar manner to <code>Min</code> and <code>Max</code>:</p>

<pre data-type="programlisting">
decimal[] numbers  = { 3, 4, 8 };
decimal sumTotal   = numbers.Sum();               // 15
decimal average    = numbers.Average();           // 5   (mean value)</pre>

<p>The following returns the total length of each of the strings in the <code>names</code> array:</p>

<pre data-type="programlisting">
int combinedLength = names.Sum (s =&gt; s.Length);   // 19</pre>

<p><code>Sum</code> and <code>Average</code> are fairly restrictive in their typing. Their definitions are hardwired to each of the numeric types (<code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>decimal</code>, and their nullable versions). In contrast, <code>Min</code> and <code>Max</code> can operate directly on anything that implements <code>IComparable&lt;T&gt;</code>—such as a <code>string</code>, for instance.</p>

<p>Further, <code>Average</code> always returns either <code>decimal</code>, <code>float</code>, or <code>double</code>, according to the following table:</p>

<table class="border">
	<thead>
		<tr>
			<th>Selector type</th>
			<th>Result type</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>decimal</code></td>
			<td><code>decimal</code></td>
		</tr>
		<tr>
			<td><code>float</code></td>
			<td><code>float</code></td>
		</tr>
		<tr>
			<td><code>int, long, double</code></td>
			<td><code>double</code></td>
		</tr>
	</tbody>
</table>

<p>This means that the following does not compile (“cannot convert <code>double</code> to <code>int</code>”):</p>

<pre data-type="programlisting">
int avg = new int[] { 3, 4 }.Average();</pre>

<p>But this will compile:</p>

<pre data-type="programlisting">
double avg = new int[] { 3, 4 }.Average();   // 3.5</pre>

<p><code>Average</code> implicitly upscales the input values to prevent loss of precision. In this example, we averaged integers and got 3.5 without needing to resort to an input element cast:</p>

<pre data-type="programlisting">
double avg = numbers.Average (n =&gt; (double) n);</pre>

<p>When querying a database, <code>Sum</code> and <code>Average</code> translate to the standard SQL aggregations. The following query returns customers whose average purchase was more than $500:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
where c.Purchases.Average (p =&gt; p.Price) &gt; 500
select c.Name;</pre>
</div></section>

<section data-pdf-bookmark="Aggregate" data-type="sect2"><div class="sect2" id="aggregate">
<h2>Aggregate</h2>

<p><a contenteditable="false" data-primary="Aggregate operator" data-type="indexterm" id="ch09.html29"/><code>Aggregate</code> allows you to specify a custom accumulation algorithm for implementing unusual aggregations. <code>Aggregate</code> is not supported in EF Core and is somewhat specialized in its use cases. The following demonstrates how <code>Aggregate</code> can do the work of <code>Sum</code>:</p>

<pre data-type="programlisting">
int[] numbers = { 1, 2, 3 };
int sum = numbers.Aggregate (0, (total, n) =&gt; total + n);   // 6</pre>

<p>The first argument to <code>Aggregate</code> is the <em>seed</em>, from which accumulation starts. The second argument is an expression to update the accumulated value, given a fresh element. You can optionally supply a third argument to project the final result value from the accumulated value.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Most problems for which <code>Aggregate</code> has been designed can be solved as easily with a <code>foreach</code> loop—and with more familiar syntax. The advantage of using <code>Aggregate</code> is that with large or complex aggregations, you can automatically parallelize the operation with PLINQ (see <a data-type="xref" href="ch22.html#parallel_programming-id00071">Chapter 22</a>).</p>
</div>

<section data-pdf-bookmark="Unseeded aggregations" data-type="sect3"><div class="sect3" id="unseeded_aggregations">
<h3>Unseeded aggregations</h3>

<p><a contenteditable="false" data-primary="unseeded aggregations" data-type="indexterm" id="id3344"/>You can omit the seed value when calling <code>Aggregate</code>, in which case the first element becomes the <em>implicit</em> seed, and aggregation proceeds from the second element. Here’s the preceding example, <em>unseeded</em>:</p>

<pre data-type="programlisting">
int[] numbers = { 1, 2, 3 };
int sum = numbers.Aggregate ((total, n) =&gt; total + n);   // 6</pre>

<p>This gives the same result as before, but we’re actually doing a <em>different calculation</em>. Before, we were calculating 0 + 1 + 2 + 3; now we’re calculating 1 + 2 + 3. We can better illustrate the difference by multiplying instead of adding:</p>

<pre data-type="programlisting">
int[] numbers = { 1, 2, 3 };
int x = numbers.Aggregate (0, (prod, n) =&gt; prod * n);   // 0*1*2*3 = <strong>0</strong>
int y = numbers.Aggregate (   (prod, n) =&gt; prod * n);   //   1*2*3 = <strong>6</strong></pre>

<p>As you’ll see in <a data-type="xref" href="ch22.html#parallel_programming-id00071">Chapter 22</a>, unseeded aggregations have the advantage of being parallelizable without requiring the use of special overloads. However, there are some traps with unseeded aggregations.</p>
</div></section>

<section data-pdf-bookmark="Traps with unseeded aggregations" data-type="sect3"><div class="sect3" id="traps_with_unseeded_aggregations">
<h3>Traps with unseeded aggregations</h3>

<p>The unseeded aggregation methods are intended for use with delegates that are <em>commutative</em> and <em>associative</em>. If used otherwise, the result is either <em>unintuitive</em> (with ordinary queries) or <em>nondeterministic</em> (in the case that you parallelize the query with PLINQ). For example, consider the following function:</p>

<pre data-type="programlisting">
(total, n) =&gt; total + n * n</pre>

<p>This is neither commutative nor associative. (For example, 1 + 2 * 2 != 2 + 1 * 1.) Let’s see what happens when we use it to sum the square of the numbers 2, 3, and 4:</p>

<pre data-type="programlisting">
int[] numbers = { 2, 3, 4 };
int sum = numbers.Aggregate ((total, n) =&gt; total + n * n);    // 27</pre>

<p>Instead of calculating</p>

<pre data-type="programlisting">
2*2 + 3*3 + 4*4    // 29</pre>

<p>it calculates:</p>

<pre data-type="programlisting">
2 + 3*3 + 4*4      // 27</pre>

<p>We can fix this in a number of ways. First, we could include 0 as the first element:</p>

<pre data-type="programlisting">
int[] numbers = { <strong>0,</strong> 2, 3, 4 };</pre>

<p>Not only is this inelegant, but it will still give incorrect results if parallelized—because PLINQ uses the function’s assumed associativity by selecting <em>multiple</em> elements as seeds. To illustrate, if we denote our aggregation function as follows:</p>

<pre data-type="programlisting">
f(total, n) =&gt; total + n * n</pre>

<p>LINQ to Objects would calculate this:</p>

<pre data-type="programlisting">
f(f(f(0, 2),3),4)</pre>

<p>whereas PLINQ might do this:</p>

<pre data-type="programlisting">
f(f(0,2),f(3,4))</pre>

<p>with the following result:</p>

<pre data-type="programlisting">
First partition:   a = 0 + 2*2  (= 4)
Second partition:  b = 3 + 4*4  (= 19)
Final result:          a + b*b  (= 365)
OR EVEN:               b + a*a  (= 35) </pre>

<p>There are two good solutions. The first is to turn this into a seeded aggregation with 0 as the seed. The only complication is that with PLINQ, we’d need to use a special overload in order for the query not to execute sequentially (see <a data-type="xref" href="ch22.html#optimizing_plinq">“Optimizing PLINQ”</a>).</p>

<p>The second solution is to restructure the query such that the aggregation function is commutative and associative:</p>

<pre data-type="programlisting">
int sum = numbers.Select (n =&gt; n * n).Aggregate ((total, n) =&gt; <strong>total + n</strong>);</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Of course, in such simple scenarios you can (and should) use the <code>Sum</code> operator instead of <code>Aggregate</code>:</p>

<pre data-type="programlisting">
int sum = numbers.Sum (n =&gt; n * n);</pre>

<p>You can actually go quite far just with <code>Sum</code> and <code>Average</code>. For instance, you can use <code>Average</code> to calculate a root-mean-square:</p>

<pre data-type="programlisting">
Math.Sqrt (numbers.Average (n =&gt; n * n))</pre>

<p>You can even calculate standard deviation:</p>

<pre data-type="programlisting">
double mean = numbers.Average();
double sdev = Math.Sqrt (numbers.Average (n =&gt;
              {
                double dif = n - mean;
                return dif * dif;
              }));</pre>

<p>Both are safe, efficient, and fully parallelizable. In <a data-type="xref" href="ch22.html#parallel_programming-id00071">Chapter 22</a>, we give a practical example of a custom aggregation that can’t be reduced to <code>Sum</code> or <code>Average</code><a contenteditable="false" data-primary="" data-startref="ch09.html29" data-type="indexterm" id="id3345"/>.<a contenteditable="false" data-primary="" data-startref="ch09.html28" data-type="indexterm" id="id3346"/><a contenteditable="false" data-primary="" data-startref="ch09.html27" data-type="indexterm" id="id3347"/></p>
</div>
</div></section>
</div></section>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Quantifiers" data-type="sect1"><div class="sect1" id="quantifiers-id00082">
<h1 class="less_space">Quantifiers</h1>

<p><a contenteditable="false" data-primary="quantifiers" data-type="indexterm" id="id3348"/><a contenteditable="false" data-primary="quantifiers" data-secondary="LINQ" data-type="indexterm" id="id3349"/><code>IEnumerable&lt;TSource&gt;</code>→<code><em>bool</em></code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
			<th>SQL equivalents</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Contains</code></td>
			<td>Returns <code>true</code> if the input sequence contains the given element</td>
			<td><code>WHERE</code> ... <code>IN (</code>...<code>)</code></td>
		</tr>
		<tr>
			<td><code>Any</code></td>
			<td>Returns <code>true</code> if any elements satisfy the given predicate</td>
			<td><code>WHERE</code> ... <code>IN (</code>...<code>)</code></td>
		</tr>
		<tr>
			<td><code>All</code></td>
			<td>Returns <code>true</code> if all elements satisfy the given predicate</td>
			<td><code>WHERE (</code>...<code>)</code></td>
		</tr>
		<tr>
			<td><span class="keep-together"><code>SequenceEqual</code></span></td>
			<td>Returns <code>true</code> if the second sequence has identical elements to the input sequence</td>
			<td> </td>
		</tr>
	</tbody>
</table>

<section data-pdf-bookmark="Contains and Any" data-type="sect2"><div class="sect2" id="contains_and_any">
<h2>Contains and Any</h2>

<p><a contenteditable="false" data-primary="Any method" data-type="indexterm" id="id3350"/><a contenteditable="false" data-primary="Contains method" data-type="indexterm" id="id3351"/>The <code>Contains</code> method accepts an argument of type <code>TSource</code>; <code>Any</code> accepts an optional <em>predicate</em>.</p>

<p><code>Contains</code> returns <code>true</code> if the given element is present:</p>

<pre data-type="programlisting">
bool hasAThree = new int[] { 2, 3, 4 }.Contains (3);       // true;</pre>

<p><code>Any</code> returns <code>true</code> if the given expression is true for at least one element. We can rewrite the preceding query with <code>Any</code> as follows:</p>

<pre data-type="programlisting">
bool hasAThree = new int[] { 2, 3, 4 }.Any (n =&gt; n == 3);  // true;</pre>

<p><code>Any</code> can do everything that <code>Contains</code> can do, and more:</p>

<pre data-type="programlisting">
bool hasABigNumber = new int[] { 2, 3, 4 }.Any (n =&gt; n &gt; 10);  // false;</pre>

<p>Calling <code>Any</code> without a predicate returns <code>true</code> if the sequence has one or more elements. Here’s another way to write the preceding query:</p>

<pre data-type="programlisting">
bool hasABigNumber = new int[] { 2, 3, 4 }.Where (n =&gt; n &gt; 10).Any();</pre>

<p><code>Any</code> is particularly useful in subqueries and is used often when querying databases; for example:</p>

<pre data-type="programlisting">
from c in dbContext.Customers
where c.Purchases.Any (p =&gt; p.Price &gt; 1000)
select c</pre>
</div></section>

<section data-pdf-bookmark="All and SequenceEqual" data-type="sect2"><div class="sect2" id="all_and_sequenceequal">
<h2>All and SequenceEqual</h2>

<p><a contenteditable="false" data-primary="All method" data-type="indexterm" id="id3352"/><a contenteditable="false" data-primary="SequenceEqual method" data-type="indexterm" id="id3353"/><code>All</code> returns <code>true</code> if all elements satisfy a predicate. The following returns customers whose purchases are less than $100:</p>

<pre data-type="programlisting">
dbContext.Customers.Where (c =&gt; c.Purchases.All (p =&gt; p.Price &lt; 100));</pre>

<p><code>SequenceEqual</code> compares two sequences. To return <code>true</code>, each sequence must have identical elements, in the identical order. You can optionally provide an equality comparer; the default is <code>EqualityComparer&lt;T&gt;.Default</code>.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Generation Methods" data-type="sect1"><div class="sect1" id="generation_methods">
<h1>Generation Methods</h1>

<p><a contenteditable="false" data-primary="LINQ operators" data-secondary="generation methods" data-type="indexterm" id="id3354"/><code>void</code>→<code>IEnumerable&lt;TResult&gt;</code></p>

<table class="border">
	<thead>
		<tr>
			<th>Method</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Empty</code></td>
			<td>Creates an empty sequence</td>
		</tr>
		<tr>
			<td><code>Repeat</code></td>
			<td>Creates a sequence of repeating elements</td>
		</tr>
		<tr>
			<td><code>Range</code></td>
			<td>Creates a sequence of integers</td>
		</tr>
	</tbody>
</table>

<p><code>Empty</code>, <code>Repeat</code>, and <code>Range</code> are static (nonextension) methods that manufacture simple local sequences.</p>

<section data-pdf-bookmark="Empty" data-type="sect2"><div class="sect2" id="empty">
<h2>Empty</h2>

<p><a contenteditable="false" data-primary="Empty operator" data-type="indexterm" id="id3355"/><code>Empty</code> manufactures an empty sequence and requires just a type argument:</p>

<pre data-type="programlisting">
foreach (string s in Enumerable.Empty&lt;string&gt;())
  Console.Write (s);                              // &lt;nothing&gt;</pre>

<p>In conjunction with the <code>??</code> operator, <code>Empty</code> does the reverse of <code>DefaultIfEmpty</code>. For example, suppose that we have a jagged array of integers and we want to get all the integers into a single flat list. The following <code>SelectMany</code> query fails if any of the inner arrays is null:</p>

<pre data-type="programlisting">
int[][] numbers =
{
  new int[] { 1, 2, 3 },
  new int[] { 4, 5, 6 },
  null                     // this null makes the query below fail.
};

IEnumerable&lt;int&gt; flat = numbers.SelectMany (innerArray =&gt; innerArray);</pre>

<p><code>Empty</code> in conjunction with <code>??</code> fixes the problem:</p>

<pre data-type="programlisting">
IEnumerable&lt;int&gt; flat = numbers
  .SelectMany (innerArray =&gt; <strong>innerArray ?? Enumerable.Empty &lt;int&gt;()</strong>);

foreach (int i in flat)
  Console.Write (i + " ");     // 1 2 3 4 5 6</pre>
</div></section>

<section data-pdf-bookmark="Range and Repeat" data-type="sect2"><div class="sect2" id="range_and_repeat">
<h2>Range and Repeat</h2>

<p><a contenteditable="false" data-primary="Range operator" data-type="indexterm" id="id3356"/><code>Range</code> accepts a starting index and count (both integers):</p>

<pre data-type="programlisting">
foreach (int i in Enumerable.Range (5, 3))
  Console.Write (i + " ");                    // 5 6 7</pre>

<p><a contenteditable="false" data-primary="Repeat operator" data-type="indexterm" id="id3357"/><code>Repeat</code> accepts an element to repeat, and the number of repetitions:<a contenteditable="false" data-primary="" data-startref="ch09.html0" data-type="indexterm" id="id3358"/></p>

<pre data-type="programlisting">
foreach (bool x in Enumerable.Repeat (true, 3))
  Console.Write (x + " ");                    // True True True</pre>
</div></section>
</div></section>
</div></section></body></html>