<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Creating Types in C#</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Creating Types in C#" data-pdf-bookmark="Chapter 3. Creating Types in C#" data-type="chapter" epub:type="chapter"><div class="chapter" id="creating_types_in_chash">
<h1><span class="label">Chapter 3. </span>Creating Types in C#</h1>
<p><a contenteditable="false" data-primary="type system, C#" data-secondary="creating types" data-type="indexterm" id="ch03.html100"/>In this chapter, we delve into types and type members.</p>
<section data-pdf-bookmark="Classes" data-type="sect1"><div class="sect1" id="classes">
<h1>Classes</h1>
<p><a contenteditable="false" data-primary="classes" data-type="indexterm" id="ch03.html101"/>A class is the most common kind of reference type. The simplest possible class declaration is as follows:</p>
<pre data-type="programlisting">class YourClassName
{
}</pre>
<p>A more complex class optionally has the following:</p>
<table class="border">
<tbody>
<tr>
<td>Preceding the keyword <code>class</code></td>
<td><em>Attributes</em> and <em>class modifiers</em>. The non-nested class modifiers are <code>public</code>, <span class="keep-together"><code>internal</code></span>, <code>abstract</code>, <code>sealed</code>, <code>static</code>, <code>unsafe</code>, and <code>partial</code>.</td>
</tr>
<tr>
<td>Following <code>YourClassName</code></td>
<td><em>Generic type parameters</em> and <em>constraints</em>, a <em>base class</em>, and <em>interfaces</em>.</td>
</tr>
<tr>
<td>Within the braces</td>
<td><em>Class members</em> (these are <em>methods</em>, <em>properties</em>, <em>indexers</em>, <em>events</em>, <em>fields</em>, <em>constructors</em>, <em>overloaded operators</em>, <em>nested types</em>, and a <em>finalizer</em>).</td>
</tr>
</tbody>
</table>
<p>This chapter covers all of these constructs except attributes, operator functions, and the <code>unsafe</code> keyword, which are covered in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>. The following sections enumerate each of the class members.</p>
<section data-pdf-bookmark="Fields" data-type="sect2"><div class="sect2" id="fields">
<h2>Fields</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="fields" data-type="indexterm" id="id1986"/><a contenteditable="false" data-primary="fields" data-type="indexterm" id="id1987"/>A <em>field</em> is a variable that is a member of a class or struct; for example:</p>
<pre data-type="programlisting">class Octopus
{
  <strong>string name;</strong>
  <strong>public int Age = 10;</strong>
}</pre>
<p>Fields allow the following modifiers:</p>
<table class="border">
<tbody>
<tr>
<td>Static modifier</td>
<td><code>static</code></td>
</tr>
<tr>
<td>Access modifiers</td>
<td><code>public internal private protected</code></td>
</tr>
<tr>
<td>Inheritance modifier</td>
<td><code>new</code></td>
</tr>
<tr>
<td>Unsafe code modifier</td>
<td><code>unsafe</code></td>
</tr>
<tr>
<td>Read-only modifier</td>
<td><code>readonly</code></td>
</tr>
<tr>
<td>Threading modifier</td>
<td><code>volatile</code></td>
</tr>
</tbody>
</table>
<p>There are two popular naming conventions for private fields: camel-cased (e.g., <code>firstName</code>), and camel-cased with an underscore (<code>_firstName</code>). The latter convention lets you instantly distinguish private fields from parameters and local variables.</p>
<section data-pdf-bookmark="The readonly modifier" data-type="sect3"><div class="sect3" id="the_readonly_modifier">
<h3>The readonly modifier</h3>
<p><a contenteditable="false" data-primary="fields" data-secondary="readonly modifier" data-type="indexterm" id="id1988"/><a contenteditable="false" data-primary="readonly modifier" data-type="indexterm" id="id1989"/>The <code>readonly</code> modifier prevents a field from being modified after construction. A read-only field can be assigned only in its declaration or within the enclosing type’s constructor.</p>
</div></section>
<section data-pdf-bookmark="Field initialization" data-type="sect3"><div class="sect3" id="field_initialization">
<h3>Field initialization</h3>
<p><a contenteditable="false" data-primary="fields" data-secondary="initialization" data-type="indexterm" id="id1990"/><a contenteditable="false" data-primary="initialization" data-secondary="fields" data-type="indexterm" id="id1991"/>Field initialization is optional. An uninitialized field has a default value (<code>0</code>, <code>'\0'</code>, <code>null</code>, <code>false</code>). Field initializers run before constructors:</p>
<pre data-type="programlisting">public int Age = 10;</pre>
<p>A field initializer can contain expressions and call methods:</p>
<pre data-type="programlisting">static readonly string TempFolder = System.IO.Path.GetTempPath();</pre>
</div></section>
<section data-pdf-bookmark="Declaring multiple fields together" data-type="sect3"><div class="sect3" id="declaring_multiple_fields_together">
<h3>Declaring multiple fields together</h3>
<p><a contenteditable="false" data-primary="fields" data-secondary="declaring multiple fields together" data-type="indexterm" id="id1992"/>For convenience, you can declare multiple fields of the same type in a comma-separated list. This is a convenient way for all the fields to share the same attributes and field modifiers:</p>
<pre data-type="programlisting">static readonly int legs = 8,
                    eyes = 2;</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Constants" data-type="sect2"><div class="sect2" id="constants">
<h2>Constants</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="constants" data-type="indexterm" id="ch03.html102"/><a contenteditable="false" data-primary="constants" data-type="indexterm" id="ch03.html103"/>A <em>constant</em> is evaluated statically at compile time, and the compiler literally substitutes its value whenever used (rather like a macro in C++). A constant can be <code>bool</code>, <code>char</code>, <code>string</code>, any of the built-in numeric types, or an enum type.</p>
<p class="pagebreak-before">A constant is declared with the <code>const</code> keyword and must be initialized with a value. For example:</p>
<pre data-type="programlisting">public class Test
{
  <strong>public const string Message = "Hello World";</strong>
}</pre>
<p><a contenteditable="false" data-primary="static readonly field" data-type="indexterm" id="id1993"/>A constant can serve a similar role to a <code>static readonly</code> field, but it is much more restrictive—both in the types you can use and in field initialization semantics. A constant also differs from a <code>static readonly</code> field in that the evaluation of the constant occurs at compile time; thus</p>
<pre data-type="programlisting">public static double Circumference (double radius)
{
  return 2 * System.Math.PI * radius;
}</pre>
<p>is compiled to</p>
<pre data-type="programlisting">public static double Circumference (double radius)
{
  return 6.2831853071795862 * radius;
}</pre>
<p>It makes sense for <code>PI</code> to be a constant because its value is predetermined at compile time. In contrast, a <code>static readonly</code> field’s value can potentially differ each time the program is run:</p>
<pre data-type="programlisting">static readonly DateTime StartupTime = DateTime.Now;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <code>static readonly</code> field is also advantageous when exposing to other assemblies a value that might change in a later version. For instance, suppose that assembly <code>X</code> exposes a constant as follows:</p>
<pre data-type="programlisting">public const decimal ProgramVersion = 2.3;</pre>
<p>If assembly <code>Y</code> references <code>X</code> and uses this constant, the value <code>2.3</code> will be baked into assembly <code>Y</code> when compiled. This means that if <code>X</code> is later recompiled with the constant set to 2.4, <code>Y</code> will still use the old value of 2.3 <em>until</em> <code>Y</code> <em>is recompiled</em>. A <code>static readonly</code> field avoids this problem.</p>
<p>Another way of looking at this is that any value that might change in the future is not constant by definition; thus, it should not be represented as one.</p>
</div>
<p>Constants can also be declared local to a method:</p>
<pre data-type="programlisting">void Test()
{
  <strong>const</strong> double twoPI = 2 * System.Math.PI;
  ...
}</pre>
<p class="pagebreak-before">Nonlocal constants allow the following modifiers:<a contenteditable="false" data-primary="" data-startref="ch03.html103" data-type="indexterm" id="id1994"/><a contenteditable="false" data-primary="" data-startref="ch03.html102" data-type="indexterm" id="id1995"/></p>
<table class="border">
<tbody>
<tr>
<td>Access modifiers</td>
<td><code>public internal private protected</code></td>
</tr>
<tr>
<td>Inheritance modifier</td>
<td><code>new</code></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Methods" data-type="sect2"><div class="sect2" id="methods">
<h2>Methods</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="methods" data-type="indexterm" id="ch03.html104"/><a contenteditable="false" data-primary="methods" data-type="indexterm" id="ch03.html105"/>A method performs an action in a series of statements. <a contenteditable="false" data-primary="return types" data-type="indexterm" id="id1996"/>A method can receive <em>input</em> data from the caller by specifying <em>parameters</em> and <em>output</em> data back to the caller by specifying a <em>return type</em>. A method can specify a <code>void</code> return type, indicating that it doesn’t return any value to its caller. A method can also output data back to the caller via <code>ref</code>/<code>out</code> parameters.</p>
<p><a contenteditable="false" data-primary="signature" data-type="indexterm" id="id1997"/>A method’s <em>signature</em> must be unique within the type. A method’s signature comprises its name and parameter types in order (but not the parameter <em>names</em>, nor the return type).</p>
<p>Methods allow the following modifiers:</p>
<table class="border">
<tbody>
<tr>
<td>Static modifier</td>
<td><code>static</code></td>
</tr>
<tr>
<td>Access modifiers</td>
<td><code>public internal private protected</code></td>
</tr>
<tr>
<td>Inheritance modifiers</td>
<td><code>new virtual abstract override sealed</code></td>
</tr>
<tr>
<td>Partial method modifier</td>
<td><code>partial</code></td>
</tr>
<tr>
<td>Unmanaged code modifiers</td>
<td><code>unsafe extern</code></td>
</tr>
<tr>
<td>Asynchronous code modifier</td>
<td><code>async</code></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Expression-bodied methods" data-type="sect3"><div class="sect3" id="expression_bodied_methods">
<h3>Expression-bodied methods</h3>
<p><a contenteditable="false" data-primary="expression-bodied methods" data-type="indexterm" id="id1998"/><a contenteditable="false" data-primary="methods" data-secondary="expression-bodied" data-type="indexterm" id="id1999"/>A method that comprises a single expression, such as</p>
<pre data-type="programlisting">int Foo (int x) { return x * 2; }</pre>
<p>can be written more tersely as an <em>expression-bodied method</em>. A fat arrow replaces the braces and <code>return</code> keyword:</p>
<pre data-type="programlisting">int Foo (int x) <strong>=&gt; x * 2;</strong></pre>
<p>Expression-bodied functions can also have a void return type:</p>
<pre data-type="programlisting"><strong>void</strong> Foo (int x) <strong>=&gt; Console.WriteLine (x);</strong></pre>
</div></section>
<section data-pdf-bookmark="Local methods" data-type="sect3"><div class="sect3" id="local_methods-id00077">
<h3>Local methods</h3>
<p><a contenteditable="false" data-primary="local methods" data-type="indexterm" id="id2000"/><a contenteditable="false" data-primary="methods" data-secondary="local methods" data-type="indexterm" id="id2001"/>You can define a method within another method:</p>
<pre data-type="programlisting">void WriteCubes()
{
  Console.WriteLine (Cube (3));
  Console.WriteLine (Cube (4));
  Console.WriteLine (Cube (5));

  int Cube (int value) =&gt; value * value * value;
}</pre>
<p>The local method (<code>Cube</code>, in this case) is visible only to the enclosing method (<code>WriteCubes</code>). This simplifies the containing type and instantly signals to anyone looking at the code that <code>Cube</code> is used nowhere else. Another benefit of local methods is that they can access the local variables and parameters of the enclosing method. This has a number of consequences, which we describe in detail in <a data-type="xref" href="ch04.html#capturing_outer_variables">“Capturing Outer Variables”</a>.</p>
<p>Local methods can appear within other function kinds, such as property accessors, constructors, and so on. You can even put local methods inside other local methods, and inside lambda expressions that use a statement block (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>). Local methods can be iterators (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>) or asynchronous (<a data-type="xref" href="ch14.html#concurrency_and_asynchron">Chapter 14</a>).</p>
</div></section>
<section data-pdf-bookmark="Static local methods" data-type="sect3"><div class="sect3" id="static_local_methods-id00090">
<h3>Static local methods</h3>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="static local methods" data-type="indexterm" id="id2002"/><a contenteditable="false" data-primary="local methods" data-secondary="static local methods" data-type="indexterm" id="id2003"/><a contenteditable="false" data-primary="static local methods" data-type="indexterm" id="id2004"/>Adding the <code>static</code> modifier to a local method (from C# 8) prevents it from seeing the local variables and parameters of the enclosing method. This helps to reduce coupling and prevents the local method from accidentally referring to variables in the containing method.</p>
</div></section>
<section data-pdf-bookmark="Local methods and top-level statements" data-type="sect3"><div class="sect3" id="local_methods_and_top_level_statements">
<h3>Local methods and top-level statements</h3>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="top-level statements" data-type="indexterm" id="id2005"/><a contenteditable="false" data-primary="local methods" data-secondary="top-level statements and" data-type="indexterm" id="id2006"/><a contenteditable="false" data-primary="top-level statements" data-secondary="local methods and" data-type="indexterm" id="id2007"/>Any methods that you declare in top-level statements are treated as local methods. This means that (unless marked as <code>static</code>) they can access the variables in the top-level statements:</p>
<pre data-type="programlisting">int x = 3;
Foo();

void Foo() =&gt; Console.WriteLine (x);</pre>
</div></section>
<section data-pdf-bookmark="Overloading methods" data-type="sect3"><div class="sect3" id="overloading_methods">
<h3>Overloading methods</h3>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a contenteditable="false" data-primary="methods" data-secondary="overloading" data-type="indexterm" id="id2008"/><a contenteditable="false" data-primary="overloading" data-secondary="overloading methods" data-type="indexterm" id="id2009"/>Local methods cannot be overloaded. This means that methods declared in top-level statements (which are treated as local methods) cannot be overloaded.</p>
</div>
<p>A type can <em>overload</em> methods (define multiple methods with the same name) as long as the signatures are different. For example, the following methods can all coexist in the same type:</p>
<pre data-type="programlisting">void Foo (int x) {...}
void Foo (double x) {...}
void Foo (int x, float y) {...}
void Foo (float x, int y) {...}</pre>
<p>However, the following pairs of methods cannot coexist in the same type, because the return type and the <code>params</code> modifier are not part of a method’s signature:</p>
<pre data-type="programlisting">void  Foo (int x) {...}
float Foo (int x) {...}           // Compile-time error

void  Goo (int[] x) {...}
void  Goo (params int[] x) {...}  // Compile-time error</pre>
<p>Whether a parameter is pass-by-value or pass-by-reference is also part of the signature. For example, <code>Foo(int)</code> can coexist with either <code>Foo(ref int)</code> or <code>Foo(out int)</code>. However, <code>Foo(ref int)</code> and <code>Foo(out int)</code> cannot coexist:<a contenteditable="false" data-primary="" data-startref="ch03.html105" data-type="indexterm" id="id2010"/><a contenteditable="false" data-primary="" data-startref="ch03.html104" data-type="indexterm" id="id2011"/></p>
<pre data-type="programlisting">void Foo (int x) {...}
void Foo (ref int x) {...}     // OK so far
void Foo (out int x) {...}     // Compile-time error</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Instance Constructors" data-type="sect2"><div class="sect2" id="instance_constructors">
<h2>Instance Constructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="instance constructors" data-type="indexterm" id="id2012"/><a contenteditable="false" data-primary="constructors" data-secondary="instance constructors" data-type="indexterm" id="id2013"/><a contenteditable="false" data-primary="instance constructors" data-type="indexterm" id="id2014"/>Constructors run initialization code on a class or struct. A constructor is defined like a method, except that the method name and return type are reduced to the name of the enclosing type:</p>
<pre data-type="programlisting">Panda p = new Panda ("Petey");   // Call constructor

public class Panda
{
  string name;                   // Define field
  <strong>public Panda (string n)        // Define constructor</strong>
  <strong>{</strong>
    <strong>name = n;                    // Initialization code (set up field)</strong>
  <strong>}</strong>
}</pre>
<p>Instance constructors allow the following modifiers:</p>
<table class="border">
<tbody>
<tr>
<td>Access modifiers</td>
<td><code>public internal private protected</code></td>
</tr>
<tr>
<td>Unmanaged code modifiers</td>
<td><code>unsafe extern</code></td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="=&gt; (expression-bodied members)" data-type="indexterm" id="id2015"/><a contenteditable="false" data-primary="=&gt; (fat arrow notation)" data-type="indexterm" id="id2016"/><a contenteditable="false" data-primary="expression-bodied members (=&gt;)" data-type="indexterm" id="id2017"/><a contenteditable="false" data-primary="fat arrow notation (=&gt;)" data-type="indexterm" id="id2018"/>Single-statement constructors can also be written as expression-bodied members:</p>
<pre data-type="programlisting">public Panda (string n) =&gt; name = n;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If a parameter name (or any variable name, for that matter) conflicts with a field name, you can disambiguate by prefixing the field with a <code>this</code> reference:</p>
<pre data-type="programlisting">public Panda (string name) =&gt; <strong>this.</strong>name = name;</pre>
</div>
<section data-pdf-bookmark="Overloading constructors" data-type="sect3"><div class="sect3" id="overloading_constructors">
<h3>Overloading constructors</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="overloading" data-type="indexterm" id="id2019"/><a contenteditable="false" data-primary="instance constructors" data-secondary="overloading" data-type="indexterm" id="id2020"/><a contenteditable="false" data-primary="overloading" data-secondary="instance constructors" data-type="indexterm" id="id2021"/>A class or struct may overload constructors. <a contenteditable="false" data-primary="this keyword" data-type="indexterm" id="id2022"/>To avoid code duplication, one constructor can call another, using the <code>this</code> keyword:</p>
<pre data-type="programlisting">public class Wine
{
  public decimal Price;
  public int Year;
  public Wine (decimal price) =&gt; Price = price;
  public Wine (decimal price, int year) <strong>: this (price)</strong> =&gt; Year = year;
}</pre>
<p>When one constructor calls another, the <em>called constructor</em> executes first.</p>
<p>You can pass an <em>expression</em> into another constructor, as follows:</p>
<pre data-type="programlisting">public Wine (decimal price, DateTime year) : this (price, <strong>year.Year</strong>) { }</pre>
<p>The expression can access static members of the class but not instance members. (This is enforced because the object has not been initialized by the constructor at this stage, so any methods that you call on it are likely to fail.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This particular example could be better implemented with a single constructor that has <code>year</code> as an optional parameter:</p>
<pre data-type="programlisting">public Wine (decimal price, int year = 0)
{
  Price = price; Year = year;
}</pre>
<p>We will offer yet another solution shortly, in <a data-type="xref" href="#object_initializers">“Object Initializers”</a>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Implicit parameterless constructors" data-type="sect3"><div class="sect3" id="implicit_parameterless_constructors">
<h3>Implicit parameterless constructors</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="implicit parameterless" data-type="indexterm" id="id2023"/><a contenteditable="false" data-primary="instance constructors" data-secondary="implicit parameterless" data-type="indexterm" id="id2024"/>For classes, the C# compiler automatically generates a parameterless public constructor if and only if you do not define any constructors. However, as soon as you define at least one constructor, the parameterless constructor is no longer automatically generated.</p>
</div></section>
<section data-pdf-bookmark="Constructor and field initialization order" data-type="sect3"><div class="sect3" id="constructor_and_field_initializ-id00007">
<h3>Constructor and field initialization order</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="instance constructor and field initialization order" data-type="indexterm" id="id2025"/><a contenteditable="false" data-primary="fields" data-secondary="constructor and field initialization order" data-type="indexterm" id="id2026"/><a contenteditable="false" data-primary="initialization" data-secondary="instance constructor and field initialization order" data-type="indexterm" id="id2027"/><a contenteditable="false" data-primary="instance constructors" data-secondary="constructor and field initialization order" data-type="indexterm" id="id2028"/>We previously saw that fields can be initialized with default values in their <span class="keep-together">declaration:</span></p>
<pre data-type="programlisting">class Player
{
  int shields = 50;   // Initialized first
  int health = 100;   // Initialized second
}</pre>
<p>Field initializations occur <em>before</em> the constructor is executed, and in the declaration order of the fields.</p>
</div></section>
<section data-pdf-bookmark="Nonpublic constructors" data-type="sect3"><div class="sect3" id="nonpublic_constructors">
<h3>Nonpublic constructors</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="nonpublic constructors" data-type="indexterm" id="id2029"/><a contenteditable="false" data-primary="instance constructors" data-secondary="nonpublic constructors" data-type="indexterm" id="id2030"/><a contenteditable="false" data-primary="nonpublic constructors" data-type="indexterm" id="id2031"/>Constructors need not be public. A common reason to have a nonpublic constructor is to control instance creation via a static method call. The static method could be used to return an object from a pool rather than creating a new object, or to return various subclasses based on input arguments:</p>
<pre class="pagebreak-before" data-type="programlisting">public class Class1
{
  Class1() {}                             // Private constructor
  public static Class1 Create (...)
  {
    // Perform custom logic here to return an instance of Class1
    ...
  }
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Deconstructors" data-type="sect2"><div class="sect2" id="deconstructors-id00060">
<h2>Deconstructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="deconstructors" data-type="indexterm" id="ch03.html106"/><a contenteditable="false" data-primary="constructors" data-secondary="deconstructors and" data-type="indexterm" id="ch03.html107"/><a contenteditable="false" data-primary="deconstructors" data-type="indexterm" id="ch03.html108"/>A deconstructor (also called a <em>deconstructing method</em>) acts as an approximate opposite to a constructor: whereas a constructor typically takes a set of values (as parameters) and assigns them to fields, a deconstructor does the reverse and assigns fields back to a set of variables.</p>
<p><a contenteditable="false" data-primary="Deconstruct method" data-type="indexterm" id="id2032"/>A deconstruction method must be called <code>Deconstruct</code> and must have one or more <code>out</code> parameters, such as in the following class:</p>
<pre data-type="programlisting">class Rectangle
{
  public readonly float Width, Height;
  
  public Rectangle (float width, float height)
  {
    Width = width;
    Height = height;
  }
  
  <strong>public void Deconstruct (out float width, out float height)</strong>
  <strong>{</strong>
    <strong>width = Width;</strong>
    <strong>height = Height;</strong>
  <strong>}</strong>
}</pre>
<p>The following special syntax calls the deconstructor:</p>
<pre data-type="programlisting">var rect = new Rectangle (3, 4);
<strong>(float width, float height) = rect;          // Deconstruction</strong>
Console.WriteLine (width + " " + height);    // 3 4</pre>
<p>The second line is the deconstructing call. It creates two local variables and then calls the <code>Deconstruct</code> method. Our deconstructing call is equivalent to the <span class="keep-together">following:</span></p>
<pre data-type="programlisting">float width, height;
rect.Deconstruct (out width, out height);</pre>
<p>Or:</p>
<pre data-type="programlisting">rect.Deconstruct (out var width, out var height);</pre>
<p class="pagebreak-before">Deconstructing calls allow implicit typing, so we could shorten our call to this:</p>
<pre data-type="programlisting">(<strong>var</strong> width, <strong>var</strong> height) = rect;</pre>
<p>Or simply this:</p>
<pre data-type="programlisting"><strong>var</strong> (width, height) = rect;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can use C#’s discard symbol (<code>_</code>) if you’re uninterested in one or more variables:</p>
<pre data-type="programlisting">var (<strong>_</strong>, height) = rect;</pre>
<p>This better indicates your intention than declaring a variable that you never use.</p>
</div>
<p>If the variables into which you’re deconstructing are already defined, omit the types altogether:</p>
<pre data-type="programlisting"><strong>float width, height;</strong>
<strong>(width, height) = rect;</strong></pre>
<p><a contenteditable="false" data-primary="deconstructing assignment" data-type="indexterm" id="id2033"/>This is called a <em>deconstructing assignment</em>. You can use a deconstructing assignment to simplify your class’s constructor:</p>
<pre data-type="programlisting">public Rectangle (float width, float height) =&gt;
  (Width, Height) = (width, height);</pre>
<p>You can offer the caller a range of deconstruction options by overloading the <code>Deconstruct</code> method.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>Deconstruct</code> method can be an extension method (see <a data-type="xref" href="ch04.html#extension_methods">“Extension Methods”</a>). This is a useful trick if you want to deconstruct types that you did not author.</p>
</div>
<p>From C# 10, you can mix and match existing and new variables when <span class="keep-together">deconstructing:</span><a contenteditable="false" data-primary="" data-startref="ch03.html108" data-type="indexterm" id="id2034"/><a contenteditable="false" data-primary="" data-startref="ch03.html107" data-type="indexterm" id="id2035"/><a contenteditable="false" data-primary="" data-startref="ch03.html106" data-type="indexterm" id="id2036"/></p>
<pre data-type="programlisting">double x1 = 0;
(x1, double y2) = rect;</pre>
</div></section>
<section data-pdf-bookmark="Object Initializers" data-type="sect2"><div class="sect2" id="object_initializers">
<h2>Object Initializers</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="object initializers" data-type="indexterm" id="id2037"/><a contenteditable="false" data-primary="initialization" data-secondary="object initializers" data-type="indexterm" id="id2038"/><a contenteditable="false" data-primary="object initializers" data-type="indexterm" id="id2039"/>To simplify object initialization, any accessible fields or properties of an object can be set via an <em>object initializer</em> directly after construction. For example, consider the following class:</p>
<pre data-type="programlisting">public class Bunny
{
  public string Name;
  public bool LikesCarrots, LikesHumans;

  public Bunny () {}
  public Bunny (string n) =&gt; Name = n;
}</pre>
<p class="pagebreak-before">Using object initializers, you can instantiate <code>Bunny</code> objects as follows:</p>
<pre data-type="programlisting">// Note parameterless constructors can omit empty parentheses
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
Bunny b2 = new Bunny ("Bo")     { LikesCarrots=true, LikesHumans=false };</pre>
<p>The code to construct <code>b1</code> and <code>b2</code> is precisely equivalent to the following:</p>
<pre data-type="programlisting">Bunny <em>temp1</em> = new Bunny();    // <em>temp1</em> is a compiler-generated name
<em>temp1</em>.Name = "Bo";
<em>temp1</em>.LikesCarrots = true;
<em>temp1</em>.LikesHumans = false;
Bunny b1 = <em>temp1</em>;

Bunny <em>temp2</em> = new Bunny ("Bo");
<em>temp2</em>.LikesCarrots = true;
<em>temp2</em>.LikesHumans = false;
Bunny b2 = <em>temp2</em>;</pre>
<p>The temporary variables are to ensure that if an exception is thrown during initialization, you can’t end up with a half-initialized object.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="object_initializers_versus_optional_par">
<h1>Object Initializers Versus Optional Parameters</h1>
<p><a contenteditable="false" data-primary="object initializers" data-secondary="optional parameters versus" data-type="indexterm" id="id2040"/><a contenteditable="false" data-primary="optional parameters" data-secondary="object initializers versus" data-type="indexterm" id="id2041"/>Instead of relying on object initializers, we could write <code>Bunny</code>’s constructor as follows, with one mandatory and two optional parameters:</p>
<pre data-type="programlisting">public Bunny (string name,
              bool likesCarrots <strong>= false</strong>,
              bool likesHumans <strong>= false</strong>)
{
  Name = name;
  LikesCarrots = likesCarrots;
  LikesHumans = likesHumans; 
}</pre>
<p>This would allow us to construct a <code>Bunny</code> as follows:</p>
<pre data-type="programlisting">Bunny b1 = new Bunny (name: "Bo",
                      likesCarrots: true);</pre>
<p>Historically, relying on constructors for object initialization could be advantageous in that it allowed us to make <code>Bunny</code>’s fields (or <em>properties</em>, which we’ll explain shortly) read-only. Making fields or properties read-only is good practice when there’s no valid reason for them to change throughout the life of the object. However, as we’ll see soon in our discussion on properties, the <code>init</code> modifier that was introduced in C# 9 lets us achieve this goal with object initializers.</p>
<p>Optional parameters have two drawbacks. The first is that while their use in constructors allows for read-only types, they don’t (easily) allow for <em>nondestructive mutation</em>. (We’ll cover nondestructive mutation—and the solution to this problem—in <a data-type="xref" href="ch04.html#records-id00087">“Records”</a>.)</p>
<p>The second drawback of optional parameters is that when used in public libraries, they hinder backward compatibility. This is because the act of adding an optional parameter at a later date breaks the assembly’s <em>binary compatibility</em> with existing consumers. (This is particularly important when a library is published on NuGet: the problem becomes intractable when a consumer references packages <em>A</em> and <em>B</em>, if <em>A</em> and <em>B</em> each depend on incompatible versions of <em>L</em>.)</p>
<p><a contenteditable="false" data-primary="calling site" data-type="indexterm" id="id2042"/>The difficulty is that each optional parameter value is baked into the <em>calling site</em>. In other words, C# translates our constructor call into this:</p>
<pre data-type="programlisting">Bunny b1 = new Bunny ("Bo", true<strong>, false</strong>);</pre>
<p>This is problematic if we instantiate the <code>Bunny</code> class from another assembly and later modify <code>Bunny</code> by adding another optional parameter—such as <code>likesCats</code>. Unless the referencing assembly is also recompiled, it will continue to call the (now nonexistent) constructor with three parameters and fail at runtime. (A subtler problem is that if we changed the value of one of the optional parameters, callers in other assemblies would continue to use the old optional value until they were recompiled.)</p>
<p>A final consideration is the effect of constructors on subclassing (which we will cover in <a data-type="xref" href="#inheritance">“Inheritance”</a>). Having multiple constructors with long parameter lists makes subclassing cumbersome; therefore, it can help to keep constructors to a minimum in number and complexity and use object initializers to fill in the details.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="The this Reference" data-type="sect2"><div class="sect2" id="the_this_reference">
<h2>The this Reference</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="this reference" data-type="indexterm" id="id2043"/><a contenteditable="false" data-primary="this reference" data-type="indexterm" id="id2044"/>The <code>this</code> reference refers to the instance itself. In the following example, the <code>Marry</code> method uses <code>this</code> to set the <code>partner</code>’s <code>mate</code> field:</p>
<pre data-type="programlisting">public class Panda
{
  public Panda Mate;

  public void Marry (Panda partner)
  {
    Mate = partner;
    partner.Mate = this;
  }
}</pre>
<p>The <code>this</code> reference also disambiguates a local variable or parameter from a field; for example:</p>
<pre data-type="programlisting">public class Test
{
  string name;
  public Test (string name) =&gt; this.name = name;
}</pre>
<p>The <code>this</code> reference is valid only within nonstatic members of a class or struct.</p>
</div></section>
<section data-pdf-bookmark="Properties" data-type="sect2"><div class="sect2" id="properties">
<h2>Properties</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="properties" data-type="indexterm" id="ch03.html109"/>Properties look like fields from the outside, but internally they contain logic, like methods do. For example, you can’t tell by looking at the following code whether <code>CurrentPrice</code> is a field or a property:</p>
<pre data-type="programlisting">Stock msft = new Stock();
msft.CurrentPrice = 30;
msft.CurrentPrice -= 3;
Console.WriteLine (msft.CurrentPrice);</pre>
<p>A property is declared like a field but with a <code>get</code>/<code>set</code> block added. Here’s how to implement <code>CurrentPrice</code> as a property:</p>
<pre data-type="programlisting">public class Stock
{
  decimal currentPrice;           // The private "backing" field

  public decimal CurrentPrice     // The public property
  {
    get { return currentPrice; }
    set { currentPrice = value; }
  }
}</pre>
<p><a contenteditable="false" data-primary="accessors" data-type="indexterm" id="id2045"/><code>get</code> and <code>set</code> denote property <em>accessors</em>. The <code>get</code> accessor runs when the property is read. It must return a value of the property’s type. The <code>set</code> accessor runs when the property is assigned. It has an implicit parameter named <code>value</code> of the property’s type that you typically assign to a private field (in this case, <code>currentPrice</code>).</p>
<p><a contenteditable="false" data-primary="fields" data-secondary="properties versus" data-type="indexterm" id="id2046"/>Although properties are accessed in the same way as fields, they differ in that they give the implementer complete control over getting and setting its value. This control enables the implementer to choose whatever internal representation is needed without exposing the internal details to the user of the property. In this example, the <code>set</code> method could throw an exception if <code>value</code> was outside a valid range of values.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Throughout this book, we use public fields extensively to keep the examples free of distraction. In a real application, you would typically favor public properties over public fields in order to promote encapsulation.</p>
</div>
<p>Properties allow the following modifiers:</p>
<table class="border">
<tbody>
<tr>
<td>Static modifier</td>
<td><code>static</code></td>
</tr>
<tr>
<td>Access modifiers</td>
<td><code>public internal private protected</code></td>
</tr>
<tr>
<td>Inheritance modifiers</td>
<td><code>new virtual abstract override sealed</code></td>
</tr>
<tr>
<td>Unmanaged code modifiers</td>
<td><code>unsafe extern</code></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Read-only and calculated properties" data-type="sect3"><div class="sect3" id="read_only_and_calculated_properties">
<h3>Read-only and calculated properties</h3>
<p><a contenteditable="false" data-primary="calculated properties" data-type="indexterm" id="id2047"/><a contenteditable="false" data-primary="properties" data-secondary="calculated properties" data-type="indexterm" id="id2048"/><a contenteditable="false" data-primary="properties" data-secondary="read-only" data-type="indexterm" id="id2049"/><a contenteditable="false" data-primary="read-only properties" data-type="indexterm" id="id2050"/>A property is read-only if it specifies only a <code>get</code> accessor, and it is write-only if it specifies only a <code>set</code> accessor. Write-only properties are rarely used.</p>
<p>A property typically has a dedicated backing field to store the underlying data. However, a property can also be computed from other data:</p>
<pre data-type="programlisting">decimal currentPrice, sharesOwned;

public decimal Worth
{
  get { return currentPrice * sharesOwned; }
}</pre>
</div></section>
<section data-pdf-bookmark="Expression-bodied properties" data-type="sect3"><div class="sect3" id="expression_bodied_properties">
<h3>Expression-bodied properties</h3>
<p><a contenteditable="false" data-primary="=&gt; (expression-bodied members)" data-type="indexterm" id="id2051"/><a contenteditable="false" data-primary="=&gt; (fat arrow notation)" data-type="indexterm" id="id2052"/><a contenteditable="false" data-primary="expression-bodied members (=&gt;)" data-type="indexterm" id="id2053"/><a contenteditable="false" data-primary="expression-bodied properties" data-type="indexterm" id="id2054"/><a contenteditable="false" data-primary="fat arrow notation (=&gt;)" data-type="indexterm" id="id2055"/><a contenteditable="false" data-primary="properties" data-secondary="expression-bodied" data-type="indexterm" id="id2056"/>You can declare a read-only property, such as the one in the preceding example, more tersely as an <em>expression-bodied property</em>. A fat arrow replaces all the braces and the <code>get</code> and <code>return</code> keywords:</p>
<pre data-type="programlisting">public decimal Worth <strong>=&gt; currentPrice * sharesOwned;</strong></pre>
<p>With a little extra syntax, <code>set</code> accessors can also be expression-bodied:</p>
<pre data-type="programlisting">public decimal Worth
{
  <strong>get =&gt; currentPrice * sharesOwned;</strong>
  <strong>set =&gt; sharesOwned = value / currentPrice;</strong>
}</pre>
</div></section>
<section data-pdf-bookmark="Automatic properties" data-type="sect3"><div class="sect3" id="automatic_properties">
<h3>Automatic properties</h3>
<p><a contenteditable="false" data-primary="automatic properties" data-type="indexterm" id="id2057"/><a contenteditable="false" data-primary="properties" data-secondary="automatic" data-type="indexterm" id="id2058"/>The most common implementation for a property is a getter and/or setter that simply reads and writes to a private field of the same type as the property. An <em>automatic property</em> declaration instructs the compiler to provide this implementation. We can improve the first example in this section by declaring <code>CurrentPrice</code> as an automatic property:</p>
<pre data-type="programlisting">public class Stock
{
  ...
  public decimal CurrentPrice { get; set; }
}</pre>
<p>The compiler automatically generates a private backing field of a compiler-generated name that cannot be referred to. The <code>set</code> accessor can be marked <code>private</code> or <code>protected</code> if you want to expose the property as read-only to other types. Automatic properties were introduced in C# 3.0.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Property initializers" data-type="sect3"><div class="sect3" id="property_initializers">
<h3 class="less_space">Property initializers</h3>
<p><a contenteditable="false" data-primary="initialization" data-secondary="property initializer" data-type="indexterm" id="id2059"/><a contenteditable="false" data-primary="properties" data-secondary="property initializers" data-type="indexterm" id="id2060"/><a contenteditable="false" data-primary="property initializer" data-type="indexterm" id="id2061"/>You can add a <em>property initializer</em> to automatic properties, just as with fields:</p>
<pre data-type="programlisting">public decimal CurrentPrice { get; set; } = 123;</pre>
<p>This gives <code>CurrentPrice</code> an initial value of <code>123</code>. Properties with an initializer can be read-only:</p>
<pre data-type="programlisting">public int Maximum { get; } = 999;</pre>
<p>Just as with read-only fields, read-only automatic properties can also be assigned in the type’s constructor. This is useful in creating <em>immutable</em> (read-only) types.</p>
</div></section>
<section data-pdf-bookmark="get and set accessibility" data-type="sect3"><div class="sect3" id="get_and_set_accessibility">
<h3>get and set accessibility</h3>
<p><a contenteditable="false" data-primary="get accessor" data-type="indexterm" id="id2062"/><a contenteditable="false" data-primary="properties" data-secondary="get and set accessors" data-type="indexterm" id="id2063"/><a contenteditable="false" data-primary="set accessor" data-type="indexterm" id="id2064"/>The <code>get</code> and <code>set</code> accessors can have different access levels. The typical use case for this is to have a <code>public</code> property with an <code>internal</code> or <code>private</code> access modifier on the setter:</p>
<pre data-type="programlisting">public class Foo
{
  private decimal x;
  public decimal X
  {
    get         { return x;  }
    <strong>private</strong> set { x = Math.Round (value, 2); }
  }
}</pre>
<p>Notice that you declare the property itself with the more permissive access level (<code>public</code>, in this case) and add the modifier to the accessor you want to be <em>less</em> accessible.</p>
</div></section>
<section data-pdf-bookmark="Init-only setters" data-type="sect3"><div class="sect3" id="init_only_setters-id00074">
<h3>Init-only setters</h3>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="init-only setters" data-type="indexterm" id="id2065"/><a contenteditable="false" data-primary="init-only setters" data-type="indexterm" id="id2066"/>From C# 9, you can declare a property accessor with <code>init</code> instead of <code>set</code>:</p>
<pre data-type="programlisting">public class Note
{
  public int Pitch    { get; <strong>init</strong>; } = 20;   // “Init-only” property
  public int Duration { get; <strong>init</strong>; } = 100;  // “Init-only” property
}</pre>
<p>These <em>init-only</em> properties act like read-only properties, except that they can also be set via an object initializer:</p>
<pre data-type="programlisting">var note = new Note { <strong>Pitch = 50</strong> };</pre>
<p>After that, the property cannot be altered:</p>
<pre data-type="programlisting">note.Pitch = 200;  // Error – init-only setter!</pre>
<p>Init-only properties cannot even be set from inside their class, except via their property initializer, the constructor, or another init-only accessor.</p>
<p>The alternative to init-only properties is to have read-only properties that you populate via a constructor:</p>
<pre data-type="programlisting">public class Note
{
  public int Pitch    { <strong>get;</strong> }
  public int Duration { <strong>get;</strong> }

  public Note (<strong>int pitch = 20, int duration = 100</strong>)
  {
    <strong>Pitch = pitch; Duration = duration;</strong>
  }
}</pre>
<p>Should the class be part of a public library, this approach makes versioning difficult, in that adding an optional parameter to the constructor at a later date breaks binary compatibility with consumers (whereas adding a new init-only property breaks nothing).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Init-only properties have another significant advantage, which is that they allow for nondestructive mutation when used in conjunction with records (see <a data-type="xref" href="ch04.html#records-id00087">“Records”</a>).</p>
</div>
<p>Just as with ordinary <code>set</code> accessors, init-only accessors can provide an <span class="keep-together">implementation:</span></p>
<pre data-type="programlisting">public class Note
{
  readonly int _pitch;
  public int Pitch { get =&gt; _pitch; <strong>init =&gt; _pitch = value;</strong> }
  ...</pre>
<p>Notice that the <code>_pitch</code> field is read-only: init-only setters are permitted to modify <code>readonly</code> fields in their own class. (Without this feature, <code>_pitch</code> would need to be writable, and the class would fail at being internally immutable.)</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Changing a property’s accessor from <code>init</code> to <code>set</code> (or vice versa) is a <em>binary breaking change</em>: anyone that references your assembly will need to recompile their assembly.</p>
<p>This should not be an issue when creating wholly immutable types, in that your type will never require properties with a (writable) <code>set</code> accessor.</p>
</div>
</div></section>
<section data-pdf-bookmark="CLR property implementation" data-type="sect3"><div class="sect3" id="clr_property_implementation">
<h3>CLR property implementation</h3>
<p><a contenteditable="false" data-primary="CLR (Common Language Runtime)" data-secondary="property implementation" data-type="indexterm" id="id2067"/><a contenteditable="false" data-primary="properties" data-secondary="CLR property implementation" data-type="indexterm" id="id2068"/>C# property accessors internally compile to methods called <code>get_<em>XXX</em></code> and <code>set_<em>XXX</em></code>:</p>
<pre data-type="programlisting">public decimal get_CurrentPrice {...}
public void set_CurrentPrice (decimal value) {...}</pre>
<p>An <code>init</code> accessor is processed like a <code>set</code> accessor, but with an extra flag encoded into the <code>set</code> accessor’s “modreq” metadata (see <a data-type="xref" href="ch18.html#init_only_properties">“Init-only properties”</a>).</p>
<p>Simple nonvirtual property accessors are <em>inlined</em> by the Just-In-Time (JIT) compiler, eliminating any performance difference between accessing a property and a field. Inlining is an optimization in which a method call is replaced with the body of that method.<a contenteditable="false" data-primary="" data-startref="ch03.html109" data-type="indexterm" id="id2069"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Indexers" data-type="sect2"><div class="sect2" id="indexers">
<h2>Indexers</h2>
<p><a contenteditable="false" data-primary="indexers" data-type="indexterm" id="ch03.html1010"/>Indexers provide a natural syntax for accessing elements in a class or struct that encapsulate a list or dictionary of values. Indexers are similar to properties but are accessed via an index argument rather than a property name. The <code>string</code> class has an indexer that lets you access each of its <code>char</code> values via an <code>int</code> index:</p>
<pre data-type="programlisting">string s = "hello";
Console.WriteLine (s[0]); // 'h'
Console.WriteLine (s[3]); // 'l'</pre>
<p>The syntax for using indexers is like that for using arrays, except that the index argument(s) can be of any type(s).</p>
<p>Indexers have the same modifiers as properties (see <a data-type="xref" href="#properties">“Properties”</a>) and can be called null-conditionally by inserting a question mark before the square bracket (see <a data-type="xref" href="ch02.html#null_operators">“Null Operators”</a>):</p>
<pre data-type="programlisting">string s = null;
Console.WriteLine (s<strong>?</strong>[0]);  // Writes nothing; no error.</pre>
<section data-pdf-bookmark="Implementing an indexer" data-type="sect3"><div class="sect3" id="implementing_an_indexer">
<h3>Implementing an indexer</h3>
<p><a contenteditable="false" data-primary="indexers" data-secondary="implementing" data-type="indexterm" id="id2070"/>To write an indexer, define a property called <code>this</code>, specifying the arguments in square brackets:</p>
<pre data-type="programlisting">class Sentence
{
  string[] words = "The quick brown fox".Split();

  <strong>public string this [int wordNum]      // indexer</strong>
  <strong>{</strong>
    <strong>get { return words [wordNum];  }</strong>
    <strong>set { words [wordNum] = value; }</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<p>Here’s how we could use this indexer:</p>
<pre data-type="programlisting">Sentence s = new Sentence();
Console.WriteLine (s[3]);       // fox
s[3] = "kangaroo";
Console.WriteLine (s[3]);       // kangaroo</pre>
<p>A type can declare multiple indexers, each with parameters of different types. An indexer can also take more than one parameter:</p>
<pre data-type="programlisting">public string this [int arg1, string arg2]
{
  get { ... }  set { ... }
}</pre>
<p>If you omit the <code>set</code> accessor, an indexer becomes read-only, and you can use expression-bodied syntax to shorten its definition:</p>
<pre data-type="programlisting">public string this [int wordNum] =&gt; words [wordNum];</pre>
</div></section>
<section data-pdf-bookmark="CLR indexer implementation" data-type="sect3"><div class="sect3" id="clr_indexer_implementation">
<h3>CLR indexer implementation</h3>
<p><a contenteditable="false" data-primary="CLR (Common Language Runtime)" data-secondary="indexer implementation" data-type="indexterm" id="id2071"/><a contenteditable="false" data-primary="indexers" data-secondary="CLR indexer implementation" data-type="indexterm" id="id2072"/>Indexers internally compile to methods called <code>get_Item</code> and <code>set_Item</code>, as follows:</p>
<pre data-type="programlisting">public string get_Item (int wordNum) {...}
public void set_Item (int wordNum, string value) {...}</pre>
</div></section>
<section data-pdf-bookmark="Using indices and ranges with indexers" data-type="sect3"><div class="sect3" id="using_indices_and_ranges_with_indexers">
<h3>Using indices and ranges with indexers</h3>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="using indices and ranges with indexers" data-type="indexterm" id="id2073"/><a contenteditable="false" data-primary="indexers" data-secondary="using indices and ranges with" data-type="indexterm" id="id2074"/><a contenteditable="false" data-primary="ranges" data-secondary="using indices and ranges with indexers" data-type="indexterm" id="id2075"/>You can support indices and ranges (see <a data-type="xref" href="ch02.html#indices_and_ranges-id00073">“Indices and Ranges”</a>) in your own classes by defining an indexer with a parameter type of <code>Index</code> or <code>Range</code>. We could extend our previous example, by adding the following indexers to the <code>Sentence</code> class:</p>
<pre data-type="programlisting">  public string this [Index index] =&gt; words [index];
  public string[] this [Range range] =&gt; words [range];</pre>
<p>This then enables the following:<a contenteditable="false" data-primary="" data-startref="ch03.html1010" data-type="indexterm" id="id2076"/></p>
<pre data-type="programlisting">Sentence s = new Sentence();
Console.WriteLine (s [^1]);         // fox  
string[] firstTwoWords = s [..2];   // (The, quick)</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Primary Constructors (C# 12)" data-type="sect2"><div class="sect2" id="primary_constructors_left_parenthesisch">
<h2>Primary Constructors (C# 12)</h2>
<p>From C# 12, you can include a parameter list directly after a class (or struct) declaration:</p>
<pre data-type="programlisting">class Person (<strong>string firstName, string lastName</strong>)
{
  public void Print() =&gt; Console.WriteLine (<strong>firstName</strong> + " " + <strong>lastName</strong>);
}</pre>
<p>This instructs the compiler to automatically build a <em>primary constructor</em> using the <em>primary constructor parameters</em> (<code>firstName</code> and <code>lastName</code>), so that we can instantiate our class as follows:</p>
<pre data-type="programlisting">Person p = <strong>new Person ("Alice", "Jones")</strong>;
p.Print();    // Alice Jones</pre>
<p>Primary constructors are useful for prototyping and other simple scenarios. The alternative would be to define fields and write a constructor explicitly:</p>
<pre data-type="programlisting">class Person    // (without primary constructors)
{
  <strong>string firstName, lastName</strong>;       // Field declarations

  public Person (<strong>string firstName, string lastName</strong>)   // Constructor
  {
    <strong>this.firstName = firstName;</strong>     // Assign field
    <strong>this.lastName = lastName;</strong>       // Assign field
  }

  public void Print() =&gt; Console.WriteLine (firstName + " " + lastName);
}</pre>
<p>The constructor that C# builds is called primary because any additional constructors that you choose to (explicitly) write must invoke it:</p>
<pre data-type="programlisting">class Person (<strong>string firstName, string lastName</strong>)
{
  public Person (string firstName, string lastName, int age)
    : <strong>this (firstName, lastName)</strong>   // Must call the primary constructor
  <strong>{</strong>
    <strong>...</strong>
  <strong>}</strong>
}</pre>
<p>This ensures that primary constructor parameters are <em>always populated</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# also provides <em>records</em>, which we cover in <a data-type="xref" href="ch04.html#records-id00087">“Records”</a>. Records also support primary constructors; however, the compiler takes an extra step with records and generates (by default) a public init-only property for each primary constructor parameter. Should this behavior be desirable, consider using records instead.</p>
</div>
<p>Primary constructors are best suited to simple scenarios due to the following <span class="keep-together">limitations:</span></p>
<ul>
<li><p>You cannot add extra initialization code to a primary constructor.</p></li>
<li><p>Although it’s easy to expose a primary constructor parameter as a public property, you cannot easily incorporate validation logic unless the property is read-only.</p></li>
</ul>
<p>Primary constructors displace the default parameterless constructor that C# would otherwise generate.</p>
<section data-pdf-bookmark="Primary constructor semantics" data-type="sect3"><div class="sect3" id="primary_constructor_semantics">
<h3>Primary constructor semantics</h3>
<p>To understand how primary constructors work, consider how an ordinary constructor behaves:</p>
<pre data-type="programlisting">class Person
{
  public Person (<strong>string firstName, string lastName</strong>)
  {
 <em>   ... do something with firstName, lastName</em>
  }
}</pre>
<p>When the code inside this constructor finishes executing, parameters <code>firstName</code> and <code>lastName</code> disappear out of scope and cannot be subsequently accessed. In contrast, a primary constructor’s parameters do <em>not</em> disappear out of scope and can be subsequently accessed from anywhere within the class, for the life of the object.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Primary constructor parameters are special C# constructs, not <em>fields</em>, although the compiler does end up generating hidden fields behind the scenes to store their values if necessary.</p>
</div>
</div></section>
<section data-pdf-bookmark="Primary constructors and field/property initializers" data-type="sect3"><div class="sect3" id="primary_constructors_and_fieldsoliduspr">
<h3>Primary constructors and field/property initializers</h3>
<p>The accessibility of primary constructor parameters extends to field and property initializers. In the following example, we use field and property initializers to assign <code>firstName</code> to a public field, and <code>lastName</code> to a public property:</p>
<pre data-type="programlisting">class Person (string firstName, string lastName)
{
  public readonly string FirstName = <strong>firstName</strong>;  // Field
  public string LastName { get; } = <strong>lastName</strong>;    // Property
}</pre>
</div></section>
<section data-pdf-bookmark="Masking primary constructor parameters" data-type="sect3"><div class="sect3" id="masking_primary_constructor_parameters">
<h3>Masking primary constructor parameters</h3>
<p>Fields (or properties) can reuse primary constructor parameter names:</p>
<pre data-type="programlisting">class Person (string firstName, string lastName)
{
  readonly string firstName = <strong>firstName</strong>;
  readonly string lastName = <strong>lastName</strong>;

  public void Print() =&gt; Console.WriteLine (firstName + " " + lastName);
}</pre>
<p>In this scenario, the field or property takes precedence, thereby masking the primary constructor parameter, <em>except</em> on the righthand side of field and property initializers (shown in boldface).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Just like ordinary parameters, primary constructor parameters are writable. Masking them with a same-named <code>readonly</code> field (as in our example) effectively protects them from subsequent modification.</p>
</div>
</div></section>
<section data-pdf-bookmark="Validating primary constructor parameters" data-type="sect3"><div class="sect3" id="validating_primary_constructor_paramete">
<h3>Validating primary constructor parameters</h3>
<p>Sometimes it’s useful to perform computation in field initializers:</p>
<pre data-type="programlisting">new Person ("Alice", "Jones").Print();   // Alice Jones

class Person (string firstName, string lastName)
{
  public readonly string FullName = <strong>firstName + " " + lastName</strong>;
  public void Print() =&gt; Console.WriteLine (FullName);
}</pre>
<p>In the next example, we save an uppercase version of <code>lastName</code> to a field of the same name (masking the original value):</p>
<pre data-type="programlisting">new Person ("Alice", "Jones").Print();   // Alice JONES

class Person (string firstName, string lastName)
{
  <strong>readonly string lastName = lastName.ToUpper()</strong>;
  public void Print() =&gt; Console.WriteLine (firstName + " " + lastName);
}</pre>
<p>In <a data-type="xref" href="ch04.html#throw_expressions-id00096">“throw expressions”</a>, we describe how to throw exceptions when encountering scenarios such as invalid data. Here’s a preview to illustrate how this can be used with primary constructors to validate <code>lastName</code> upon construction, ensuring that it cannot be null:</p>
<pre data-type="programlisting">new Person ("Alice", null);   // throws ArgumentNullException

class Person (string firstName, string lastName)
{
  <strong>readonly string lastName = (lastName == null)</strong>
    <strong> ? throw new ArgumentNullException ("lastName")</strong>
    <strong> : lastName</strong>;
}</pre>
<p>(Remember that code within a field or property initializer executes when the object is constructed—not when the field or property is accessed.) In the next example, we expose a primary constructor parameter as a read/write property:</p>
<pre data-type="programlisting">class Person (string firstName, string lastName)
{
  public <strong>string LastName { get; set; } = lastName;</strong>
}</pre>
<p>Adding validation to this example is not straightforward in that you must validate in two places: in a (manually implemented) property <code>set</code> accessor and in the property initializer. (The same problem exists if the property is defined as init-only.) At this point, it’s easier to abandon the shortcut of primary constructors and define a constructor and backing fields explicitly.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Static Constructors" data-type="sect2"><div class="sect2" id="static_constructors">
<h2>Static Constructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="static constructors" data-type="indexterm" id="id2077"/><a contenteditable="false" data-primary="constructors" data-secondary="static" data-type="indexterm" id="id2078"/><a contenteditable="false" data-primary="static constructors" data-type="indexterm" id="id2079"/>A static constructor executes once per <em>type</em> rather than once per <em>instance</em>. A type can define only one static constructor, and it must be parameterless and have the same name as the type:</p>
<pre data-type="programlisting">class Test
{
  static Test() { Console.WriteLine ("Type Initialized"); }
}</pre>
<p class="pagebreak-before">The runtime automatically invokes a static constructor just prior to the type being used. Two things trigger this:</p>
<ul>
<li><p>Instantiating the type</p></li>
<li><p>Accessing a static member in the type</p></li>
</ul>
<p>The only modifiers allowed by static constructors are <code>unsafe</code> and <code>extern</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If a static constructor throws an unhandled exception (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), that type becomes <em>unusable</em> for the life of the application.</p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="module initializers" data-type="indexterm" id="id2080"/>From C# 9, you can also define <em>module initializers</em>, which execute once per assembly (when the assembly is first loaded). To define a module initializer, write a static void method and then apply the <code>[ModuleInitializer]</code> attribute to that method:</p>
<pre data-type="programlisting">[System.Runtime.CompilerServices.ModuleInitializer]
internal static void InitAssembly()
{
  ...
}</pre>
</div>
<section data-pdf-bookmark="Static constructors and field initialization order" data-type="sect3"><div class="sect3" id="static_constructors_and_field_initializ">
<h3>Static constructors and field initialization order</h3>
<p><a contenteditable="false" data-primary="fields" data-secondary="static constructors and field initialization order" data-type="indexterm" id="id2081"/><a contenteditable="false" data-primary="initialization" data-secondary="static constructor and field initialization order" data-type="indexterm" id="id2082"/>Static field initializers run just <em>before</em> the static constructor is called. If a type has no static constructor, static field initializers will execute just prior to the type being used—or <em>anytime earlier</em> at the whim of the runtime.</p>
<p>Static field initializers run in the order in which the fields are declared. The following example illustrates this. <code>X</code> is initialized to <code>0</code>, and <code>Y</code> is initialized to <code>3</code>:</p>
<pre data-type="programlisting">class Foo
{
  public static int X = Y;    // 0
  public static int Y = 3;    // 3
}</pre>
<p>If we swap the two field initializers around, both fields are initialized to 3. The next example prints 0 followed by 3 because the field initializer that instantiates a <code>Foo</code> executes before <code>X</code> is initialized to <code>3</code>:</p>
<pre data-type="programlisting">Console.WriteLine (Foo.X);    // 3

class Foo
{
  <strong>public static Foo Instance = new Foo();</strong>
  <strong>public static int X = 3;</strong>

  Foo() =&gt; Console.WriteLine (X);    // 0
}</pre>
<p>If we swap the two lines in boldface, the example prints 3 followed by 3.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Static Classes" data-type="sect2"><div class="sect2" id="static_classes">
<h2>Static Classes</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="static classes" data-type="indexterm" id="id2083"/><a contenteditable="false" data-primary="static classes" data-type="indexterm" id="id2084"/>A class marked <code>static</code> cannot be instantiated or subclassed, and must be composed solely of static members. The <code>System.Console</code> and <code>System.Math</code> classes are good examples of static classes.</p>
</div></section>
<section data-pdf-bookmark="Finalizers" data-type="sect2"><div class="sect2" id="finalizers">
<h2>Finalizers</h2>
<p><a contenteditable="false" data-primary="~ (finalizer)" data-type="indexterm" id="id2085"/><a contenteditable="false" data-primary="classes" data-secondary="finalizers" data-type="indexterm" id="id2086"/><a contenteditable="false" data-primary="finalizer (~)" data-type="indexterm" id="id2087"/>Finalizers are class-only methods that execute before the garbage collector reclaims the memory for an unreferenced object. The syntax for a finalizer is the name of the class prefixed with the <code>~</code> symbol:</p>
<pre data-type="programlisting">class Class1
{
  ~Class1()
  {
    ...
  }
}</pre>
<p>This is actually C# syntax for overriding <code>Object</code>’s <code>Finalize</code> method, and the compiler expands it into the following method declaration:</p>
<pre data-type="programlisting">protected override void Finalize()
{
  ...
  base.Finalize();
}</pre>
<p>We discuss garbage collection and finalizers fully in <a data-type="xref" href="ch12.html#disposal_and_garbage_collection">Chapter 12</a>.</p>
<p><a contenteditable="false" data-primary="=&gt; (expression-bodied members)" data-type="indexterm" id="id2088"/><a contenteditable="false" data-primary="expression-bodied members (=&gt;)" data-type="indexterm" id="id2089"/>You can write single-statement finalizers using expression-bodied syntax:</p>
<pre data-type="programlisting">~Class1() =&gt; Console.WriteLine ("Finalizing");</pre>
</div></section>
<section data-pdf-bookmark="Partial Types and Methods" data-type="sect2"><div class="sect2" id="partial_types_and_methods">
<h2>Partial Types and Methods</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="partial types/methods" data-type="indexterm" id="id2090"/><a contenteditable="false" data-primary="partial methods" data-type="indexterm" id="id2091"/><a contenteditable="false" data-primary="partial types" data-type="indexterm" id="id2092"/><a contenteditable="false" data-primary="types" data-secondary="partial types/methods" data-type="indexterm" id="id2093"/>Partial types allow a type definition to be split—typically across multiple files. A common scenario is for a partial class to be autogenerated from some other source (such as a Visual Studio template or designer), and for that class to be augmented with additional hand-authored methods:</p>
<pre data-type="programlisting">// PaymentFormGen.cs - auto-generated
partial class PaymentForm { ... }

// PaymentForm.cs - hand-authored
partial class PaymentForm { ... }</pre>
<p>Each participant must have the <code>partial</code> declaration; the following is illegal:</p>
<pre data-type="programlisting">partial class PaymentForm {}
class PaymentForm {}</pre>
<p class="pagebreak-before">Participants cannot have conflicting members. A constructor with the same parameters, for instance, cannot be repeated. Partial types are resolved entirely by the compiler, which means that each participant must be available at compile time and must reside in the same assembly.</p>
<p>You can specify a base class on one or more partial class declarations, as long as the base class, if specified, is the same. In addition, each participant can independently specify interfaces to implement. We cover base classes and interfaces in <a data-type="xref" href="#inheritance">“Inheritance”</a> and <a data-type="xref" href="#interfaces">“Interfaces”</a>.</p>
<p>The compiler makes no guarantees with regard to field initialization order between partial type declarations.</p>
<section data-pdf-bookmark="Partial methods" data-type="sect3"><div class="sect3" id="partial_methods">
<h3>Partial methods</h3>
<p>A partial type can contain <em>partial methods</em>. These let an autogenerated partial type provide customizable hooks for manual authoring; for example:</p>
<pre data-type="programlisting">partial class PaymentForm    // In auto-generated file
{
  ...
  partial void ValidatePayment (decimal amount);
}

partial class PaymentForm    // In hand-authored file
{
  ...
  partial void ValidatePayment (decimal amount)
  {
    if (amount &gt; 100)
      ...
  }
}</pre>
<p>A partial method consists of two parts: a <em>definition</em> and an <em>implementation</em>. The definition is typically written by a code generator, and the implementation is typically manually authored. If an implementation is not provided, the definition of the partial method is compiled away (as is the code that calls it). This allows autogenerated code to be liberal in providing hooks without having to worry about bloat. Partial methods must be <code>void</code> and are implicitly <code>private</code>. They cannot include <code>out</code> parameters.</p>
</div></section>
<section data-pdf-bookmark="Extended partial methods" data-type="sect3"><div class="sect3" id="extended_partial_methods">
<h3>Extended partial methods</h3>
<p><a contenteditable="false" data-primary="extended partial methods" data-type="indexterm" id="id2094"/><a contenteditable="false" data-primary="partial methods" data-type="indexterm" id="id2095"/><em>Extended partial methods</em> (from C# 9) are designed for the reverse code generation scenario, where a programmer defines hooks that a code generator implements. An example of where this might occur is with <em>source generators</em>, a Roslyn feature that lets you feed the compiler an assembly that automatically generates portions of your code.</p>
<p class="pagebreak-before">A partial method declaration is <em>extended</em> if it begins with an accessibility modifier:</p>
<pre data-type="programlisting">public partial class Test
{
  <strong>public</strong> partial void M1();    // Extended partial method
  <strong>private</strong> partial void M2();   // Extended partial method
}</pre>
<p>The presence of the accessibility modifier doesn’t just affect accessibility: it tells the compiler to treat the declaration differently.</p>
<p>Extended partial methods <em>must</em> have implementations; they do not melt away if unimplemented. In this example, both <code>M1</code> and <code>M2</code> must have implementations because they each specify accessibility modifiers (<code>public</code> and <code>private</code>).</p>
<p>Because they cannot melt away, extended partial methods can return any type and can include <code>out</code> parameters:</p>
<pre data-type="programlisting">public partial class Test
{
  public partial <strong>bool</strong> IsValid (string identifier);
  internal partial <strong>bool</strong> TryParse (string number, <strong>out</strong> int result);
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="The nameof operator" data-type="sect2"><div class="sect2" id="the_nameof_operator">
<h2>The nameof operator</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="nameof operator" data-type="indexterm" id="id2096"/><a contenteditable="false" data-primary="nameof operator" data-type="indexterm" id="id2097"/>The <code>nameof</code> operator returns the name of any symbol (type, member, variable, and so on) as a string:</p>
<pre data-type="programlisting">int count = 123;
string name = <strong>nameof</strong> (count);       // name is "count"</pre>
<p>Its advantage over simply specifying a string is that of static type checking. Tools such as Visual Studio can understand the symbol reference, so if you rename the symbol in question, all of its references will be renamed, too.</p>
<p>To specify the name of a type member such as a field or property, include the type as well. This works with both static and instance members:</p>
<pre data-type="programlisting">string name = nameof (StringBuilder.Length);</pre>
<p>This evaluates to <code>Length</code>. To return <code>StringBuilder.Length</code>, you would do this:<a contenteditable="false" data-primary="" data-startref="ch03.html101" data-type="indexterm" id="id2098"/></p>
<pre data-type="programlisting">nameof (StringBuilder) + "." + nameof (StringBuilder.Length);</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Inheritance" data-type="sect1"><div class="sect1" id="inheritance">
<h1>Inheritance</h1>
<p><a contenteditable="false" data-primary="inheritance" data-type="indexterm" id="ch03.html1011"/>A class can <em>inherit</em> from another class to extend or customize the original class. Inheriting from a class lets you reuse the functionality in that class instead of building it from scratch. A class can inherit from only a single class but can itself be inherited by many classes, thus forming a class hierarchy. In this example, we begin by defining a class called <code>Asset</code>:</p>
<pre class="pagebreak-before" data-type="programlisting">public class Asset
{
  public string Name;
}</pre>
<p>Next, we define classes called <code>Stock</code> and <code>House</code>, which will inherit from <code>Asset</code>. <code>Stock</code> and <code>House</code> get everything an <code>Asset</code> has, plus any additional members that they define:</p>
<pre data-type="programlisting">public class Stock <strong>: Asset</strong>   // inherits from Asset
{
  public long SharesOwned;
}

public class House <strong>: Asset</strong>   // inherits from Asset
{
  public decimal Mortgage;
}</pre>
<p>Here’s how we can use these classes:</p>
<pre data-type="programlisting">Stock msft = new Stock { Name="MSFT",
                         SharesOwned=1000 };

Console.WriteLine (msft.Name);         // MSFT
Console.WriteLine (msft.SharesOwned);  // 1000

House mansion = new House { Name="Mansion",
                            Mortgage=250000 };

Console.WriteLine (mansion.Name);      // Mansion
Console.WriteLine (mansion.Mortgage);  // 250000</pre>
<p>The <em>derived classes</em>, <code>Stock</code> and <code>House</code>, inherit the <code>Name</code> field from the <em>base class</em>, <code>Asset</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A derived class is also called a <em>subclass</em>.</p>
<p>A base class is also called a <em>superclass</em>.</p>
</div>
<section data-pdf-bookmark="Polymorphism" data-type="sect2"><div class="sect2" id="polymorphism">
<h2>Polymorphism</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="polymorphism" data-type="indexterm" id="id2099"/><a contenteditable="false" data-primary="polymorphism" data-type="indexterm" id="id2100"/>References are <em>polymorphic</em>. This means a variable of type <em>x</em> can refer to an object that subclasses <em>x</em>. For instance, consider the following method:</p>
<pre data-type="programlisting">public static void Display (Asset asset)
{
  System.Console.WriteLine (asset.Name);
}</pre>
<p>This method can display both a <code>Stock</code> and a <code>House</code> because they are both <code>Asset</code>s:</p>
<pre data-type="programlisting">Stock msft    = new Stock ... ;
House mansion = new House ... ;

Display (msft);
Display (mansion);</pre>
<p>Polymorphism works on the basis that subclasses (<code>Stock</code> and <code>House</code>) have all the features of their base class (<code>Asset</code>). The converse, however, is not true. If <code>Display</code> was modified to accept a <code>House</code>, you could not pass in an <code>Asset</code>:</p>
<pre data-type="programlisting">Display (new Asset());     // Compile-time error

public static void Display (House house)         // Will not accept Asset
{
  System.Console.WriteLine (house.Mortgage);
}</pre>
</div></section>
<section data-pdf-bookmark="Casting and Reference Conversions" data-type="sect2"><div class="sect2" id="casting_and_reference_conversions">
<h2>Casting and Reference Conversions</h2>
<p><a contenteditable="false" data-primary="casting" data-type="indexterm" id="ch03.html1012"/><a contenteditable="false" data-primary="inheritance" data-secondary="casting and reference conversions" data-type="indexterm" id="ch03.html1013"/><a contenteditable="false" data-primary="reference conversions" data-type="indexterm" id="ch03.html1014"/>An object reference can be:</p>
<ul>
<li><p>Implicitly <em>upcast</em> to a base class reference</p></li>
<li><p>Explicitly <em>downcast</em> to a subclass reference</p></li>
</ul>
<p>Upcasting and downcasting between compatible reference types performs <em>reference conversions</em>: a new reference is (logically) created that points to the <em>same</em> object. An upcast always succeeds; a downcast succeeds only if the object is suitably typed.</p>
<section data-pdf-bookmark="Upcasting" data-type="sect3"><div class="sect3" id="upcasting">
<h3>Upcasting</h3>
<p><a contenteditable="false" data-primary="casting" data-secondary="upcasting" data-type="indexterm" id="id2101"/><a contenteditable="false" data-primary="upcasting" data-type="indexterm" id="id2102"/>An upcast operation creates a base class reference from a subclass reference:</p>
<pre data-type="programlisting">Stock msft = new Stock();
<strong>Asset a = msft;              // Upcast</strong></pre>
<p>After the upcast, variable <code>a</code> still references the same <code>Stock</code> object as variable <code>msft</code>. The object being referenced is not itself altered or converted:</p>
<pre data-type="programlisting">Console.WriteLine (a == msft);        // True</pre>
<p>Although <code>a</code> and <code>msft</code> refer to the identical object, <code>a</code> has a more restrictive view on that object:</p>
<pre data-type="programlisting">Console.WriteLine (a.Name);           // OK
Console.WriteLine (a.SharesOwned);    // Compile-time error</pre>
<p>The last line generates a compile-time error because the variable <code>a</code> is of type <code>Asset</code>, even though it refers to an object of type <code>Stock</code>. To get to its <code>SharesOwned</code> field, you must <em>downcast</em> the <code>Asset</code> to a <code>Stock</code>.</p>
</div></section>
<section data-pdf-bookmark="Downcasting" data-type="sect3"><div class="sect3" id="downcasting">
<h3>Downcasting</h3>
<p><a contenteditable="false" data-primary="casting" data-secondary="downcasting" data-type="indexterm" id="id2103"/><a contenteditable="false" data-primary="downcasting" data-type="indexterm" id="id2104"/>A downcast operation creates a subclass reference from a base class reference:</p>
<pre data-type="programlisting">Stock msft = new Stock();
Asset a = msft;                      // Upcast
<strong>Stock s = (Stock)a;                  // Downcast</strong>
Console.WriteLine (s.SharesOwned);   // &lt;No error&gt;
Console.WriteLine (s == a);          // True
Console.WriteLine (s == msft);       // True</pre>
<p>As with an upcast, only references are affected—not the underlying object. A downcast requires an explicit cast because it can potentially fail at runtime:</p>
<pre data-type="programlisting">House h = new House();
Asset a = h;               // Upcast always succeeds
Stock s = (Stock)a;        // Downcast fails: <strong>a</strong> is not a Stock</pre>
<p>If a downcast fails, an <code>InvalidCastException</code> is thrown. This is an example of <em>runtime type checking</em> (we elaborate on this concept in <a data-type="xref" href="#static_and_runtime_type_checking">“Static and Runtime Type Checking”</a>).</p>
</div></section>
<section data-pdf-bookmark="The as operator" data-type="sect3"><div class="sect3" id="the_as_operator">
<h3>The as operator</h3>
<p><a contenteditable="false" data-primary="as operator" data-type="indexterm" id="id2105"/><a contenteditable="false" data-primary="casting" data-secondary="as operator" data-type="indexterm" id="id2106"/>The <code>as</code> operator performs a downcast that evaluates to <code>null</code> (rather than throwing an exception) if the downcast fails:</p>
<pre data-type="programlisting">Asset a = new Asset();
Stock s = a as Stock;       // s is null; no exception thrown</pre>
<p>This is useful when you’re going to subsequently test whether the result is <code>null</code>:</p>
<pre data-type="programlisting"><strong>if (s != null)</strong> Console.WriteLine (s.SharesOwned);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Without such a test, a cast is advantageous, because if it fails, a more helpful exception is thrown. We can illustrate by comparing the following two lines of code:</p>
<pre data-type="programlisting">long shares = ((Stock)a).SharesOwned;    // Approach #1
long shares = (a as Stock).SharesOwned;  // Approach #2</pre>
<p>If <code>a</code> is not a <code>Stock</code>, the first line throws an <code>InvalidCastException</code>, which is an accurate description of what went wrong. The second line throws a <code>NullReferenceException</code>, which is ambiguous. Was <code>a</code> not a <code>Stock</code>, or was <code>a</code> null?</p>
<p>Another way of looking at it is that with the cast operator, you’re saying to the compiler: “I’m <em>certain</em> of a value’s type; if I’m wrong, there’s a bug in my code, so throw an exception!” Whereas with the <code>as</code> operator, you’re uncertain of its type and want to branch according to the outcome at runtime.</p>
</div>
<p>The <code>as</code> operator cannot perform <em>custom conversions</em> (see <a data-type="xref" href="ch04.html#operator_overloading">“Operator Overloading”</a>), and it cannot do numeric conversions:</p>
<pre data-type="programlisting">long x = 3 as long;    // Compile-time error</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>as</code> and cast operators will also perform upcasts, although this is not terribly useful because an implicit conversion will do the job.</p>
</div>
</div></section>
<section data-pdf-bookmark="The is operator" data-type="sect3"><div class="sect3" id="the_is_operator">
<h3>The is operator</h3>
<p><a contenteditable="false" data-primary="casting" data-secondary="is operator and" data-type="indexterm" id="id2107"/><a contenteditable="false" data-primary="is operator" data-type="indexterm" id="id2108"/><a contenteditable="false" data-primary="unboxing" data-secondary="is operator and" data-type="indexterm" id="id2109"/>The <code>is</code> operator tests whether a variable matches a <em>pattern</em>. C# supports several kinds of patterns, the most important being a <em>type pattern</em>, where a type name follows the <code>is</code> keyword.</p>
<p>In this context, the <code>is</code> operator tests whether a reference conversion would succeed—in other words, whether an object derives from a specified class (or implements an interface). It is often used to test before downcasting:</p>
<pre data-type="programlisting">if (<strong>a is Stock</strong>)
  Console.WriteLine (((Stock)a).SharesOwned);</pre>
<p>The <code>is</code> operator also evaluates to true if an <em>unboxing conversion</em> would succeed (see <a data-type="xref" href="#the_object_type">“The object Type”</a>). However, it does not consider custom or numeric conversions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>is</code> operator works with many other patterns introduced in recent versions of C#. For a full discussion, see <a data-type="xref" href="ch04.html#patterns">“Patterns”</a>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Introducing a pattern variable" data-type="sect3"><div class="sect3" id="introducing_a_pattern_variable">
<h3>Introducing a pattern variable</h3>
<p><a contenteditable="false" data-primary="casting" data-secondary="introducing a pattern variable" data-type="indexterm" id="id2110"/><a contenteditable="false" data-primary="pattern variable" data-type="indexterm" id="id2111"/>You can introduce a variable while using the <code>is</code> operator:</p>
<pre data-type="programlisting">if (a is <strong>Stock s</strong>)
  Console.WriteLine (s.SharesOwned);</pre>
<p>This is equivalent to the following:</p>
<pre data-type="programlisting">Stock s;
if (a is Stock)
{
  s = (Stock) a;
  Console.WriteLine (s.SharesOwned);
}</pre>
<p>The variable that you introduce is available for “immediate” consumption, so the following is legal:</p>
<pre data-type="programlisting">if (a is <strong>Stock s</strong> &amp;&amp; <strong>s.</strong>SharesOwned &gt; 100000)
  Console.WriteLine ("Wealthy");</pre>
<p>And it remains in scope outside the <code>is</code> expression, allowing this:<a contenteditable="false" data-primary="" data-startref="ch03.html1014" data-type="indexterm" id="id2112"/><a contenteditable="false" data-primary="" data-startref="ch03.html1013" data-type="indexterm" id="id2113"/><a contenteditable="false" data-primary="" data-startref="ch03.html1012" data-type="indexterm" id="id2114"/></p>
<pre data-type="programlisting">if (a is Stock s &amp;&amp; s.SharesOwned &gt; 100000)
  Console.WriteLine ("Wealthy");
else
  <strong>s = new Stock();   // s is in scope</strong>

<strong>Console.WriteLine (s.SharesOwned);  // Still in scope</strong></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Virtual Function Members" data-type="sect2"><div class="sect2" id="virtual_function_members">
<h2>Virtual Function Members</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="virtual function members" data-type="indexterm" id="id2115"/><a contenteditable="false" data-primary="virtual function members" data-type="indexterm" id="id2116"/>A function marked as <code>virtual</code> can be <em>overridden</em> by subclasses wanting to provide a specialized implementation. Methods, properties, indexers, and events can all be declared <code>virtual</code>:</p>
<pre data-type="programlisting">public class Asset
{
  public string Name;
  public <strong>virtual</strong> decimal Liability =&gt; 0;   // Expression-bodied property
}</pre>
<p>(<code>Liability =&gt; 0</code> is a shortcut for <code>{ get { return 0; } }</code>. For more details on this syntax, see <a data-type="xref" href="#expression_bodied_properties">“Expression-bodied properties”</a>.)</p>
<p><a contenteditable="false" data-primary="override modifier" data-type="indexterm" id="id2117"/>A subclass overrides a virtual method by applying the <code>override</code> modifier:</p>
<pre data-type="programlisting">public class Stock : Asset
{
  public long SharesOwned;
}

public class House : Asset
{
  public decimal Mortgage;
  public <strong>override</strong> decimal Liability =&gt; Mortgage;
}</pre>
<p>By default, the <code>Liability</code> of an <code>Asset</code> is <code>0</code>. A <code>Stock</code> does not need to specialize this behavior. However, the <code>House</code> specializes the <code>Liability</code> property to return the value of the <code>Mortgage</code>:</p>
<pre data-type="programlisting">House mansion = new House { Name="McMansion", Mortgage=250000 };
Asset a = mansion;
Console.WriteLine (mansion.Liability);  // 250000
Console.WriteLine (a.Liability);        // 250000</pre>
<p>The signatures, return types, and accessibility of the virtual and overridden methods must be identical. An overridden method can call its base class implementation via the <code>base</code> keyword (we cover this in <a data-type="xref" href="#the_base_keyword">“The base Keyword”</a>).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Calling virtual methods from a constructor is potentially dangerous because authors of subclasses are unlikely to know, when overriding the method, that they are working with a partially initialized object. In other words, the overriding method might end up accessing methods or properties that rely on fields not yet initialized by the constructor.</p>
</div>
<section data-pdf-bookmark="Covariant return types" data-type="sect3"><div class="sect3" id="covariant_return_types">
<h3>Covariant return types</h3>
<p><a contenteditable="false" data-primary="covariant return types" data-type="indexterm" id="id2118"/><a contenteditable="false" data-primary="return types" data-secondary="covariant return types (C# 9)" data-type="indexterm" id="id2119"/>From C# 9, you can override a method (or property <code>get</code> accessor) such that it returns a <em>more derived</em> (subclassed) type. For example:</p>
<pre class="pagebreak-before" data-type="programlisting">public class Asset
{
  public string Name;
  public virtual <strong>Asset</strong> Clone() =&gt; new Asset { Name = Name };
}

public class House : Asset
{
  public decimal Mortgage;
  public override <strong>House</strong> Clone() =&gt; new House
                                   { Name = Name, Mortgage = Mortgage };
}</pre>
<p>This is permitted because it does not break the contract that <code>Clone</code> must return an <code>Asset</code>: it returns a <code>House</code>, which <em>is</em> an <code>Asset</code> (and more).</p>
<p>Prior to C# 9, you had to override methods with the identical return type:</p>
<pre data-type="programlisting">public override <strong>Asset</strong> Clone() =&gt; new House { ... }</pre>
<p>This still does the job, because the overridden <code>Clone</code> method instantiates a <code>House</code> rather than an <code>Asset</code>. However, to treat the returned object as a <code>House</code>, you must then perform a downcast:</p>
<pre data-type="programlisting">House mansion1 = new House { Name="McMansion", Mortgage=250000 };
House mansion2 = <strong>(House)</strong> mansion1.Clone();</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Abstract Classes and Abstract Members" data-type="sect2"><div class="sect2" id="abstract_classes_and_abstract_members">
<h2>Abstract Classes and Abstract Members</h2>
<p><a contenteditable="false" data-primary="abstract classes" data-type="indexterm" id="id2120"/><a contenteditable="false" data-primary="classes" data-secondary="abstract" data-type="indexterm" id="id2121"/><a contenteditable="false" data-primary="inheritance" data-secondary="abstract classes/abstract members" data-type="indexterm" id="id2122"/>A class declared as <em>abstract</em> can never be instantiated. Instead, only its concrete <em>subclasses</em> can be instantiated.</p>
<p><a contenteditable="false" data-primary="abstract members" data-type="indexterm" id="id2123"/>Abstract classes are able to define <em>abstract members</em>. Abstract members are like virtual members except that they don’t provide a default implementation. That implementation must be provided by the subclass unless that subclass is also declared abstract:</p>
<pre data-type="programlisting">public <strong>abstract</strong> class Asset
{
  // Note empty implementation
  public <strong>abstract</strong> decimal NetValue { get; }
}

public class Stock : Asset
{
  public long SharesOwned;
  public decimal CurrentPrice;

  // Override like a virtual method.
  public <strong>override</strong> decimal NetValue =&gt; CurrentPrice * SharesOwned;
}</pre>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Hiding Inherited Members" data-type="sect2"><div class="sect2" id="hiding_inherited_members">
<h2 class="less_space">Hiding Inherited Members</h2>
<p><a contenteditable="false" data-primary="hiding inherited members" data-type="indexterm" id="id2124"/><a contenteditable="false" data-primary="inheritance" data-secondary="hiding inherited members" data-type="indexterm" id="id2125"/>A base class and a subclass can define identical members. For example:</p>
<pre data-type="programlisting">public class A      { public int Counter = 1; }
public class B : A  { public int Counter = 2; }</pre>
<p>The <code>Counter</code> field in class <code>B</code> is said to <em>hide</em> the <code>Counter</code> field in class <code>A</code>. Usually, this happens by accident, when a member is added to the base type <em>after</em> an identical member was added to the subtype. For this reason, the compiler generates a warning and then resolves the ambiguity as follows:</p>
<ul>
<li><p>References to <code>A</code> (at compile time) bind to <code>A.Counter</code>.</p></li>
<li><p>References to <code>B</code> (at compile time) bind to <code>B.Counter</code>.</p></li>
</ul>
<p><a contenteditable="false" data-primary="new keyword" data-type="indexterm" id="id2126"/>Occasionally, you want to hide a member deliberately, in which case you can apply the <code>new</code> modifier to the member in the subclass. The <code>new</code> modifier <em>does nothing more than suppress the compiler warning that would otherwise result</em>:</p>
<pre data-type="programlisting">public class A     { public     int Counter = 1; }
public class B : A { public <strong>new</strong> int Counter = 2; }</pre>
<p>The <code>new</code> modifier communicates your intent to the compiler—and other programmers—that the duplicate member is not an accident.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# overloads the <code>new</code> keyword to have independent meanings in different contexts. Specifically, the <code>new</code> <em>operator</em> is different from the <code>new</code> <em>member modifier</em>.</p>
</div>
<section data-pdf-bookmark="new versus override" data-type="sect3"><div class="sect3" id="new_versus_override">
<h3>new versus override</h3>
<p><a contenteditable="false" data-primary="override modifier" data-type="indexterm" id="id2127"/>Consider the following class hierarchy:</p>
<pre data-type="programlisting">public class BaseClass
{
  public virtual void Foo()  { Console.WriteLine ("BaseClass.Foo"); }
}

public class Overrider : BaseClass
{
  public <strong>override</strong> void Foo() { Console.WriteLine ("Overrider.Foo"); }
}

public class Hider : BaseClass
{
  public <strong>new</strong> void Foo()      { Console.WriteLine ("Hider.Foo"); }
}</pre>
<p>The differences in behavior between <code>Overrider</code> and <code>Hider</code> are demonstrated in the following code:</p>
<pre data-type="programlisting">Overrider over = new Overrider();
BaseClass b1 = over;
over.Foo();                         // Overrider.Foo
b1.Foo();                           // Overrider.Foo

Hider h = new Hider();
BaseClass b2 = h;
h.Foo();                           // Hider.Foo
b2.Foo();                          // <strong>BaseClass.Foo</strong></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Sealing Functions and Classes" data-type="sect2"><div class="sect2" id="sealing_functions_and_classes">
<h2>Sealing Functions and Classes</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="sealing functions and classes" data-type="indexterm" id="id2128"/><a contenteditable="false" data-primary="inheritance" data-secondary="sealing functions and classes" data-type="indexterm" id="id2129"/>An overridden function member can <em>seal</em> its implementation with the <code>sealed</code> keyword to prevent it from being overridden by further subclasses. In our earlier virtual function member example, we could have sealed <code>House</code>’s implementation of <code>Liability</code>, preventing a class that derives from <code>House</code> from overriding <code>Liability</code>, as follows:</p>
<pre data-type="programlisting">public <strong>sealed</strong> override decimal Liability { get { return Mortgage; } }</pre>
<p><a contenteditable="false" data-primary="sealed modifier" data-type="indexterm" id="id2130"/>You can also apply the <code>sealed</code> modifier to the class itself, to prevent subclassing. Sealing a class is more common than sealing a function member.</p>
<p>Although you can seal a function member against overriding, you can’t seal a member against being <em>hidden</em>.</p>
</div></section>
<section data-pdf-bookmark="The base Keyword" data-type="sect2"><div class="sect2" id="the_base_keyword">
<h2>The base Keyword</h2>
<p><a contenteditable="false" data-primary="base keyword" data-type="indexterm" id="id2131"/><a contenteditable="false" data-primary="inheritance" data-secondary="base keyword" data-type="indexterm" id="id2132"/>The <code>base</code> keyword is similar to the <code>this</code> keyword. It serves two essential purposes:</p>
<ul>
<li><p>Accessing an overridden function member from the subclass</p></li>
<li><p>Calling a base-class constructor (see the next section)</p></li>
</ul>
<p>In this example, <code>House</code> uses the <code>base</code> keyword to access <code>Asset</code>’s implementation of <code>Liability</code>:</p>
<pre data-type="programlisting">public class House : Asset
{
  ...
  public override decimal Liability =&gt; <strong>base.</strong>Liability + Mortgage;
}</pre>
<p>With the <code>base</code> keyword, we access <code>Asset</code>’s <code>Liability</code> property <em>nonvirtually</em>. This means that we will always access <code>Asset</code>’s version of this property—regardless of the instance’s actual runtime type.</p>
<p>The same approach works if <code>Liability</code> is <em>hidden</em> rather than <em>overridden</em>. (You can also access hidden members by casting to the base class before invoking the function.)</p>
</div></section>
<section data-pdf-bookmark="Constructors and Inheritance" data-type="sect2"><div class="sect2" id="constructors_and_inheritance">
<h2>Constructors and Inheritance</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="constructors and inheritance" data-type="indexterm" id="ch03.html0"/><a contenteditable="false" data-primary="constructors" data-secondary="inheritance and" data-type="indexterm" id="ch03.html1"/><a contenteditable="false" data-primary="inheritance" data-secondary="constructors and" data-type="indexterm" id="ch03.html2"/>A subclass must declare its own constructors. The base class’s constructors are <em>accessible</em> to the derived class but are never automatically <em>inherited</em>. For example, if we define <code>Baseclass</code> and <code>Subclass</code> as follows:</p>
<pre data-type="programlisting">public class Baseclass
{
  public int X;
  public Baseclass () { }
  public Baseclass (int x) =&gt; X = x;
}

public class Subclass : Baseclass { }</pre>
<p>the following is illegal:</p>
<pre data-type="programlisting">Subclass s = new Subclass (123);</pre>
<p><code>Subclass</code> must hence “redefine” any constructors it wants to expose. In doing so, however, it can call any of the base class’s constructors via the <code>base</code> keyword:</p>
<pre data-type="programlisting">public class Subclass : Baseclass
{
  public Subclass (int x) <strong>: base (x)</strong> { }
}</pre>
<p>The <code>base</code> keyword works rather like the <code>this</code> keyword except that it calls a constructor in the base class.</p>
<p>Base-class constructors always execute first; this ensures that <em>base</em> initialization occurs before <em>specialized</em> initialization.</p>
<section data-pdf-bookmark="Implicit calling of the parameterless base-class constructor" data-type="sect3"><div class="sect3" id="implicit_calling_of_the_parameterless_b">
<h3>Implicit calling of the parameterless base-class constructor</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="implicit calling of the parameterless base-class constructor" data-type="indexterm" id="id2133"/><a contenteditable="false" data-primary="parameterless constructor" data-type="indexterm" id="id2134"/>If a constructor in a subclass omits the <code>base</code> keyword, the base type’s <em>parameterless</em> constructor is implicitly called:</p>
<pre data-type="programlisting">public class Baseclass
{
  public int X;
  public Baseclass() { X = 1; }
}

public class Subclass : Baseclass
{
  public Subclass() { Console.WriteLine (X); }  // 1
}</pre>
<p>If the base class has no accessible parameterless constructor, subclasses are forced to use the <code>base</code> keyword in their constructors. This means that a base class with (only) a multiparameter constructor burdens subclasses with the obligation to call it:</p>
<pre data-type="programlisting">class Baseclass
{
   public Baseclass (int x, int y, int z, string s, DateTime d) { ... }
}

public class Subclass : Baseclass
{
  <strong>public Subclass (int x, int y, int z, string s, DateTime d)</strong>
    <strong>: base (x, y, z, s, d) { ... }</strong>
}</pre>
</div></section>
<section data-pdf-bookmark="Required members (C# 11)" data-type="sect3"><div class="sect3" id="required_members_left_parenthesischash">
<h3>Required members (C# 11)</h3>
<p><a contenteditable="false" data-primary="required members" data-type="indexterm" id="id2135"/><a contenteditable="false" data-primary="C# 11" data-secondary="required members for constructors" data-type="indexterm" id="id2136"/><a contenteditable="false" data-primary="constructors" data-secondary="required members (C# 11)" data-type="indexterm" id="id2137"/>The requirement for subclasses to invoke a constructor in the base class can become burdensome in large class hierarchies if there are many constructors with many parameters. Sometimes, the best solution is to avoid constructors altogether and rely solely on object initializers to set fields or properties during construction. To help with this, you can mark a field or property as <code>required</code> (from C# 11):</p>
<pre data-type="programlisting">public class Asset
{
  public <strong>required</strong> string Name;
}</pre>
<p>A required member <em>must</em> be populated via an object initializer when constructed:</p>
<pre data-type="programlisting">Asset a1 = new Asset { Name="House" };  // OK
Asset a2 = new Asset();                 // Error: will not compile!</pre>
<p>Should you wish to also write a constructor, you can apply the <code>[SetsRequired​Mem⁠bers]</code> attribute to bypass the required member restriction for that constructor:</p>
<pre data-type="programlisting">public class Asset
{
  public <strong>required</strong> string Name;

  public Asset() { }
    
  <strong>[</strong>System.Diagnostics.CodeAnalysis<strong>.SetsRequiredMembers]</strong>
  public Asset (string n) =&gt; Name = n;
}</pre>
<p>Consumers can now benefit from the convenience of that constructor without any trade-off:</p>
<pre data-type="programlisting">Asset a1 = new Asset { Name = "House" };  // OK
Asset a2 = new Asset ("House");           // OK
Asset a3 = new Asset();                   // Error!</pre>
<p>Notice that we also defined a parameterless constructor (for use with the object initializer). Its presence also ensures that subclasses remain under no burden to reproduce any constructor. In the following example, the <code>House</code> class chooses not to implement a convenience constructor:</p>
<pre data-type="programlisting">public class House : Asset { }            // No constructor, no worries!

House h1 = new House { Name = "House" };  // OK
House h2 = new House();                   // Error!</pre>
</div></section>
<section data-pdf-bookmark="Constructor and field initialization order" data-type="sect3"><div class="sect3" id="constructor_and_field_initializ-id00058">
<h3>Constructor and field initialization order</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="field initialization order" data-type="indexterm" id="id2138"/><a contenteditable="false" data-primary="fields" data-secondary="constructors and field initialization order" data-type="indexterm" id="id2139"/><a contenteditable="false" data-primary="object instantiation" data-type="indexterm" id="id2140"/>When an object is instantiated, initialization takes place in the following order:</p>
<ol>
<li><p>From subclass to base class:</p>
<ol type="a">
<li><p>Fields are initialized.</p></li>
<li><p>Arguments to base-class constructor calls are evaluated.</p></li>
</ol></li>
<li><p>From base class to subclass:</p>
<ol type="a">
<li><p>Constructor bodies execute.</p></li>
</ol></li>
</ol>
<p>For example:</p>
<pre data-type="programlisting">public class B
{
  int x = 1;         // Executes 3rd
  public B (int x)
  {
    ...              // Executes 4th
  }
}
public class D : B
{
  int y = 1;         // Executes 1st
  public D (int x)
    : base (<strong>x + 1</strong>)   // Executes 2nd
  {
     ...             // Executes 5th
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Inheritance with primary constructors" data-type="sect3"><div class="sect3" id="inheritance_with_primary_constructors">
<h3>Inheritance with primary constructors</h3>
<p><a contenteditable="false" data-primary="classes" data-secondary="primary constructors and subclassing" data-type="indexterm" id="id2141"/><a contenteditable="false" data-primary="primary constructors" data-type="indexterm" id="id2142"/><a contenteditable="false" data-primary="subclass" data-secondary="inheritance with primary constructors" data-type="indexterm" id="id2143"/>Classes with primary constructors can subclass with the following syntax:</p>
<pre data-type="programlisting">public class Baseclass (int x) { ... }

public class Subclass (int x, int y) : <strong>Baseclass (x)</strong> { ... }</pre>
<p>The call to <code>Baseclass(x)</code> is equivalent to calling <code>base(x)</code> in the following example:<a contenteditable="false" data-primary="" data-startref="ch03.html2" data-type="indexterm" id="id2144"/><a contenteditable="false" data-primary="" data-startref="ch03.html1" data-type="indexterm" id="id2145"/><a contenteditable="false" data-primary="" data-startref="ch03.html0" data-type="indexterm" id="id2146"/></p>
<pre data-type="programlisting">public class Subclass : Baseclass
{
  public Subclass (int x, int y) : <strong>base (x)</strong> { ... }
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Overloading and Resolution" data-type="sect2"><div class="sect2" id="overloading_and_resolution">
<h2>Overloading and Resolution</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="overloading and resolution" data-type="indexterm" id="id2147"/><a contenteditable="false" data-primary="method overloading" data-type="indexterm" id="id2148"/><a contenteditable="false" data-primary="overloading" data-secondary="resolution and" data-type="indexterm" id="id2149"/>Inheritance has an interesting impact on method overloading. Consider the following two overloads:</p>
<pre data-type="programlisting">static void Foo (Asset a) { }
static void Foo (House h) { }</pre>
<p>When an overload is called, the most specific type has precedence:</p>
<pre data-type="programlisting">House h = new House (...);
Foo(h);                      // Calls Foo(House)</pre>
<p>The particular overload to call is determined statically (at compile time) rather than at runtime. The following code calls <code>Foo(Asset)</code>, even though the runtime type of <code>a</code> is <code>House</code>:</p>
<pre data-type="programlisting">Asset a = new House (...);
Foo(a);                      // Calls Foo(Asset)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="" data-startref="ch03.html1011" data-type="indexterm" id="id2150"/>If you cast <code>Asset</code> to <code>dynamic</code> (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), the decision as to which overload to call is deferred until runtime and is then based on the object’s actual type:</p>
<pre data-type="programlisting">Asset a = new House (...);
Foo ((dynamic)a);   // Calls Foo(House)</pre>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="The object Type" data-type="sect1"><div class="sect1" id="the_object_type">
<h1>The object Type</h1>
<p><a contenteditable="false" data-primary="object type" data-type="indexterm" id="ch03.html1015"/><a contenteditable="false" data-primary="type system, C#" data-secondary="object type" data-type="indexterm" id="ch03.html1016"/><code>object</code> <a contenteditable="false" data-primary="Object..." data-secondary="object.System.Object class" data-type="indexterm" id="id2151"/><a contenteditable="false" data-primary="System..." data-secondary="System.Object" data-type="indexterm" id="id2152"/> (<code>System.Object</code>) is the ultimate base class for all types. Any type can be upcast to <code>object</code>.</p>
<p>To illustrate how this is useful, consider a general-purpose <em>stack</em>. A stack is a data structure based on the principle of <em>LIFO</em>—“last in, first out.” A stack has two operations: <em>push</em> an object on the stack and <em>pop</em> an object off the stack. Here is a simple implementation that can hold up to 10 objects:</p>
<pre data-type="programlisting">public class Stack
{
  int position;
  <strong>object</strong>[] data = new object[10];
  public void Push (<strong>object</strong> obj)   { data[position++] = obj;  }
  public <strong>object</strong> Pop()             { return data[--position]; }
}</pre>
<p>Because <code>Stack</code> works with the object type, we can <code>Push</code> and <code>Pop</code> instances of <em>any type</em> to and from the <code>Stack</code>:</p>
<pre data-type="programlisting">Stack stack = new Stack();
stack.Push ("sausage");
string s = (string) stack.Pop();   // Downcast, so explicit cast is needed

Console.WriteLine (s);             // sausage</pre>
<p><code>object</code> is a reference type, by virtue of being a class. Despite this, value types, such as <code>int</code>, can also be cast to and from <code>object</code>, and so be added to our stack. <a contenteditable="false" data-primary="type unification" data-type="indexterm" id="id2153"/>This feature of C# is called <em>type unification</em> and is demonstrated here:</p>
<pre data-type="programlisting">stack.Push (3);
int three = (int) stack.Pop();</pre>
<p>When you cast between a value type and <code>object</code>, the CLR must perform some special work to bridge the difference in semantics between value and reference types. This process is called <em>boxing</em> and <em>unboxing</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In <a data-type="xref" href="#generics">“Generics”</a>, we describe how to improve our <code>Stack</code> class to better handle stacks with same-typed elements.</p>
</div>
<section data-pdf-bookmark="Boxing and Unboxing" data-type="sect2"><div class="sect2" id="boxing_and_unboxing">
<h2>Boxing and Unboxing</h2>
<p><a contenteditable="false" data-primary="boxing" data-secondary="defined" data-type="indexterm" id="id2154"/><a contenteditable="false" data-primary="object type" data-secondary="boxing and unboxing" data-type="indexterm" id="id2155"/><a contenteditable="false" data-primary="unboxing" data-type="indexterm" id="id2156"/>Boxing is the act of converting a value-type instance to a reference-type instance. The reference type can be either the <code>object</code> class or an interface (which we visit later in the chapter).<sup><a data-type="noteref" href="ch03.html#ch01fn5" id="ch01fn5-marker">1</a></sup> In this example, we box an <code>int</code> into an object:</p>
<pre data-type="programlisting">int x = 9;
object obj = x;           // Box the int</pre>
<p>Unboxing reverses the operation by casting the object back to the original value type:</p>
<pre data-type="programlisting">int y = (int)obj;         // Unbox the int</pre>
<p>Unboxing requires an explicit cast. The runtime checks that the stated value type matches the actual object type, and throws an <code>InvalidCastException</code> if the check fails. For instance, the following throws an exception because <code>long</code> does not exactly match <code>int</code>:</p>
<pre data-type="programlisting">object obj = 9;           // 9 is inferred to be of type int
long x = (long) obj;      // InvalidCastException</pre>
<p>The following succeeds, however:</p>
<pre data-type="programlisting">object obj = 9;
long x = (int) obj;</pre>
<p>As does this:</p>
<pre data-type="programlisting">object obj = 3.5;              // 3.5 is inferred to be of type double
int x = (int) (double) obj;    // x is now 3</pre>
<p>In the last example, <code>(double)</code> performs an <em>unboxing</em> and then <code>(int)</code> performs a <em>numeric conversion</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Boxing conversions are crucial in providing a unified type system. The system is not perfect, however: we’ll see in <a data-type="xref" href="#generics">“Generics”</a> that variance with arrays and generics supports only <em>reference conversions</em> and not <em>boxing conversions</em>:</p>
<pre data-type="programlisting">object[] a1 = new <strong>string</strong>[3];   // Legal
object[] a2 = new <strong>int</strong>[3];      // Error</pre>
</div>
<section data-pdf-bookmark="Copying semantics of boxing and unboxing" data-type="sect3"><div class="sect3" id="copying_semantics_of_boxing_and_unboxin">
<h3>Copying semantics of boxing and unboxing</h3>
<p><a contenteditable="false" data-primary="boxing" data-secondary="copying semantics" data-type="indexterm" id="id2157"/>Boxing <em>copies</em> the value-type instance into the new object, and unboxing <em>copies</em> the contents of the object back into a value-type instance. In the following example, changing the value of <code>i</code> doesn’t change its previously boxed copy:</p>
<pre data-type="programlisting">int i = 3;
object boxed = i;
i = 5;
Console.WriteLine (boxed);    // 3</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Static and Runtime Type Checking" data-type="sect2"><div class="sect2" id="static_and_runtime_type_checking">
<h2>Static and Runtime Type Checking</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="static/runtime type checking" data-type="indexterm" id="id2158"/><a contenteditable="false" data-primary="runtime type checking" data-type="indexterm" id="id2159"/><a contenteditable="false" data-primary="static type checking" data-type="indexterm" id="id2160"/><a contenteditable="false" data-primary="type checking" data-type="indexterm" id="id2161"/>C# programs are type-checked both statically (at compile time) and at runtime (by the CLR).</p>
<p>Static type checking enables the compiler to verify the correctness of your program without running it. The following code will fail because the compiler enforces static typing:</p>
<pre data-type="programlisting">int x = "5";</pre>
<p>Runtime type checking is performed by the CLR when you downcast via a reference conversion or unboxing:</p>
<pre data-type="programlisting">object y = "5";
int z = (int) y;          // Runtime error, downcast failed</pre>
<p>Runtime type checking is possible because each object on the heap internally stores a little type token. <a contenteditable="false" data-primary="Get..." data-secondary="GetType method" data-type="indexterm" id="id2162"/>You can retrieve this token by calling the <code>GetType</code> method of <code>object</code>.</p>
</div></section>
<section data-pdf-bookmark="The GetType Method and typeof Operator" data-type="sect2"><div class="sect2" id="the_gettype_method_and_typeof_operator">
<h2>The GetType Method and typeof Operator</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="GetType method and typeof operator" data-type="indexterm" id="id2163"/><a contenteditable="false" data-primary="System..." data-secondary="System.Type" data-type="indexterm" id="id2164"/>All types in C# are represented at runtime with an instance of <code>System.Type</code>. There are two basic ways to get a <code>System.Type</code> object:</p>
<ul>
<li><p>Call <code>GetType</code> on the instance</p></li>
<li><p>Use the <code>typeof</code> operator on a type name</p></li>
</ul>
<p><a contenteditable="false" data-primary="typeof operator" data-type="indexterm" id="id2165"/><code>GetType</code> is evaluated at runtime; <code>typeof</code> is evaluated statically at compile time (when generic type parameters are involved, it’s resolved by the JIT compiler).</p>
<p><code>System.Type</code> has properties for such things as the type’s name, assembly, base type, and so on:</p>
<pre data-type="programlisting">Point p = new Point();
Console.WriteLine (p.GetType().Name);             // Point
Console.WriteLine (typeof (Point).Name);          // Point
Console.WriteLine (p.GetType() == typeof(Point)); // True
Console.WriteLine (p.X.GetType().Name);           // Int32
Console.WriteLine (p.Y.GetType().FullName);       // System.Int32

public class Point { public int X, Y; }</pre>
<p><code>System.Type</code> also has methods that act as a gateway to the runtime’s reflection model, described in <a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>.</p>
</div></section>
<section data-pdf-bookmark="The ToString Method" data-type="sect2"><div class="sect2" id="the_tostring_method">
<h2>The ToString Method</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="ToString method" data-type="indexterm" id="id2166"/><a contenteditable="false" data-primary="To..." data-secondary="ToString method" data-type="indexterm" id="id2167"/>The <code>ToString</code> method returns the default textual representation of a type instance. This method is overridden by all built-in types. Here is an example of using the <code>int</code> type’s <code>ToString</code> method:</p>
<pre data-type="programlisting">int x = 1;
string s = x.ToString();     // s is "1"</pre>
<p>You can override the <code>ToString</code> method on custom types as follows:</p>
<pre data-type="programlisting">Panda p = new Panda { Name = "Petey" };
Console.WriteLine (p);   // Petey

public class Panda
{
  public string Name;
  public override string ToString() =&gt; Name;
}</pre>
<p>If you don’t override <code>ToString</code>, the method returns the type name.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you call an <em>overridden</em> <code>object</code> member such as <code>ToString</code> directly on a value type, boxing doesn’t occur. Boxing then occurs only if you cast:</p>
<pre data-type="programlisting">int x = 1;
string s1 = x.ToString();    // Calling on nonboxed value
object box = x;
string s2 = box.ToString();  // Calling on boxed value</pre>
</div>
</div></section>
<section data-pdf-bookmark="Object Member Listing" data-type="sect2"><div class="sect2" id="object_member_listing">
<h2>Object Member Listing</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="object member listing" data-type="indexterm" id="id2168"/>Here are all the members of <code>object</code>:</p>
<pre data-type="programlisting">public class Object
{
  public Object();

  public extern Type GetType();

  public virtual bool Equals (object obj);
  public static bool Equals  (object objA, object objB);
  public static bool ReferenceEquals (object objA, object objB);

  public virtual int GetHashCode();

  public virtual string ToString();

  protected virtual void Finalize();
  protected extern object MemberwiseClone();
}</pre>
<p>We describe the <code>Equals</code>, <code>ReferenceEquals</code>, and <code>GetHashCode</code> methods in <a data-type="xref" href="ch06.html#equality_comparison-id00067">“Equality Comparison”</a>.<a contenteditable="false" data-primary="" data-startref="ch03.html1016" data-type="indexterm" id="id2169"/><a contenteditable="false" data-primary="" data-startref="ch03.html1015" data-type="indexterm" id="id2170"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Structs" data-type="sect1"><div class="sect1" id="structs">
<h1>Structs</h1>
<p><a contenteditable="false" data-primary="structs" data-type="indexterm" id="ch03.html1017"/><a contenteditable="false" data-primary="type system, C#" data-secondary="structs" data-type="indexterm" id="ch03.html1018"/>A <em>struct</em> is similar to a class, with the following key differences:</p>
<ul>
<li><p>A struct is a value type, whereas a class is a reference type.</p></li>
<li><p>A struct does not support inheritance (other than implicitly deriving from <code>object</code>, or more precisely, <code>System.ValueType</code>).</p></li>
</ul>
<p>A struct can have all of the members that a class can, except for a finalizer. And because it cannot be subclassed, members cannot be marked as virtual, abstract, or protected.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Prior to C# 10, structs were further prohibited from defining fields initializers and parameterless constructors. Although this prohibition has now been relaxed—primarily for the benefit of record structs (see <a data-type="xref" href="ch04.html#records-id00087">“Records”</a>)—it’s worth thinking carefully before defining these constructs, as they can result in confusing behavior that we’ll describe in <a data-type="xref" href="#struct_construction_semantics">“Struct Construction Semantics”</a>.</p>
</div>
<p>A struct is appropriate when value-type semantics are desirable. Good examples of structs are numeric types, where it is more natural for assignment to copy a value rather than a reference. Because a struct is a value type, each instance does not require instantiation of an object on the heap; this results in useful savings when creating many instances of a type. For instance, creating an array of value type elements requires only a single heap allocation.</p>
<p>Because structs are value types, an instance cannot be null. The default value for a struct is an empty instance, with all fields empty (set to their default values).</p>
<section data-pdf-bookmark="Struct Construction Semantics" data-type="sect2"><div class="sect2" id="struct_construction_semantics">
<h2>Struct Construction Semantics</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="structs" data-secondary="construction semantics" data-type="indexterm" id="id2171"/>Prior to C# 11, every field in a struct had to be explicitly assigned in the constructor (or field initializer). This restriction has now been relaxed.</p>
</div>
<section data-pdf-bookmark="The default constructor" data-type="sect3"><div class="sect3" id="the_default_constructor">
<h3>The default constructor</h3>
<p>In addition to any constructors that you define, a struct always has an implicit parameterless constructor that performs a bitwise-zeroing of its fields (setting them to their default values):</p>
<pre data-type="programlisting">Point p = new Point();        // p.x and p.y will be 0
struct Point { int x, y; }</pre>
<p>Even when you define a parameterless constructor of your own, the implicit parameterless constructor still exists and can be accessed via the <code>default</code> keyword:</p>
<pre data-type="programlisting">Point p1 = new Point();       // p1.x and p1.y will be 1
Point p2 = <strong>default</strong>;           // <strong>p2.x and p2.y will be 0</strong>

struct Point
{
  int x = 1;
  int y;
  public Point() =&gt; y = 1;
}</pre>
<p>In this example, we initialized <code>x</code> to 1 via a field initializer, and we initialized <code>y</code> to 1 via the parameterless constructor. And yet with the <code>default</code> keyword, we were still able to create a <code>Point</code> that bypassed both initializations. The default constructor can be accessed other ways, too, as the following example illustrates:</p>
<pre data-type="programlisting">var points = new Point[10];   // Each point in the array will be (0,0)
var test = new Test();        // test.p will be (0,0)

class Test { Point p; }</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Having what amounts to two parameterless constructors can be a source of confusion, and is arguably a good reason to avoid defining field initializers and explicit parameterless constructors in structs.</p>
</div>
<p>A good strategy with structs is to design them such that their <code>default</code> value is a valid state, thereby making initialization redundant. For example, rather than initializing a property as follows:</p>
<pre data-type="programlisting">public string Protocol { get; set; } = "https";</pre>
<p>consider the following:</p>
<pre data-type="programlisting">struct WebOptions
{
  string protocol;
  public string Protocol { get =&gt; protocol ?? "https";
                           set =&gt; protocol = value;    }
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Read-Only Structs and Functions" data-type="sect2"><div class="sect2" id="read_only_structs_and_functions">
<h2>Read-Only Structs and Functions</h2>
<p><a contenteditable="false" data-primary="read-only structs" data-type="indexterm" id="id2172"/><a contenteditable="false" data-primary="structs" data-secondary="read-only structs/functions" data-type="indexterm" id="id2173"/>You can apply the <code>readonly</code> modifier to a struct to enforce that all fields are <code>readonly</code>; this aids in declaring intent as well as affording the compiler more optimization freedom:</p>
<pre data-type="programlisting"><strong>readonly</strong> struct Point
{
  public readonly int X, Y;   // X and Y must be readonly
}</pre>
<p><a contenteditable="false" data-primary="readonly modifier" data-type="indexterm" id="id2174"/>If you need to apply <code>readonly</code> at a more granular level, you can apply the <code>readonly</code> modifier (from C# 8) to a struct’s <em>functions</em>. This ensures that if the function attempts to modify any field, a compile-time error is generated:</p>
<pre data-type="programlisting">struct Point
{
  public int X, Y;
  public <strong>readonly</strong> void ResetX() =&gt; X = 0;  // Error!
}</pre>
<p>If a <code>readonly</code> function calls a non-<code>readonly</code> function, the compiler generates a warning (and defensively copies the struct to avoid the possibility of a mutation).</p>
</div></section>
<section data-pdf-bookmark="Ref Structs" data-type="sect2"><div class="sect2" id="ref_structs">
<h2>Ref Structs</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="ref structs" data-type="indexterm" id="id2175"/><a contenteditable="false" data-primary="structs" data-secondary="ref structs" data-type="indexterm" id="id2176"/>Ref structs were introduced in C# 7.2 as a niche feature primarily for the benefit of the <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> structs that we describe in <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a> (and the highly optimized <code>Utf8JsonReader</code> that we describe in <a data-type="xref" href="ch11.html#other_xml_and_json_technologies">Chapter 11</a>). These structs help with a micro-optimization technique that aims to reduce memory allocations.</p>
</div>
<p>Unlike reference types, whose instances always live on the heap, value types live <em>in-place</em> (wherever the variable was declared). If a value type appears as a parameter or local variable, it will reside on the stack:</p>
<pre data-type="programlisting">void SomeMethod()
{
  Point p;   // p will reside on the stack
}
<strong>struct</strong> Point { public int X, Y; }</pre>
<p>But if a value type appears as a field in a class, it will reside on the heap:</p>
<pre data-type="programlisting">class MyClass
{
  Point p;   // Lives on heap, because MyClass instances live on the heap
}</pre>
<p>Similarly, arrays of structs live on the heap, and boxing a struct sends it to the heap.</p>
<p>Adding the <code>ref</code> modifier to a struct’s declaration ensures that it can only ever reside on the stack. Attempting to use a <em>ref struct</em> in such a way that it could reside on the heap generates a compile-time error:</p>
<pre data-type="programlisting">var points = new Point [100];           // Error: will not compile!

<strong>ref</strong> struct Point { public int X, Y; }
class MyClass    { <strong>Point P</strong>;         }   // Error: will not compile!</pre>
<p>Ref structs were introduced mainly for the benefit of the <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> structs. Because <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> instances can exist only on the stack, it’s possible for them to safely wrap stack-allocated memory.</p>
<p>Ref structs cannot partake in any C# feature that directly or indirectly introduces the possibility of existing on the heap. This includes a number of advanced C# features that we describe in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>, namely, lambda expressions, iterators, and asynchronous functions (because, behind the scenes, these features all create hidden classes with fields). Also, ref structs cannot appear inside non-ref structs, and they cannot implement interfaces (because this could result in boxing).<a contenteditable="false" data-primary="" data-startref="ch03.html1018" data-type="indexterm" id="id2177"/><a contenteditable="false" data-primary="" data-startref="ch03.html1017" data-type="indexterm" id="id2178"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Access Modifiers" data-type="sect1"><div class="sect1" id="access_modifiers">
<h1>Access Modifiers</h1>
<p><a contenteditable="false" data-primary="access modifiers" data-type="indexterm" id="ch03.html1019"/><a contenteditable="false" data-primary="type system, C#" data-secondary="access modifiers" data-type="indexterm" id="ch03.html1020"/>To promote encapsulation, a type or type member can limit its <em>accessibility</em> to other types and other assemblies by adding an <em>access modifier</em> to the declaration:</p>
<dl>
<dt><code>public</code></dt>
<dd><a contenteditable="false" data-primary="public access modifier" data-type="indexterm" id="id2179"/>Fully accessible. This is the implicit accessibility for members of an enum or interface.</dd>
<dt><code>internal</code></dt>
<dd><a contenteditable="false" data-primary="internal access modifier" data-type="indexterm" id="id2180"/>Accessible only within the containing assembly or friend assemblies. This is the default accessibility for non-nested types.</dd>
<dt><code>private</code></dt>
<dd><a contenteditable="false" data-primary="private access modifier" data-type="indexterm" id="id2181"/>Accessible only within the containing type. This is the default accessibility for members of a class or struct.</dd>
<dt><code>protected</code></dt>
<dd><a contenteditable="false" data-primary="protected access modifier" data-type="indexterm" id="id2182"/>Accessible only within the containing type or subclasses.</dd>
<dt><code>protected internal</code></dt>
<dd><a contenteditable="false" data-primary="protected internal access modifier" data-type="indexterm" id="id2183"/>The <em>union</em> of <code>protected</code> and <code>internal</code> accessibility. A member that is <code>protected internal</code> is accessible in two ways.</dd>
<dt><code>private protected</code></dt>
<dd><a contenteditable="false" data-primary="private protected access modifier" data-type="indexterm" id="id2184"/>The <em>intersection</em> of <code>protected</code> and <code>internal</code> accessibility. A member that is <code>private protected</code> is accessible only within the containing type, or from subclasses <em>that reside in the same assembly</em> (making it <em>less</em> accessible than <code>protected</code> or <code>internal</code> alone).</dd>
<dt><code>file</code> (from C# 11)</dt>
<dd><a contenteditable="false" data-primary="file access modifier" data-type="indexterm" id="id2185"/>Accessible only from within the same file. Intended for use by <em>source generators</em> (see <a data-type="xref" href="#extended_partial_methods">“Extended partial methods”</a>). This modifier can be applied only to type declarations.</dd>
</dl>
<section data-pdf-bookmark="Examples" data-type="sect2"><div class="sect2" id="examples">
<h2>Examples</h2>
<p><code>Class2</code> is accessible from outside its assembly; <code>Class1</code> is not:</p>
<pre data-type="programlisting">class Class1 {}                  // Class1 is internal (default)
<strong>public</strong> class Class2 {}</pre>
<p class="pagebreak-before"><code>ClassB</code> exposes field <code>x</code> to other types in the same assembly; <code>ClassA</code> does not:</p>
<pre data-type="programlisting">class ClassA { int x;          } // x is private (default)
class ClassB { <strong>internal</strong> int x; }</pre>
<p>Functions within <code>Subclass</code> can call <code>Bar</code> but not <code>Foo</code>:</p>
<pre data-type="programlisting">class BaseClass
{
  void Foo()           {}        // Foo is private (default)
  <strong>protected</strong> void Bar() {}
}

class Subclass : BaseClass
{
  void Test1() { Foo(); }       // Error - cannot access Foo
  void Test2() { Bar(); }       // OK
}</pre>
</div></section>
<section data-pdf-bookmark="Friend Assemblies" data-type="sect2"><div class="sect2" id="friend_assemblies">
<h2>Friend Assemblies</h2>
<p><a contenteditable="false" data-primary="access modifiers" data-secondary="friend assemblies" data-type="indexterm" id="id2186"/><a contenteditable="false" data-primary="friend assemblies" data-type="indexterm" id="id2187"/>You can expose <code>internal</code> members to other <em>friend</em> assemblies by adding the <span class="keep-together"><code>System.Runtime.CompilerServices.InternalsVisibleTo</code></span> assembly attribute, specifying the name of the friend assembly as follows:</p>
<pre data-type="programlisting">[assembly: InternalsVisibleTo ("Friend")]</pre>
<p>If the friend assembly has a strong name (see <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>), you must specify its <em>full</em> 160-byte public key:</p>
<pre data-type="programlisting">[assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]</pre>
<p>You can extract the full public key from a strongly named assembly with a LINQ query (we explain LINQ in detail in <a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>):</p>
<pre data-type="programlisting">string key = string.Join ("",
  Assembly.GetExecutingAssembly().GetName().GetPublicKey()
    .Select (b =&gt; b.ToString ("x2")));</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The companion sample in LINQPad invites you to browse to an assembly and then copies the assembly’s full public key to the clipboard.</p>
</div>
</div></section>
<section data-pdf-bookmark="Accessibility Capping" data-type="sect2"><div class="sect2" id="accessibility_capping">
<h2>Accessibility Capping</h2>
<p><a contenteditable="false" data-primary="access modifiers" data-secondary="accessibility capping" data-type="indexterm" id="id2188"/>A type caps the accessibility of its declared members. The most common example of capping is when you have an <code>internal</code> type with <code>public</code> members. For example, consider this:</p>
<pre data-type="programlisting">class C { public void Foo() {} }</pre>
<p><code>C</code>’s (default) <code>internal</code> accessibility caps <code>Foo</code>’s accessibility, effectively making <code>Foo internal</code>. A common reason <code>Foo</code> would be marked <code>public</code> is to make for easier refactoring should <code>C</code> later be changed to <code>public</code>.</p>
</div></section>
<section data-pdf-bookmark="Restrictions on Access Modifiers" data-type="sect2"><div class="sect2" id="restrictions_on_access_modifiers">
<h2>Restrictions on Access Modifiers</h2>
<p><a contenteditable="false" data-primary="access modifiers" data-secondary="restrictions on" data-type="indexterm" id="id2189"/>When overriding a base class function, accessibility must be identical on the overridden function; for example:</p>
<pre data-type="programlisting">class BaseClass             { protected virtual  void Foo() {} }
class Subclass1 : BaseClass { protected override void Foo() {} }  // OK
class Subclass2 : BaseClass { <strong>public</strong>    override void Foo() {} }  // Error</pre>
<p>(An exception is when overriding a <code>protected internal</code> method in another assembly, in which case the override must simply be <code>protected</code>.)</p>
<p>The compiler prevents any inconsistent use of access modifiers. For example, a subclass itself can be less accessible than a base class but not more:<a contenteditable="false" data-primary="" data-startref="ch03.html1020" data-type="indexterm" id="id2190"/><a contenteditable="false" data-primary="" data-startref="ch03.html1019" data-type="indexterm" id="id2191"/></p>
<pre data-type="programlisting">internal class A {}
public class B : A {}          // Error</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Interfaces" data-type="sect1"><div class="sect1" id="interfaces">
<h1>Interfaces</h1>
<p><a contenteditable="false" data-primary="interface" data-type="indexterm" id="ch03.html1021"/><a contenteditable="false" data-primary="type system, C#" data-secondary="interfaces" data-type="indexterm" id="ch03.html1022"/>An interface is similar to a class, but only <em>specifies behavior</em> and does not hold state (data). Consequently:</p>
<ul>
<li><p>An interface can define only functions and not fields.</p></li>
<li><p>Interface members are <em>implicitly abstract</em>. (There are exceptions to this rule that we will describe in <a data-type="xref" href="#default_interface_members-id00061">“Default Interface Members”</a> and <a data-type="xref" href="#static_interface_members">“Static Interface Members”</a>.)</p></li>
<li><p>A class (or struct) can implement multiple interfaces. In contrast, a class can inherit from only a single class, and a struct cannot inherit at all (aside from deriving from <code>System.ValueType</code>).</p></li>
</ul>
<p>An interface declaration is like a class declaration, but it (normally) provides no implementation for its members because its members are implicitly abstract. These members will be implemented by the classes and structs that implement the interface. An interface can contain only functions, that is, methods, properties, events, and indexers (which noncoincidentally are precisely the members of a class that can be abstract).</p>
<p>Here is the definition of the <code>IEnumerator</code> interface, defined in <code>System.Collections</code>:</p>
<pre data-type="programlisting">public <strong>interface</strong> IEnumerator
{
  bool MoveNext();
  object Current { get; }
  void Reset();
}</pre>
<p>Interface members are always implicitly public and cannot declare an access modifier. Implementing an interface means providing a <code>public</code> implementation for all of its members:</p>
<pre data-type="programlisting">internal class Countdown : IEnumerator
{
  int count = 11;
  public bool MoveNext() =&gt; count-- &gt; 0;
  public object Current =&gt; count;
  public void Reset() { throw new NotSupportedException(); }
}</pre>
<p>You can implicitly cast an object to any interface that it implements:</p>
<pre data-type="programlisting">IEnumerator e = new Countdown();
while (e.MoveNext())
  Console.Write (e.Current);      // 109876543210</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Even though <code>Countdown</code> is an internal class, its members that implement <code>IEnumerator</code> can be called publicly by casting an instance of <code>Countdown</code> to <code>IEnumerator</code>. For instance, if a public type in the same assembly defined a method as follows:</p>
<pre data-type="programlisting">public static class Util
{
  public static object GetCountDown() =&gt; new CountDown();
}</pre>
<p>a caller from another assembly could do this:</p>
<pre data-type="programlisting">IEnumerator e = (IEnumerator) Util.GetCountDown();
e.MoveNext();</pre>
<p>If <code>IEnumerator</code> were itself defined as <code>internal</code>, this wouldn’t be possible.</p>
</div>
<section data-pdf-bookmark="Extending an Interface" data-type="sect2"><div class="sect2" id="extending_an_interface">
<h2>Extending an Interface</h2>
<p><a contenteditable="false" data-primary="interface" data-secondary="extending" data-type="indexterm" id="id2192"/>Interfaces can derive from other interfaces; for instance:</p>
<pre data-type="programlisting">public interface IUndoable             { void Undo(); }
public interface IRedoable : IUndoable { void Redo(); }</pre>
<p><code>IRedoable</code> “inherits” all the members of <code>IUndoable</code>. In other words, types that implement <code>IRedoable</code> must also implement the members of <code>IUndoable</code>.</p>
</div></section>
<section data-pdf-bookmark="Explicit Interface Implementation" data-type="sect2"><div class="sect2" id="explicit_interface_implementation">
<h2>Explicit Interface Implementation</h2>
<p><a contenteditable="false" data-primary="interface" data-secondary="explicit implementation" data-type="indexterm" id="id2193"/>Implementing multiple interfaces can sometimes result in a collision between member signatures. You can resolve such collisions by <em>explicitly implementing</em> an interface member. Consider the following example:</p>
<pre data-type="programlisting">interface I1 { void Foo(); }
interface I2 { int Foo(); }

public class Widget : I1, I2
{
  public void Foo()
  {
    Console.WriteLine ("Widget's implementation of I1.Foo");
  }

  int <strong>I2.Foo</strong>()
  {
    Console.WriteLine ("Widget's implementation of I2.Foo");
    return 42;
  }
}</pre>
<p>Because <code>I1</code> and <code>I2</code> have conflicting <code>Foo</code> signatures, <code>Widget</code> explicitly implements <code>I2</code>’s <code>Foo</code> method. This lets the two methods coexist in one class. The only way to call an explicitly implemented member is to cast to its interface:</p>
<pre data-type="programlisting">Widget w = new Widget();
w.Foo();                      // Widget's implementation of I1.Foo
((I1)w).Foo();                // Widget's implementation of I1.Foo
((I2)w).Foo();                // Widget's implementation of I2.Foo</pre>
<p>Another reason to explicitly implement interface members is to hide members that are highly specialized and distracting to a type’s normal use case. For example, a type that implements <code>ISerializable</code> would typically want to avoid flaunting its <code>ISerializable</code> members unless explicitly cast to that interface.</p>
</div></section>
<section data-pdf-bookmark="Implementing Interface Members Virtually" data-type="sect2"><div class="sect2" id="implementing_interface_members_virtuall">
<h2>Implementing Interface Members Virtually</h2>
<p><a contenteditable="false" data-primary="interface" data-secondary="virtual implementation" data-type="indexterm" id="id2194"/>An implicitly implemented interface member is, by default, sealed. It must be marked <code>virtual</code> or <code>abstract</code> in the base class in order to be overridden:</p>
<pre data-type="programlisting">public interface IUndoable { void Undo(); }

public class TextBox : IUndoable
{
  public <strong>virtual</strong> void Undo() =&gt; Console.WriteLine ("TextBox.Undo");
}

public class RichTextBox : TextBox
{
  public <strong>override</strong> void Undo() =&gt; Console.WriteLine ("RichTextBox.Undo");
}</pre>
<p>Calling the interface member through either the base class or the interface calls the subclass’s <span class="keep-together">implementation:</span></p>
<pre data-type="programlisting">RichTextBox r = new RichTextBox();
r.Undo();                          // RichTextBox.Undo
((IUndoable)r).Undo();             // RichTextBox.Undo
((TextBox)r).Undo();               // RichTextBox.Undo</pre>
<p>An explicitly implemented interface member cannot be marked <code>virtual</code>, nor can it be overridden in the usual manner. It can, however, be <em>reimplemented</em>.</p>
</div></section>
<section data-pdf-bookmark="Reimplementing an Interface in a Subclass" data-type="sect2"><div class="sect2" id="reimplementing_an_interface_in_a_subcla">
<h2>Reimplementing an Interface in a Subclass</h2>
<p><a contenteditable="false" data-primary="interface" data-secondary="reimplementing in a subclass" data-type="indexterm" id="ch03.html1023"/><a contenteditable="false" data-primary="reimplementing interfaces" data-type="indexterm" id="ch03.html1024"/><a contenteditable="false" data-primary="subclass" data-secondary="reimplementing an interface in" data-type="indexterm" id="ch03.html1025"/>A subclass can reimplement any interface member already implemented by a base class. Reimplementation hijacks a member implementation (when called through the interface) and works whether or not the member is <code>virtual</code> in the base class. It also works whether a member is implemented implicitly or explicitly—although it works best in the latter case, as we will demonstrate.</p>
<p>In the following example, <code>TextBox</code> implements <code>IUndoable.Undo</code> explicitly, and so it cannot be marked as <code>virtual</code>. To “override” it, <code>RichTextBox</code> must reimplement <code>IUndoable</code>’s <code>Undo</code> method:</p>
<pre data-type="programlisting">public interface IUndoable { void Undo(); }

public class TextBox : IUndoable
{
  void IUndoable.Undo() =&gt; Console.WriteLine ("TextBox.Undo");
}

public class RichTextBox : TextBox<strong>, IUndoable</strong>
{
  public void Undo() =&gt; Console.WriteLine ("RichTextBox.Undo");
}</pre>
<p>Calling the reimplemented member through the interface calls the subclass’s implementation:</p>
<pre data-type="programlisting">RichTextBox r = new RichTextBox();
r.Undo();                 // RichTextBox.Undo      Case 1
((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2</pre>
<p>Assuming the same <code>RichTextBox</code> definition, suppose that <code>TextBox</code> implemented <code>Undo</code> <em>implicitly</em>:</p>
<pre data-type="programlisting">public class TextBox : IUndoable
{
  public void Undo() =&gt; Console.WriteLine ("TextBox.Undo");
}</pre>
<p>This would give us another way to call <code>Undo</code>, which would “break” the system, as shown in Case 3:</p>
<pre data-type="programlisting">RichTextBox r = new RichTextBox();
r.Undo();                 // RichTextBox.Undo      Case 1
((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2
((TextBox)r).Undo();      // <strong>TextBox.Undo</strong>          Case 3</pre>
<p>Case 3 demonstrates that reimplementation hijacking is effective only when a member is called through the interface and not through the base class. This is usually undesirable in that it can create inconsistent semantics. This makes reimplementation most appropriate as a strategy for overriding <em>explicitly</em> implemented interface members.</p>
<section data-pdf-bookmark="Alternatives to interface reimplementation" data-type="sect3"><div class="sect3" id="alternatives_to_interface_reimplementat">
<h3>Alternatives to interface reimplementation</h3>
<p><a contenteditable="false" data-primary="interface" data-secondary="alternatives to reimplementation" data-type="indexterm" id="id2195"/>Even with explicit member implementation, interface reimplementation is problematic for a couple of reasons:</p>
<ul class="pagebreak-before">
<li><p>The subclass has no way to call the base class method.</p></li>
<li><p>The base class author might not anticipate that a method will be reimplemented and might not allow for the potential consequences.</p></li>
</ul>
<p>Reimplementation can be a good last resort when subclassing hasn’t been anticipated. A better option, however, is to design a base class such that reimplementation will never be required. There are two ways to achieve this:</p>
<ul>
<li><p>When implicitly implementing a member, mark it <code>virtual</code> if appropriate.</p></li>
<li><p>When explicitly implementing a member, use the following pattern if you anticipate that subclasses might need to override any logic:</p></li>
</ul>
<pre data-type="programlisting">public class TextBox : IUndoable
{
  void IUndoable.Undo()         =&gt; Undo();    // Calls method below
  protected virtual void Undo() =&gt; Console.WriteLine ("TextBox.Undo");
}

public class RichTextBox : TextBox
{
  protected override void Undo() =&gt; Console.WriteLine("RichTextBox.Undo");
}</pre>
<p><a contenteditable="false" data-primary="sealed modifier" data-type="indexterm" id="id2196"/>If you don’t anticipate any subclassing, you can mark the class as <code>sealed</code> to preempt interface reimplementation.<a contenteditable="false" data-primary="" data-startref="ch03.html1025" data-type="indexterm" id="id2197"/><a contenteditable="false" data-primary="" data-startref="ch03.html1024" data-type="indexterm" id="id2198"/><a contenteditable="false" data-primary="" data-startref="ch03.html1023" data-type="indexterm" id="id2199"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Interfaces and Boxing" data-type="sect2"><div class="sect2" id="interfaces_and_boxing">
<h2>Interfaces and Boxing</h2>
<p><a contenteditable="false" data-primary="boxing" data-secondary="interfaces and" data-type="indexterm" id="id2200"/><a contenteditable="false" data-primary="interface" data-secondary="boxing and" data-type="indexterm" id="id2201"/>Converting a struct to an interface causes boxing. Calling an implicitly implemented member on a struct does not cause boxing:</p>
<pre data-type="programlisting">interface  I { void Foo();          }
struct S : I { public void Foo() {} }

...
S s = new S();
s.Foo();         // No boxing.

I i = s;         // Box occurs when casting to interface.
i.Foo();</pre>
</div></section>
<section data-pdf-bookmark="Default Interface Members" data-type="sect2"><div class="sect2" id="default_interface_members-id00061">
<h2>Default Interface Members</h2>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="default interface members" data-type="indexterm" id="id2202"/><a contenteditable="false" data-primary="interface" data-secondary="default implementation" data-type="indexterm" id="id2203"/>From C# 8, you can add a default implementation to an interface member, making it optional to implement:</p>
<pre data-type="programlisting">interface ILogger
{
  void Log (string text) <strong>=&gt; Console.WriteLine (text);</strong>
}</pre>
<p>This is advantageous if you want to add a member to an interface defined in a popular library without breaking (potentially thousands of) implementations.</p>
<p>Default implementations are always explicit, so if a class implementing <code>ILogger</code> fails to define a <code>Log</code> method, the only way to call it is through the interface:</p>
<pre data-type="programlisting">class Logger : ILogger { }
...
(<strong>(ILogger)</strong>new Logger()).Log ("message");</pre>
<p>This prevents a problem of multiple implementation inheritance: if the same default member is added to two interfaces that a class implements, there is never an ambiguity as to which member is called.</p>
</div></section>
<section data-pdf-bookmark="Static Interface Members" data-type="sect2"><div class="sect2" id="static_interface_members">
<h2>Static Interface Members</h2>
<p><a contenteditable="false" data-primary="interface" data-secondary="static interface members" data-type="indexterm" id="ch03.html3"/><a contenteditable="false" data-primary="static interface members" data-type="indexterm" id="ch03.html4"/>An interface can also declare static members. There are two kinds of static interface members:</p>
<ul>
<li><p>Static nonvirtual interface members</p></li>
<li><p>Static virtual/abstract interface members</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In contrast to <em>instance</em> members, static members on interfaces are nonvirtual by default. To make a static interface member virtual, you must mark it with <code>static abstract</code> or <code>static virtual</code>.</p>
</div>
<section data-pdf-bookmark="Static nonvirtual interface members" data-type="sect3"><div class="sect3" id="static_nonvirtual_interface_members">
<h3>Static nonvirtual interface members</h3>
<p><a contenteditable="false" data-primary="static interface members" data-secondary="static nonvirtual members" data-type="indexterm" id="id2204"/>Static nonvirtual interface members exist mainly to help with writing default interface members. They are not implemented by classes or structs; instead, they are consumed directly. Along with methods, properties, events, and indexers, static nonvirtual members permit fields, which are typically accessed from code inside default member implementations:</p>
<pre data-type="programlisting">interface ILogger
{
  void Log (string text) =&gt; 
    Console.WriteLine (<strong>Prefix</strong> + text);

  <strong>static string Prefix</strong> = ""; 
}</pre>
<p>Static nonvirtual interface members are public by default, so they can be accessed from the outside:</p>
<pre data-type="programlisting"><strong>ILogger.Prefix</strong> = "File log: ";</pre>
<p>You can restrict this by adding an accessibility modifier (such as <code>private</code>, <span class="keep-together"><code>protected</code></span>, or <code>internal</code>).</p>
<p>Instance fields are (still) prohibited. This is in line with the principle of interfaces, which is to define <em>behavior</em>, not <em>state</em>.</p>
</div></section>
<section data-pdf-bookmark="Static virtual/abstract interface members" data-type="sect3"><div class="sect3" id="static_virtualsolidusabstract-id00091">
<h3>Static virtual/abstract interface members</h3>
<p><a contenteditable="false" data-primary="static virtual members" data-type="indexterm" id="id2205"/><a contenteditable="false" data-primary="static abstract members" data-type="indexterm" id="id2206"/><a contenteditable="false" data-primary="static interface members" data-secondary="static virtual/abstract members" data-type="indexterm" id="id2207"/><a contenteditable="false" data-primary="static polymorphism" data-secondary="static virtual/abstract members and" data-type="indexterm" id="id2208"/>Static virtual/abstract interface members (from C# 11) enable <em>static polymorphism</em>, an advanced feature that we will discuss in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>. Static virtual interface members are marked with <code>static abstract</code> or <code>static virtual</code>:</p>
<pre data-type="programlisting">interface ITypeDescribable
{
  <strong>static abstract</strong> string Description { get; }
  <strong>static virtual</strong> string Category =&gt; null;
}</pre>
<p>An implementing class or struct must implement static abstract members, and can optionally implement static virtual members:</p>
<pre data-type="programlisting">class CustomerTest : ITypeDescribable
{
  public static string Description =&gt; "Customer tests";  // Mandatory
  public static string Category    =&gt; "Unit testing";    // Optional
}</pre>
<p>In addition to methods, properties, and events, operators and conversions are also legal targets for static virtual interface members (see <a data-type="xref" href="ch04.html#operator_overloading">“Operator Overloading”</a>). Static virtual interface members are called through a constrained type parameter; we will demonstrate this in <a data-type="xref" href="ch04.html#static_polymorphism">“Static Polymorphism”</a> and <a data-type="xref" href="ch04.html#generic_math-id00069">“Generic Math”</a>, after covering generics later in this chapter.<a contenteditable="false" data-primary="" data-startref="ch03.html4" data-type="indexterm" id="id2209"/><a contenteditable="false" data-primary="" data-startref="ch03.html3" data-type="indexterm" id="id2210"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="writing_a_class_versus_an_interface">
<h1>Writing a Class Versus an Interface</h1>
<p><a contenteditable="false" data-primary="classes" data-secondary="writing a class versus an interface" data-type="indexterm" id="id2211"/><a contenteditable="false" data-primary="interface" data-secondary="writing a class versus an interface" data-type="indexterm" id="id2212"/>As a guideline:</p>
<ul>
<li><p>Use classes and subclasses for types that naturally share an implementation.</p></li>
<li><p>Use interfaces for types that have independent implementations.</p></li>
</ul>
<p>Consider the following classes:</p>
<pre data-type="programlisting">abstract class Animal {}
abstract class Bird           : Animal {}
abstract class Insect         : Animal {}
abstract class FlyingCreature : Animal {}
abstract class Carnivore      : Animal {}

// Concrete classes:

class Ostrich : Bird {}
class Eagle   : Bird, FlyingCreature, Carnivore {}  // Illegal
class Bee     : Insect, FlyingCreature {}           // Illegal
class Flea    : Insect, Carnivore {}                // Illegal</pre>
<p class="pagebreak-before">The <code>Eagle</code>, <code>Bee</code>, and <code>Flea</code> classes do not compile because inheriting from multiple classes is prohibited. To resolve this, we must convert some of the types to interfaces. The question then arises, which types? Following our general rule, we could say that insects share an implementation, and birds share an implementation, so they remain classes. In contrast, flying creatures have independent mechanisms for flying, and carnivores have independent strategies for eating animals, so we would convert <code>FlyingCreature</code> and <code>Carnivore</code> to interfaces:</p>
<pre data-type="programlisting">interface IFlyingCreature {}
interface ICarnivore      {}</pre>
<p>In a typical scenario, <code>Bird</code> and <code>Insect</code> might correspond to a Windows control and a web control; <code>FlyingCreature</code> and <code>Carnivore</code> might correspond to <code>IPrintable</code> and <code>IUndoable</code>.<a contenteditable="false" data-primary="" data-startref="ch03.html1022" data-type="indexterm" id="id2213"/><a contenteditable="false" data-primary="" data-startref="ch03.html1021" data-type="indexterm" id="id2214"/></p>
</div></aside>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Enums" data-type="sect1"><div class="sect1" id="enums-id00013">
<h1>Enums</h1>
<p><a contenteditable="false" data-primary="enums" data-type="indexterm" id="ch03.html1026"/><a contenteditable="false" data-primary="type system, C#" data-secondary="enums" data-type="indexterm" id="ch03.html1027"/>An <a contenteditable="false" data-primary="enums" data-secondary="defined" data-type="indexterm" id="id2215"/>enum is a special value type that lets you specify a group of named numeric constants. For example:</p>
<pre data-type="programlisting">public enum BorderSide { Left, Right, Top, Bottom }</pre>
<p>We can use this enum type as follows:</p>
<pre data-type="programlisting">BorderSide topSide = BorderSide.Top;
bool isTop = (topSide == BorderSide.Top);   // true</pre>
<p>Each enum member has an underlying integral value. These are by default:</p>
<ul>
<li><p>Underlying values are of type <code>int</code>.</p></li>
<li><p>The constants <code>0</code>, <code>1</code>, <code>2</code>... are automatically assigned, in the declaration order of the enum members.</p></li>
</ul>
<p>You can specify an alternative integral type, as follows:</p>
<pre data-type="programlisting">public enum BorderSide : <strong>byte</strong> { Left, Right, Top, Bottom }</pre>
<p>You can also specify an explicit underlying value for each enum member:</p>
<pre data-type="programlisting">public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The compiler also lets you explicitly assign <em>some</em> of the enum members. The unassigned enum members keep incrementing from the last explicit value. The preceding example is equivalent to the following:</p>
<pre data-type="programlisting">public enum BorderSide : byte
 { Left=1, Right, Top=10, Bottom }</pre>
</div>
<section class="pagebreak-before" data-pdf-bookmark="Enum Conversions" data-type="sect2"><div class="sect2" id="enum_conversions-id00014">
<h2 class="less_space">Enum Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="enums" data-type="indexterm" id="id2216"/><a contenteditable="false" data-primary="enums" data-secondary="conversions" data-type="indexterm" id="id2217"/>You can convert an <code>enum</code> instance to and from its underlying integral value with an explicit cast:</p>
<pre data-type="programlisting">int i = (int) BorderSide.Left;
BorderSide side = (BorderSide) i;
bool leftOrRight = (int) side &lt;= 2;</pre>
<p>You can also explicitly cast one enum type to another. Suppose that <code>Horizontal​A⁠lignment</code> is defined as follows:</p>
<pre data-type="programlisting">public enum HorizontalAlignment
{
  Left = BorderSide.Left,
  Right = BorderSide.Right,
  Center
}</pre>
<p>A translation between the enum types uses the underlying integral values:</p>
<pre data-type="programlisting">HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;
// same as:
HorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.Right;</pre>
<p>The numeric literal <code>0</code> is treated specially by the compiler in an <code>enum</code> expression and does not require an explicit cast:</p>
<pre data-type="programlisting">BorderSide b = 0;    // No cast required
if (b == 0) ...</pre>
<p>There are two reasons for the special treatment of <code>0</code>:</p>
<ul>
<li><p>The first member of an enum is often used as the “default” value.</p></li>
<li><p>For <em>combined enum</em> types, <code>0</code> means “no flags.”</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Flags Enums" data-type="sect2"><div class="sect2" id="flags_enums">
<h2>Flags Enums</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="Flags attribute" data-type="indexterm" id="id2218"/><a contenteditable="false" data-primary="Flags attribute" data-type="indexterm" id="id2219"/>You can combine enum members. To prevent ambiguities, members of a combinable enum require explicitly assigned values, typically in powers of two:</p>
<pre data-type="programlisting">[Flags]
enum BorderSides { None=0, Left=1, Right=2, Top=4, Bottom=8 }</pre>
<p>or:</p>
<pre data-type="programlisting">enum BorderSides { None=0, Left=1, Right=1&lt;&lt;<strong>1</strong>, Top=1&lt;&lt;<strong>2</strong>, Bottom=1&lt;&lt;<strong>3</strong> }</pre>
<p><a contenteditable="false" data-primary="&amp; (ampersand)" data-secondary="bitwise AND operator" data-type="indexterm" id="id2220"/><a contenteditable="false" data-primary="| (vertical bar)" data-secondary="bitwise OR operator" data-type="indexterm" id="id2221"/><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="bitwise AND operator" data-type="indexterm" id="id2222"/><a contenteditable="false" data-primary="vertical bar (|)" data-secondary="bitwise OR operator" data-type="indexterm" id="id2223"/>To work with combined enum values, you use bitwise operators such as <code>|</code> and <code>&amp;</code>. These operate on the underlying integral values:</p>
<pre data-type="programlisting">BorderSides leftRight = BorderSides.Left | BorderSides.Right;

if ((leftRight &amp; BorderSides.Left) != 0)
  Console.WriteLine ("Includes Left");     // Includes Left

string formatted = leftRight.ToString();   // "Left, Right"

BorderSides s = BorderSides.Left;
s |= BorderSides.Right;
Console.WriteLine (s == leftRight);   // True

s ^= BorderSides.Right;               // Toggles BorderSides.Right
Console.WriteLine (s);                // Left</pre>
<p>By convention, the <code>Flags</code> attribute should always be applied to an enum type when its members are combinable. If you declare such an <code>enum</code> without the <code>Flags</code> attribute, you can still combine members, but calling <code>ToString</code> on an <code>enum</code> instance will emit a number rather than a series of names.</p>
<p>By convention, a combinable enum type is given a plural rather than singular name.</p>
<p>For convenience, you can include combination members within an enum declaration itself:</p>
<pre data-type="programlisting">[Flags]
enum BorderSides
{
  None=0,
  Left=1, Right=1&lt;&lt;1, Top=1&lt;&lt;2, Bottom=1&lt;&lt;3,
  <strong>LeftRight = Left | Right,</strong> 
  <strong>TopBottom = Top  | Bottom,</strong>
  <strong>All       = LeftRight | TopBottom</strong>
}</pre>
</div></section>
<section data-pdf-bookmark="Enum Operators" data-type="sect2"><div class="sect2" id="enum_operators">
<h2>Enum Operators</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="operators that work with" data-type="indexterm" id="id2224"/>The operators that work with enums are:</p>
<pre data-type="programlisting">=   ==   !=   &lt;   &gt;   &lt;=   &gt;=   +   -   ^  &amp;  |   ˜
+=   -=   ++  --   sizeof</pre>
<p>The bitwise, arithmetic, and comparison operators return the result of processing the underlying integral values. Addition is permitted between an enum and an integral type, but not between two enums.</p>
</div></section>
<section data-pdf-bookmark="Type-Safety Issues" data-type="sect2"><div class="sect2" id="type_safety_issues">
<h2>Type-Safety Issues</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="type-safety issues" data-type="indexterm" id="id2225"/><a contenteditable="false" data-primary="type safety" data-secondary="enums and" data-type="indexterm" id="id2226"/>Consider the following enum:</p>
<pre data-type="programlisting">public enum BorderSide { Left, Right, Top, Bottom }</pre>
<p>Because an enum can be cast to and from its underlying integral type, the actual value it can have might fall outside the bounds of a legal enum member:</p>
<pre data-type="programlisting">BorderSide b = (BorderSide) 12345;
Console.WriteLine (b);                // 12345</pre>
<p class="pagebreak-before">The bitwise and arithmetic operators can produce similarly invalid values:</p>
<pre data-type="programlisting">BorderSide b = BorderSide.Bottom;
b++;                                  // No errors</pre>
<p>An invalid <code>BorderSide</code> would break the following code:</p>
<pre data-type="programlisting">void Draw (BorderSide side)
{
  if      (side == BorderSide.Left)  {...}
  else if (side == BorderSide.Right) {...}
  else if (side == BorderSide.Top)   {...}
  else                               {...} // Assume BorderSide.Bottom
}</pre>
<p>One solution is to add another <code>else</code> clause:</p>
<pre data-type="programlisting">  ...
  else if (side == BorderSide.Bottom) ...
  else throw new ArgumentException ("Invalid BorderSide: " + side, "side");</pre>
<p>Another workaround is to explicitly check an enum value for validity. The static <code>Enum.IsDefined</code> method does this job:</p>
<pre data-type="programlisting">BorderSide side = (BorderSide) 12345;
Console.WriteLine (Enum.IsDefined (typeof (BorderSide), side));   // False</pre>
<p>Unfortunately, <code>Enum.IsDefined</code> does not work for flagged enums. However, the following helper method (a trick dependent on the behavior of <code>Enum.ToString()</code>) returns <code>true</code> if a given flagged enum is valid:<a contenteditable="false" data-primary="" data-startref="ch03.html1027" data-type="indexterm" id="id2227"/><a contenteditable="false" data-primary="" data-startref="ch03.html1026" data-type="indexterm" id="id2228"/></p>
<pre data-type="programlisting">for (int i = 0; i &lt;= 16; i++)
{
  BorderSides side = (BorderSides)i;
  Console.WriteLine (IsFlagDefined (side) + " " + side);
}

<strong>bool IsFlagDefined (Enum e)</strong>
<strong>{</strong>
  <strong>decimal d;</strong>
  <strong>return !decimal.TryParse(e.ToString(), out d);</strong>
<strong>}</strong>

[Flags]
public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Nested Types" data-type="sect1"><div class="sect1" id="nested_types">
<h1>Nested Types</h1>
<p><a contenteditable="false" data-primary="nested types" data-type="indexterm" id="ch03.html1028"/><a contenteditable="false" data-primary="type system, C#" data-secondary="nested types" data-type="indexterm" id="ch03.html1029"/>A <em>nested type</em> is declared within the scope of another type:</p>
<pre data-type="programlisting">public class TopLevel
{
  public class Nested { }               // Nested class
  public enum Color { Red, Blue, Tan }  // Nested enum
}</pre>
<p>A nested type has the following features:</p>
<ul>
<li><p>It can access the enclosing type’s private members and everything else the enclosing type can access.</p></li>
<li><p>You can declare it with the full range of access modifiers rather than just <code>public</code> and <code>internal</code>.</p></li>
<li><p>The default accessibility for a nested type is <code>private</code> rather than <code>internal</code>.</p></li>
<li><p>Accessing a nested type from outside the enclosing type requires qualification with the enclosing type’s name (like when accessing static members).</p></li>
</ul>
<p>For example, to access <code>Color.Red</code> from outside our <code>TopLevel</code> class, we’d need to do this:</p>
<pre data-type="programlisting">TopLevel.Color color = TopLevel.Color.Red;</pre>
<p>All types (classes, structs, interfaces, delegates, and enums) can be nested within either a class or a struct.</p>
<p>Here is an example of accessing a private member of a type from a nested type:</p>
<pre data-type="programlisting">public class TopLevel
{
  static int x;
  class Nested
  {
    static void Foo() { Console.WriteLine (TopLevel.x); }
  }
}</pre>
<p>Here is an example of applying the <code>protected</code> access modifier to a nested type:</p>
<pre data-type="programlisting">public class TopLevel
{
  protected class Nested { }
}

public class SubTopLevel : TopLevel
{
  static void Foo() { new TopLevel.Nested(); }
}</pre>
<p>Here is an example of referring to a nested type from outside the enclosing type:</p>
<pre data-type="programlisting">public class TopLevel
{
  public class Nested { }
}

class Test
{
  TopLevel.Nested n;
}</pre>
<p>Nested types are used heavily by the compiler itself when it generates private classes that capture state for constructs such as iterators and anonymous methods.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If the sole reason for using a nested type is to avoid cluttering a namespace with too many types, consider using a nested namespace, instead. A nested type should be used because of its stronger access control restrictions, or when the nested class must access private members of the containing class.<a contenteditable="false" data-primary="" data-startref="ch03.html1029" data-type="indexterm" id="id2229"/><a contenteditable="false" data-primary="" data-startref="ch03.html1028" data-type="indexterm" id="id2230"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Generics" data-type="sect1"><div class="sect1" id="generics">
<h1>Generics</h1>
<p><a contenteditable="false" data-primary="generics" data-type="indexterm" id="ch03.html1030"/><a contenteditable="false" data-primary="type system, C#" data-secondary="generics" data-type="indexterm" id="ch03.html1031"/>C# has two separate mechanisms for writing code that is reusable across different types: <em>inheritance</em> and <em>generics</em>. Whereas inheritance expresses reusability with a base type, generics express reusability with a “template” that contains “placeholder” types. Generics, when compared to inheritance, can <em>increase type safety</em> and <em>reduce casting and boxing</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# generics and C++ templates are similar concepts, but they work differently. We explain this difference in <a data-type="xref" href="#chash_generics_versus_cplusplus_templat">“C# Generics Versus C++ Templates”</a>.</p>
</div>
<section data-pdf-bookmark="Generic Types" data-type="sect2"><div class="sect2" id="generic_types-id00020">
<h2>Generic Types</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="generic types" data-type="indexterm" id="id2231"/><a contenteditable="false" data-primary="type parameters" data-secondary="generic types and" data-type="indexterm" id="id2232"/>A generic type declares <em>type parameters</em>—placeholder types to be filled in by the consumer of the generic type, which supplies the <a contenteditable="false" data-primary="type arguments" data-type="indexterm" id="id2233"/><em>type arguments</em>. Here is a generic type <code>Stack&lt;T&gt;</code>, designed to stack instances of type <code>T</code>. <code>Stack&lt;T&gt;</code> declares a single type parameter <code>T</code>:</p>
<pre data-type="programlisting">public class Stack<strong>&lt;T&gt;</strong>
{
  int position;
  <strong>T</strong>[] data = new <strong>T</strong>[100];
  public void Push (<strong>T</strong> obj)  =&gt; data[position++] = obj;
  public <strong>T</strong> Pop()            =&gt; data[--position];
}</pre>
<p>We can use <code>Stack&lt;T&gt;</code> as follows:</p>
<pre data-type="programlisting">var stack = new Stack<strong>&lt;int&gt;</strong>();
stack.Push (5);
stack.Push (10);
int x = stack.Pop();        // x is 10
int y = stack.Pop();        // y is 5</pre>
<p><code>Stack&lt;int&gt;</code> fills in the type parameter <code>T</code> with the type argument <code>int</code>, implicitly creating a type on the fly (the synthesis occurs at runtime). Attempting to push a string onto our <code>Stack&lt;int&gt;</code> would, however, produce a compile-time error. <code>Stack&lt;int&gt;</code> effectively has the following definition (substitutions appear in bold, with the class name hashed out to avoid confusion):</p>
<pre data-type="programlisting">public class ###
{
  int position;
  <strong>int</strong>[] data = new <strong>int</strong>[100];
  public void Push (<strong>int</strong> obj)  =&gt; data[position++] = obj;
  public <strong>int</strong> Pop()            =&gt; data[--position];
}</pre>
<p>Technically, we say that <code>Stack&lt;T&gt;</code> is an <em>open type</em>, whereas <code>Stack&lt;int&gt;</code> is a <em>closed type</em>. At runtime, all generic type instances are closed—with the placeholder types filled in. This means that the following statement is illegal:</p>
<pre data-type="programlisting">var stack = new Stack&lt;T&gt;();   // Illegal: What is T?</pre>
<p>However, it’s legal if it’s within a class or method that itself defines <code>T</code> as a type parameter:</p>
<pre data-type="programlisting">public class Stack&lt;T&gt;
{
  ...
  public Stack&lt;T&gt; Clone()
  {
    Stack&lt;T&gt; clone = new Stack&lt;T&gt;();   // Legal
    ...
  } 
}</pre>
</div></section>
<section data-pdf-bookmark="Why Generics Exist" data-type="sect2"><div class="sect2" id="why_generics_exist">
<h2>Why Generics Exist</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="purpose of" data-type="indexterm" id="id2234"/>Generics exist to write code that is reusable across different types. Suppose that we need a stack of integers but we don’t have generic types. One solution would be to hardcode a separate version of the class for every required element type (e.g., <code>IntStack</code>, <code>StringStack</code>, etc.). Clearly, this would cause considerable code duplication. Another solution would be to write a stack that is generalized by using <code>object</code> as the element type:</p>
<pre data-type="programlisting">public class ObjectStack
{
  int position;
  <strong>object</strong>[] data = new <strong>object</strong>[10];
  public void Push (<strong>object</strong> obj) =&gt; data[position++] = obj;
  public <strong>object</strong> Pop()           =&gt; data[--position];
}</pre>
<p>An <code>ObjectStack</code>, however, wouldn’t work as well as a hardcoded <code>IntStack</code> for specifically stacking integers. An <code>ObjectStack</code> would require boxing and downcasting that could not be checked at compile time:</p>
<pre data-type="programlisting">// Suppose we just want to store integers here:
ObjectStack stack = new ObjectStack();

stack.Push ("s");          // Wrong type, but no error!
int i = (int)stack.Pop();  // Downcast - runtime error</pre>
<p>What we need is both a general implementation of a stack that works for all element types as well as a way to easily specialize that stack to a specific element type for increased type safety and reduced casting and boxing. Generics give us precisely this by allowing us to parameterize the element type. <code>Stack&lt;T&gt;</code> has the benefits of both <code>ObjectStack</code> and <code>IntStack</code>. Like <code>ObjectStack</code>, <code>Stack&lt;T&gt;</code> is written once to work <em>generally</em> across all types. Like <code>IntStack</code>, <code>Stack&lt;T&gt;</code> is <em>specialized</em> for a particular type—the beauty is that this type is <code>T</code>, which we substitute on the fly.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>ObjectStack</code> is functionally equivalent to <code>Stack&lt;object&gt;</code>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Generic Methods" data-type="sect2"><div class="sect2" id="generic_methods-id00019">
<h2>Generic Methods</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="generic methods" data-type="indexterm" id="id2235"/><a contenteditable="false" data-primary="methods" data-secondary="generic" data-type="indexterm" id="id2236"/>A generic method declares type parameters within the signature of a method.</p>
<p>With generic methods, many fundamental algorithms can be implemented in a general-purpose way. Here is a generic method that swaps the contents of two variables of any type <code>T</code>:</p>
<pre data-type="programlisting">static void Swap&lt;T&gt; (ref T a, ref T b)
{
  T temp = a;
  a = b;
  b = temp;
}</pre>
<p><code>Swap&lt;T&gt;</code> is called as follows:</p>
<pre data-type="programlisting">int x = 5;
int y = 10;
Swap (ref x, ref y);</pre>
<p>Generally, there is no need to supply type arguments to a generic method, because the compiler can implicitly infer the type. If there is ambiguity, generic methods can be called with type arguments as follows:</p>
<pre data-type="programlisting">Swap<strong>&lt;int&gt;</strong> (ref x, ref y);</pre>
<p>Within a generic <em>type</em>, a method is not classed as generic unless it <em>introduces</em> type parameters (with the angle bracket syntax). The <code>Pop</code> method in our generic stack merely uses the type’s existing type parameter, <code>T</code>, and is not classed as a generic method.</p>
<p>Methods and types are the only constructs that can introduce type parameters. Properties, indexers, events, fields, constructors, operators, and so on cannot declare type parameters, although they can partake in any type parameters already declared by their enclosing type. In our generic stack example, for instance, we could write an indexer that returns a generic item:</p>
<pre data-type="programlisting">public T this [int index] =&gt; data [index];</pre>
<p>Similarly, constructors can partake in existing type parameters but not <em>introduce</em> them:</p>
<pre data-type="programlisting">public Stack&lt;T&gt;() { }   // Illegal</pre>
</div></section>
<section data-pdf-bookmark="Declaring Type Parameters" data-type="sect2"><div class="sect2" id="declaring_type_parameters">
<h2>Declaring Type Parameters</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="declaring type parameters" data-type="indexterm" id="id2237"/><a contenteditable="false" data-primary="type parameters" data-secondary="declaring" data-type="indexterm" id="id2238"/>Type parameters can be introduced in the declaration of classes, structs, interfaces, delegates (covered in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), and methods. Other constructs, such as properties, cannot <em>introduce</em> a type parameter, but they can <em>use</em> one. For example, the property <code>Value</code> uses <code>T</code>:</p>
<pre data-type="programlisting">public struct Nullable<strong>&lt;T&gt;</strong>
{
  public <strong>T</strong> Value { get; }
}</pre>
<p>A generic type or method can have multiple parameters:</p>
<pre data-type="programlisting">class Dictionary&lt;<strong>TKey, TValue</strong>&gt; {...}</pre>
<p>To instantiate:</p>
<pre data-type="programlisting">Dictionary&lt;int,string&gt; myDict = new Dictionary&lt;int,string&gt;();</pre>
<p>Or:</p>
<pre data-type="programlisting">var myDict = new Dictionary&lt;int,string&gt;();</pre>
<p>Generic type names and method names can be overloaded as long as the number of type parameters is different. For example, the following three type names do not conflict:</p>
<pre data-type="programlisting">class A        {}
class A&lt;T&gt;     {}
class A&lt;T1,T2&gt; {}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>By convention, generic types and methods with a <em>single</em> type parameter typically name their parameter <code>T</code>, as long as the intent of the parameter is clear. When using <em>multiple</em> type parameters, each parameter is prefixed with <code>T</code> but has a more descriptive name.</p>
</div>
</div></section>
<section data-pdf-bookmark="typeof and Unbound Generic Types" data-type="sect2"><div class="sect2" id="typeof_and_unbound_generic_types">
<h2>typeof and Unbound Generic Types</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="typeof operator" data-type="indexterm" id="id2239"/><a contenteditable="false" data-primary="generics" data-secondary="unbound generic type" data-type="indexterm" id="id2240"/><a contenteditable="false" data-primary="typeof operator" data-type="indexterm" id="id2241"/><a contenteditable="false" data-primary="unbound generic type" data-type="indexterm" id="id2242"/>Open generic types do not exist at runtime: they are closed as part of compilation. However, it is possible for an <em>unbound</em> generic type to exist at runtime—purely as a <code>Type</code> object. The only way to specify an unbound generic type in C# is via the <code>typeof</code> operator:</p>
<pre data-type="programlisting">class A&lt;T&gt; {}
class A&lt;T1,T2&gt; {}
...

Type a1 = <strong>typeof (A&lt;&gt;)</strong>;   // <em>Unbound</em> type (notice no type arguments).
Type a2 = <strong>typeof (A&lt;,&gt;)</strong>;  // Use commas to indicate multiple type args.</pre>
<p>Open generic types are used in conjunction with the Reflection API (<a data-type="xref" href="ch18.html#reflection_and_metadata">Chapter 18</a>).</p>
<p class="pagebreak-before">You can also use the <code>typeof</code> operator to specify a closed type:</p>
<pre data-type="programlisting">Type a3 = typeof (A&lt;int,int&gt;);</pre>
<p>Or, you can specify an open type (which is closed at runtime):</p>
<pre data-type="programlisting">class B&lt;T&gt; { void X() { Type t = typeof (T); } }</pre>
</div></section>
<section data-pdf-bookmark="The default Generic Value" data-type="sect2"><div class="sect2" id="the_default_generic_value">
<h2>The default Generic Value</h2>
<p><a contenteditable="false" data-primary="default keyword" data-type="indexterm" id="id2243"/><a contenteditable="false" data-primary="generics" data-secondary="default generic value" data-type="indexterm" id="id2244"/>You can use the <code>default</code> keyword to get the default value for a generic type parameter. The default value for a reference type is <code>null</code>, and the default value for a value type is the result of bitwise-zeroing the value type’s fields:</p>
<pre data-type="programlisting">static void Zap&lt;T&gt; (T[] array)
{
  for (int i = 0; i &lt; array.Length; i++)
    array[i] = default(T);
}</pre>
<p>From C# 7.1, you can omit the type argument for cases in which the compiler is able to infer it. We could replace the last line of code with this:</p>
<pre data-type="programlisting">    array[i] = default;</pre>
</div></section>
<section data-pdf-bookmark="Generic Constraints" data-type="sect2"><div class="sect2" id="generic_constraints">
<h2>Generic Constraints</h2>
<p><a contenteditable="false" data-primary="constraints" data-type="indexterm" id="ch03.html1032"/><a contenteditable="false" data-primary="generics" data-secondary="constraints" data-type="indexterm" id="ch03.html1033"/>By default, you can substitute a type parameter with any type whatsoever. <em>Constraints</em> can be applied to a type parameter to require more specific type arguments. These are the possible constraints:</p>
<pre data-type="programlisting">where <em>T</em> : <em>base-class</em>   // Base-class constraint
where <em>T</em> : <em>interface</em>    // Interface constraint
where <em>T</em> : class        // Reference-type constraint
where <em>T</em> : class?       // (See "Nullable Reference Types" in Chapter 4)
where <em>T</em> : struct       // Value-type constraint (excludes Nullable types)
where <em>T</em> : unmanaged    // Unmanaged constraint
where <em>T</em> : new()        // Parameterless constructor constraint
where <em>U</em> : <em>T</em>            // Naked type constraint
where <em>T</em> : notnull      // Non-nullable value type, or (from C# 8)
                       // a non-nullable reference type</pre>
<p>In the following example, <code>GenericClass&lt;T,U&gt;</code> requires <code>T</code> to derive from (or be identical to) <code>SomeClass</code> and implement <code>Interface1</code>, and requires <code>U</code> to provide a parameterless constructor:</p>
<pre data-type="programlisting">class     SomeClass {}
interface Interface1 {}

class GenericClass&lt;T,U&gt; where T : SomeClass, Interface1
                        where U : new()
{...}</pre>
<p>You can apply constraints wherever type parameters are defined, in both methods and type definitions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <em>constraint</em> is a <em>restriction</em>; however, the main purpose of type parameter constraints is to enable things that would otherwise be prohibited.</p>
<p>For instance, the constraint <code>T:Foo</code> lets you treat instances of <code>T</code> as <code>Foo</code>, and the constraint <code>T:new()</code> lets you construct new instances of <code>T</code>.</p>
</div>
<p><a contenteditable="false" data-primary="base-class constraint" data-type="indexterm" id="id2245"/>A <em>base-class constraint</em> specifies that the type parameter must subclass (or match) a particular class; <a contenteditable="false" data-primary="interface constraint" data-type="indexterm" id="id2246"/>an <em>interface constraint</em> specifies that the type parameter must implement that interface. These constraints allow instances of the type parameter to be implicitly converted to that class or interface. For example, suppose that we want to write a generic <code>Max</code> method, which returns the maximum of two values. We can take advantage of the generic interface defined in the <code>System</code> namespace called <code>IComparable&lt;T&gt;</code>:</p>
<pre data-type="programlisting">public interface IComparable&lt;T&gt;   // Simplified version of interface
{
  int CompareTo (T other);
}</pre>
<p><code>CompareTo</code> returns a positive number if <code>this</code> is greater than <code>other</code>. Using this interface as a constraint, we can write a <code>Max</code> method as follows (to avoid distraction, null checking is omitted):</p>
<pre data-type="programlisting">static T Max &lt;T&gt; (T a, T b) where T : IComparable&lt;T&gt;
{
  return a.CompareTo (b) &gt; 0 ? a : b;
}</pre>
<p>The <code>Max</code> method can accept arguments of any type implementing <code>IComparable&lt;T&gt;</code> (which includes most built-in types such as <code>int</code> and <code>string</code>):</p>
<pre data-type="programlisting">int z = Max (5, 10);               // 10
string last = Max ("ant", "zoo");  // zoo</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From C# 11, an interface constraint also lets you call static virtual/abstract members on that interface (see <a data-type="xref" href="ch01.html#static_virtualsolidusabstract-id00040">“Static virtual/abstract interface members”</a>). For example, if interface <code>IFoo</code> defines a static abstract method called <code>Bar</code>, the <code>T:IFoo</code> constraint makes it legal to call <code>T.Bar()</code>. We pick up this topic again in <a data-type="xref" href="ch04.html#static_polymorphism">“Static Polymorphism”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="class constraint" data-type="indexterm" id="id2247"/><a contenteditable="false" data-primary="struct constraint" data-type="indexterm" id="id2248"/>The <em>class constraint</em> and <em>struct constraint</em> specify that <code>T</code> must be a reference type or (non-nullable) value type. A great example of the struct constraint is the <span class="keep-together"><code>System.Nullable&lt;T&gt;</code></span> struct (we discuss this class in depth in <a data-type="xref" href="ch04.html#nullable_value_types">“Nullable Value Types”</a>):</p>
<pre data-type="programlisting">struct Nullable&lt;T&gt; where T : struct {...}</pre>
<p><a contenteditable="false" data-primary="unmanaged constraint" data-type="indexterm" id="id2249"/>The <em>unmanaged constraint</em> (introduced in C# 7.3) is a stronger version of a struct constraint: <code>T</code> must be a simple value type or a struct that is (recursively) free of any reference types.</p>
<p><a contenteditable="false" data-primary="parameterless constructor constraint" data-type="indexterm" id="id2250"/>The <em>parameterless constructor constraint</em> requires <code>T</code> to have a public parameterless constructor. If this constraint is defined, you can call <code>new()</code> on <code>T</code>:</p>
<pre data-type="programlisting">static void Initialize&lt;T&gt; (T[] array) where T : new()
{
  for (int i = 0; i &lt; array.Length; i++)
    array[i] = new T();
}</pre>
<p><a contenteditable="false" data-primary="naked type constraint" data-type="indexterm" id="id2251"/>The <em>naked type constraint</em> requires one type parameter to derive from (or match) another type parameter. In this example, the method <code>FilteredStack</code> returns another <code>Stack</code>, containing only the subset of elements where the type parameter <code>U</code> is of the type parameter <code>T</code>:<a contenteditable="false" data-primary="" data-startref="ch03.html1033" data-type="indexterm" id="id2252"/><a contenteditable="false" data-primary="" data-startref="ch03.html1032" data-type="indexterm" id="id2253"/></p>
<pre data-type="programlisting">class Stack&lt;T&gt;
{
  Stack&lt;U&gt; FilteredStack&lt;U&gt;() where U : T {...}
}</pre>
</div></section>
<section data-pdf-bookmark="Subclassing Generic Types" data-type="sect2"><div class="sect2" id="subclassing_generic_types">
<h2>Subclassing Generic Types</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="subclassing generic types" data-type="indexterm" id="id2254"/><a contenteditable="false" data-primary="subclass" data-secondary="subclassing generic types" data-type="indexterm" id="id2255"/>A generic class can be subclassed just like a nongeneric class. The subclass can leave the base class’s type parameters open, as in the following example:</p>
<pre data-type="programlisting">class Stack&lt;T&gt;                   {...}
class SpecialStack&lt;T&gt; : Stack&lt;T&gt; {...}</pre>
<p>Or, the subclass can close the generic type parameters with a concrete type:</p>
<pre data-type="programlisting">class IntStack : Stack&lt;<strong>int</strong>&gt;  {...}</pre>
<p>A subtype can also introduce fresh type arguments:</p>
<pre data-type="programlisting">class List&lt;T&gt;                     {...}
class KeyedList&lt;T<strong>,TKey</strong>&gt; : List&lt;T&gt; {...}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Technically, <em>all</em> type arguments on a subtype are fresh: you could say that a subtype closes and then reopens the base type arguments. This means that a subclass can give new (and potentially more meaningful) names to the type arguments that it reopens:</p>
<pre data-type="programlisting">class List&lt;T&gt; {...}
class KeyedList&lt;TElement,TKey&gt; : List&lt;TElement&gt; {...}</pre>
</div>
</div></section>
<section data-pdf-bookmark="Self-Referencing Generic Declarations" data-type="sect2"><div class="sect2" id="self_referencing_generic_declarations">
<h2>Self-Referencing Generic Declarations</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="self-referencing generic declarations" data-type="indexterm" id="id2256"/>A type can name <em>itself</em> as the concrete type when closing a type argument:</p>
<pre data-type="programlisting">public interface IEquatable&lt;T&gt; { bool Equals (T obj); }

public class <strong>Balloon</strong> : IEquatable&lt;<strong>Balloon</strong>&gt;
{
  public string Color { get; set; }
  public int CC { get; set; }

  public bool Equals (Balloon b)
  {
    if (b == null) return false;
    return b.Color == Color &amp;&amp; b.CC == CC;
  }
}</pre>
<p>The following are also legal:</p>
<pre data-type="programlisting">class Foo&lt;T&gt; where T : IComparable&lt;T&gt; { ... }
class Bar&lt;T&gt; where T : Bar&lt;T&gt; { ... }</pre>
</div></section>
<section data-pdf-bookmark="Static Data" data-type="sect2"><div class="sect2" id="static_data">
<h2>Static Data</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="static data" data-type="indexterm" id="id2257"/>Static data is unique for each closed type:</p>
<pre data-type="programlisting">Console.WriteLine (++Bob&lt;int&gt;.Count);     // 1
Console.WriteLine (++Bob&lt;int&gt;.Count);     // 2
Console.WriteLine (++Bob&lt;string&gt;.Count);  // 1
Console.WriteLine (++Bob&lt;object&gt;.Count);  // 1

class Bob&lt;T&gt; { public static int Count; }</pre>
</div></section>
<section data-pdf-bookmark="Type Parameters and Conversions" data-type="sect2"><div class="sect2" id="type_parameters_and_conversions">
<h2>Type Parameters and Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="generic types" data-type="indexterm" id="id2258"/><a contenteditable="false" data-primary="generics" data-secondary="type parameters and conversion" data-type="indexterm" id="id2259"/>C#’s cast operator can perform several kinds of conversion, including the following:</p>
<ul>
<li><p>Numeric conversion</p></li>
<li><p>Reference conversion</p></li>
<li><p>Boxing/unboxing conversion</p></li>
<li><p>Custom conversion (via operator overloading; see <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>)</p></li>
</ul>
<p>The decision as to which kind of conversion will take place happens at <em>compile time</em>, based on the known types of the operands. This creates an interesting scenario with generic type parameters, because the precise operand types are unknown at compile time. If this leads to ambiguity, the compiler generates an error.</p>
<p>The most common scenario is when you want to perform a reference conversion:</p>
<pre data-type="programlisting">StringBuilder Foo&lt;T&gt; (T arg)
{
  if (arg is StringBuilder)
    return <strong>(StringBuilder) arg</strong>;   // Will not compile
  ...
}</pre>
<p><a contenteditable="false" data-primary="custom conversion" data-type="indexterm" id="id2260"/>Without knowledge of <code>T</code>’s actual type, the compiler is concerned that you might have intended this to be a <em>custom conversion</em>. The simplest solution is to instead use the <code>as</code> operator, which is unambiguous because it cannot perform custom conversions:</p>
<pre data-type="programlisting">StringBuilder Foo&lt;T&gt; (T arg)
{
  StringBuilder sb = <strong>arg as StringBuilder</strong>;
  if (sb != null) return sb;
  ...
}</pre>
<p>A more general solution is to first cast to <code>object</code>. This works because conversions to/from <code>object</code> are assumed not to be custom conversions, but reference or boxing/unboxing conversions. In this case, <code>StringBuilder</code> is a reference type, so it must be a reference conversion:</p>
<pre data-type="programlisting">  return <strong>(StringBuilder) (object) arg</strong>;</pre>
<p>Unboxing conversions can also introduce ambiguities. The following could be an unboxing, numeric, or custom conversion:</p>
<pre data-type="programlisting">int Foo&lt;T&gt; (T x) =&gt; <strong>(int) x</strong>;     // Compile-time error</pre>
<p>The solution, again, is to first cast to <code>object</code> and then to <code>int</code> (which then unambiguously signals an unboxing conversion in this case):</p>
<pre data-type="programlisting">int Foo&lt;T&gt; (T x) =&gt; <strong>(int) (object) x</strong>;</pre>
</div></section>
<section data-pdf-bookmark="Covariance" data-type="sect2"><div class="sect2" id="covariance">
<h2>Covariance</h2>
<p><a contenteditable="false" data-primary="covariance" data-type="indexterm" id="ch03.html1034"/><a contenteditable="false" data-primary="generics" data-secondary="covariance" data-type="indexterm" id="ch03.html1035"/>Assuming <code>A</code> is convertible to <code>B</code>, <code>X</code> has a covariant type parameter if <code>X&lt;A&gt;</code> is convertible to <code>X&lt;B&gt;</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>With C#’s notion of covariance (and contravariance), “convertible” means convertible via an <em>implicit reference conversion</em>—such as <code>A</code> <em>subclassing</em> <code>B</code>, or <code>A</code> <em>implementing</em> <code>B</code>. Numeric conversions, boxing conversions, and custom conversions are not included.</p>
</div>
<p>For instance, type <code>IFoo&lt;T&gt;</code> has a covariant <code>T</code> if the following is legal:</p>
<pre data-type="programlisting">IFoo&lt;string&gt; s = ...;
<strong>IFoo&lt;object&gt; b = s;</strong></pre>
<p>Interfaces permit covariant type parameters (as do delegates; see <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>), but classes do not. Arrays also allow covariance (<code>A[]</code> can be converted to <code>B[]</code> if <code>A</code> has an implicit reference conversion to <code>B</code>) and are discussed here for comparison.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Covariance and contravariance (or simply “variance”) are advanced concepts. The motivation behind introducing and enhancing variance in C# was to allow generic interface and generic types (in particular, those defined in .NET, such as <code>IEnumerable&lt;T&gt;</code>) to work more as you’d expect. You can benefit from this without understanding the details behind covariance and contravariance.</p>
</div>
<section data-pdf-bookmark="Variance is not automatic" data-type="sect3"><div class="sect3" id="variance_is_not_automatic">
<h3>Variance is not automatic</h3>
<p>To ensure static type safety, type parameters are not automatically variant. Consider the following:</p>
<pre data-type="programlisting">class Animal {}
class Bear : Animal {}
class Camel : Animal {}

public class Stack&lt;T&gt;   // A simple Stack implementation
{
  int position;
  T[] data = new T[100];
  public void Push (T obj)  =&gt; data[position++] = obj;
  public T Pop()            =&gt; data[--position]; 
}</pre>
<p>The following fails to compile:</p>
<pre data-type="programlisting">Stack&lt;Bear&gt; bears = new Stack&lt;Bear&gt;();
<strong>Stack&lt;Animal&gt; animals = bears;            // Compile-time error</strong></pre>
<p>That restriction prevents the possibility of runtime failure with the following code:</p>
<pre data-type="programlisting">animals.Push (new Camel());      // Trying to add Camel to bears</pre>
<p>Lack of covariance, however, can hinder reusability. Suppose, for instance, that we wanted to write a method to <code>Wash</code> a stack of animals:</p>
<pre data-type="programlisting">public class ZooCleaner
{
  public static void Wash (Stack&lt;Animal&gt; animals) {...}
}</pre>
<p>Calling <code>Wash</code> with a stack of bears would generate a compile-time error. One workaround is to redefine the <code>Wash</code> method with a constraint:</p>
<pre data-type="programlisting">class ZooCleaner
{
  public static void Wash&lt;T&gt; (Stack&lt;T&gt; animals) <strong>where T : Animal</strong> { ... }
}</pre>
<p>We can now call <code>Wash</code> as follows:</p>
<pre data-type="programlisting">Stack&lt;Bear&gt; bears = new Stack&lt;Bear&gt;();
ZooCleaner.Wash (bears);</pre>
<p>Another solution is to have <code>Stack&lt;T&gt;</code> implement an interface with a covariant type parameter, as you’ll see shortly.</p>
</div></section>
<section data-pdf-bookmark="Arrays" data-type="sect3"><div class="sect3" id="arrays-id00052">
<h3>Arrays</h3>
<p><a contenteditable="false" data-primary="arrays" data-secondary="covariance" data-type="indexterm" id="id2261"/>For historical reasons, array types support covariance. This means that <code>B[]</code> can be cast to <code>A[]</code> if <code>B</code> subclasses <code>A</code> (and both are reference types):</p>
<pre data-type="programlisting">Bear[] bears = new Bear[3];
Animal[] animals = bears;     // OK</pre>
<p>The downside of this reusability is that element assignments can fail at runtime:</p>
<pre data-type="programlisting">animals[0] = new Camel();     // Runtime error</pre>
</div></section>
<section data-pdf-bookmark="Declaring a covariant type parameter" data-type="sect3"><div class="sect3" id="declaring_a_covariant_type_parameter">
<h3>Declaring a covariant type parameter</h3>
<p><a contenteditable="false" data-primary="type parameters" data-secondary="covariance" data-type="indexterm" id="id2262"/>Type parameters on interfaces and delegates can be declared covariant by marking them with the <code>out</code> modifier. This modifier ensures that, unlike with arrays, covariant type parameters are fully type-safe.</p>
<p>We can illustrate this with our <code>Stack&lt;T&gt;</code> class by having it implement the following interface:</p>
<pre data-type="programlisting">public interface IPoppable&lt;<strong>out</strong> T&gt; { T Pop(); }</pre>
<p>The <code>out</code> modifier on <code>T</code> indicates that <code>T</code> is used only in <em>output positions</em> (e.g., return types for methods). The <code>out</code> modifier flags the type parameter as <em>covariant</em> and allows us to do this:</p>
<pre data-type="programlisting">var bears = new Stack&lt;Bear&gt;();
bears.Push (new Bear());
// Bears implements IPoppable&lt;Bear&gt;. We can convert to IPoppable&lt;Animal&gt;:
<strong>IPoppable&lt;Animal&gt; animals = bears;   // Legal</strong>
Animal a = animals.Pop();</pre>
<p>The conversion from <code>bears</code> to <code>animals</code> is permitted by the compiler—by virtue of the type parameter being covariant. This is type-safe because the case the compiler is trying to avoid—pushing a <code>Camel</code> onto the stack—can’t occur, because there’s no way to feed a <code>Camel</code> <em>in</em>to an interface where <code>T</code> can appear only in <em>out</em>put positions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Covariance (and contravariance) in interfaces is something that you typically <em>consume</em>: it’s less common that you need to <em>write</em> variant interfaces.</p>
</div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Curiously, method parameters marked as <code>out</code> are not eligible for covariance, due to a limitation in the CLR.</p>
</div>
<p>We can leverage the ability to cast covariantly to solve the reusability problem described earlier:</p>
<pre data-type="programlisting">public class ZooCleaner
{
  public static void Wash (<strong>IPoppable&lt;Animal&gt;</strong> animals) { ... }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>IEnumerator&lt;T&gt;</code> and <code>IEnumerable&lt;T&gt;</code> interfaces described in <a data-type="xref" href="ch07.html#collections-id00055">Chapter 7</a> have a covariant <code>T</code>. This allows you to cast <code>IEnumerable&lt;string&gt;</code> to <code>IEnumerable&lt;object&gt;</code>, for instance.</p>
</div>
<p>The compiler will generate an error if you use a covariant type parameter in an <em>input</em> position (e.g., a parameter to a method or a writable property).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Covariance (and contravariance) works only for elements with <em>reference conversions</em>—not <em>boxing conversions</em>. (This applies both to type parameter variance and array variance.) So, if you wrote a method that accepted a parameter of type <code>IPoppable&lt;object&gt;</code>, you could call it with <code>IPoppable&lt;string&gt;</code> but not <code>IPoppable&lt;int&gt;</code>.<a contenteditable="false" data-primary="" data-startref="ch03.html1035" data-type="indexterm" id="id2263"/><a contenteditable="false" data-primary="" data-startref="ch03.html1034" data-type="indexterm" id="id2264"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Contravariance" data-type="sect2"><div class="sect2" id="contravariance">
<h2>Contravariance</h2>
<p><a contenteditable="false" data-primary="contravariance" data-type="indexterm" id="id2265"/><a contenteditable="false" data-primary="generics" data-secondary="contravariance" data-type="indexterm" id="id2266"/><a contenteditable="false" data-primary="reference conversions" data-type="indexterm" id="id2267"/>We previously saw that, assuming that <code>A</code> allows an implicit reference conversion to <code>B</code>, a type <code>X</code> has a covariant type parameter if <code>X&lt;A&gt;</code> allows a reference conversion to <code>X&lt;B&gt;</code>. <em>Contravariance</em> is when you can convert in the reverse direction—from <code>X&lt;B&gt;</code> to <code>X&lt;A&gt;</code>. This is supported if the type parameter appears only in <em>input</em> positions and is designated with the <code>in</code> modifier. Extending our previous example, suppose the <code>Stack&lt;T&gt;</code> class implements the following interface:</p>
<pre data-type="programlisting">public interface IPushable&lt;<strong>in</strong> T&gt; { void Push (T obj); }</pre>
<p>We can now legally do this:</p>
<pre data-type="programlisting">IPushable&lt;Animal&gt; animals = new Stack&lt;Animal&gt;();
<strong>IPushable&lt;Bear&gt; bears = animals;    // Legal</strong>
bears.Push (new Bear());</pre>
<p>No member in <code>IPushable</code> <em>outputs</em> a <code>T</code>, so we can’t get into trouble by casting <code>animals</code> to <code>bears</code> (there’s no way to <code>Pop</code>, for instance, through that interface).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Our <code>Stack&lt;T&gt;</code> class can implement both <code>IPushable&lt;T&gt;</code> and <code>IPoppable&lt;T&gt;</code>—despite <code>T</code> having opposing variance annotations in the two interfaces! This works because you must exercise variance through the interface and not the class; therefore, you must commit to the lens of either <code>IPoppable</code> or <code>IPushable</code> before performing a variant conversion. This lens then restricts you to the operations that are legal under the appropriate variance rules.</p>
<p>This also illustrates why <em>classes</em> do not allow variant type parameters: concrete implementations typically require data to flow in both directions.</p>
</div>
<p>To give another example, consider the following interface, defined in the <code>System</code> namespace:</p>
<pre data-type="programlisting">public interface IComparer&lt;<strong>in</strong> T&gt;
{
  // Returns a value indicating the relative ordering of a and b
  int Compare (T a, T b);
}</pre>
<p>Because the interface has a contravariant <code>T</code>, we can use an <code>IComparer&lt;<strong>object</strong>&gt;</code> to compare two <em>strings</em>:</p>
<pre class="pagebreak-before" data-type="programlisting">var objectComparer = Comparer&lt;object&gt;.Default;
// objectComparer implements IComparer&lt;object&gt;
IComparer&lt;string&gt; stringComparer = objectComparer;
int result = stringComparer.Compare ("Brett", "Jemaine");</pre>
<p>Mirroring covariance, the compiler will report an error if you try to use a contravariant type parameter in an output position (e.g., as a return value or in a readable property).</p>
</div></section>
<section data-pdf-bookmark="C# Generics Versus C++ Templates" data-type="sect2"><div class="sect2" id="chash_generics_versus_cplusplus_templat">
<h2>C# Generics Versus C++ Templates</h2>
<p><a contenteditable="false" data-primary="generic types" data-secondary="C++ templates versus" data-type="indexterm" id="id2268"/><a contenteditable="false" data-primary="generics" data-secondary="C# generics versus C++ templates" data-type="indexterm" id="id2269"/>C# generics are similar in application to C++ templates, but they work very differently. In both cases, a synthesis between the producer and consumer must take place in which the placeholder types of the producer are filled in by the consumer. However, with C# generics, producer types (i.e., open types such as <code>List&lt;T&gt;</code>) can be compiled into a library (such as <em>mscorlib.dll</em>). This works because the synthesis between the producer and the consumer that produces closed types doesn’t actually happen until runtime. With C++ templates, this synthesis is performed at compile time. This means that in C++ you don’t deploy template libraries as <em>.dll</em>s—they exist only as source code. It also makes it difficult to dynamically inspect, let alone create, parameterized types on the fly.</p>
<p>To dig deeper into why this is the case, consider again the <code>Max</code> method in C#:</p>
<pre data-type="programlisting">static T Max &lt;T&gt; (T a, T b) where T : IComparable&lt;T&gt;
  =&gt; a.CompareTo (b) &gt; 0 ? a : b;</pre>
<p>Why couldn’t we have implemented it like this?</p>
<pre data-type="programlisting">static T Max &lt;T&gt; (T a, T b)
  =&gt; (a &gt; b ? a : b);             // Compile error</pre>
<p>The reason is that <code>Max</code> needs to be compiled once and work for all possible values of <code>T</code>. Compilation cannot succeed because there is no single meaning for <code>&gt;</code> across all values of <code>T</code>—in fact, not every <code>T</code> even has a <code>&gt;</code> operator. In contrast, the following code shows the same <code>Max</code> method written with C++ templates. This code will be compiled separately for each value of <code>T</code>, taking on whatever semantics <code>&gt;</code> has for a particular <code>T</code>, and failing to compile if a particular <code>T</code> does not support the <code>&gt;</code> operator:<a contenteditable="false" data-primary="" data-startref="ch03.html1031" data-type="indexterm" id="id2270"/><a contenteditable="false" data-primary="" data-startref="ch03.html1030" data-type="indexterm" id="id2271"/><a contenteditable="false" data-primary="" data-startref="ch03.html100" data-type="indexterm" id="id2272"/></p>
<pre data-type="programlisting">template &lt;class T&gt; T Max (T a, T b)
{
  return a &gt; b ? a : b;
}</pre>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn5"><sup><a href="ch03.html#ch01fn5-marker">1</a></sup> The reference type can also be <code>System.ValueType</code> or <code>System.Enum</code> (<a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>).</p></div></div></section></body></html>