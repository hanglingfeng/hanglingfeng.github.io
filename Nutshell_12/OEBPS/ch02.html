<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>C# Language Basics</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="C# Language Basics" data-pdf-bookmark="Chapter 2. C# Language Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="chash_language_basics">
<h1><span class="label">Chapter 2. </span>C# Language Basics</h1>
<p><a contenteditable="false" data-primary="C# (generally)" data-secondary="language basics" data-type="indexterm" id="ch02.html100"/>In this chapter, we introduce the basics of the C# language.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Almost all of the code listings in this book are available as interactive samples in LINQPad. Working through these samples in conjunction with the book accelerates learning in that you can edit the samples and instantly see the results without needing to set up projects and solutions in Visual Studio.</p>
<p>To download the samples, in LINQPad, click the Samples tab, and then click “Download more samples.” LINQPad is free—go to <a href="http://www.linqpad.net">http://<em>www.linqpad.net</em></a>.</p>
</div>
<section data-pdf-bookmark="A First C# Program" data-type="sect1"><div class="sect1" id="a_first_chash_program">
<h1>A First C# Program</h1>
<p><a contenteditable="false" data-primary="C# (generally)" data-secondary="simple program" data-type="indexterm" id="ch02.html101"/>Following is a program that multiplies 12 by 30 and prints the result, 360, to the screen. <a contenteditable="false" data-primary="// (forward slash, double)" data-type="indexterm" id="id1587"/><a contenteditable="false" data-primary="forward slash, double (//)" data-type="indexterm" id="id1588"/>The double forward slash indicates that the remainder of a line is a <em>comment</em>:</p>
<pre data-type="programlisting">int x = 12 * 30;                  // Statement 1
System.Console.WriteLine (x);     // Statement 2</pre>
<p><a contenteditable="false" data-primary="statements" data-type="indexterm" id="id1589"/>Our program consists of two <em>statements</em>. <a contenteditable="false" data-primary="; (semicolon)" data-type="indexterm" id="id1590"/><a contenteditable="false" data-primary="semicolon (;)" data-type="indexterm" id="id1591"/>Statements in C# execute sequentially and are terminated by a semicolon. The first statement computes the <em>expression</em> <code>12 * 30</code> and stores the result in a <em>variable</em>, named <code>x</code>, whose type is a 32-bit integer (<code>int</code>). The second statement calls the <code>WriteLine</code> <em>method</em> on a <em>class</em> called <code>Console</code>, which is defined in a <em>namespace</em> called <code>System</code>. This prints the variable <code>x</code> to a text window on the screen.</p>
<p><a contenteditable="false" data-primary="methods" data-secondary="purpose of" data-type="indexterm" id="id1592"/>A method performs a function; a class groups function members and data members to form an object-oriented building block. The <code>Console</code> class groups members that handle command-line input/output (I/O) functionality, such as the <code>WriteLine</code> method. A class is a kind of <em>type</em>, which we examine in <a data-type="xref" href="#type_basics">“Type Basics”</a>.</p>
<p><a contenteditable="false" data-primary="namespaces" data-type="indexterm" id="id1593"/>At the outermost level, types are organized into <em>namespaces</em>. Many commonly used types—including the <code>Console</code> class—reside in the <code>System</code> namespace. The .NET libraries are organized into nested namespaces. For example, the <code>System.Text</code> namespace contains types for handling text, and <code>System.IO</code> contain types for input/output.</p>
<p>Qualifying the <code>Console</code> class with the <code>System</code> namespace on every use adds clutter. The <code>using</code> directive lets you avoid this clutter by <em>importing</em> a namespace:</p>
<pre data-type="programlisting"><strong>using System;</strong>             // Import the System namespace

int x = 12 * 30;
<strong>Console.WriteLine</strong> (x);    // No need to specify System.</pre>
<p>A basic form of code reuse is to write higher-level functions that call lower-level functions. <a contenteditable="false" data-primary="refactoring" data-type="indexterm" id="id1594"/>We can <em>refactor</em> our program with a reusable <em>method</em> called <code>FeetToInches</code> that multiplies an integer by 12, as follows:</p>
<pre data-type="programlisting">using System;

Console.WriteLine (<strong>FeetToInches (30)</strong>);      // 360
Console.WriteLine (<strong>FeetToInches (100)</strong>);     // 1200

<strong>int FeetToInches (int feet)</strong>
<strong>{</strong>
  <strong>int inches = feet * 12;</strong>
  <strong>return inches;</strong>
<strong>}</strong></pre>
<p><a contenteditable="false" data-primary="{} (braces)" data-secondary="enclosing statement blocks" data-type="indexterm" id="id1595"/><a contenteditable="false" data-primary="braces ({})" data-secondary="enclosing statement blocks" data-type="indexterm" id="id1596"/>Our method contains a series of statements surrounded by a pair of braces. <a contenteditable="false" data-primary="statement block" data-type="indexterm" id="id1597"/>This is called a <em>statement block</em>.</p>
<p><a contenteditable="false" data-primary="return types" data-type="indexterm" id="id1598"/>A method can receive <em>input</em> data from the caller by specifying <em>parameters</em> and <em>output</em> data back to the caller by specifying a <em>return type</em>. Our <code>FeetToInches</code> method has a parameter for inputting feet, and a return type for outputting inches:</p>
<pre data-type="programlisting"><strong>int</strong> FeetToInches (<strong>int feet</strong>)
...</pre>
<p>The <em>literals</em> <code>30</code> and <code>100</code> are the <em>arguments</em> passed to the <code>FeetToInches</code> method.</p>
<p>If a method doesn’t receive input, use empty parentheses. If it doesn’t return anything, use the <code>void</code> keyword:</p>
<pre data-type="programlisting">using System;
SayHello();

<strong>void</strong> SayHello<strong>()</strong>
{
  Console.WriteLine ("Hello, world");
}</pre>
<p>Methods are one of several kinds of functions in C#. <a contenteditable="false" data-primary="* (asterisk)" data-secondary="as multiplication operator" data-type="indexterm" id="id1599"/><a contenteditable="false" data-primary="asterisk (*)" data-secondary="as multiplication operator" data-type="indexterm" id="id1600"/>Another kind of function we used in our example program was the <code>*</code> <em>operator</em>, which performs multiplication. There are also <em>constructors</em>, <em>properties</em>, <em>events</em>, <em>indexers</em>, and <em>finalizers</em>.</p>
<section data-pdf-bookmark="Compilation" data-type="sect2"><div class="sect2" id="compilation">
<h2>Compilation</h2>
<p><a contenteditable="false" data-primary="assemblies" data-type="indexterm" id="id1601"/><a contenteditable="false" data-primary="compilation" data-type="indexterm" id="id1602"/>The C# compiler compiles source code (a set of files with the <em>.cs</em> extension) into an <em>assembly</em>. An assembly is the unit of packaging and deployment in .NET. An assembly can be either an <em>application</em> or a <em>library</em>. A normal console or Windows application has an <em>entry point</em>, whereas a library does not. The purpose of a library is to be called upon (<em>referenced</em>) by an application or by other libraries. .NET itself is a set of libraries (as well as a runtime environment).</p>
<p>Each of the programs in the preceding section began directly with a series of statements (called <em>top-level statements</em>). The presence of top-level statements implicitly creates an entry point for a console or Windows application. (<a contenteditable="false" data-primary="Main method" data-type="indexterm" id="id1603"/>Without top-level statements, a <em>Main method</em> denotes an application’s entry point—see <a data-type="xref" href="#custom_types">“Custom Types”</a>.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Unlike .NET Framework, .NET 8 assemblies never have a <em>.exe</em> extension. <a contenteditable="false" data-primary=".dll files" data-primary-sortas="dll" data-type="indexterm" id="id1604"/><a contenteditable="false" data-primary=".exe files" data-primary-sortas="exe" data-type="indexterm" id="id1605"/>The <em>.exe</em> that you see after building a .NET 8 application is a platform-specific native loader responsible for starting your application’s <em>.dll</em> assembly.</p>
<p>.NET 8 also allows you to create a self-contained deployment that includes the loader, your assemblies, and the required portions of the .NET runtime—all in a single <em>.exe</em> file. .NET 8 also allows ahead-of-time (AOT) compilation, where the executable contains precompiled native code for faster startup and reduced memory consumption.</p>
</div>
<p><a contenteditable="false" data-primary="dotnet tool" data-type="indexterm" id="id1606"/>The <code>dotnet</code> tool (<em>dotnet.exe</em> on Windows) helps you to manage .NET source code and binaries from the command line. You can use it to both build and run your program, as an alternative to using an integrated development environment (IDE) such as Visual Studio or Visual Studio Code.</p>
<p>You can obtain the <code>dotnet</code> tool either by installing the .NET 8 SDK or by installing Visual Studio. Its default location is <em>%ProgramFiles%\dotnet</em> on Windows or <em>/usr/bin/dotnet</em> on Ubuntu Linux.</p>
<p><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET Framework" data-secondary="compilation" data-type="indexterm" id="id1607"/>To compile an application, the <code>dotnet</code> tool requires a <em>project file</em> as well as one or more C# files. The following command <em>scaffolds</em> a new console project (creates its basic structure):</p>
<pre data-type="programlisting">dotnet new Console -n MyFirstProgram</pre>
<p>This creates a subfolder called <em>MyFirstProgram</em> containing a project file called <em>MyFirstProgram.csproj</em> and a C# file called <em>Program.cs</em> that prints “Hello world.”</p>
<p>To build and run your program, run the following command from the <em>MyFirstProgram</em> folder:</p>
<pre data-type="programlisting">dotnet run MyFirstProgram</pre>
<p>Or, if you just want to build without running:</p>
<pre data-type="programlisting">dotnet build MyFirstProgram.csproj</pre>
<p>The output assembly will be written to a subdirectory under <em>bin\debug</em>.</p>
<p><a contenteditable="false" data-primary="" data-startref="ch02.html101" data-type="indexterm" id="id1608"/>We explain assemblies in detail in <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Syntax" data-type="sect1"><div class="sect1" id="syntax">
<h1>Syntax</h1>
<p><a contenteditable="false" data-primary="C# (generally)" data-secondary="syntax" data-type="indexterm" id="ch02.html102"/><a contenteditable="false" data-primary="syntax, C#" data-type="indexterm" id="ch02.html103"/>C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s elements of syntax, using the following program:</p>
<pre data-type="programlisting">using System;

int x = 12 * 30;
Console.WriteLine (x);</pre>
<section data-pdf-bookmark="Identifiers and Keywords" data-type="sect2"><div class="sect2" id="identifiers_and_keywords">
<h2>Identifiers and Keywords</h2>
<p><a contenteditable="false" data-primary="identifiers" data-type="indexterm" id="ch02.html104"/><a contenteditable="false" data-primary="keywords" data-type="indexterm" id="ch02.html105"/><a contenteditable="false" data-primary="syntax, C#" data-secondary="identifiers and keywords" data-type="indexterm" id="ch02.html106"/><em>Identifiers</em> are names that programmers choose for their classes, methods, variables, and so on. Here are the identifiers in our example program, in the order in which they appear:</p>
<pre data-type="programlisting">System   x   Console   WriteLine</pre>
<p>An identifier must be a whole word, essentially made up of Unicode characters starting with a letter or underscore. C# identifiers are case sensitive. By convention, parameters, local variables, and private fields should be in <em>camel case</em> (e.g., <code>myVariable</code>), and all other identifiers should be in <em>Pascal case</em> (e.g., <code>MyMethod</code>).</p>
<p><em>Keywords</em> are names that mean something special to the compiler. There are two keywords in our example program: <code>using</code> and <code>int</code>.</p>
<p><a contenteditable="false" data-primary="reserved keywords" data-type="indexterm" id="id1609"/>Most keywords are <em>reserved</em>, which means that you can’t use them as identifiers. Here is the full list of C# reserved keywords:</p>
<table class="border">
<tbody>
<tr>
<td><code>abstract</code><br/><code>as</code><br/><code>base</code><br/><code>bool</code><br/><code>break</code><br/><code>byte</code><br/><code>case</code><br/><code>catch</code><br/><code>char</code><br/><code>checked</code><br/><code>class</code><br/><code>const</code><br/><code>continue</code><br/><code>decimal</code><br/><code>default</code><br/><code>delegate</code></td>
<td><code>do</code><br/><code>double</code><br/><code>else</code> <br/><code>enum</code><br/><code>event</code><br/><code>explicit</code><br/><code>extern</code><br/><code>false</code><br/><code>finally</code><br/><code>fixed</code><br/><code>float</code><br/><code>for</code><br/><code>foreach</code><br/><code>goto</code><br/><code>if</code><br/><code>implicit</code></td>
<td><code>in</code><br/><code>int</code><br/><code>interface</code><br/><code>internal</code><br/><code>is</code><br/><code>lock</code><br/><code>long</code><br/><code>namespace</code><br/><code>new</code><br/><code>null</code><br/><code>object</code><br/><code>operator</code><br/><code>out</code><br/><code>override</code><br/><code>params</code><br/><code>private</code></td>
<td><code>protected</code><br/><code>public</code><br/><code>readonly</code><br/><code>record</code><br/><code>ref</code><br/><code>return</code><br/><code>sbyte</code><br/><code>sealed</code><br/><code>short</code><br/><code>sizeof</code><br/><code>stackalloc</code><br/><code>static</code><br/><code>string</code><br/><code>struct</code><br/><code>switch</code><br/><code>this</code></td>
<td><code>throw</code><br/><code>true</code><br/><code>try</code><br/><code>typeof</code><br/><code>uint</code><br/><code>ulong</code><br/><code>unchecked</code><br/><code>unsafe</code><br/><code>ushort</code><br/><code>using</code><br/><code>virtual</code><br/><code>void</code><br/><code>volatile</code><br/><code>while</code></td>
</tr>
</tbody>
</table>
<p>If you really want to use an identifier that clashes with a reserved keyword, you can do so by qualifying it with the <code>@</code> prefix. For instance:</p>
<pre data-type="programlisting">int using = 123;      // Illegal
int @using = 123;     // Legal</pre>
<p>The <code>@</code> symbol doesn’t form part of the identifier itself. So, <code>@myVariable</code> is the same as <code>myVariable</code>.</p>
<section data-pdf-bookmark="Contextual keywords" data-type="sect3"><div class="sect3" id="contextual_keywords">
<h3>Contextual keywords</h3>
<p><a contenteditable="false" data-primary="contextual keywords" data-type="indexterm" id="id1610"/>Some keywords are <em>contextual</em>, meaning that you also can use them as identifiers—without an <code>@</code> symbol:</p>
<table class="border">
<tbody>
<tr>
<td><code>add</code><br/><code>alias</code><br/><code>and</code><br/><code>ascending</code><br/><code>async</code><br/><code>await</code><br/><code>by</code><br/><code>descending</code></td>
<td><code>dynamic</code><br/><code>equals</code><br/><code>file</code><br/><code>from</code><br/><code>get</code><br/><code>global</code><br/><code>group</code><br/><code>init</code></td>
<td><code>into</code><br/><code>join</code><br/><code>let</code><br/><code>managed</code><br/><code>nameof</code><br/><code>nint</code><br/><code>not</code><br/><code>notnull</code></td>
<td><code>nuint</code><br/><code>on</code><br/><code>or</code><br/><code>orderby</code><br/><code>partial</code><br/><code>remove</code><br/><code>required</code><br/><code>select</code></td>
<td><code>set</code><br/><code>unmanaged</code><br/><code>value</code><br/><code>var</code><br/><code>with</code><br/><code>when</code><br/><code>where</code><br/><code>yield</code></td>
</tr>
</tbody>
</table>
<p>With contextual keywords, ambiguity cannot arise within the context in which they are used. <a contenteditable="false" data-primary="" data-startref="ch02.html106" data-type="indexterm" id="id1611"/><a contenteditable="false" data-primary="" data-startref="ch02.html105" data-type="indexterm" id="id1612"/><a contenteditable="false" data-primary="" data-startref="ch02.html104" data-type="indexterm" id="id1613"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Literals, Punctuators, and Operators" data-type="sect2"><div class="sect2" id="literalscomma_punctuatorscomma_and_oper">
<h2>Literals, Punctuators, and Operators</h2>
<p><a contenteditable="false" data-primary="literals" data-type="indexterm" id="id1614"/><a contenteditable="false" data-primary="syntax, C#" data-secondary="literals, punctuators, and operators" data-type="indexterm" id="id1615"/><em>Literals</em> are primitive pieces of data lexically embedded into the program. The literals we used in our example program are <code>12</code> and <code>30</code>.</p>
<p><a contenteditable="false" data-primary="punctuators" data-type="indexterm" id="id1616"/><em>Punctuators</em> <a contenteditable="false" data-primary="; (semicolon)" data-type="indexterm" id="id1617"/><a contenteditable="false" data-primary="semicolon (;)" data-type="indexterm" id="id1618"/>help demarcate the structure of the program. An example is the semicolon, which terminates a statement. Statements can wrap multiple lines:</p>
<pre data-type="programlisting">Console.WriteLine
  (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);</pre>
<p><a contenteditable="false" data-primary="operator, defined" data-type="indexterm" id="id1619"/>An <em>operator</em> transforms and combines expressions. <a contenteditable="false" data-primary="* (asterisk)" data-secondary="as multiplication operator" data-type="indexterm" id="id1620"/><a contenteditable="false" data-primary="asterisk (*)" data-secondary="as multiplication operator" data-type="indexterm" id="id1621"/>Most operators in C# are denoted with a symbol, such as the multiplication operator, <code>*</code>. We discuss operators in more detail later in this chapter. These are the operators we used in our example program:</p>
<pre data-type="programlisting">=  *  .  ()</pre>
<p><a contenteditable="false" data-primary=". (period)" data-type="indexterm" id="id1622"/><a contenteditable="false" data-primary="period (.)" data-type="indexterm" id="id1623"/>A period denotes a member of something (or a decimal point with numeric literals). <a contenteditable="false" data-primary="() (parentheses)" data-type="indexterm" id="id1624"/><a contenteditable="false" data-primary="parentheses ()" data-type="indexterm" id="id1625"/>Parentheses are used when declaring or calling a method; empty parentheses are used when the method accepts no arguments. (Parentheses also have other purposes that you’ll see later in this chapter.) <a contenteditable="false" data-primary="= (equal sign), as assignment operator" data-type="indexterm" id="id1626"/><a contenteditable="false" data-primary="equal sign (=), as assignment operator" data-type="indexterm" id="id1627"/>An equals sign performs <em>assignment</em>. (<a contenteditable="false" data-primary="== (equality operator)" data-type="indexterm" id="id1628"/><a contenteditable="false" data-primary="equality operator (==)" data-type="indexterm" id="id1629"/>The double equals sign, <code>==</code>, performs equality comparison, as you’ll see later.)</p>
</div></section>
<section data-pdf-bookmark="Comments" data-type="sect2"><div class="sect2" id="comments">
<h2>Comments</h2>
<p><a contenteditable="false" data-primary="comments" data-type="indexterm" id="id1630"/><a contenteditable="false" data-primary="syntax, C#" data-secondary="comments" data-type="indexterm" id="id1631"/>C# offers two different styles of source-code documentation: <em>single-line comments</em> and <em>multiline comments</em>. <a contenteditable="false" data-primary="// (forward slash, double)" data-type="indexterm" id="id1632"/><a contenteditable="false" data-primary="forward slash, double (//)" data-type="indexterm" id="id1633"/><a contenteditable="false" data-primary="single-line comments" data-type="indexterm" id="id1634"/>A single-line comment begins with a double forward slash and continues until the end of the line; for example:</p>
<pre data-type="programlisting">int x = 3;   // Comment about assigning 3 to x</pre>
<p><a contenteditable="false" data-primary="/* */ (multiline comments)" data-type="indexterm" id="id1635"/><a contenteditable="false" data-primary="multiline comments (/* */)" data-type="indexterm" id="id1636"/>A multiline comment begins with <code>/*</code> and ends with <code>*/</code>; for example:</p>
<pre data-type="programlisting">int x = 3;   /* This is a comment that
                spans two lines */</pre>
<p>Comments can embed XML documentation tags, which we explain in <a data-type="xref" href="ch04.html#xml_documentation">“XML Documentation”</a>.<a contenteditable="false" data-primary="" data-startref="ch02.html103" data-type="indexterm" id="id1637"/><a contenteditable="false" data-primary="" data-startref="ch02.html102" data-type="indexterm" id="id1638"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Type Basics" data-type="sect1"><div class="sect1" id="type_basics">
<h1>Type Basics</h1>
<p><a contenteditable="false" data-primary="int type" data-type="indexterm" id="id1639"/>A <a contenteditable="false" data-primary="type system, C#" data-secondary="basics" data-type="indexterm" id="ch02.html107"/><em>type</em> defines the blueprint for a value. In this example, we use two literals of type <code>int</code> with values <code>12</code> and <code>30</code>. We also declare a <em>variable</em> of type <code>int</code> whose name is <code>x</code>:</p>
<pre data-type="programlisting">int x = 12 * 30;
Console.WriteLine (x);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because most of the code listings in this book require types from the <code>System</code> namespace, we will omit “<code>using System</code>” from now on, unless we’re illustrating a concept relating to namespaces.</p>
</div>
<p><a contenteditable="false" data-primary="variables" data-secondary="purpose of" data-type="indexterm" id="id1640"/><a contenteditable="false" data-primary="variables" data-seealso="parameters" data-type="indexterm" id="id1641"/>A <em>variable</em> denotes a storage location that can contain different values over time. In contrast, a <em>constant</em> always represents the same value (more on this later):</p>
<pre data-type="programlisting"><strong>const</strong> int y = 360;</pre>
<p>All values in C# are <em>instances</em> of a type. The meaning of a value and the set of possible values a variable can have are determined by its type.</p>
<section data-pdf-bookmark="Predefined Type Examples" data-type="sect2"><div class="sect2" id="predefined_type_examples">
<h2>Predefined Type Examples</h2>
<p><a contenteditable="false" data-primary="type system, C#" data-secondary="predefined type examples" data-type="indexterm" id="id1642"/>Predefined types are types that are specially supported by the compiler. The <code>int</code> type is a predefined type for representing the set of integers that fit into 32 bits of memory, from −2<sup>31</sup> to 2<sup>31</sup>−1, and is the default type for numeric literals within this range. You can perform functions such as arithmetic with instances of the <code>int</code> type, as follows:</p>
<pre data-type="programlisting">int x = 12 * 30;</pre>
<p><a contenteditable="false" data-primary="string type" data-type="indexterm" id="id1643"/>Another predefined C# type is <code>string</code>. The <code>string</code> type represents a sequence of characters, such as “.NET” or <a href="http://oreilly.com"><em class="hyperlink">http://oreilly.com</em></a>. You can work with strings by calling functions on them, as follows:</p>
<pre class="pagebreak-before" data-type="programlisting">string message = "Hello world";
string upperMessage = message.ToUpper();
Console.WriteLine (upperMessage);               // HELLO WORLD

int x = 2022;
message = message + x.ToString();
Console.WriteLine (message);                    // Hello world2022</pre>
<p>In this example, we called <code>x.ToString()</code> to obtain a string representation of the integer <code>x</code>. You can call <code>ToString()</code> on a variable of almost any type.</p>
<p><a contenteditable="false" data-primary="bool (Boolean) type and operators" data-type="indexterm" id="id1644"/><a contenteditable="false" data-primary="predefined types" data-seealso="specific types" data-type="indexterm" id="id1645"/>The predefined <code>bool</code> type has exactly two possible values: <code>true</code> and <code>false</code>. The <code>bool</code> type is commonly used with an <code>if</code> statement to conditionally branch execution flow:</p>
<pre data-type="programlisting">bool simpleVar = false;
if (simpleVar)
  Console.WriteLine ("This will not print");

int x = 5000;
bool lessThanAMile = x &lt; 5280;
if (lessThanAMile)
  Console.WriteLine ("This will print");</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="built-in types" data-type="indexterm" id="id1646"/>In C#, predefined types (also referred to as built-in types) are recognized with a C# keyword. The <code>System</code> namespace in .NET contains many important types that are not predefined by C# (e.g., <code>DateTime</code>).</p>
</div>
</div></section>
<section data-pdf-bookmark="Custom Types" data-type="sect2"><div class="sect2" id="custom_types">
<h2>Custom Types</h2>
<p><a contenteditable="false" data-primary="custom types" data-type="indexterm" id="ch02.html108"/><a contenteditable="false" data-primary="type system, C#" data-secondary="custom type examples" data-type="indexterm" id="ch02.html109"/>Just as we can write our own methods, we can write our own types. In this next example, we define a custom type named <code>UnitConverter</code>—a class that serves as a blueprint for unit conversions:</p>
<pre data-type="programlisting">UnitConverter feetToInchesConverter = new UnitConverter (12);
UnitConverter milesToFeetConverter  = new UnitConverter (5280);

Console.WriteLine (feetToInchesConverter.Convert(30));    // 360
Console.WriteLine (feetToInchesConverter.Convert(100));   // 1200

Console.WriteLine (feetToInchesConverter.Convert(
                   milesToFeetConverter.Convert(1)));     // 63360

<strong>public class UnitConverter</strong>
<strong>{</strong>
  <strong>int ratio;                              // Field</strong>

  <strong>public UnitConverter (int unitRatio)    // Constructor</strong>
  <strong>{</strong>
    <strong> ratio = unitRatio;</strong>
  <strong>}</strong> 

  <strong>public int Convert (int unit)           // Method</strong>
  <strong>{</strong>
    <strong> return unit * ratio;</strong>
  <strong>}</strong> 
<strong>}</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this example, our class definition appears in the same file as our top-level statements. This is legal—as long as the top-level statements appear first—and is acceptable when writing small test programs. With larger programs, the standard approach is to put the class definition in a separate file such as <span class="keep-together"><em>UnitConverter.cs</em></span>.</p>
</div>
<section data-pdf-bookmark="Members of a type" data-type="sect3"><div class="sect3" id="members_of_a_type">
<h3>Members of a type</h3>
<p><a contenteditable="false" data-primary="custom types" data-secondary="members of a type" data-type="indexterm" id="id1647"/><a contenteditable="false" data-primary="data members" data-type="indexterm" id="id1648"/>A type contains <em>data members</em> and <em>function members</em>. The data member of <span class="keep-together"><code>UnitConverter</code></span> is the <em>field</em> called <code>ratio</code>. The function members of <code>UnitConverter</code> are the <code>Convert</code> method and the <code>UnitConverter</code>’s <em>constructor</em>.</p>
</div></section>
<section data-pdf-bookmark="Symmetry of predefined types and custom types" data-type="sect3"><div class="sect3" id="symmetry_of_predefined_types_and_custom">
<h3>Symmetry of predefined types and custom types</h3>
<p><a contenteditable="false" data-primary="custom types" data-secondary="symmetry of predefined/custom types" data-type="indexterm" id="id1649"/>A beautiful aspect of C# is that predefined types and custom types have few differences. The predefined <code>int</code> type serves as a blueprint for integers. It holds data—32 bits—and provides function members that use that data, such as <code>ToString</code>. Similarly, our custom <code>UnitConverter</code> type acts as a blueprint for unit conversions. It holds data—the ratio—and provides function members to use that data.</p>
</div></section>
<section data-pdf-bookmark="Constructors and instantiation" data-type="sect3"><div class="sect3" id="constructors_and_instantiation">
<h3>Constructors and instantiation</h3>
<p><a contenteditable="false" data-primary="constructors" data-type="indexterm" id="id1650"/><a contenteditable="false" data-primary="custom types" data-secondary="constructors and instantiation" data-type="indexterm" id="id1651"/><a contenteditable="false" data-primary="instantiating a type" data-type="indexterm" id="id1652"/>Data is created by <em>instantiating</em> a type. Predefined types can be instantiated simply by using a literal such as <code>12</code> or <code>"Hello world"</code>. The <code>new</code> operator creates instances of a custom type. We created and declared an instance of the <code>UnitConverter</code> type with this statement:</p>
<pre data-type="programlisting">UnitConverter feetToInchesConverter = new UnitConverter (12);</pre>
<p>Immediately after the <code>new</code> operator instantiates an object, the object’s <em>constructor</em> is called to perform initialization. A constructor is defined like a method, except that the method name and return type are reduced to the name of the enclosing type:</p>
<pre data-type="programlisting">public UnitConverter (int unitRatio) { ratio = unitRatio; }</pre>
</div></section>
<section data-pdf-bookmark="Instance versus static members" data-type="sect3"><div class="sect3" id="instance_versus_static_members">
<h3>Instance versus static members</h3>
<p><a contenteditable="false" data-primary="custom types" data-secondary="instance versus static members" data-type="indexterm" id="id1653"/><a contenteditable="false" data-primary="instance, static members versus" data-type="indexterm" id="id1654"/><a contenteditable="false" data-primary="static members" data-secondary="instance versus" data-type="indexterm" id="id1655"/>The data members and function members that operate on the <em>instance</em> of the type are called <em>instance members</em>. The <code>UnitConverter</code>’s <code>Convert</code> method and the <code>int</code>’s <code>ToString</code> method are examples of instance members. By default, members are instance members.</p>
<p>Data members and function members that don’t operate on the instance of the type can be marked as <code>static</code>. To refer to a static member from outside its type, you specify its <em>type</em> name rather than an <em>instance</em>. An example is the <code>WriteLine</code> method of the <code>Console</code> class. Because this is static, we call <code>Console.WriteLine()</code> and not <code>new Console().WriteLine()</code>.</p>
<p>(The <code>Console</code> class is actually declared as a <em>static class</em>, which means that <em>all</em> of its members are static and you can never create instances of a <code>Console</code>.)</p>
<p>In the following code, the instance field <code>Name</code> pertains to an instance of a particular <code>Panda</code>, whereas <code>Population</code> pertains to the set of all <code>Panda</code> instances. We create two instances of the <code>Panda</code>, print their names, and then print the total population:</p>
<pre data-type="programlisting">Panda p1 = new Panda ("Pan Dee");
Panda p2 = new Panda ("Pan Dah");

Console.WriteLine (p1.Name);      // Pan Dee
Console.WriteLine (p2.Name);      // Pan Dah

Console.WriteLine (<strong>Panda.Population</strong>);   // 2

public class Panda
{
  public string Name;             // Instance field
  public <strong>static</strong> int Population;   // Static field

  public Panda (string n)         // Constructor
  {
    Name = n;                     // Assign the instance field
    <strong>Population = Population + 1</strong>;  // Increment the static Population field
  }
}</pre>
<p>Attempting to evaluate <code>p1.Population</code> or <code>Panda.Name</code> will generate a compile-time error.</p>
</div></section>
<section data-pdf-bookmark="The public keyword" data-type="sect3"><div class="sect3" id="the_public_keyword">
<h3>The public keyword</h3>
<p><a contenteditable="false" data-primary="custom types" data-secondary="public keyword" data-type="indexterm" id="id1656"/><a contenteditable="false" data-primary="public keyword" data-type="indexterm" id="id1657"/>The <code>public</code> keyword exposes members to other classes. In this example, if the <code>Name</code> field in <code>Panda</code> was not marked as public, it would be private and could not be accessed from outside the class. Marking a member <code>public</code> is how a type communicates: “Here is what I want other types to see—everything else is my own private implementation details.” In object-oriented terms, we say that the public members <em>encapsulate</em> the private members of the class.</p>
</div></section>
<section data-pdf-bookmark="Defining namespaces" data-type="sect3"><div class="sect3" id="defining_namespaces">
<h3>Defining namespaces</h3>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="defining" data-type="indexterm" id="id1658"/>Particularly with larger programs, it makes sense to organize types into namespaces. Here’s how to define the <code>Panda</code> class inside a namespace called <code>Animals</code>:</p>
<pre data-type="programlisting">using System;
using Animals;

Panda p = new Panda ("Pan Dee");
Console.WriteLine (p.Name);

<strong>namespace Animals</strong>
<strong>{</strong>
  public class Panda
  {
     ...
  }
<strong>}</strong></pre>
<p>In this example, we also <em>imported</em> the <code>Animals</code> namespace so that our top-level statements could access its types without qualification. Without that import, we’d need to do this:</p>
<pre data-type="programlisting"><strong>Animals.Panda</strong> p = new <strong>Animals.Panda</strong> ("Pan Dee");</pre>
<p>We cover namespaces in detail at the end of this chapter (see <a data-type="xref" href="#namespaces-id00029">“Namespaces”</a>).</p>
</div></section>
<section data-pdf-bookmark="Defining a Main method" data-type="sect3"><div class="sect3" id="defining_a_main_method">
<h3>Defining a Main method</h3>
<p><a contenteditable="false" data-primary="Main method" data-type="indexterm" id="id1659"/>All of our examples, so far, have used top-level statements (a feature introduced in C# 9).</p>
<p>Without top-level statements, a simple console or Windows application looks like this:</p>
<pre data-type="programlisting">using System;

<strong>class Program</strong>
<strong>{</strong>
  <strong>static void Main()</strong>   // Program entry point
  <strong>{</strong>
    int x = 12 * 30;
    Console.WriteLine (x);
  <strong>}</strong>
<strong>}</strong></pre>
<p>In the absence of top-level statements, C# looks for a static method called <code>Main</code>, which becomes the entry point. The <code>Main</code> method can be defined inside any class (and only one <code>Main</code> method can exist).</p>
<p>The <code>Main</code> method can optionally return an integer (rather than <code>void</code>) in order to return a value to the execution environment (where a nonzero value typically indicates an error). The <code>Main</code> method can also optionally accept an array of strings as a parameter (that will be populated with any arguments passed to the executable). For example:</p>
<pre data-type="programlisting">static int Main (string[] args) {...}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="array declaration" data-type="indexterm" id="id1660"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="array declaration" data-type="indexterm" id="id1661"/>An array (such as <code>string[]</code>) represents a fixed number of elements of a particular type. Arrays are specified by placing square brackets after the element type. We describe them in <a data-type="xref" href="#arrays-id00001">“Arrays”</a>.</p>
</div>
<p>(The <code>Main</code> method can also be declared <code>async</code> and return a <code>Task</code> or <code>Task&lt;int&gt;</code> in support of asynchronous programming, which we cover in <a data-type="xref" href="ch14.html#concurrency_and_asynchron">Chapter 14</a>.)</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="top_level_statements-id00098">
<h1>Top-Level Statements</h1>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="top-level statements" data-type="indexterm" id="id1662"/><a contenteditable="false" data-primary="top-level statements" data-secondary="elements of" data-type="indexterm" id="id1663"/>Top-level statements (introduced in C# 9) let you avoid the baggage of a static <code>Main</code> method and a containing class. A file with top-level statements comprises three parts, in this order:</p>
<ol>
<li><p>(Optionally) <code>using</code> directives</p></li>
<li><p>A series of statements, optionally mixed with method declarations</p></li>
<li><p>(Optionally) Type and namespace declarations</p></li>
</ol>
<p>For example:</p>
<pre data-type="programlisting">using System;                           // Part 1

Console.WriteLine ("Hello, world");     // Part 2
void SomeMethod1() { ... }              // Part 2
Console.WriteLine ("Hello again!");     // Part 2
void SomeMethod2() { ... }              // Part 2

class SomeClass { ... }                 // Part 3
namespace SomeNamespace { ... }         // Part 3</pre>
<p>Because the CLR doesn’t explicitly support top-level statements, the compiler translates your code into something like this:</p>
<pre data-type="programlisting">using System;                           // Part 1

<strong>static class Program$   // Special compiler-generated name</strong>
<strong>{
  static void Main$ (string[] args)   // Compiler-generated name
  {</strong>
    Console.WriteLine ("Hello, world");     // Part 2
    void SomeMethod1() { ... }              // Part 2
    Console.WriteLine ("Hello again!");     // Part 2
    void SomeMethod2() { ... }              // Part 2
  <strong>}
}</strong>

class SomeClass { ... }                 // Part 3
namespace SomeNamespace { ... }         // Part 3</pre>
<p>Notice that everything in Part 2 is wrapped inside the main method. This means that <code>SomeMethod1</code> and <code>SomeMethod2</code> act as <em>local methods</em>. We discuss the full implications in <a data-type="xref" href="ch03.html#local_methods-id00077">“Local methods”</a>, the most important being that local methods (unless declared as <code>static</code>) can access variables declared within the containing method:</p>
<pre data-type="programlisting">int <strong>x</strong> = 3;
LocalMethod();

void LocalMethod() { Console.WriteLine (<strong>x</strong>); }   // We can access x</pre>
<p>Another consequence is that top-level methods cannot be accessed from other classes or types.</p>
<p>Top-level statements can optionally return an integer value to the caller and access a “magic” variable of type <code>string[]</code> called <code>args</code>, corresponding to command-line arguments passed by the caller.</p>
<p>As a program can have only one entry point, there can be at most one file with top-level statements in a C# project. <a contenteditable="false" data-primary="" data-startref="ch02.html109" data-type="indexterm" id="id1664"/><a contenteditable="false" data-primary="" data-startref="ch02.html108" data-type="indexterm" id="id1665"/></p>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Types and Conversions" data-type="sect2"><div class="sect2" id="types_and_conversions">
<h2>Types and Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-type="indexterm" id="id1666"/><a contenteditable="false" data-primary="conversions" data-secondary="numeric types" data-type="indexterm" id="id1667"/><a contenteditable="false" data-primary="type system, C#" data-secondary="converting types" data-type="indexterm" id="id1668"/>C# can convert between instances of compatible types. A conversion always creates a new value from an existing one. <a contenteditable="false" data-primary="conversions" data-secondary="implicit/explicit" data-type="indexterm" id="id1669"/><a contenteditable="false" data-primary="explicit conversions" data-type="indexterm" id="id1670"/><a contenteditable="false" data-primary="implicit conversions" data-type="indexterm" id="id1671"/>Conversions can be either <em>implicit</em> or <em>explicit</em>: implicit conversions happen automatically, and explicit conversions require a <em>cast</em>. In the following example, we <em>implicitly</em> convert an <code>int</code> to a <code>long</code> type (which has twice the bit capacity of an <code>int</code>) and <em>explicitly</em> cast an <code>int</code> to a <code>short</code> type (which <span class="keep-together">has half</span> the bit capacity of an <code>int</code>):</p>
<pre data-type="programlisting">int x = 12345;       // int is a 32-bit integer
long y = x;          // Implicit conversion to 64-bit integer
short z = (short)x;  // Explicit conversion to 16-bit integer</pre>
<p>Implicit conversions are allowed when both of the following are true:</p>
<ul>
<li><p>The compiler can guarantee that they will always succeed.</p></li>
<li><p>No information is lost in conversion.<sup><a data-type="noteref" href="ch02.html#ch01fn1" id="ch01fn1-marker">1</a></sup></p></li>
</ul>
<p>Conversely, <em>explicit</em> conversions are required when one of the following is true:</p>
<ul>
<li><p>The compiler cannot guarantee that they will always succeed.</p></li>
<li><p>Information might be lost during conversion.</p></li>
</ul>
<p>(If the compiler can determine that a conversion will <em>always</em> fail, both kinds of conversion are prohibited. Conversions that involve generics can also fail in certain conditions—see <a data-type="xref" href="ch03.html#type_parameters_and_conversions">“Type Parameters and Conversions”</a>.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <em>numeric conversions</em> that we just saw are built into the language. C# also supports <em>reference conversions</em> and <em>boxing conversions</em> (see <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>) as well as <em>custom conversions</em> (see <a data-type="xref" href="ch04.html#operator_overloading">“Operator Overloading”</a>). The compiler doesn’t enforce the aforementioned rules with custom conversions, so it’s possible for badly designed types to behave otherwise.</p>
</div>
</div></section>
<section data-pdf-bookmark="Value Types Versus Reference Types" data-type="sect2"><div class="sect2" id="value_types_versus_reference-id00051">
<h2>Value Types Versus Reference Types</h2>
<p><a contenteditable="false" data-primary="type system, C#" data-secondary="value types versus reference types" data-type="indexterm" id="ch02.html1010"/>All C# types fall into the following categories:</p>
<ul>
<li><p>Value types</p></li>
<li><p>Reference types</p></li>
<li><p>Generic type parameters</p></li>
<li><p>Pointer types</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this section, we describe value types and reference types. We cover generic type parameters in <a data-type="xref" href="ch03.html#generics">“Generics”</a> and pointer types in <a data-type="xref" href="ch04.html#unsafe_code_and_pointers">“Unsafe Code and Pointers”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="value types" data-type="indexterm" id="id1672"/><em>Value types</em> comprise most built-in types (specifically, all numeric types, the <code>char</code> type, and the <code>bool</code> type) as well as custom <code>struct</code> and <code>enum</code> types.</p>
<p><a contenteditable="false" data-primary="reference types" data-type="indexterm" id="id1673"/><em>Reference types</em> comprise all class, array, delegate, and interface types. (This includes the predefined <code>string</code> type.)</p>
<p>The fundamental difference between value types and reference types is how they are handled in memory.</p>
<section data-pdf-bookmark="Value types" data-type="sect3"><div class="sect3" id="value_types">
<h3>Value types</h3>
<p>The content of a <em>value type</em> variable or constant is simply a value. For example, the content of the built-in value type, <code>int</code>, is 32 bits of data.</p>
<p>You can define a custom value type with the <code>struct</code> keyword (see <a data-type="xref" href="#a_value_type_instance_in_memory">Figure 2-1</a>):</p>
<pre data-type="programlisting">public struct Point { public int X; public int Y; }</pre>
<p>Or more tersely:</p>
<pre data-type="programlisting">public struct Point { public int X, Y; }</pre>
<figure><div class="figure" id="a_value_type_instance_in_memory">
<img alt="A value-type instance in memory" src="assets/cn10_0201.png"/>
<h6><span class="label">Figure 2-1. </span>A value-type instance in memory</h6>
</div></figure>
<p>The assignment of a value-type instance always <em>copies</em> the instance; for example:</p>
<pre data-type="programlisting">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // Assignment causes copy

Console.WriteLine (p1.X);  // 7
Console.WriteLine (p2.X);  // 7

p1.X = 9;                  // Change p1.X

Console.WriteLine (p1.X);  // 9
Console.WriteLine (p2.X);  // 7</pre>
<p><a data-type="xref" href="#assignment_copies_a_value_type_instance">Figure 2-2</a> shows that <code>p1</code> and <code>p2</code> have independent storage.</p>
<figure><div class="figure" id="assignment_copies_a_value_type_instance">
<img alt="Assignment copies a value-type instance" src="assets/cn10_0202.png"/>
<h6><span class="label">Figure 2-2. </span>Assignment copies a value-type instance</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Reference types" data-type="sect3"><div class="sect3" id="reference_types">
<h3>Reference types</h3>
<p><a contenteditable="false" data-primary="reference types" data-type="indexterm" id="id1674"/>A reference type is more complex than a value type, having two parts: an <em>object</em> and the <em>reference</em> to that object. The content of a reference-type variable or constant is a reference to an object that contains the value. Here is the <code>Point</code> type from our previous example rewritten as a class rather than a <code>struct</code> (shown in <a data-type="xref" href="#a_reference_type_instance_in_memory">Figure 2-3</a>):</p>
<pre data-type="programlisting">public class Point { public int X, Y; }</pre>
<figure><div class="figure" id="a_reference_type_instance_in_memory">
<img alt="A reference-type instance in memory" src="assets/cn10_0203.png"/>
<h6><span class="label">Figure 2-3. </span>A reference-type instance in memory</h6>
</div></figure>
<p>Assigning a reference-type variable copies the reference, not the object instance. This allows multiple variables to refer to the same object—something not ordinarily possible with value types. If we repeat the previous example, but with <code>Point</code> now a class, an operation to <code>p1</code> affects <code>p2</code>:</p>
<pre data-type="programlisting">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // Copies p1 reference

Console.WriteLine (p1.X);  // 7
Console.WriteLine (p2.X);  // 7

p1.X = 9;                  // Change p1.X

Console.WriteLine (p1.X);  // 9
Console.WriteLine (p2.X);  // 9</pre>
<p class="pagebreak-before"><a data-type="xref" href="#assignment_copies_a_reference">Figure 2-4</a> shows that <code>p1</code> and <code>p2</code> are two references that point to the same object.</p>
<figure><div class="figure" id="assignment_copies_a_reference">
<img alt="Assignment copies a reference" src="assets/cn10_0204.png"/>
<h6><span class="label">Figure 2-4. </span>Assignment copies a reference</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Null" data-type="sect3"><div class="sect3" id="null">
<h3>Null</h3>
<p><a contenteditable="false" data-primary="null reference" data-type="indexterm" id="id1675"/>A reference can be assigned the literal <code>null</code>, indicating that the reference points to no object:</p>
<pre data-type="programlisting">Point p = null;
Console.WriteLine (p == null);   // True

// The following line generates a runtime error
// (a NullReferenceException is thrown):
Console.WriteLine (p.X);

<strong>class Point</strong> {...}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In <a data-type="xref" href="ch04.html#nullable_reference_types-id00081">“Nullable Reference Types”</a>, we describe a feature of C# that helps to reduce accidental <code>NullReference​Ex⁠ception</code> errors.</p>
</div>
<p><a contenteditable="false" data-primary="null value, literal for" data-type="indexterm" id="id1676"/>In contrast, a value type cannot ordinarily have a null value:</p>
<pre data-type="programlisting">Point p = null;  // Compile-time error
int x = null;    // Compile-time error

<strong>struct Point</strong> {...}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="nullable types" data-type="indexterm" id="id1677"/>C# also has a construct called <em>nullable value types</em> for representing value-type nulls. For more information, see <a data-type="xref" href="ch04.html#nullable_value_types">“Nullable Value Types”</a>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Storage overhead" data-type="sect3"><div class="sect3" id="storage_overhead">
<h3>Storage overhead</h3>
<p>Value-type instances occupy precisely the memory required to store their fields. In this example, <code>Point</code> takes 8 bytes of memory:</p>
<pre data-type="programlisting">struct Point
{
  int x;  // 4 bytes
  int y;  // 4 bytes
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Technically, the CLR positions fields within the type at an address that’s a multiple of the fields’ size (up to a maximum of 8 bytes). Thus, the following actually consumes 16 bytes of memory (with the 7 bytes following the first field “wasted”):</p>
<pre data-type="programlisting">struct A { byte b; long l; }</pre>
<p>You can override this behavior by applying the <code>StructLayout</code> attribute (see <a data-type="xref" href="ch24.html#mapping_a_struct_to_unmanaged_memory">“Mapping a Struct to Unmanaged Memory”</a>).</p>
</div>
<p>Reference types require separate allocations of memory for the reference and object. The object consumes as many bytes as its fields, plus additional administrative overhead. The precise overhead is intrinsically private to the implementation of the .NET runtime, but at minimum, the overhead is 8 bytes, used to store a key to the object’s type as well as temporary information such as its lock state for multithreading and a flag to indicate whether it has been fixed from movement by the garbage collector. Each reference to an object requires an extra 4 or 8 bytes, depending on whether the .NET runtime is running on a 32- or 64-bit platform. <a contenteditable="false" data-primary="" data-startref="ch02.html1010" data-type="indexterm" id="id1678"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Predefined Type Taxonomy" data-type="sect2"><div class="sect2" id="predefined_type_taxonomy">
<h2>Predefined Type Taxonomy</h2>
<p><a contenteditable="false" data-primary="predefined types" data-type="indexterm" id="id1679"/>The predefined types in C# are as follows:</p>
<dl>
<dt><em>Value types</em></dt>
<dd><ul>
<li><p>Numeric</p>
<ul class="list_style_type_none">
<li><p>Signed integer (<code>sbyte</code>, <code>short</code>, <code>int</code>, <code>long</code>)</p></li>
<li><p>Unsigned integer (<code>byte</code>, <code>ushort</code>, <code>uint</code>, <code>ulong</code>)</p></li>
<li><p>Real number (<code>float</code>, <code>double</code>, <code>decimal</code>)</p></li>
</ul></li>
<li><p>Logical (<code>bool</code>)</p></li>
<li><p>Character (<code>char</code>)</p></li>
</ul></dd>
<dt><em>Reference types</em></dt>
<dd><ul>
<li><p>String (<code>string</code>)</p></li>
<li><p>Object (<code>object</code>)</p></li>
</ul></dd>
</dl>
<p>Predefined types in C# alias .NET types in the <code>System</code> namespace. There is only a syntactic difference between these two statements:</p>
<pre data-type="programlisting">int i = 5;
System.Int32 i = 5;</pre>
<p><a contenteditable="false" data-primary="primitive types" data-type="indexterm" id="id1680"/>The set of predefined <em>value</em> types excluding <code>decimal</code> are known as <em>primitive types</em> in the CLR. Primitive types are so called because they are supported directly via instructions in compiled code, and this usually translates to direct support on the underlying processor; for example:</p>
<pre data-type="programlisting">                   <strong>// Underlying hexadecimal representation</strong>
int i = 7;         // 0x7
bool b = true;     // 0x1
char c = 'A';      // 0x41
float f = 0.5f;    // uses IEEE floating-point encoding</pre>
<p>The <code>System.IntPtr</code> and <code>System.UIntPtr</code> types are also primitive (see <a data-type="xref" href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>).<a contenteditable="false" data-primary="" data-startref="ch02.html107" data-type="indexterm" id="id1681"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Numeric Types" data-type="sect1"><div class="sect1" id="numeric_types">
<h1>Numeric Types</h1>
<p><a contenteditable="false" data-primary="ushort (numeric type)" data-type="indexterm" id="id1682"/>C# <a contenteditable="false" data-primary="numeric types" data-type="indexterm" id="ch02.html1011"/><a contenteditable="false" data-primary="type system, C#" data-secondary="numeric types" data-type="indexterm" id="ch02.html1012"/>has the predefined numeric types shown in <a data-type="xref" href="#predefined_numeric_types_in_chash">Table 2-1</a>.</p>
<table class="border" id="predefined_numeric_types_in_chash">
<caption><span class="label">Table 2-1. </span>Predefined numeric types in C#</caption>
<thead>
<tr>
<th>C# type</th>
<th>System type</th>
<th>Suffix</th>
<th>Size</th>
<th>Range</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="5"><strong>Integral—signed</strong></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>SByte</code></td>
<td/>
<td>8 bits</td>
<td>–2<sup>7</sup> to 2<sup>7</sup>–1</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Int16</code></td>
<td/>
<td>16 bits</td>
<td>–2<sup>15</sup> to 2<sup>15</sup>–1</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Int32</code></td>
<td/>
<td>32 bits</td>
<td>–2<sup>31</sup> to 2<sup>31</sup>–1</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Int64</code></td>
<td><code>L</code></td>
<td>64 bits</td>
<td>–2<sup>63</sup> to 2<sup>63</sup>–1</td>
</tr>
<tr>
<td><code>nint</code></td>
<td><code>IntPtr</code></td>
<td/>
<td>32/64 bits</td>
<td/>
</tr>
<tr>
<td colspan="5"><strong>Integral—unsigned</strong></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td/>
<td>8 bits</td>
<td>0 to 2<sup>8</sup>–1</td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>UInt16</code></td>
<td/>
<td>16 bits</td>
<td>0 to 2<sup>16</sup>–1</td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>UInt32</code></td>
<td><code>U</code></td>
<td>32 bits</td>
<td>0 to 2<sup>32</sup>–1</td>
</tr>
<tr>
<td><code>ulong</code></td>
<td><code>UInt64</code></td>
<td><code>UL</code></td>
<td>64 bits</td>
<td>0 to 2<sup>64</sup>–1</td>
</tr>
<tr>
<td><code>nuint</code></td>
<td><code>UIntPtr</code></td>
<td/>
<td>32/64 bits</td>
<td/>
</tr>
<tr>
<td colspan="5"><strong>Real</strong></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Single</code></td>
<td><code>F</code></td>
<td>32 bits</td>
<td>± (~10<sup>–45</sup> to 10<sup>38</sup>)</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
<td><code>D</code></td>
<td>64 bits</td>
<td>± (~10<sup>–324</sup> to 10<sup>308</sup>)</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td><code>Decimal</code></td>
<td><code>M</code></td>
<td>128 bits</td>
<td>± (~10<sup>–28</sup> to 10<sup>28</sup>)</td>
</tr>
</tbody>
</table>
<p>Of the <em>integral</em> types, <code>int</code> and <code>long</code> are first-class citizens and are favored by both C# and the runtime. The other integral types are typically used for interoperability or when space efficiency is paramount. The <code>nint</code> and <code>nuint</code> native-sized integer types are most useful when working with pointers, so we will describe these in a later chapter (see <a data-type="xref" href="ch04.html#native_sized_integers">“Native-Sized Integers”</a>).</p>
<p><a contenteditable="false" data-primary="floating-point types" data-type="indexterm" id="id1683"/>Of the <em>real</em> number types, <code>float</code> and <code>double</code> are called <em>floating-point types</em><sup><a data-type="noteref" href="ch02.html#ch01fn2" id="ch01fn2-marker">2</a></sup> and are typically used for scientific and graphical calculations. The <code>decimal</code> type is typically used for financial calculations, for which base-10-accurate arithmetic and high precision are required.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>.NET supplements this list with several specialized numeric types, including <code>Int128</code> and <code>UInt128</code> for signed and unsigned 128-bit integers, <code>BigInteger</code> for arbitrarily large integers, and <code>Half</code> for 16-bit floating point numbers. <code>Half</code> is intended mainly for interoperating with graphics card processors and does not have native support in most CPUs, making <code>float</code> and <code>double</code> better choices for general use.</p>
</div>
<section data-pdf-bookmark="Numeric Literals" data-type="sect2"><div class="sect2" id="numeric_literals">
<h2>Numeric Literals</h2>
<p><a contenteditable="false" data-primary="integral-type literals" data-type="indexterm" id="id1684"/><a contenteditable="false" data-primary="numeric literals" data-type="indexterm" id="id1685"/><a contenteditable="false" data-primary="numeric types" data-secondary="numeric literals" data-type="indexterm" id="id1686"/><em>Integral-type literals</em> can use decimal or hexadecimal notation; hexadecimal is denoted with the <code>0x</code> prefix. For example:</p>
<pre data-type="programlisting">int x = 127;
long y = 0x7F;</pre>
<p>You can insert an underscore anywhere within a numeric literal to make it more readable:</p>
<pre data-type="programlisting">int million = 1_000_000;</pre>
<p>You can specify numbers in binary with the <code>0b</code> prefix:</p>
<pre data-type="programlisting">var b = 0b1010_1011_1100_1101_1110_1111;</pre>
<p><a contenteditable="false" data-primary="real literals" data-type="indexterm" id="id1687"/><em>Real literals</em> can use decimal and/or exponential notation:</p>
<pre data-type="programlisting">double d = 1.5;
double million = 1E06;</pre>
<section data-pdf-bookmark="Numeric literal type inference" data-type="sect3"><div class="sect3" id="numeric_literal_type_inference">
<h3>Numeric literal type inference</h3>
<p><a contenteditable="false" data-primary="numeric literals" data-secondary="type inference" data-type="indexterm" id="id1688"/>By default, the compiler <em>infers</em> a numeric literal to be either <code>double</code> or an integral type:</p>
<ul>
<li><p>If the literal contains a decimal point or the exponential symbol (<code>E</code>), it is a <code>double</code>.</p></li>
<li><p>Otherwise, the literal’s type is the first type in this list that can fit the literal’s value: <code>int</code>, <code>uint</code>, <code>long</code>, and <code>ulong</code>.</p></li>
</ul>
<p>For example:</p>
<pre data-type="programlisting">Console.WriteLine (        1.0.GetType());  // Double  <em>(double)</em>
Console.WriteLine (       1E06.GetType());  // Double  <em>(double)</em>
Console.WriteLine (          1.GetType());  // Int32   <em>(int)</em>
Console.WriteLine ( 0xF0000000.GetType());  // UInt32  <em>(uint)</em>
Console.WriteLine (0x100000000.GetType());  // Int64   <em>(long)</em></pre>
</div></section>
<section data-pdf-bookmark="Numeric suffixes" data-type="sect3"><div class="sect3" id="numeric_suffixes">
<h3>Numeric suffixes</h3>
<p><a contenteditable="false" data-primary="numeric literals" data-secondary="numeric suffixes" data-type="indexterm" id="id1689"/><a contenteditable="false" data-primary="numeric suffixes" data-type="indexterm" id="id1690"/><em>Numeric suffixes</em> explicitly define the type of a literal. Suffixes can be either lowercase or uppercase, and are as follows:</p>
<table class="border">
<thead>
<tr>
<th>Category</th>
<th>C# type</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>F</code></td>
<td><code>float</code></td>
<td><code>float f = 1.0F;</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td><code>double</code></td>
<td><code>double d = 1D;</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td><code>decimal</code></td>
<td><code>decimal d = 1.0M;</code></td>
</tr>
<tr>
<td><code>U</code></td>
<td><code>uint</code></td>
<td><code>uint i = 1U;</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>long</code></td>
<td><code>long i = 1L;</code></td>
</tr>
<tr>
<td><code>UL</code></td>
<td><code>ulong</code></td>
<td><code>ulong i = 1UL;</code></td>
</tr>
</tbody>
</table>
<p>The suffixes <code>U</code> and <code>L</code> are rarely necessary because the <code>uint</code>, <code>long</code>, and <code>ulong</code> types can nearly always be either <em>inferred</em> or <em>implicitly converted</em> from <code>int</code>:</p>
<pre data-type="programlisting">long i = 5;     // Implicit lossless conversion from int literal to long</pre>
<p>The <code>D</code> suffix is technically redundant in that all literals with a decimal point are inferred to be <code>double</code>. And you can always add a decimal point to a numeric literal:</p>
<pre data-type="programlisting">double x = 4.0;</pre>
<p>The <code>F</code> and <code>M</code> suffixes are the most useful and should always be applied when specifying <code>float</code> or <code>decimal</code> literals. Without the <code>F</code> suffix, the following line would not compile, because 4.5 would be inferred to be of type <code>double</code>, which has no implicit conversion to <code>float</code>:</p>
<pre data-type="programlisting">float f = 4.5F;</pre>
<p>The same principle is true for a decimal literal:</p>
<pre data-type="programlisting">decimal d = -1.23M;     // Will not compile without the M suffix.</pre>
<p>We describe the semantics of numeric conversions in detail in the following section.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Numeric Conversions" data-type="sect2"><div class="sect2" id="numeric_conversions">
<h2>Numeric Conversions</h2>
<section data-pdf-bookmark="Converting between integral types" data-type="sect3"><div class="sect3" id="converting_between_integral_types">
<h3>Converting between integral types</h3>
<p><a contenteditable="false" data-primary="implicit conversions" data-type="indexterm" id="id1691"/><a contenteditable="false" data-primary="integral types" data-secondary="conversions" data-type="indexterm" id="id1692"/><a contenteditable="false" data-primary="numeric types" data-secondary="conversions" data-type="indexterm" id="id1693"/>Integral type conversions are <em>implicit</em> when the destination type can represent every possible value of the source type. Otherwise, an <em>explicit</em> conversion is required; for example:</p>
<pre data-type="programlisting">int x = 12345;       // int is a 32-bit integer
long y = x;          // Implicit conversion to 64-bit integral type
short z = (short)x;  // Explicit conversion to 16-bit integral type</pre>
</div></section>
<section data-pdf-bookmark="Converting between floating-point types" data-type="sect3"><div class="sect3" id="converting_between_floating_point_types">
<h3>Converting between floating-point types</h3>
<p>A <code>float</code> can be implicitly converted to a <code>double</code> given that a <code>double</code> can represent every possible value of a <code>float</code>. The reverse conversion must be explicit.</p>
</div></section>
<section data-pdf-bookmark="Converting between floating-point and integral types" data-type="sect3"><div class="sect3" id="converting_between_floating_point_and_i">
<h3>Converting between floating-point and integral types</h3>
<p><a contenteditable="false" data-primary="floating-point types" data-secondary="conversions" data-type="indexterm" id="id1694"/>All integral types can be implicitly converted to all floating-point types:</p>
<pre data-type="programlisting">int i = 1;
float f = i;</pre>
<p>The reverse conversion must be explicit:</p>
<pre data-type="programlisting">int i2 = (int)f;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you cast from a floating-point number to an integral type, any fractional portion is truncated; no rounding is performed. The static class <code>System.Convert</code> provides methods that round while converting between various numeric types (see <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>).</p>
</div>
<p>Implicitly converting a large integral type to a floating-point type preserves <em>magnitude</em> but can occasionally lose <em>precision</em>. This is because floating-point types always have more magnitude than integral types but can have less precision. Rewriting our example with a larger number demonstrates this:</p>
<pre data-type="programlisting">int i1 = 100000001;
float f = i1;          // Magnitude preserved, precision lost
int i2 = (int)f;       // 100000000</pre>
</div></section>
<section data-pdf-bookmark="Decimal conversions" data-type="sect3"><div class="sect3" id="decimal_conversions">
<h3>Decimal conversions</h3>
<p><a contenteditable="false" data-primary="decimal conversions" data-type="indexterm" id="id1695"/>All integral types can be implicitly converted to the decimal type given that a decimal can represent every possible C# integral-type value. All other numeric conversions to and from a decimal type must be explicit because they introduce the possibility of either a value being out of range or precision being lost.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Arithmetic Operators" data-type="sect2"><div class="sect2" id="arithmetic_operators">
<h2>Arithmetic Operators</h2>
<p><a contenteditable="false" data-primary="- (minus sign)" data-secondary="subtraction operator" data-type="indexterm" id="id1696"/><a contenteditable="false" data-primary="* (asterisk)" data-secondary="as multiplication operator" data-type="indexterm" id="id1697"/><a contenteditable="false" data-primary="/ (forward slash)" data-secondary="as division operator" data-type="indexterm" id="id1698"/><a contenteditable="false" data-primary="% (remainder operator)" data-type="indexterm" id="id1699"/><a contenteditable="false" data-primary="+ (plus sign)" data-secondary="addition operator" data-type="indexterm" id="id1700"/><a contenteditable="false" data-primary="arithmetic operators" data-type="indexterm" id="id1701"/><a contenteditable="false" data-primary="asterisk (*)" data-secondary="as multiplication operator" data-type="indexterm" id="id1702"/><a contenteditable="false" data-primary="forward slash (/)" data-secondary="as division operator" data-type="indexterm" id="id1703"/><a contenteditable="false" data-primary="minus sign (-)" data-secondary="subtraction operator" data-type="indexterm" id="id1704"/><a contenteditable="false" data-primary="numeric types" data-secondary="arithmetic operators" data-type="indexterm" id="id1705"/><a contenteditable="false" data-primary="plus sign (+)" data-secondary="addition operator" data-type="indexterm" id="id1706"/><a contenteditable="false" data-primary="remainder operator (%)" data-type="indexterm" id="id1707"/>The arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) are defined for all numeric types except the 8- and 16-bit integral types:</p>
<pre data-type="programlisting">+    Addition
-    Subtraction
*    Multiplication
/    Division
%    Remainder after division</pre>
</div></section>
<section data-pdf-bookmark="Increment and Decrement Operators" data-type="sect2"><div class="sect2" id="increment_and_decrement_operators">
<h2>Increment and Decrement Operators</h2>
<p><a contenteditable="false" data-primary="-- (decrement operator)" data-type="indexterm" id="id1708"/><a contenteditable="false" data-primary="++ (increment operator)" data-type="indexterm" id="id1709"/><a contenteditable="false" data-primary="decrement operator (--)" data-type="indexterm" id="id1710"/><a contenteditable="false" data-primary="increment operator (++)" data-type="indexterm" id="id1711"/><a contenteditable="false" data-primary="numeric types" data-secondary="increment and decrement operators" data-type="indexterm" id="id1712"/>The increment and decrement operators (<code>++</code>, <code>--</code>, respectively) increment and decrement numeric types by 1. The operator can either follow or precede the variable, depending on whether you want its value <em>before</em> or <em>after</em> the increment/decrement; for example:</p>
<pre data-type="programlisting">int x = 0, y = 0;
Console.WriteLine (x++);   // Outputs 0; x is now 1
Console.WriteLine (++y);   // Outputs 1; y is now 1</pre>
</div></section>
<section data-pdf-bookmark="Specialized Operations on Integral Types" data-type="sect2"><div class="sect2" id="specialized_operations_on_integral_type">
<h2>Specialized Operations on Integral Types</h2>
<p><a contenteditable="false" data-primary="integral types" data-secondary="specialized operations on" data-type="indexterm" id="id1713"/><a contenteditable="false" data-primary="numeric types" data-secondary="specialized operations on integral types" data-type="indexterm" id="id1714"/>The <em>integral types</em> are <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>short</code>, <code>ushort</code>, <code>byte</code>, and <code>sbyte</code>.</p>
<section data-pdf-bookmark="Division" data-type="sect3"><div class="sect3" id="division">
<h3>Division</h3>
<p><a contenteditable="false" data-primary="division" data-type="indexterm" id="id1715"/>Division operations on integral types always eliminate the remainder (round toward zero). Dividing by a variable whose value is zero generates a runtime error (a <code>DivideByZeroException</code>):</p>
<pre data-type="programlisting">int a = 2 / 3;      // 0

int b = 0;
int c = 5 / b;      // throws DivideByZeroException</pre>
<p>Dividing by the <em>literal</em> or <em>constant</em> 0 generates a compile-time error.</p>
</div></section>
<section data-pdf-bookmark="Overflow" data-type="sect3"><div class="sect3" id="overflow">
<h3>Overflow</h3>
<p><a contenteditable="false" data-primary="overflow" data-type="indexterm" id="id1716"/>At runtime, arithmetic operations on integral types can overflow. By default, this happens silently—no exception is thrown, and the result exhibits “wraparound” behavior, as though the computation were done on a larger integer type and the extra significant bits discarded. For example, decrementing the minimum possible <code>int</code> value results in the maximum possible <code>int</code> value:</p>
<pre data-type="programlisting">int a = int.MinValue;
a--;
Console.WriteLine (a == int.MaxValue); // True</pre>
</div></section>
<section data-pdf-bookmark="Overflow check operators" data-type="sect3"><div class="sect3" id="overflow_check_operators">
<h3>Overflow check operators</h3>
<p><a contenteditable="false" data-primary="checked operators" data-type="indexterm" id="id1717"/><a contenteditable="false" data-primary="overflow check operators" data-secondary="integral types and" data-type="indexterm" id="id1718"/>The <code>checked</code> operator instructs the runtime to generate an <code>OverflowException</code> rather than overflowing silently when an integral-type expression or statement exceeds the arithmetic limits of that type. The <code>checked</code> operator affects expressions with the <code>++</code>, <code>−−</code>, <code>+</code>, <code>−</code> (binary and unary), <code>*</code>, <code>/</code>, and explicit conversion operators between integral types. Overflow checking incurs a small performance cost.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>checked</code> operator has no effect on the <code>double</code> and <code>float</code> types (which overflow to special “infinite” values, as you’ll see soon) and no effect on the <code>decimal</code> type (which is always checked).</p>
</div>
<p>You can use <code>checked</code> around either an expression or a statement block:</p>
<pre data-type="programlisting">int a = 1000000;
int b = 1000000;

int c = <strong>checked</strong> (a * b);      // Checks just the expression.

<strong>checked</strong>                       // Checks all expressions
<strong>{</strong>                             // in statement block.
   ...
   c = a * b;
   ...
<strong>}</strong></pre>
<p>You can make arithmetic overflow checking the default for all expressions in a program by selecting the “checked” option at the project level (in Visual Studio, go to Advanced Build Settings). If you then need to disable overflow checking just for specific expressions or statements, you can do so with the <code>unchecked</code> operator. For example, the following code will not throw exceptions—even if the project’s “checked” option is selected:</p>
<pre data-type="programlisting">int x = int.MaxValue;
int y = <strong>unchecked</strong> (x + 1);
<strong>unchecked</strong> { int z = x + 1; }</pre>
</div></section>
<section data-pdf-bookmark="Overflow checking for constant expressions" data-type="sect3"><div class="sect3" id="overflow_checking_for_constant_expressi">
<h3>Overflow checking for constant expressions</h3>
<p><a contenteditable="false" data-primary="overflow check operators" data-secondary="for constant expressions" data-type="indexterm" id="id1719"/>Regardless of the “checked” project setting, expressions evaluated at compile time are always overflow-checked—unless you apply the <code>unchecked</code> operator:</p>
<pre data-type="programlisting">int x = int.MaxValue + 1;               // Compile-time error
int y = unchecked (int.MaxValue + 1);   // No errors</pre>
</div></section>
<section data-pdf-bookmark="Bitwise operators" data-type="sect3"><div class="sect3" id="bitwise_operators">
<h3>Bitwise operators</h3>
<p><a contenteditable="false" data-primary="&amp; (ampersand)" data-secondary="bitwise AND operator" data-type="indexterm" id="id1720"/><a contenteditable="false" data-primary="&lt;&lt; (shift left operator)" data-type="indexterm" id="id1721"/><a contenteditable="false" data-primary="^ (caret)" data-secondary="bitwise exclusive OR operator" data-type="indexterm" id="id1722"/><a contenteditable="false" data-primary="&gt;&gt; (shift right operator)" data-type="indexterm" id="id1723"/><a contenteditable="false" data-primary="| (vertical bar)" data-secondary="bitwise OR operator" data-type="indexterm" id="id1724"/><a contenteditable="false" data-primary="~ (complement operator)" data-type="indexterm" id="id1725"/><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="bitwise AND operator" data-type="indexterm" id="id1726"/><a contenteditable="false" data-primary="bitwise operators" data-type="indexterm" id="id1727"/><a contenteditable="false" data-primary="caret (^)" data-secondary="bitwise exclusive OR operator" data-type="indexterm" id="id1728"/><a contenteditable="false" data-primary="complement operator (~)" data-type="indexterm" id="id1729"/><a contenteditable="false" data-primary="shift left operator (&lt;&lt;)" data-type="indexterm" id="id1730"/><a contenteditable="false" data-primary="shift right operator (&gt;&gt;)" data-type="indexterm" id="id1731"/><a contenteditable="false" data-primary="vertical bar (|)" data-secondary="bitwise OR operator" data-type="indexterm" id="id1732"/>C# supports the following bitwise operators:</p>
<table class="border">
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
<th>Sample expression</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>Complement</td>
<td><code>~0xfU</code></td>
<td><code>0xfffffff0U</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>And</td>
<td><code>0xf0 &amp; 0x33</code></td>
<td><code>0x30</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>Or</td>
<td><code>0xf0 | 0x33</code></td>
<td><code>0xf3</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>Exclusive Or</td>
<td><code>0xff00 ^ 0x0ff0</code></td>
<td><code>0xf0f0</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Shift left</td>
<td><code>0x20 &lt;&lt; 2</code></td>
<td><code>0x80</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Shift right</td>
<td><code>0x20 &gt;&gt; 1</code></td>
<td><code>0x10</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>Unsigned shift right</td>
<td><code>int.MinValue &gt;&gt;&gt; 1</code></td>
<td><code>0x40000000</code></td>
</tr>
</tbody>
</table>
<p>The shift-right operator <code>(&gt;&gt;</code>) replicates the high-order bit when operating on signed integers, whereas the unsigned shift-right operator (<code>&gt;&gt;&gt;</code>) does not.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Additional bitwise operations are exposed via a class called <code>BitOperations</code> in the <code>System.Numerics</code> namespace (see <a data-type="xref" href="ch06.html#bitoperations">“BitOperations”</a>).</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="8- and 16-Bit Integral Types" data-type="sect2"><div class="sect2" id="eight__and_onesix_bit_integral_types">
<h2>8- and 16-Bit Integral Types</h2>
<p><a contenteditable="false" data-primary="8- and 16-bit integral types" data-primary-sortas="eight" data-type="indexterm" id="id1733"/><a contenteditable="false" data-primary="byte type" data-type="indexterm" id="id1734"/><a contenteditable="false" data-primary="integral types" data-secondary="8- and 16-bit integral types" data-type="indexterm" id="id1735"/><a contenteditable="false" data-primary="numeric types" data-secondary="8- and 16-bit integral types" data-type="indexterm" id="id1736"/><a contenteditable="false" data-primary="sbyte (numeric type)" data-type="indexterm" id="id1737"/>The 8- and 16-bit integral types are <code>byte</code>, <code>sbyte</code>, <code>short</code>, and <code>ushort</code>. These types lack their own arithmetic operators, so C# implicitly converts them to larger types as required. This can cause a compile-time error when trying to assign the result back to a small integral type:</p>
<pre data-type="programlisting">short x = 1, y = 1;
short z = x + y;          // Compile-time error</pre>
<p>In this case, <code>x</code> and <code>y</code> are implicitly converted to <code>int</code> so that the addition can be performed. This means that the result is also an <code>int</code>, which cannot be implicitly cast back to a <code>short</code> (because it could cause loss of data). To make this compile, you must add an explicit cast:</p>
<pre data-type="programlisting">short z = (short) (x + y);   // OK</pre>
</div></section>
<section data-pdf-bookmark="Special Float and Double Values" data-type="sect2"><div class="sect2" id="special_float_and_double_values">
<h2>Special Float and Double Values</h2>
<p><a contenteditable="false" data-primary="floating-point types" data-secondary="special float and double values" data-type="indexterm" id="id1738"/><a contenteditable="false" data-primary="numeric types" data-secondary="special float and double values" data-type="indexterm" id="id1739"/>Unlike integral types, floating-point types have values that certain operations treat specially. <a contenteditable="false" data-primary="- (minus sign)" data-secondary="negative infinity (−∞)" data-type="indexterm" id="id1740"/><a contenteditable="false" data-primary="- (minus sign)" data-secondary="negative zero (−0)" data-type="indexterm" id="id1741"/><a contenteditable="false" data-primary="+∞(positive infinity)" data-type="indexterm" id="id1742"/><a contenteditable="false" data-primary="minus sign (-)" data-secondary="negative infinity (-∞)" data-type="indexterm" id="id1743"/><a contenteditable="false" data-primary="minus sign (-)" data-secondary="negative zero (-0)" data-type="indexterm" id="id1744"/><a contenteditable="false" data-primary="positive infinity (+∞)" data-type="indexterm" id="id1745"/>These special values are NaN (Not a Number), +∞, −∞, and −0. The <code>float</code> and <code>double</code> classes have constants for <code>NaN</code>, +∞, and −∞, as well as other values (<code>MaxValue</code>, <code>MinValue</code>, and <code>Epsilon</code>); for example:</p>
<pre data-type="programlisting">Console.WriteLine (double.NegativeInfinity);   // -Infinity</pre>
<p>The constants that represent special values for <code>double</code> and <code>float</code> are as follows:</p>
<table class="border">
<thead>
<tr>
<th>Special value</th>
<th>Double constant</th>
<th>Float constant</th>
</tr>
</thead>
<tbody>
<tr>
<td>NaN</td>
<td><code>double.NaN</code></td>
<td><code>float.NaN</code></td>
</tr>
<tr>
<td>+∞</td>
<td><code>double.PositiveInfinity</code></td>
<td><code>float.PositiveInfinity</code></td>
</tr>
<tr>
<td>−∞</td>
<td><code>double.NegativeInfinity</code></td>
<td><code>float.NegativeInfinity</code></td>
</tr>
<tr>
<td>−0</td>
<td><code>−0.0</code></td>
<td><code>−0.0f</code></td>
</tr>
</tbody>
</table>
<p>Dividing a nonzero number by zero results in an infinite value:</p>
<pre data-type="programlisting">Console.WriteLine ( 1.0 /  0.0);                  //  Infinity
Console.WriteLine (−1.0 /  0.0);                  // -Infinity
Console.WriteLine ( 1.0 / −0.0);                  // -Infinity
Console.WriteLine (−1.0 / −0.0);                  //  Infinity</pre>
<p>Dividing zero by zero, or subtracting infinity from infinity, results in a NaN:</p>
<pre data-type="programlisting">Console.WriteLine ( 0.0 /  0.0);                  //  NaN
Console.WriteLine ((1.0 /  0.0) − (1.0 / 0.0));   //  NaN</pre>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="NaN value and" data-type="indexterm" id="id1746"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="NaN value and" data-type="indexterm" id="id1747"/>When using <code>==</code>, a NaN value is never equal to another value, even another NaN value:</p>
<pre data-type="programlisting">Console.WriteLine (0.0 / 0.0 == double.NaN);    // False</pre>
<p>To test whether a value is NaN, you must use the <code>float.IsNaN</code> or <code>double.IsNaN</code> method:</p>
<pre data-type="programlisting">Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True</pre>
<p>When using <code>object.Equals</code>, however, two NaN values are equal:</p>
<pre data-type="programlisting">Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));   // True</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>NaNs are sometimes useful in representing special values. In Windows Presentation Foundation (WPF), <code>double.NaN</code> represents a measurement whose value is “Automatic.” Another way to represent such a value is with a nullable type (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>); another is with a custom struct that wraps a numeric type and adds an additional field (<a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>).</p>
</div>
<p><code>float</code> and <code>double</code> follow the specification of the IEEE 754 format types, supported natively by almost all processors. You can find detailed information on the behavior of these types at <a href="http://www.ieee.org"><em class="hyperlink">http://www.ieee.org</em></a>.</p>
</div></section>
<section data-pdf-bookmark="double Versus decimal" data-type="sect2"><div class="sect2" id="double_versus_decimal">
<h2>double Versus decimal</h2>
<p><a contenteditable="false" data-primary="double type" data-type="indexterm" id="id1748"/><a contenteditable="false" data-primary="numeric types" data-secondary="double versus decimal" data-type="indexterm" id="id1749"/><code>double</code> is useful for scientific computations (such as computing spatial coordinates). <code>decimal</code> is useful for financial computations and values that are manufactured rather than the result of real-world measurements. Here’s a summary of the <span class="keep-together">differences</span>.</p>
<table class="border">
<thead>
<tr>
<th>Category</th>
<th>double</th>
<th>decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internal representation</td>
<td>Base 2</td>
<td>Base 10</td>
</tr>
<tr>
<td>Decimal precision</td>
<td>15–16 significant figures</td>
<td>28–29 significant figures</td>
</tr>
<tr>
<td>Range</td>
<td>±(~10<sup>−324</sup> to ~10<sup>308</sup>)</td>
<td>±(~10<sup>−28</sup> to ~10<sup>28</sup>)</td>
</tr>
<tr>
<td>Special values</td>
<td>+0, −0, +∞, −∞, and NaN</td>
<td>None</td>
</tr>
<tr>
<td>Speed</td>
<td>Native to processor</td>
<td>Non-native to processor (about 10 times slower than <code>double</code>)</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Real Number Rounding Errors" data-type="sect2"><div class="sect2" id="real_number_rounding_errors">
<h2>Real Number Rounding Errors</h2>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="real number rounding errors" data-type="indexterm" id="id1750"/><a contenteditable="false" data-primary="rounding errors" data-type="indexterm" id="id1751"/><code>float</code> and <code>double</code> internally represent numbers in base 2. For this reason, only numbers expressible in base 2 are represented precisely. Practically, this means most literals with a fractional component (which are in base 10) will not be represented precisely; for example:</p>
<pre data-type="programlisting">float x = 0.1f;  // Not quite 0.1
Console.WriteLine (x + x + x + x + x + x + x + x + x + x);    // 1.0000001</pre>
<p>This is why <code>float</code> and <code>double</code> are bad for financial calculations. In contrast, <code>decimal</code> works in base 10 and so can precisely represent numbers expressible in base 10 (as well as its factors, base 2 and base 5). Because real literals are in base 10, <code>decimal</code> can precisely represent numbers such as 0.1. However, neither <code>double</code> nor <code>decimal</code> can precisely represent a fractional number whose base 10 representation is recurring:</p>
<pre data-type="programlisting">decimal m = 1M / 6M;               // 0.1666666666666666666666666667M
double  d = 1.0 / 6.0;             // 0.16666666666666666</pre>
<p>This leads to accumulated rounding errors:</p>
<pre data-type="programlisting">decimal notQuiteWholeM = m+m+m+m+m+m;  // 1.0000000000000000000000000002M
double  notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989</pre>
<p>which break equality and comparison operations:<a contenteditable="false" data-primary="" data-startref="ch02.html1012" data-type="indexterm" id="id1752"/><a contenteditable="false" data-primary="" data-startref="ch02.html1011" data-type="indexterm" id="id1753"/></p>
<pre data-type="programlisting">Console.WriteLine (notQuiteWholeM == 1M);   // False
Console.WriteLine (notQuiteWholeD &lt; 1.0);   // True</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Boolean Type and Operators" data-type="sect1"><div class="sect1" id="boolean_type_and_operators">
<h1>Boolean Type and Operators</h1>
<p><a contenteditable="false" data-primary="bool (Boolean) type and operators" data-type="indexterm" id="ch02.html1013"/><a contenteditable="false" data-primary="type system, C#" data-secondary="Boolean type and operators" data-type="indexterm" id="ch02.html1014"/>C#’s <code>bool</code> type (aliasing the <code>System.Boolean</code> type) is a logical value that can be assigned the literal <code>true</code> or <code>false</code>.</p>
<p>Although a Boolean value requires only one bit of storage, the runtime will use one byte of memory because this is the minimum chunk that the runtime and processor can efficiently work with. To avoid space inefficiency in the case of arrays, .NET provides a <code>BitArray</code> class in the <code>System.Collections</code> namespace that is designed to use just one bit per Boolean value.</p>
<section data-pdf-bookmark="bool Conversions" data-type="sect2"><div class="sect2" id="bool_conversions">
<h2>bool Conversions</h2>
<p>No casting conversions can be made from the <code>bool</code> type to numeric types, or vice versa.</p>
</div></section>
<section data-pdf-bookmark="Equality and Comparison Operators" data-type="sect2"><div class="sect2" id="equality_and_comparison_operators">
<h2>Equality and Comparison Operators</h2>
<p><a contenteditable="false" data-primary="! (logical negation operator)" data-type="indexterm" id="id1754"/><a contenteditable="false" data-primary="!= (inequality operator)" data-type="indexterm" id="id1755"/><a contenteditable="false" data-primary="== (equality operator)" data-secondary="Boolean values and" data-type="indexterm" id="id1756"/><a contenteditable="false" data-primary="bool (Boolean) type and operators" data-secondary="equality and comparison operators" data-type="indexterm" id="id1757"/><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="id1758"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="Boolean values and" data-type="indexterm" id="id1759"/><a contenteditable="false" data-primary="inequality operator (!=)" data-type="indexterm" id="id1760"/><a contenteditable="false" data-primary="logical negation operator (!)" data-type="indexterm" id="id1761"/><code>==</code> and <code>!=</code> test for equality and inequality of any type but always return a <code>bool</code> value.<sup><a data-type="noteref" href="ch02.html#ch01fn3" id="ch01fn3-marker">3</a></sup> Value types typically have a very simple notion of equality:</p>
<pre data-type="programlisting">int x = 1;
int y = 2;
int z = 1;
Console.WriteLine (x == y);         // False
Console.WriteLine (x == z);         // True</pre>
<p>For reference types, equality, by default, is based on <em>reference</em>, as opposed to the actual <em>value</em> of the underlying object (more on this in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>):</p>
<pre data-type="programlisting">Dude d1 = new Dude ("John");
Dude d2 = new Dude ("John");
Console.WriteLine (d1 == d2);       // False
Dude d3 = d1;
Console.WriteLine (d1 == d3);       // True

public class Dude
{
  public string Name;
  public Dude (string n) { Name = n; }
}</pre>
<p>The equality and comparison operators, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>, work for all numeric types, but you should use them with caution with real numbers (as we saw in <a data-type="xref" href="#real_number_rounding_errors">“Real Number Rounding Errors”</a>). The comparison operators also work on <code>enum</code> type members by comparing their underlying integral-type values. We describe this in <a data-type="xref" href="ch03.html#enums-id00013">“Enums”</a>.</p>
<p>We explain the equality and comparison operators in greater detail in <a data-type="xref" href="ch04.html#operator_overloading">“Operator Overloading”</a>, and in <a data-type="xref" href="ch06.html#equality_comparison-id00067">“Equality Comparison”</a> and <a data-type="xref" href="ch06.html#order_comparison">“Order Comparison”</a>.</p>
</div></section>
<section data-pdf-bookmark="Conditional Operators" data-type="sect2"><div class="sect2" id="conditional_operators">
<h2>Conditional Operators</h2>
<p><a contenteditable="false" data-primary="&amp;&amp; (conditional and operator)" data-type="indexterm" id="id1762"/><a contenteditable="false" data-primary="|| (conditional or operator)" data-type="indexterm" id="id1763"/><a contenteditable="false" data-primary="bool (Boolean) type and operators" data-secondary="conditional operators" data-type="indexterm" id="id1764"/><a contenteditable="false" data-primary="conditional and operator (&amp;&amp;)" data-type="indexterm" id="id1765"/><a contenteditable="false" data-primary="conditional or operator (||)" data-type="indexterm" id="id1766"/>The <code>&amp;&amp;</code> and <code>||</code> operators test for <em>and</em> and <em>or</em> conditions. They are frequently used in conjunction with the <code>!</code> operator, which expresses <em>not</em>. In the following example, the <code>UseUmbrella</code> method returns <code>true</code> if it’s rainy or sunny (to protect us from the rain or the sun), as long as it’s not also windy (umbrellas are useless in the wind):</p>
<pre data-type="programlisting">static bool UseUmbrella (bool rainy, bool sunny, bool windy)
{
  return !windy &amp;&amp; (rainy || sunny);
}</pre>
<p>The <code>&amp;&amp;</code> and <code>||</code> operators <em>short-circuit</em> evaluation when possible. In the preceding example, if it is windy, the expression <code>(rainy || sunny)</code> is not even evaluated. Short-circuiting is essential in allowing expressions such as the following to run without throwing a <code>NullReferenceException</code>:</p>
<pre data-type="programlisting">if (sb != null &amp;&amp; sb.Length &gt; 0) ...</pre>
<p>The <code>&amp;</code> and <code>|</code> operators also test for <em>and</em> and <em>or</em> conditions:</p>
<pre data-type="programlisting">return !windy &amp; (rainy | sunny);</pre>
<p class="pagebreak-before">The difference is that they <em>do not short-circuit</em>. For this reason, they are rarely used in place of conditional operators.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Unlike in C and C++, the <code>&amp;</code> and <code>|</code> operators perform (non-short-circuiting) Boolean comparisons when applied to <code>bool</code> expressions. The <code>&amp;</code> and <code>|</code> operators perform <em>bitwise</em> operations only when applied to numbers.</p>
</div>
<section data-pdf-bookmark="Conditional operator (ternary operator)" data-type="sect3"><div class="sect3" id="conditional_operator_left_parenthesiste">
<h3>Conditional operator (ternary operator)</h3>
<p><a contenteditable="false" data-primary="conditional (ternary) operator" data-type="indexterm" id="id1767"/><a contenteditable="false" data-primary="ternary (conditional) operator" data-type="indexterm" id="id1768"/>The <em>conditional operator</em> (more commonly called the <em>ternary operator</em> because it’s the only operator that takes three operands) has the form <code>q ? a : b</code>; thus, if condition <code>q</code> is true, <code>a</code> is evaluated; otherwise <code>b</code> is evaluated:</p>
<pre data-type="programlisting">static int Max (int a, int b)
{
  return (a &gt; b) ? a : b;
}</pre>
<p>The conditional operator is particularly useful in Language-Integrated Query (LINQ) expressions (<a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>).<a contenteditable="false" data-primary="" data-startref="ch02.html1014" data-type="indexterm" id="id1769"/><a contenteditable="false" data-primary="" data-startref="ch02.html1013" data-type="indexterm" id="id1770"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Strings and Characters" data-type="sect1"><div class="sect1" id="strings_and_characters">
<h1>Strings and Characters</h1>
<p><a contenteditable="false" data-primary="type system, C#" data-secondary="strings and characters" data-type="indexterm" id="ch02.html1015"/>C#’s <a contenteditable="false" data-primary="string type" data-type="indexterm" id="ch02.html1016"/><code>char</code> type (aliasing the <code>System.Char</code> type) represents a Unicode character and occupies 2 bytes (UTF-16). <a contenteditable="false" data-primary="' (quote, single)" data-secondary="enclosing char literals" data-type="indexterm" id="id1771"/><a contenteditable="false" data-primary="quote, single (')" data-secondary="enclosing char literals" data-type="indexterm" id="id1772"/>A <code>char</code> literal is specified within single quotes:</p>
<pre data-type="programlisting">char c = 'A';       // Simple character</pre>
<p><a contenteditable="false" data-primary="\ (backslash)" data-secondary="preceding escape sequences" data-type="indexterm" id="id1773"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="preceding escape sequences" data-type="indexterm" id="id1774"/><a contenteditable="false" data-primary="escape sequences" data-type="indexterm" id="id1775"/><em>Escape sequences</em> express characters that cannot be expressed or interpreted literally. An escape sequence is a backslash followed by a character with a special meaning; for example:</p>
<pre data-type="programlisting">char newLine = '\n';
char backSlash = '\\';</pre>
<p><a data-type="xref" href="#escape_sequence_characters">Table 2-2</a> shows the escape sequence characters.</p>
<table class="border" id="escape_sequence_characters">
<caption><span class="label">Table 2-2. </span>Escape sequence characters</caption>
<thead>
<tr>
<th>Char</th>
<th>Meaning</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\'</code></td>
<td>Single quote</td>
<td><code>0x0027</code></td>
</tr>
<tr>
<td><code>\"</code></td>
<td>Double quote</td>
<td><code>0x0022</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
<td><code>0x005C</code></td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Null</td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td><code>\a</code></td>
<td>Alert</td>
<td><code>0x0007</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
<td><code>0x0008</code></td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Form feed</td>
<td><code>0x000C</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>New line</td>
<td><code>0x000A</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
<td><code>0x000D</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Horizontal tab</td>
<td><code>0x0009</code></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Vertical tab</td>
<td><code>0x000B</code></td>
</tr>
</tbody>
</table>
<p>The <code>\u</code> (or <code>\x</code>) escape sequence lets you specify any Unicode character via its four-digit hexadecimal code:</p>
<pre data-type="programlisting">char copyrightSymbol = '\u00A9';
char omegaSymbol     = '\u03A9';
char newLine         = '\u000A';</pre>
<section data-pdf-bookmark="Char Conversions" data-type="sect2"><div class="sect2" id="char_conversions">
<h2>Char Conversions</h2>
<p><a contenteditable="false" data-primary="char type" data-type="indexterm" id="id1776"/><a contenteditable="false" data-primary="numeric types" data-secondary="char type conversions" data-type="indexterm" id="id1777"/>An implicit conversion from a <code>char</code> to a numeric type works for the numeric types that can accommodate an unsigned <code>short</code>. For other numeric types, an explicit conversion is required.</p>
</div></section>
<section data-pdf-bookmark="String Type" data-type="sect2"><div class="sect2" id="string_type">
<h2>String Type</h2>
<p>C#’s string type (aliasing the <code>System.String</code> type, covered in depth in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>) represents an immutable (unmodifiable) sequence of Unicode characters. A string literal is specified within double quotes:</p>
<pre data-type="programlisting">string a = "Heat";</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>string</code> is a reference type rather than a value type. Its equality operators, however, follow value-type semantics:</p>
<pre data-type="programlisting">string a = "test";
string b = "test";
Console.Write (a == b);  // True</pre>
</div>
<p>The escape sequences that are valid for <code>char</code> literals also work inside strings:</p>
<pre data-type="programlisting">string a = "Here's a tab:<strong>\t</strong>";</pre>
<p>The cost of this is that whenever you need a literal backslash, you must write it twice:</p>
<pre data-type="programlisting">string a1 = "\\\\server\\fileshare\\helloworld.cs";</pre>
<p><a contenteditable="false" data-primary="verbatim string literals" data-type="indexterm" id="id1778"/>To avoid this problem, C# allows <em>verbatim</em> string literals. A verbatim string literal is prefixed with <code>@</code> and does not support escape sequences. The following verbatim string is identical to the preceding one:</p>
<pre data-type="programlisting">string a2 = <strong>@</strong>"\\server\fileshare\helloworld.cs";</pre>
<p>A verbatim string literal can also span multiple lines:</p>
<pre data-type="programlisting">string escaped  = "First Line\r\nSecond Line";
string verbatim = @"First Line
Second Line";

// True if your text editor uses CR-LF line separators:
Console.WriteLine (escaped == verbatim);</pre>
<p>You can include the double-quote character in a verbatim literal by writing it twice:</p>
<pre data-type="programlisting">string xml = @"&lt;customer id=""123""&gt;&lt;/customer&gt;";</pre>
<section data-pdf-bookmark="Raw string literals (C# 11)" data-type="sect3"><div class="sect3" id="raw_string_literals_left_parenthesischa">
<h3>Raw string literals (C# 11)</h3>
<p><a contenteditable="false" data-primary="C# 11" data-secondary="raw string literals" data-type="indexterm" id="ch02.html0"/><a contenteditable="false" data-primary="raw string literals (C# 11)" data-type="indexterm" id="ch02.html1"/>Wrapping a string in three or more quote characters (<code>"""</code>) creates a <em>raw string literal</em>. Raw string literals can contain almost any character sequence, without escaping or doubling up:</p>
<pre data-type="programlisting">string raw = <strong>"""</strong>&lt;file path="c:\temp\test.txt"&gt;&lt;/file&gt;<strong>"""</strong>;</pre>
<p>Raw string literals make it easy to represent JSON, XML, and HTML literals, as well as regular expressions and source code. Should you need to include three (or more) quote characters in the string itself, you can do so by wrapping the string in four (or more) quote characters:</p>
<pre data-type="programlisting">string raw = <strong>""""</strong>The """ sequence denotes raw string literals.<strong>""""</strong>;</pre>
<p>Multiline raw string literals are subject to special rules. We can represent the string <code>"Line 1\r\nLine 2"</code> as follows:</p>
<pre data-type="programlisting">string multiLineRaw = <strong>"""</strong>
  Line 1
  Line 2
  <strong>"""</strong>;</pre>
<p>Notice that the opening and closing quotes must be on separate lines to the string content. Additionally:</p>
<ul>
<li><p>Whitespace following the <em>opening</em> <code>"""</code> (on the same line) is ignored.</p></li>
<li><p>Whitespace preceding the <em>closing</em> <code>"""</code> (on the same line) is treated as <em>common indentation</em> and is removed from every line in the string. This lets you include indentation for source-code readability without that indentation becoming part of the string.</p></li>
</ul>
<p>Here’s another example to illustrate the multiline raw string literal rules:</p>
<pre data-type="programlisting">if (true)
  Console.WriteLine ("""
    {
      "Name" : "Joe"
    }
    """);</pre>
<p>The output is as follows:</p>
<pre data-type="programlisting">{
  "Name" : "Joe"
}</pre>
<p>The compiler will generate an error if each line in a multiline raw string literal is not prefixed with the common indentation specified by the closing quotes.</p>
<p>Raw string literals can be interpolated, subject to special rules described in <a data-type="xref" href="#string_interpolation">“String interpolation”</a>.<a contenteditable="false" data-primary="" data-startref="ch02.html1" data-type="indexterm" id="id1779"/><a contenteditable="false" data-primary="" data-startref="ch02.html0" data-type="indexterm" id="id1780"/></p>
</div></section>
<section data-pdf-bookmark="String concatenation" data-type="sect3"><div class="sect3" id="string_concatenation">
<h3>String concatenation</h3>
<p><a contenteditable="false" data-primary="+ (plus sign)" data-secondary="string concatenation operator" data-type="indexterm" id="id1781"/><a contenteditable="false" data-primary="concatenation" data-type="indexterm" id="id1782"/><a contenteditable="false" data-primary="plus sign (+)" data-secondary="string concatenation operator" data-type="indexterm" id="id1783"/>The <code>+</code> operator concatenates two strings:</p>
<pre data-type="programlisting">string s = "a" + "b";</pre>
<p>One of the operands might be a nonstring value, in which case <code>ToString</code> is called on that value:</p>
<pre data-type="programlisting">string s = "a" + 5;  // a5</pre>
<p>Using the <code>+</code> operator repeatedly to build up a string is inefficient: a better solution is to use the <code>System.Text.StringBuilder</code> type (described in <a data-type="xref" href="ch06.html#dotnet_fundamentals">Chapter 6</a>).</p>
</div></section>
<section data-pdf-bookmark="String interpolation" data-type="sect3"><div class="sect3" id="string_interpolation">
<h3>String interpolation</h3>
<p><a contenteditable="false" data-primary="$ (dollar sign)" data-secondary="preceding interpolated strings" data-type="indexterm" id="id1784"/><a contenteditable="false" data-primary="dollar sign ($)" data-secondary="preceding interpolated strings" data-type="indexterm" id="id1785"/><a contenteditable="false" data-primary="interpolated string" data-type="indexterm" id="id1786"/><a contenteditable="false" data-primary="interpolation" data-type="indexterm" id="id1787"/>A string preceded with the <code>$</code> character is called an <em>interpolated string</em>. Interpolated strings can include expressions enclosed in braces:</p>
<pre data-type="programlisting">int x = 4;
Console.Write (<strong>$</strong>"A square has <strong>{x}</strong> sides");  // Prints: A square has 4 sides</pre>
<p>Any valid C# expression of any type can appear within the braces, and C# will convert the expression to a string by calling its <code>ToString</code> method or equivalent. You can change the formatting by appending the expression with a colon and a <em>format string</em> (format strings are described in <a data-type="xref" href="ch06.html#stringdotformat_and_composite_format_st">“String.Format and composite format strings”</a>):</p>
<pre data-type="programlisting">string s = $"255 in hex is {byte.MaxValue<strong>:X2</strong>}";  // X2 = 2-digit hexadecimal
// Evaluates to "255 in hex is FF"</pre>
<p>Should you need to use a colon for another purpose (such as a ternary conditional operator, which we’ll cover later), you must wrap the entire expression in parentheses:</p>
<pre data-type="programlisting">bool b = true;
Console.WriteLine ($"The answer in binary is {<strong>(</strong>b ? 1 : 0<strong>)</strong>}");</pre>
<p>From C# 10, interpolated strings can be constants, as long as the interpolated values are constants:</p>
<pre data-type="programlisting">const string greeting = "Hello";
const string message = $"{greeting}, world";</pre>
<p>From C# 11, interpolated strings are permitted to span multiple lines (whether standard or verbatim):</p>
<pre data-type="programlisting">string s = <strong>$</strong>"this interpolation spans <strong>{</strong>1 +
1<strong>}</strong> lines";</pre>
<p>Raw string literals (from C# 11) can also be interpolated:</p>
<pre data-type="programlisting">string s = <strong>$</strong>"""The date and time is <strong>{</strong>DateTime.Now<strong>}</strong>""";</pre>
<p>To include a brace literal in an interpolated string:</p>
<ul>
<li><p>With standard and verbatim string literals, repeat the desired brace character.</p></li>
<li><p>With raw string literals, change the interpolation sequence by repeating the <code>$</code> prefix.</p></li>
</ul>
<p>Using two (or more) <code>$</code> characters in a raw string literal prefix changes the interpolation sequence from one brace to two (or more) braces:</p>
<pre data-type="programlisting">Console.WriteLine ($$"""{ "TimeStamp": "<strong>{{</strong>DateTime.Now<strong>}}</strong>" }""");
// Output: { "TimeStamp": "01/01/2024 12:13:25 PM" }</pre>
<p>This preserves the ability to copy-and-paste text into a raw string literal without needing to modify the string.<a contenteditable="false" data-primary="" data-startref="ch02.html1016" data-type="indexterm" id="id1788"/><a contenteditable="false" data-primary="" data-startref="ch02.html1015" data-type="indexterm" id="id1789"/></p>
</div></section>
<section data-pdf-bookmark="String comparisons" data-type="sect3"><div class="sect3" id="string_comparisons">
<h3>String comparisons</h3>
<p><a contenteditable="false" data-primary="== (equality operator)" data-secondary="string equality comparison" data-type="indexterm" id="id1790"/><a contenteditable="false" data-primary="CompareTo method" data-type="indexterm" id="id1791"/><a contenteditable="false" data-primary="comparisons" data-secondary="string equality comparisons" data-type="indexterm" id="id1792"/><a contenteditable="false" data-primary="equality operator (==)" data-secondary="string equality comparison" data-type="indexterm" id="id1793"/><a contenteditable="false" data-primary="string type" data-secondary="comparing" data-type="indexterm" id="id1794"/>To perform <em>equality</em> comparisons with strings, you can use the <code>==</code> operator (or one of <code>string</code>’s <code>Equals</code> methods). For <em>order</em> comparison, you must use the string’s <code>CompareTo</code> method; the <code>&lt;</code> and <code>&gt;</code> operators are unsupported. We describe equality and order comparison in detail in <a data-type="xref" href="ch06.html#comparing_strings">“Comparing Strings”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="UTF-8 Strings" data-type="sect2"><div class="sect2" id="utf_eight_strings-id000101">
<h2>UTF-8 Strings</h2>
<p><a contenteditable="false" data-primary="C# 11" data-secondary="UTF-8 string literals" data-type="indexterm" id="id1795"/><a contenteditable="false" data-primary="string type" data-secondary="UTF-8 string literals" data-type="indexterm" id="id1796"/><a contenteditable="false" data-primary="UTF-8 string literals" data-type="indexterm" id="id1797"/>From C# 11, you can use the <code>u8</code> suffix to create string literals encoded in UTF-8 rather than UTF-16. This feature is intended for advanced scenarios such as the low-level handling of JSON text in performance hotspots:</p>
<pre data-type="programlisting">ReadOnlySpan&lt;byte&gt; utf8 = "ab→cd"<strong>u8</strong>;  // Arrow symbol consumes 3 bytes
Console.WriteLine (utf8.Length);      // 7</pre>
<p>The underlying type is <code>ReadOnlySpan&lt;byte&gt;</code>, which we cover in <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>. You can convert this to an array by calling the <code>ToArray()</code> method.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Arrays" data-type="sect1"><div class="sect1" id="arrays-id00001">
<h1>Arrays</h1>
<p><a contenteditable="false" data-primary="arrays" data-type="indexterm" id="ch02.html1017"/>An array represents a fixed number of variables (called <em>elements</em>) of a particular type. The elements in an array are always stored in a contiguous block of memory, providing highly efficient access.</p>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="array declaration" data-type="indexterm" id="id1798"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="array declaration" data-type="indexterm" id="id1799"/>An array is denoted with square brackets after the element type:</p>
<pre data-type="programlisting">char[] vowels = new char[5];    // Declare an array of 5 characters</pre>
<p>Square brackets also <em>index</em> the array, accessing a particular element by position:</p>
<pre data-type="programlisting">vowels[0] = 'a';
vowels[1] = 'e';
vowels[2] = 'i';
vowels[3] = 'o';
vowels[4] = 'u';
Console.WriteLine (vowels[1]);      // e</pre>
<p>This prints “e” because array indexes start at 0. You can use a <code>for</code> loop statement to iterate through each element in the array. The <code>for</code> loop in this example cycles the integer <code>i</code> from <code>0</code> to <code>4</code>:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; vowels.Length; i++)
  Console.Write (vowels[i]);            // aeiou</pre>
<p>The <code>Length</code> property of an array returns the number of elements in the array. After an array has been created, you cannot change its length. The <code>System.Collection</code> namespace and subnamespaces provide higher-level data structures, such as dynamically sized arrays and dictionaries.</p>
<p><a contenteditable="false" data-primary="array initialization expressions" data-type="indexterm" id="id1800"/><a contenteditable="false" data-primary="arrays" data-secondary="array initialization expressions" data-type="indexterm" id="id1801"/>An <em>array initialization expression</em> lets you declare and populate an array in a single step:</p>
<pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};</pre>
<p>Or simply:</p>
<pre data-type="programlisting">char[] vowels = {'a','e','i','o','u'};</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From C# 12, you can use square brackets instead of curly braces:</p>
<pre data-type="programlisting">char[] vowels = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;</pre>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="in collection expressions" data-type="indexterm" id="id1802"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="in collection expressions" data-type="indexterm" id="id1803"/><a contenteditable="false" data-primary="C# 12" data-secondary="collection expressions" data-type="indexterm" id="id1804"/><a contenteditable="false" data-primary="collection expressions" data-type="indexterm" id="id1805"/>This is called a <em>collection expression</em> and has the advantage of also working when calling methods:</p>
<pre data-type="programlisting">Foo (['a','e','i','o','u']);

void Foo (char[] letters) { ... }</pre>
<p>Collection expressions also work with other collection types such as lists and sets—see <a data-type="xref" href="ch04.html#collection_initializers_and_collection">“Collection Initializers and Collection Expressions”</a>.</p>
</div>
<p>All arrays inherit from the <code>System.Array</code> class, providing common services for all arrays. These members include methods to get and set elements regardless of the array type. We describe them in <a data-type="xref" href="ch07.html#the_array_class">“The Array Class”</a>.</p>
<section data-pdf-bookmark="Default Element Initialization" data-type="sect2"><div class="sect2" id="default_element_initialization">
<h2>Default Element Initialization</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="default element initialization" data-type="indexterm" id="id1806"/>Creating an array always preinitializes the elements with default values. The default value for a type is the result of a bitwise zeroing of memory. For example, consider creating an array of integers. Because <code>int</code> is a value type, this allocates 1,000 integers in one contiguous block of memory. The default value for each element will be 0:</p>
<pre data-type="programlisting">int[] a = new int[1000];
Console.Write (a[123]);            // 0</pre>
<section data-pdf-bookmark="Value types versus reference types" data-type="sect3"><div class="sect3" id="value_types_versus_reference-id000102">
<h3>Value types versus reference types</h3>
<p><a contenteditable="false" data-primary="arrays" data-secondary="value types versus reference types" data-type="indexterm" id="id1807"/>Whether an array element type is a value type or a reference type has important performance implications. When the element type is a value type, each element value is allocated as part of the array, as shown here:</p>
<pre data-type="programlisting">Point[] a = new Point[1000];
int x = a[500].X;                  // 0

public <strong>struct</strong> Point { public int X, Y; }</pre>
<p>Had <code>Point</code> been a class, creating the array would have merely allocated 1,000 null references:</p>
<pre data-type="programlisting">Point[] a = new Point[1000];
int x = a[500].X;                  // Runtime error, NullReferenceException

public <strong>class</strong> Point { public int X, Y; }</pre>
<p>To avoid this error, we must explicitly instantiate 1,000 <code>Point</code>s after instantiating the array:</p>
<pre data-type="programlisting">Point[] a = new Point[1000];
for (int i = 0; i &lt; a.Length; i++) // Iterate i from 0 to 999
   a[i] = new Point();             // Set array element i with new point</pre>
<p>An array <em>itself</em> is always a reference type object, regardless of the element type. For instance, the following is legal:</p>
<pre data-type="programlisting">int[] a = null;</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Indices and Ranges" data-type="sect2"><div class="sect2" id="indices_and_ranges-id00073">
<h2>Indices and Ranges</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="indices and ranges" data-type="indexterm" id="id1808"/><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="array ranges and indices" data-type="indexterm" id="id1809"/><em>Indices and ranges</em> (introduced in C# 8) simplify working with elements or portions of an array.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Indices and ranges also work with the CLR types <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> (see <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a>).</p>
<p>You can also make your own types work with indices and ranges, by defining an indexer of type <code>Index</code> or <code>Range</code> (see <a data-type="xref" href="ch03.html#indexers">“Indexers”</a>).</p>
</div>
<section data-pdf-bookmark="Indices" data-type="sect3"><div class="sect3" id="indices">
<h3>Indices</h3>
<p><a contenteditable="false" data-primary="indices" data-secondary="arrays and" data-type="indexterm" id="id1810"/>Indices let you refer to elements relative to the <em>end</em> of an array, with the <code>^</code> operator. <code>^1</code> refers to the last element, <code>^2</code> refers to the second-to-last element, and so on:</p>
<pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [<strong>^1</strong>];   // 'u'
char secondToLast = vowels [<strong>^2</strong>];   // 'o'</pre>
<p>(<code>^0</code> equals the length of the array, so <code>vowels[^0]</code> generates an error.)</p>
<p class="pagebreak-before">C# implements indices with the help of the <code>Index</code> type, so you can also do the following:</p>
<pre data-type="programlisting"><strong>Index</strong> first = <strong>0</strong>;
<strong>Index</strong> last = <strong>^1</strong>;
char firstElement = vowels [<strong>first</strong>];   // 'a'
char lastElement = vowels [<strong>last</strong>];     // 'u'</pre>
</div></section>
<section data-pdf-bookmark="Ranges" data-type="sect3"><div class="sect3" id="ranges">
<h3>Ranges</h3>
<p><a contenteditable="false" data-primary="ranges" data-secondary="arrays and" data-type="indexterm" id="id1811"/>Ranges let you “slice” an array by using the <code>..</code> operator:</p>
<pre data-type="programlisting">char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3];   // 'i'</pre>
<p>The second number in the range is <em>exclusive</em>, so <code>..2</code> returns the elements <em>before</em> <code>vowels[2]</code>.</p>
<p>You can also use the <code>^</code> symbol in ranges. The following returns the last two characters:</p>
<pre data-type="programlisting">char[] lastTwo = vowels [^2..];     // 'o', 'u'</pre>
<p>C# implements ranges with the help of the <code>Range</code> type, so you can also do the following:</p>
<pre data-type="programlisting">Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Multidimensional Arrays" data-type="sect2"><div class="sect2" id="multidimensional_arrays">
<h2>Multidimensional Arrays</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="multidimensional" data-type="indexterm" id="id1812"/><a contenteditable="false" data-primary="multidimensional arrays" data-type="indexterm" id="id1813"/>Multidimensional arrays come in two varieties: <em>rectangular</em> and <em>jagged</em>. Rectangular arrays represent an <em>n</em>-dimensional block of memory, and jagged arrays are arrays of arrays.</p>
<section data-pdf-bookmark="Rectangular arrays" data-type="sect3"><div class="sect3" id="rectangular_arrays">
<h3>Rectangular arrays</h3>
<p><a contenteditable="false" data-primary=", (comma)" data-type="indexterm" id="id1814"/><a contenteditable="false" data-primary="arrays" data-secondary="rectangular" data-type="indexterm" id="id1815"/><a contenteditable="false" data-primary="comma (,)" data-type="indexterm" id="id1816"/><a contenteditable="false" data-primary="rectangular arrays" data-type="indexterm" id="id1817"/>Rectangular arrays are declared using commas to separate each dimension. The following declares a rectangular two-dimensional array for which the dimensions are 3 by 3:</p>
<pre data-type="programlisting">int[,] matrix = new int[3,3];</pre>
<p>The <code>GetLength</code> method of an array returns the length for a given dimension (starting at 0):</p>
<pre data-type="programlisting">for (int i = 0; i &lt; matrix.GetLength(0); i++)
  for (int j = 0; j &lt; matrix.GetLength(1); j++)
    matrix[i,j] = i * 3 + j;</pre>
<p>You can initialize a rectangular array with explicit values. The following code creates an array identical to the previous example:</p>
<pre data-type="programlisting">int[,] matrix = new int[,]
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};</pre>
</div></section>
<section data-pdf-bookmark="Jagged arrays" data-type="sect3"><div class="sect3" id="jagged_arrays">
<h3>Jagged arrays</h3>
<p><a contenteditable="false" data-primary="[] (square brackets)" data-secondary="array declaration" data-type="indexterm" id="id1818"/><a contenteditable="false" data-primary="arrays" data-secondary="jagged" data-type="indexterm" id="id1819"/><a contenteditable="false" data-primary="jagged arrays" data-type="indexterm" id="id1820"/><a contenteditable="false" data-primary="square brackets ([])" data-secondary="array declaration" data-type="indexterm" id="id1821"/>Jagged arrays are declared using successive square brackets to represent each dimension. Here is an example of declaring a jagged two-dimensional array for which the outermost dimension is 3:</p>
<pre data-type="programlisting">int[][] matrix = new int[3][];</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Interestingly, this is <code>new int[3][]</code> and not <code>new int[][3]</code>. Eric Lippert has written <a href="http://albahari.com/jagged">an excellent article</a> on why this is so.</p>
</div>
<p>The inner dimensions aren’t specified in the declaration because, unlike a rectangular array, each inner array can be an arbitrary length. Each inner array is implicitly initialized to null rather than an empty array. You must manually create each inner array:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; matrix.Length; i++)
{
  matrix[i] = new int[3];                    // Create inner array
  for (int j = 0; j &lt; matrix[i].Length; j++)
    matrix[i][j] = i * 3 + j;
}</pre>
<p>You can initialize a jagged array with explicit values. The following code creates an array identical to the previous example with an additional element at the end:</p>
<pre data-type="programlisting">int[][] matrix = new int[][]
{
  new int[] {0,1,2},
  new int[] {3,4,5},
  new int[] {6,7,8,9}
};</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Simplified Array Initialization Expressions" data-type="sect2"><div class="sect2" id="simplified_array_initialization_express">
<h2>Simplified Array Initialization Expressions</h2>
<p><a contenteditable="false" data-primary="array initialization expressions" data-type="indexterm" id="id1822"/><a contenteditable="false" data-primary="arrays" data-secondary="array initialization expressions" data-type="indexterm" id="id1823"/><a contenteditable="false" data-primary="arrays" data-secondary="simplified initialization expressions" data-type="indexterm" id="id1824"/>There are two ways to shorten array initialization expressions. The first is to omit the <code>new</code> operator and type qualifications:</p>
<pre data-type="programlisting">char[] vowels = {'a','e','i','o','u'};

int[,] rectangularMatrix =
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};

int[][] jaggedMatrix =
{
  new int[] {0,1,2},
  new int[] {3,4,5},
  new int[] {6,7,8,9}
};</pre>
<p>(From C# 12, you can use square brackets instead of braces with single-dimensional arrays.)</p>
<p>The second approach is to use the <code>var</code> keyword, which instructs the compiler to implicitly type a local variable. Here are simple examples:</p>
<pre data-type="programlisting"><strong>var</strong> i = 3;           // i is implicitly of type int
<strong>var</strong> s = "sausage";   // s is implicitly of type string</pre>
<p>The same principle can be applied to arrays, except that it can be taken one stage further. By omitting the type qualifier after the <code>new</code> keyword, the compiler infers the array type:</p>
<pre data-type="programlisting"><strong>var</strong> vowels = new[] {'a','e','i','o','u'};   // Compiler infers char[]</pre>
<p>Here’s how we can apply this to multidimensional arrays:</p>
<pre data-type="programlisting">var rectMatrix = new[,]        // rectMatrix is implicitly of type int[,]
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};
var jaggedMat = new int[][]    // jaggedMat is implicitly of type int[][]
{
  new[] {0,1,2},
  new[] {3,4,5},
  new[] {6,7,8,9}
};</pre>
<p>For this to work, the elements must all be implicitly convertible to a single type (and at least one of the elements must be of that type, and there must be exactly one best type), as in the following example:</p>
<pre data-type="programlisting">var x = new[] {1,10000000000};   // all convertible to long</pre>
</div></section>
<section data-pdf-bookmark="Bounds Checking" data-type="sect2"><div class="sect2" id="bounds_checking">
<h2>Bounds Checking</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="bounds checking" data-type="indexterm" id="id1825"/><a contenteditable="false" data-primary="bounds checking" data-type="indexterm" id="id1826"/><a contenteditable="false" data-primary="indices" data-secondary="bounds checking" data-type="indexterm" id="id1827"/>All array indexing is bounds checked by the runtime. An <code>IndexOutOfRange​Excep⁠tion</code> is thrown if you use an invalid index:</p>
<pre data-type="programlisting">int[] arr = new int[3];
arr[3] = 1;               // IndexOutOfRangeException thrown</pre>
<p>Array bounds checking is necessary for type safety and simplifies debugging.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Generally, the performance hit from bounds checking is minor, and the Just-In-Time (JIT) compiler can perform optimizations, such as determining in advance whether all indexes will be safe before entering a loop, thus avoiding a check on each iteration. In addition, C# provides “unsafe” code that can explicitly bypass bounds checking (see <a data-type="xref" href="ch04.html#unsafe_code_and_pointers">“Unsafe Code and Pointers”</a>).<a contenteditable="false" data-primary="" data-startref="ch02.html1017" data-type="indexterm" id="id1828"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Variables and Parameters" data-type="sect1"><div class="sect1" id="variables_and_parameters">
<h1>Variables and Parameters</h1>
<p><a contenteditable="false" data-primary="variables" data-type="indexterm" id="ch02.html1018"/>A variable represents a storage location that has a modifiable value. A variable can be a <em>local variable</em>, <em>parameter</em> (<em>value</em>, <em>ref</em>, or <em>out</em>, or <em>in</em>), <em>field</em> (<em>instance</em> or <em>static</em>), or <em>array element</em>.</p>
<section data-pdf-bookmark="The Stack and the Heap" data-type="sect2"><div class="sect2" id="the_stack_and_the_heap">
<h2>The Stack and the Heap</h2>
<p><a contenteditable="false" data-primary="stack" data-type="indexterm" id="id1829"/><a contenteditable="false" data-primary="variables" data-secondary="heap" data-type="indexterm" id="id1830"/><a contenteditable="false" data-primary="variables" data-secondary="stack and" data-type="indexterm" id="id1831"/>The stack and the heap are the places where variables reside. Each has very different lifetime semantics.</p>
<section data-pdf-bookmark="Stack" data-type="sect3"><div class="sect3" id="stack">
<h3>Stack</h3>
<p>The stack is a block of memory for storing local variables and parameters. The stack logically grows and shrinks as a method or function is entered and exited. Consider the following method (to avoid distraction, input argument checking is ignored):</p>
<pre data-type="programlisting">static int Factorial (int x)
{
  if (x == 0) return 1;
  return x * Factorial (x-1);
}</pre>
<p>This method is recursive, meaning that it calls itself. Each time the method is entered, a new <code>int</code> is allocated on the stack, and each time the method exits, the <code>int</code> is deallocated.</p>
</div></section>
<section data-pdf-bookmark="Heap" data-type="sect3"><div class="sect3" id="heap">
<h3>Heap</h3>
<p><a contenteditable="false" data-primary="heap" data-type="indexterm" id="id1832"/><a contenteditable="false" data-primary="objects" data-secondary="heap and" data-type="indexterm" id="id1833"/>The heap is the memory in which <em>objects</em> (i.e., reference-type instances) reside. Whenever a new object is created, it is allocated on the heap, and a reference to that object is returned. During a program’s execution, the heap begins filling up as new objects are created. The runtime has a garbage collector that periodically deallocates objects from the heap, so your program does not run out of memory. An object is eligible for deallocation as soon as it’s not referenced by anything that’s itself “alive.”</p>
<p>In the following example, we begin by creating a <code>StringBuilder</code> object referenced by the variable <code>ref1</code> and then write out its content. That <code>StringBuilder</code> object is then immediately eligible for garbage collection because nothing subsequently <span class="keep-together">uses it</span>.</p>
<p>Then, we create another <code>StringBuilder</code> referenced by variable <code>ref2</code> and copy that reference to <code>ref3</code>. Even though <code>ref2</code> is not used after that point, <code>ref3</code> keeps the same <code>StringBuilder</code> object alive—ensuring that it doesn’t become eligible for collection until we’ve finished using <code>ref3</code>:</p>
<pre data-type="programlisting">using System;
using System.Text;

StringBuilder ref1 = new StringBuilder ("object1");
Console.WriteLine (ref1);
// The StringBuilder referenced by ref1 is now eligible for GC.

StringBuilder ref2 = new StringBuilder ("object2");
StringBuilder ref3 = ref2;
// The StringBuilder referenced by ref2 is NOT yet eligible for GC.

Console.WriteLine (ref3);      // object2</pre>
<p>Value-type instances (and object references) live wherever the variable was declared. If the instance was declared as a field within a class type, or as an array element, that instance lives on the heap.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can’t explicitly delete objects in C#, as you can in C++. An unreferenced object is eventually collected by the garbage collector.</p>
</div>
<p>The heap also stores static fields. Unlike objects allocated on the heap (which can be garbage-collected), these live until the process ends.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Definite Assignment" data-type="sect2"><div class="sect2" id="definite_assignment">
<h2>Definite Assignment</h2>
<p><a contenteditable="false" data-primary="definite assignment policy" data-type="indexterm" id="id1834"/><a contenteditable="false" data-primary="variables" data-secondary="definite assignment and" data-type="indexterm" id="id1835"/>C# enforces a definite assignment policy. In practice, this means that outside of an <code>unsafe</code> or interop context, you can’t accidentally access uninitialized memory. Definite assignment has three implications:</p>
<ul>
<li><p>Local variables must be assigned a value before they can be read.</p></li>
<li><p>Function arguments must be supplied when a method is called (unless marked as optional; see <a data-type="xref" href="#optional_parameters">“Optional parameters”</a>).</p></li>
<li><p>All other variables (such as fields and array elements) are automatically initialized by the runtime.</p></li>
</ul>
<p>For example, the following code results in a compile-time error:</p>
<pre data-type="programlisting">int x;
Console.WriteLine (x);        // Compile-time error</pre>
<p>Fields and array elements are automatically initialized with the default values for their type. The following code outputs <code>0</code> because array elements are implicitly assigned to their default values:</p>
<pre data-type="programlisting">int[] ints = new int[2];
Console.WriteLine (ints[0]);    // 0</pre>
<p>The following code outputs <code>0</code>, because fields are implicitly assigned a default value (whether instance or static):</p>
<pre data-type="programlisting">Console.WriteLine (Test.X);   // 0

class Test { public static int X; }   // field</pre>
</div></section>
<section data-pdf-bookmark="Default Values" data-type="sect2"><div class="sect2" id="default_values">
<h2>Default Values</h2>
<p><a contenteditable="false" data-primary="variables" data-secondary="default values" data-type="indexterm" id="id1836"/>All type instances have a default value. <a contenteditable="false" data-primary="predefined types" data-type="indexterm" id="id1837"/>The default value for the predefined types is the result of a bitwise zeroing of memory:</p>
<table class="border">
<thead>
<tr>
<th>Type</th>
<th>Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reference types (and nullable value types)</td>
<td><code>null</code></td>
</tr>
<tr>
<td>Numeric and enum types</td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>char</code> type</td>
<td><code>'\0'</code></td>
</tr>
<tr>
<td><code>bool</code> type</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="default keyword" data-type="indexterm" id="id1838"/>You can obtain the default value for any type via the <code>default</code> keyword:</p>
<pre data-type="programlisting">Console.WriteLine (<strong>default (decimal)</strong>);   // 0</pre>
<p>You can optionally omit the type when it can be inferred:</p>
<pre data-type="programlisting">decimal d = <strong>default</strong>;</pre>
<p>The default value in a custom value type (i.e., <code>struct</code>) is the same as the default value for each field defined by the custom type. <a contenteditable="false" data-primary="" data-startref="ch02.html1018" data-type="indexterm" id="id1839"/></p>
</div></section>
<section data-pdf-bookmark="Parameters" data-type="sect2"><div class="sect2" id="parameters">
<h2>Parameters</h2>
<p><a contenteditable="false" data-primary="parameters" data-type="indexterm" id="ch02.html1019"/>A method may have a sequence of parameters. Parameters define the set of arguments that must be provided for that method. In the following example, the method <code>Foo</code> has a single parameter named <code>p</code>, of type <code>int</code>:</p>
<pre data-type="programlisting">Foo (8);                        // 8 is an <strong>argument</strong>
static void Foo (int p) {...}   // p is a <strong>parameter</strong></pre>
<p>You can control how parameters are passed with the <code>ref</code>, <code>in</code>, and <code>out</code> modifiers:</p>
<table class="border">
<thead>
<tr>
<th>Parameter modifier</th>
<th>Passed by</th>
<th>Variable must be definitely assigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>(None)</td>
<td>Value</td>
<td>Going in</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>Reference</td>
<td>Going in</td>
</tr>
<tr>
<td><code>in</code></td>
<td>Reference (read-only)</td>
<td>Going in</td>
</tr>
<tr>
<td><code>out</code></td>
<td>Reference</td>
<td>Going out</td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Passing arguments by value" data-type="sect3"><div class="sect3" id="passing_arguments_by_value">
<h3>Passing arguments by value</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="pass-by-value versus pass-by-reference" data-type="indexterm" id="id1840"/><a contenteditable="false" data-primary="parameters" data-secondary="passing arguments by value" data-type="indexterm" id="id1841"/>By default, arguments in C# are <em>passed by value</em>, which is by far the most common case. This means that a copy of the value is created when passed to the method:</p>
<pre data-type="programlisting">int x = 8;
Foo (x);                    // Make a copy of x
Console.WriteLine (x);      // x will still be 8

static void Foo (int p)
{
  p = p + 1;                // Increment p by 1
  Console.WriteLine (p);    // Write p to screen
}</pre>
<p>Assigning <code>p</code> a new value does not change the contents of <code>x</code>, because <code>p</code> and <code>x</code> reside in different memory locations.</p>
<p>Passing a reference-type argument by value copies the <em>reference</em> but not the object. In the following example, <code>Foo</code> sees the same <code>StringBuilder</code> object we instantiated (<code>sb</code>) but has an independent <em>reference</em> to it. In other words, <code>sb</code> and <code>fooSB</code> are separate variables that reference the same <code>StringBuilder</code> object:</p>
<pre data-type="programlisting">StringBuilder sb = new StringBuilder();
Foo (sb);
Console.WriteLine (sb.ToString());    // test

static void Foo (StringBuilder fooSB)
{
  fooSB.Append ("test");
  fooSB = null;
}</pre>
<p>Because <code>fooSB</code> is a <em>copy</em> of a reference, setting it to <code>null</code> doesn’t make <code>sb</code> null. (If, however, <code>fooSB</code> was declared and called with the <code>ref</code> modifier, <code>sb</code> <em>would</em> become null.)</p>
</div></section>
<section data-pdf-bookmark="The ref modifier" data-type="sect3"><div class="sect3" id="the_ref_modifier">
<h3>The ref modifier</h3>
<p><a contenteditable="false" data-primary="parameters" data-secondary="ref modifier" data-type="indexterm" id="id1842"/><a contenteditable="false" data-primary="passing by reference" data-secondary="ref modifier" data-type="indexterm" id="id1843"/><a contenteditable="false" data-primary="ref parameter modifier" data-type="indexterm" id="id1844"/>To <em>pass by reference</em>, C# provides the <code>ref</code> parameter modifier. In the following example, <code>p</code> and <code>x</code> refer to the same memory locations:</p>
<pre data-type="programlisting">int x = 8;
Foo (<strong>ref</strong>  x);              // Ask Foo to deal directly with x
Console.WriteLine (x);     // x is now 9

static void Foo (<strong>ref</strong> int p)
{
  p = p + 1;               // Increment p by 1
  Console.WriteLine (p);   // Write p to screen
}</pre>
<p>Now assigning <code>p</code> a new value changes the contents of <code>x</code>. Notice how the <code>ref</code> modifier is required both when writing and when calling the method.<sup><a data-type="noteref" href="ch02.html#ch01fn4" id="ch01fn4-marker">4</a></sup> This makes it very clear what’s going on.</p>
<p>The <code>ref</code> modifier is essential in implementing a swap method (in <a data-type="xref" href="ch03.html#generics">“Generics”</a>, we show how to write a swap method that works with any type):</p>
<pre data-type="programlisting">string x = "Penn";
string y = "Teller";
Swap (ref x, ref y);
Console.WriteLine (x);   // Teller
Console.WriteLine (y);   // Penn

static void Swap (ref string a, ref string b)
{
  string temp = a;
  a = b;
  b = temp;
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A parameter can be passed by reference or by value, regardless of whether the parameter type is a reference type or a value type.</p>
</div>
</div></section>
<section data-pdf-bookmark="The out modifier" data-type="sect3"><div class="sect3" id="the_out_modifier">
<h3>The out modifier</h3>
<p>An <code>out</code> argument is like a <code>ref</code> argument except for the following:</p>
<ul>
<li><p>It need not be assigned before going into the function.</p></li>
<li><p>It must be assigned before it comes <em>out</em> of the function.</p></li>
</ul>
<p><a contenteditable="false" data-primary="out parameter modifier" data-type="indexterm" id="id1845"/><a contenteditable="false" data-primary="parameters" data-secondary="out modifier" data-type="indexterm" id="id1846"/>The <code>out</code> modifier is most commonly used to get multiple return values back from a method; for example:</p>
<pre data-type="programlisting">string a, b;
Split ("Stevie Ray Vaughn", <strong>out</strong> a, <strong>out</strong> b);
Console.WriteLine (a);                      // Stevie Ray
Console.WriteLine (b);                      // Vaughn

void Split (string name, <strong>out</strong> string firstNames, <strong>out</strong> string lastName)
{
  int i = name.LastIndexOf (' ');
  firstNames = name.Substring (0, i);
  lastName = name.Substring (i + 1);
}</pre>
<p>Like a <code>ref</code> parameter, an <code>out</code> parameter is passed by reference.</p>
</div></section>
<section data-pdf-bookmark="Out variables and discards" data-type="sect3"><div class="sect3" id="out_variables_and_discards-id00083">
<h3>Out variables and discards</h3>
<p><a contenteditable="false" data-primary="discards" data-type="indexterm" id="id1847"/><a contenteditable="false" data-primary="out variables" data-type="indexterm" id="id1848"/><a contenteditable="false" data-primary="parameters" data-secondary="out variables and discards" data-type="indexterm" id="id1849"/>You can declare variables on the fly when calling methods with <code>out</code> parameters. We can replace the first two lines in our preceding example with this:</p>
<pre data-type="programlisting">Split ("Stevie Ray Vaughan", <strong>out string a, out string b</strong>);</pre>
<p><a contenteditable="false" data-primary="_ (discard symbol)" data-type="indexterm" id="id1850"/><a contenteditable="false" data-primary="discard symbol (_)" data-type="indexterm" id="id1851"/>When calling methods with multiple <code>out</code> parameters, sometimes you’re not interested in receiving values from all the parameters. In such cases, you can “discard” the ones in which you’re uninterested by using an underscore:</p>
<pre data-type="programlisting">Split ("Stevie Ray Vaughan", out string a, <strong>out _</strong>);   // Discard 2nd param
Console.WriteLine (a);</pre>
<p>In this case, the compiler treats the underscore as a special symbol, called a <em>discard</em>. You can include multiple discards in a single call. Assuming <code>SomeBigMethod</code> has been defined with seven <code><strong>out</strong></code> parameters, we can ignore all but the fourth, as follows:</p>
<pre data-type="programlisting">SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);</pre>
<p>For backward compatibility, this language feature will not take effect if a real underscore variable is in scope:</p>
<pre data-type="programlisting"><strong>string _;</strong>
Split ("Stevie Ray Vaughan", out string a, out <strong>_</strong>);
Console.WriteLine (_);     // Vaughan</pre>
</div></section>
<section data-pdf-bookmark="Implications of passing by reference" data-type="sect3"><div class="sect3" id="implications_of_passing_by_reference">
<h3>Implications of passing by reference</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="implications of passing by reference" data-type="indexterm" id="id1852"/><a contenteditable="false" data-primary="parameters" data-secondary="implications of passing arguments by reference" data-type="indexterm" id="id1853"/><a contenteditable="false" data-primary="passing by reference" data-secondary="implications of" data-type="indexterm" id="id1854"/>When you pass an argument by reference, you alias the storage location of an existing variable rather than create a new storage location. In the following example, the variables <code>x</code> and <code>y</code> represent the same instance:</p>
<pre data-type="programlisting">class Test
{
  static int x;

  static void Main() { Foo (out x); }

  static void Foo (out int y)
  {
    Console.WriteLine (x);                // x is 0
    y = 1;                                // Mutate y
    Console.WriteLine (x);                // x is 1
  }
}</pre>
</div></section>
<section data-pdf-bookmark="The in modifier" data-type="sect3"><div class="sect3" id="the_in_modifier">
<h3>The in modifier</h3>
<p><a contenteditable="false" data-primary="in parameter" data-type="indexterm" id="id1855"/><a contenteditable="false" data-primary="parameters" data-secondary="in modifier" data-type="indexterm" id="id1856"/>An <code>in</code> parameter is similar to a <code>ref</code> parameter except that the argument’s value cannot be modified by the method (doing so generates a compile-time error). This modifier is most useful when passing a large value type to the method because it allows the compiler to avoid the overhead of copying the argument prior to passing it in while still protecting the original value from modification.</p>
<p>Overloading solely on the presence of <code>in</code> is permitted:</p>
<pre data-type="programlisting">void Foo (   SomeBigStruct a) { ... }
void Foo (<strong>in</strong> SomeBigStruct a) { ... }</pre>
<p>To call the second overload, the caller must use the <code>in</code> modifier:</p>
<pre data-type="programlisting">SomeBigStruct x = ...;
Foo (x);      // Calls the first overload
Foo (<strong>in</strong> x);   // Calls the second overload</pre>
<p>When there’s no ambiguity</p>
<pre data-type="programlisting">void Bar (in SomeBigStruct a) { ... }</pre>
<p>use of the <code>in</code> modifier is optional for the caller:</p>
<pre data-type="programlisting">Bar (x);     // OK (calls the 'in' overload)
Bar (in x);  // OK (calls the 'in' overload)</pre>
<p>To make this example meaningful, <code>SomeBigStruct</code> would be defined as a struct (see <a data-type="xref" href="ch03.html#structs">“Structs”</a>).</p>
</div></section>
<section data-pdf-bookmark="The params modifier" data-type="sect3"><div class="sect3" id="the_params_modifier">
<h3>The params modifier</h3>
<p><a contenteditable="false" data-primary="parameters" data-secondary="params modifier" data-type="indexterm" id="id1857"/><a contenteditable="false" data-primary="params modifier" data-type="indexterm" id="id1858"/>The <code>params</code> modifier, if applied to the last parameter of a method, allows the method to accept any number of arguments of a particular type. The parameter type must be declared as a (single-dimensional) array, as shown in the following example:</p>
<pre data-type="programlisting">int total = Sum (1, 2, 3, 4);
Console.WriteLine (total);              // 10

// The call to Sum above is equivalent to:
int total2 = Sum (new int[] { 1, 2, 3, 4 });

int Sum (<strong>params int[] ints</strong>)
{
  int sum = 0;
  for (int i = 0; i &lt; ints.Length; i++)
    sum += ints [i];                       // Increase sum by ints[i]
  return sum;
}</pre>
<p>If there are zero arguments in the <code>params</code> position, a zero-length array is created.</p>
<p>You can also supply a <code>params</code> argument as an ordinary array. The first line in our example is semantically equivalent to this:</p>
<pre data-type="programlisting">int total = Sum (new int[] { 1, 2, 3, 4 } );</pre>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Optional parameters" data-type="sect3"><div class="sect3" id="optional_parameters">
<h3 class="less_space">Optional parameters</h3>
<p><a contenteditable="false" data-primary="optional parameters" data-type="indexterm" id="id1859"/><a contenteditable="false" data-primary="parameters" data-secondary="optional parameters" data-type="indexterm" id="id1860"/>Methods, constructors, and indexers (<a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>) can declare <em>optional parameters</em>. A parameter is optional if it specifies a <em>default value</em> in its declaration:</p>
<pre data-type="programlisting">void Foo (int <strong>x = 23</strong>) { Console.WriteLine (x); }</pre>
<p>You can omit optional parameters when calling the method:</p>
<pre data-type="programlisting">Foo();     // 23</pre>
<p>The <em>default argument</em> of <code>23</code> is actually <em>passed</em> to the optional parameter <code>x</code>—the compiler bakes the value 23 into the compiled code at the <em>calling</em> side. The preceding call to <code>Foo</code> is semantically identical to:</p>
<pre data-type="programlisting">Foo (23);</pre>
<p>because the compiler simply substitutes the default value of an optional parameter wherever it is used.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Adding an optional parameter to a public method that’s called from another assembly requires recompilation of both assemblies—just as though the parameter were mandatory.</p>
</div>
<p>The default value of an optional parameter must be specified by a constant expression, a parameterless constructor of a value type, or a <code>default</code> expression. Optional parameters cannot be marked with <code>ref</code> or <code>out</code>.</p>
<p>Mandatory parameters must occur <em>before</em> optional parameters in both the method declaration and the method call (the exception is with <code>params</code> arguments, which still always come last). In the following example, the explicit value of <code>1</code> is passed to <code>x</code>, and the default value of <code>0</code> is passed to <code>y</code>:</p>
<pre data-type="programlisting">Foo (1);    // 1, 0

void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }</pre>
<p>You can do the converse (pass a default value to <code>x</code> and an explicit value to <code>y</code>) by combining optional parameters with <em>named arguments</em>.</p>
</div></section>
<section data-pdf-bookmark="Named arguments" data-type="sect3"><div class="sect3" id="named_arguments">
<h3>Named arguments</h3>
<p><a contenteditable="false" data-primary=": (colon), in named arguments" data-type="indexterm" id="id1861"/><a contenteditable="false" data-primary="arguments" data-secondary="named" data-type="indexterm" id="id1862"/><a contenteditable="false" data-primary="colon (:), in named arguments" data-type="indexterm" id="id1863"/><a contenteditable="false" data-primary="named arguments" data-type="indexterm" id="id1864"/><a contenteditable="false" data-primary="parameters" data-secondary="named arguments and" data-type="indexterm" id="id1865"/>Rather than identifying an argument by position, you can identify an argument by name:</p>
<pre data-type="programlisting">Foo (<strong>x:1, y:2</strong>);  // 1, 2

void Foo (int x, int y) { Console.WriteLine (x + ", " + y); }</pre>
<p>Named arguments can occur in any order. The following calls to <code>Foo</code> are semantically identical:</p>
<pre data-type="programlisting">Foo (x:1, y:2);
Foo (y:2, x:1);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A subtle difference is that argument expressions are evaluated in the order in which they appear at the <em>calling</em> site. In general, this makes a difference only with interdependent side-effecting expressions such as the following, which writes <code>0, 1</code>:</p>
<pre data-type="programlisting">int a = 0;
Foo (y: ++a, x: --a);  // ++a is evaluated first</pre>
<p>Of course, you would almost certainly avoid writing such code in practice!</p>
</div>
<p>You can mix named and positional arguments:</p>
<pre data-type="programlisting">Foo (1, y:2);</pre>
<p>However, there is a restriction: positional arguments must come before named arguments unless they are used in the correct position. So, you could call <code>Foo</code> like this:</p>
<pre data-type="programlisting">Foo (x:1, 2);         // OK. Arguments in the declared positions</pre>
<p>But not like this:</p>
<pre data-type="programlisting">Foo (y:2, 1);         // Compile-time error. y isn't in the first position</pre>
<p>Named arguments are particularly useful in conjunction with optional parameters. For instance, consider the following method:</p>
<pre data-type="programlisting">void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }</pre>
<p>You can call this supplying only a value for <code>d</code>, as follows:</p>
<pre data-type="programlisting">Bar (d:3);</pre>
<p>This is particularly useful when calling COM APIs, which we discuss in detail in <a data-type="xref" href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Ref Locals" data-type="sect2"><div class="sect2" id="ref_locals">
<h2>Ref Locals</h2>
<p><a contenteditable="false" data-primary="ref locals" data-type="indexterm" id="id1866"/><a contenteditable="false" data-primary="variables" data-secondary="ref locals" data-type="indexterm" id="id1867"/>A somewhat esoteric feature of C# is that you can define a local variable that <em>references</em> an element in an array or field in an object (from C# 7):</p>
<pre data-type="programlisting">int[] numbers = { 0, 1, 2, 3, 4 };
<strong>ref</strong> int numRef = <strong>ref</strong> numbers [2];</pre>
<p>In this example, <code>numRef</code> is a <em>reference</em> to <code>numbers[2]</code>. When we modify <code>numRef</code>, we modify the array element:</p>
<pre data-type="programlisting">numRef *= 10;
Console.WriteLine (numRef);        // 20
Console.WriteLine (numbers [2]);   // 20</pre>
<p>The target for a ref local must be an array element, field, or local variable; it cannot be a <em>property</em> (<a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>). <em>Ref locals</em> are intended for specialized micro-optimization scenarios and are typically used in conjunction with <em>ref returns</em>.</p>
</div></section>
<section data-pdf-bookmark="Ref Returns" data-type="sect2"><div class="sect2" id="ref_returns">
<h2>Ref Returns</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="ref returns" data-type="indexterm" id="id1868"/><a contenteditable="false" data-primary="variables" data-secondary="ref returns" data-type="indexterm" id="id1869"/>The <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> types that we describe in <a data-type="xref" href="ch23.html#spanless_thantgreater_than_and-id00089">Chapter 23</a> use ref returns to implement a highly efficient indexer. Outside such scenarios, ref returns are not commonly used, and you can consider them a micro-optimization <span class="keep-together">feature</span>.</p>
</div>
<p>You can return a <em>ref local</em> from a method. This is called a <em>ref return</em>:</p>
<pre data-type="programlisting">class Program
{
  static string x = "Old Value";

  static <strong>ref</strong> string GetX() =&gt; <strong>ref</strong> x;    // This method returns a ref

  static void Main()
  {
    <strong>ref</strong> string xRef = <strong>ref</strong> GetX();       // Assign result to a ref local
    xRef = "New Value";
    Console.WriteLine (x);              // New Value
  }
}</pre>
<p>If you omit the <code>ref</code> modifier on the calling side, it reverts to returning an ordinary value:</p>
<pre data-type="programlisting">string localX = GetX();  // Legal: localX is an ordinary non-ref variable.</pre>
<p>You also can use ref returns when defining a property or indexer:</p>
<pre data-type="programlisting">static <strong>ref</strong> string Prop =&gt; <strong>ref</strong> x;</pre>
<p>Such a property is implicitly writable, despite there being no <code>set</code> accessor:</p>
<pre data-type="programlisting">Prop = "New Value";</pre>
<p>You can prevent such modification by using <code>ref readonly</code>:</p>
<pre data-type="programlisting">static <strong>ref readonly</strong> string Prop =&gt; ref x;</pre>
<p>The <code>ref readonly</code> modifier prevents modification while still enabling the performance gain of returning by reference. The gain would be very small in this case, because <code>x</code> is of type <code>string</code> (a reference type): no matter how long the <code>string</code>, the only inefficiency that you can hope to avoid is the copying of a single 32- or 64-bit <em>reference</em>. Real gains can occur with custom value types (see <a data-type="xref" href="ch03.html#structs">“Structs”</a>), but only if the struct is marked as <code>readonly</code> (otherwise, the compiler will perform a defensive copy).</p>
<p>Attempting to define an explicit <code>set</code> accessor on a <em>ref return</em> property or indexer is illegal.</p>
</div></section>
<section data-pdf-bookmark="var—Implicitly Typed Local Variables" data-type="sect2"><div class="sect2" id="varem_dashimplicitly_typed_local_variab">
<h2>var—Implicitly Typed Local Variables</h2>
<p><a contenteditable="false" data-primary="implicit typing" data-type="indexterm" id="id1870"/><a contenteditable="false" data-primary="local variables" data-secondary="var keyword" data-type="indexterm" id="id1871"/><a contenteditable="false" data-primary="var keyword" data-type="indexterm" id="id1872"/><a contenteditable="false" data-primary="variables" data-secondary="var keyword" data-type="indexterm" id="id1873"/>It is often the case that you declare and initialize a variable in one step. If the compiler is able to infer the type from the initialization expression, you can use the keyword <code>var</code> in place of the type declaration; for example:</p>
<pre data-type="programlisting"><strong>var</strong> x = "hello";
<strong>var</strong> y = new System.Text.StringBuilder();
<strong>var</strong> z = (float)Math.PI;</pre>
<p>This is precisely equivalent to the following:</p>
<pre data-type="programlisting"><strong>string</strong> x = "hello";
<strong>System.Text.StringBuilder</strong> y = new System.Text.StringBuilder();
<strong>float</strong> z = (float)Math.PI;</pre>
<p>Because of this direct equivalence, implicitly typed variables are statically typed. For example, the following generates a compile-time error:</p>
<pre data-type="programlisting">var x = 5;
x = "hello";    // Compile-time error; x is of type int</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>var</code> can decrease code readability when you can’t deduce the type purely by looking at the variable declaration. For example:</p>
<pre data-type="programlisting">Random r = new Random();
var x = r.Next();</pre>
<p>What type is <code>x</code>?</p>
</div>
<p>In <a data-type="xref" href="ch04.html#anonymous_types">“Anonymous Types”</a>, we will describe a scenario in which the use of <code>var</code> is mandatory.</p>
</div></section>
<section data-pdf-bookmark="Target-Typed new Expressions" data-type="sect2"><div class="sect2" id="target_typed_new_expressions-id00094">
<h2>Target-Typed new Expressions</h2>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="target-typed new expressions" data-type="indexterm" id="id1874"/><a contenteditable="false" data-primary="target typing" data-type="indexterm" id="id1875"/>Another way to reduce lexical repetition is with <em>target-typed</em> <code>new</code> <em>expressions</em> (from C# 9):</p>
<pre data-type="programlisting">System.Text.StringBuilder sb1 = <strong>new()</strong>;
System.Text.StringBuilder sb2 = <strong>new ("Test")</strong>;</pre>
<p>This is precisely equivalent to:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb1 = <strong>new System.Text.StringBuilder()</strong>;
System.Text.StringBuilder sb2 = <strong>new System.Text.StringBuilder ("Test")</strong>;</pre>
<p>The principle is that you can call <code>new</code> without specifying a type name if the compiler is able to unambiguously infer it. Target-typed <code>new</code> expressions are particularly useful when the variable declaration and initialization are in different parts of your code. A common example is when you want to initialize a field in a constructor:</p>
<pre data-type="programlisting">class Foo
{
  <strong>System.Text.StringBuilder</strong> sb;
  
  public Foo (string initialValue)
  {
    sb = <strong>new (initialValue)</strong>;
  }
}</pre>
<p><a contenteditable="false" data-primary="" data-startref="ch02.html1019" data-type="indexterm" id="id1876"/>Target-typed <code>new</code> expressions are also helpful in the following scenario:</p>
<pre data-type="programlisting">MyMethod (<strong>new ("test")</strong>);

void MyMethod (System.Text.StringBuilder sb) { ... }</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Expressions and Operators" data-type="sect1"><div class="sect1" id="expressions_and_operators">
<h1>Expressions and Operators</h1>
<p><a contenteditable="false" data-primary="expressions" data-type="indexterm" id="ch02.html1020"/>An <em>expression</em> essentially denotes a value. The simplest kinds of expressions are constants and variables. Expressions can be transformed and combined using operators. An <em>operator</em> takes one or more input <em>operands</em> to output a new expression.</p>
<p>Here is an example of a <em>constant expression</em>:</p>
<pre data-type="programlisting">12</pre>
<p>We can use the <code>*</code> operator to combine two operands (the literal expressions <code>12</code> and <code>30</code>), as follows:</p>
<pre data-type="programlisting">12 * 30</pre>
<p>We can build complex expressions because an operand can itself be an expression, such as the operand <code>(12 * 30)</code> in the following example:</p>
<pre data-type="programlisting">1 + (12 * 30)</pre>
<p>Operators in C# can be classed as <em>unary</em>, <em>binary</em>, or <em>ternary</em>, depending on the number of operands they work on (one, two, or three). The binary operators always use <em>infix</em> notation in which the operator is placed <em>between</em> the two operands.</p>
<section data-pdf-bookmark="Primary Expressions" data-type="sect2"><div class="sect2" id="primary_expressions">
<h2>Primary Expressions</h2>
<p><a contenteditable="false" data-primary="expressions" data-secondary="primary expressions" data-type="indexterm" id="id1877"/><a contenteditable="false" data-primary="primary expressions" data-type="indexterm" id="id1878"/>Primary expressions include expressions composed of operators that are intrinsic to the basic plumbing of the language. Here is an example:</p>
<pre data-type="programlisting">Math.Log (1)</pre>
<p>This expression is composed of two primary expressions. <a contenteditable="false" data-primary=". (period)" data-type="indexterm" id="id1879"/><a contenteditable="false" data-primary="period (.)" data-type="indexterm" id="id1880"/>The first expression performs a member lookup (with the <code>.</code> operator), and the <a contenteditable="false" data-primary="() (parentheses)" data-type="indexterm" id="id1881"/><a contenteditable="false" data-primary="parentheses ()" data-type="indexterm" id="id1882"/>second expression performs a method call (with the <code>()</code> operator).</p>
</div></section>
<section data-pdf-bookmark="Void Expressions" data-type="sect2"><div class="sect2" id="void_expressions">
<h2>Void Expressions</h2>
<p><a contenteditable="false" data-primary="expressions" data-secondary="void expressions" data-type="indexterm" id="id1883"/><a contenteditable="false" data-primary="void expressions" data-type="indexterm" id="id1884"/>A void expression is an expression that has no value, such as this:</p>
<pre data-type="programlisting">Console.WriteLine (1)</pre>
<p>Because it has no value, you cannot use a void expression as an operand to build more complex expressions:</p>
<pre data-type="programlisting">1 + Console.WriteLine (1)      // Compile-time error</pre>
</div></section>
<section data-pdf-bookmark="Assignment Expressions" data-type="sect2"><div class="sect2" id="assignment_expressions">
<h2>Assignment Expressions</h2>
<p><a contenteditable="false" data-primary="= (equal sign), as assignment operator" data-type="indexterm" id="id1885"/><a contenteditable="false" data-primary="assignment expressions" data-type="indexterm" id="id1886"/><a contenteditable="false" data-primary="equal sign (=), as assignment operator" data-type="indexterm" id="id1887"/><a contenteditable="false" data-primary="expressions" data-secondary="assignment expressions" data-type="indexterm" id="id1888"/>An assignment expression uses the <code>=</code> operator to assign the result of another expression to a variable; for example:</p>
<pre data-type="programlisting">x = x * 5</pre>
<p>An assignment expression is not a void expression—it has a value of whatever was assigned, and so can be incorporated into another expression. In the following example, the expression assigns <code>2</code> to <code>x</code> and <code>10</code> to <code>y</code>:</p>
<pre data-type="programlisting">y = 5 * (x = 2)</pre>
<p>You can use this style of expression to initialize multiple values:</p>
<pre data-type="programlisting">a = b = c = d = 0</pre>
<p>The <em>compound assignment operators</em> are syntactic shortcuts that combine assignment with another operator:</p>
<pre data-type="programlisting">x *= 2    // equivalent to x = x * 2
x &lt;&lt;= 1   // equivalent to x = x &lt;&lt; 1</pre>
<p>(A subtle exception to this rule is with <em>events</em>, which we describe in <a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>: the <code>+=</code> and <code>-=</code> operators here are treated specially and map to the event’s <code>add</code> and <code>remove</code> accessors.)</p>
</div></section>
<section data-pdf-bookmark="Operator Precedence and Associativity" data-type="sect2"><div class="sect2" id="operator_precedence_and_associativity">
<h2>Operator Precedence and Associativity</h2>
<p><a contenteditable="false" data-primary="associativity, operator" data-type="indexterm" id="id1889"/><a contenteditable="false" data-primary="precedence, operator" data-type="indexterm" id="id1890"/>When an expression contains multiple operators, <em>precedence</em> and <em>associativity</em> determine the order of their evaluation. Operators with higher precedence execute before operators of lower precedence. If the operators have the same precedence, the operator’s associativity determines the order of evaluation.</p>
<section data-pdf-bookmark="Precedence" data-type="sect3"><div class="sect3" id="precedence">
<h3>Precedence</h3>
<p>The following expression</p>
<pre data-type="programlisting">1 + 2 * 3</pre>
<p>is evaluated as follows because <code>*</code> has a higher precedence than <code>+</code>:</p>
<pre data-type="programlisting">1 + (2 * 3)</pre>
</div></section>
<section data-pdf-bookmark="Left-associative operators" data-type="sect3"><div class="sect3" id="left_associative_operators">
<h3>Left-associative operators</h3>
<p><a contenteditable="false" data-primary="binary operators" data-type="indexterm" id="id1891"/><a contenteditable="false" data-primary="left-associative operators" data-type="indexterm" id="id1892"/>Binary operators (except for assignment, lambda, and null-coalescing operators) are <em>left-associative</em>; in other words, they are evaluated from left to right. For example, the following expression</p>
<pre data-type="programlisting">8 / 4 / 2</pre>
<p>is evaluated as follows:</p>
<pre data-type="programlisting">( 8 / 4 ) / 2    // 1</pre>
<p>You can insert parentheses to change the actual order of evaluation:</p>
<pre data-type="programlisting">8 / ( 4 / 2 )    // 4</pre>
</div></section>
<section data-pdf-bookmark="Right-associative operators" data-type="sect3"><div class="sect3" id="right_associative_operators">
<h3>Right-associative operators</h3>
<p><a contenteditable="false" data-primary="assignment operators" data-type="indexterm" id="id1893"/><a contenteditable="false" data-primary="right-associative operators" data-type="indexterm" id="id1894"/>The <em>assignment operators</em> as well as the lambda, null-coalescing, and conditional operators are <em>right-associative</em>; in other words, they are evaluated from right to left.</p>

<p>Right associativity allows multiple assignments such as the following to compile:</p>
<pre data-type="programlisting">x = y = 3;</pre>
<p>This first assigns <code>3</code> to <code>y</code> and then assigns the result of that expression (<code>3</code>) to <code>x</code>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Operator Table" data-type="sect2"><div class="sect2" id="operator_table">
<h2>Operator Table</h2>
<p><a data-type="xref" href="#chash_operators_left_parenthesiscategor">Table 2-3</a> lists C#’s operators in order of precedence. Operators in the same category have the same precedence.</p> 

<p>We explain user-overloadable operators in <a data-type="xref" href="ch04.html#operator_overloading">“Operator Overloading”</a>.<a contenteditable="false" data-primary="" data-startref="ch02.html1020" data-type="indexterm" id="id1895"/></p>
<table class="border" id="chash_operators_left_parenthesiscategor">
<caption><span class="label">Table 2-3. </span>C# operators (categories in order of precedence)</caption>
<thead>
<tr>
<th>Category</th>
<th>Operator symbol</th>
<th>Operator name</th>
<th>Example</th>
<th>User-overloadable</th>
<th/>
</tr>
</thead>
<tbody>
<tr>
<td>Primary</td>
<td><code>.</code></td>
<td>Member access</td>
<td><code>x.y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>?.</code> and <code>?[]</code></td>
<td>Null-conditional</td>
<td><code>x?.y</code> or <code>x?[0]</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>!</code> (postfix)</td>
<td>Null-forgiving</td>
<td><code>x!.y</code> or <code>x![0]</code></td>
<td colspan="2">No</td>
</tr>
<tr>
<td/>
<td><code>-&gt;</code> (unsafe)</td>
<td>Pointer to struct</td>
<td><code>x-&gt;y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>()</code></td>
<td>Function call</td>
<td><code>x()</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>[]</code></td>
<td>Array/index</td>
<td><code>a[x]</code></td>
<td>Via indexer</td>
<td/>
</tr>
<tr>
<td/>
<td><code>++</code></td>
<td>Post-increment</td>
<td><code>x++</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>−−</code></td>
<td>Post-decrement</td>
<td><code>x−−</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>new</code></td>
<td>Create instance</td>
<td><code>new Foo()</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>stackalloc</code></td>
<td>Stack allocation</td>
<td><code>stackalloc(10)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>typeof</code></td>
<td>Get type from identifier</td>
<td><code>typeof(int)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>nameof</code></td>
<td>Get name of identifier</td>
<td><code>nameof(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>checked</code></td>
<td>Integral overflow check on</td>
<td><code>checked(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>unchecked</code></td>
<td>Integral overflow check off</td>
<td><code>unchecked(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>default</code></td>
<td>Default value</td>
<td><code>default(char)</code></td>
<td>No</td>
<td/>
</tr>
<tr class="pagebreak-before">
<td>Unary</td>
<td><code>await</code></td>
<td>Await</td>
<td><code>await myTask</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>sizeof</code></td>
<td>Get size of struct</td>
<td><code>sizeof(int)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>+</code></td>
<td>Positive value of</td>
<td><code>+x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>−</code></td>
<td>Negative value of</td>
<td><code>−x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>!</code></td>
<td>Not</td>
<td><code>!x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>~</code></td>
<td>Bitwise complement</td>
<td><code>~x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>++</code></td>
<td>Pre-increment</td>
<td><code>++x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>−−</code></td>
<td>Pre-decrement</td>
<td><code>−−x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>()</code></td>
<td>Cast</td>
<td><code>(int)x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>^</code></td>
<td>Index from end</td>
<td><code>array[^1]</code></td>
<td colspan="2">No</td>
</tr>
<tr>
<td/>
<td><code>*</code> (unsafe)</td>
<td>Value at address</td>
<td><code>*x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&amp;</code> (unsafe)</td>
<td>Address of value</td>
<td><code>&amp;x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td>Range</td>
<td><code>..</code><br/><code>..^</code></td>
<td>Range of indices</td>
<td><code>x..y</code><br/><code>x..^y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td>Switch &amp; with</td>
<td><code>switch</code></td>
<td>Switch expression</td>
<td><code>num switch {</code><br/><code>  1 =&gt; true,</code><br/><code>  _ =&gt; false</code><br/><code>}</code></td>
<td colspan="2">No</td>
</tr>
<tr>
<td/>
<td><code>with</code></td>
<td>With expression</td>
<td><code>rec with</code><br/><code>{ X = 123 }</code></td>
<td colspan="2">No</td>
</tr>
<tr>
<td>Multiplicative</td>
<td><code>*</code></td>
<td>Multiply</td>
<td><code>x * y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>/</code></td>
<td>Divide</td>
<td><code>x / y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>%</code></td>
<td>Remainder</td>
<td><code>x % y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Additive</td>
<td><code>+</code></td>
<td>Add</td>
<td><code>x + y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>−</code></td>
<td>Subtract</td>
<td><code>x − y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Shift</td>
<td><code>&lt;&lt;</code></td>
<td>Shift left</td>
<td><code>x &lt;&lt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;&gt;</code></td>
<td>Shift right</td>
<td><code>x &gt;&gt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;&gt;&gt;</code></td>
<td>Unsigned shift right</td>
<td><code>x &gt;&gt;&gt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Relational</td>
<td><code>&lt;</code></td>
<td>Less than</td>
<td><code>x &lt; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;</code></td>
<td>Greater than</td>
<td><code>x &gt; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&lt;=</code></td>
<td>Less than or equal to</td>
<td><code>x &lt;= y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;=</code></td>
<td>Greater than or equal to</td>
<td><code>x &gt;= y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>is</code></td>
<td>Type is or is subclass of</td>
<td><code>x is y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>as</code></td>
<td>Type conversion</td>
<td><code>x as y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td>Equality</td>
<td><code>==</code></td>
<td>Equals</td>
<td><code>x == y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td/>
<td><code>!=</code></td>
<td>Not equals</td>
<td><code>x != y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Bitwise And</td>
<td><code>&amp;</code></td>
<td>And</td>
<td><code>x &amp; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Bitwise Xor</td>
<td><code>^</code></td>
<td>Exclusive Or</td>
<td><code>x ^ y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Bitwise Or</td>
<td><code>|</code></td>
<td>Or</td>
<td><code>x | y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td>Conditional And</td>
<td><code>&amp;&amp;</code></td>
<td>Conditional And</td>
<td><code>x &amp;&amp; y</code></td>
<td>Via <code>&amp;</code></td>
<td/>
</tr>
<tr>
<td>Conditional Or</td>
<td><code>||</code></td>
<td>Conditional Or</td>
<td><code>x || y</code></td>
<td>Via <code>|</code></td>
<td/>
</tr>
<tr>
<td>Null coalescing</td>
<td><code>??</code></td>
<td>Null coalescing</td>
<td><code>x ?? y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td>Conditional</td>
<td><code>?:</code></td>
<td>Conditional</td>
<td><code>isTrue ? thenThis : elseThis</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td>Assignment and lambda</td>
<td><code>=</code></td>
<td>Assign</td>
<td><code>x = y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>*=</code></td>
<td>Multiply self by</td>
<td><code>x *= 2</code></td>
<td>Via <code>*</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>/=</code></td>
<td>Divide self by</td>
<td><code>x /= 2</code></td>
<td>Via <code>/</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>%=</code></td>
<td>Remainder &amp; assign to self</td>
<td><code>x %= 2</code></td>
<td colspan="2"/>
</tr>
<tr>
<td/>
<td><code>+=</code></td>
<td>Add to self</td>
<td><code>x += 2</code></td>
<td>Via <code>+</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>−=</code></td>
<td>Subtract from self</td>
<td><code>x −= 2</code></td>
<td>Via <code>−</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>&lt;&lt;=</code></td>
<td>Shift self left by</td>
<td><code>x &lt;&lt;= 2</code></td>
<td>Via <code>&lt;&lt;</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;&gt;=</code></td>
<td>Shift self right by</td>
<td><code>x &gt;&gt;= 2</code></td>
<td>Via <code>&gt;&gt;</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>&gt;&gt;&gt;=</code></td>
<td>Unsigned shift self right by</td>
<td><code>x &gt;&gt;&gt;= 2</code></td>
<td>Via <code>&gt;&gt;&gt;</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>&amp;=</code></td>
<td>And self by</td>
<td><code>x &amp;= 2</code></td>
<td>Via <code>&amp;</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>^=</code></td>
<td>Exclusive-Or self by</td>
<td><code>x ^= 2</code></td>
<td>Via <code>^</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>|=</code></td>
<td>Or self by</td>
<td><code>x |= 2</code></td>
<td>Via <code>|</code></td>
<td/>
</tr>
<tr>
<td/>
<td><code>??=</code></td>
<td>Null-coalescing assignment</td>
<td><code>x ??= 0</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td/>
<td><code>=&gt;</code></td>
<td>Lambda</td>
<td><code>x =&gt; x + 1</code></td>
<td>No</td>
<td/>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="Null Operators" data-type="sect1"><div class="sect1" id="null_operators">
<h1>Null Operators</h1>
<p><a contenteditable="false" data-primary="null operators" data-type="indexterm" id="ch02.html1021"/>C# provides three operators to make it easier to work with nulls: the <em>null-coalescing operator</em>, the <em>null-coalescing assignment operator</em>, and the <em>null-conditional operator</em>.</p>
<section data-pdf-bookmark="Null-Coalescing Operator" data-type="sect2"><div class="sect2" id="null_coalescing_operator">
<h2>Null-Coalescing Operator</h2>
<p><a contenteditable="false" data-primary="?? (null-coalescing operator)" data-type="indexterm" id="id1896"/><a contenteditable="false" data-primary="null-coalescing operator (??)" data-type="indexterm" id="id1897"/>The <code>??</code> operator is the <em>null-coalescing operator</em>. It says, “If the operand to the left is non-null, give it to me; otherwise, give me another value.” For example:</p>
<pre data-type="programlisting">string s1 = null;
string s2 = s1 ?? "nothing";   // s2 evaluates to "nothing"</pre>
<p>If the lefthand expression is non-null, the righthand expression is never evaluated. The null-coalescing operator also works with nullable value types (see <a data-type="xref" href="ch04.html#nullable_value_types">“Nullable Value Types”</a>).</p>
</div></section>
<section data-pdf-bookmark="Null-Coalescing Assignment Operator" data-type="sect2"><div class="sect2" id="null_coalescing_assignment_operator">
<h2>Null-Coalescing Assignment Operator</h2>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="null-coalescing assignment operators" data-type="indexterm" id="id1898"/><a contenteditable="false" data-primary="null-coalescing assignment operators" data-type="indexterm" id="id1899"/>The <code>??=</code> operator (introduced in C# 8) is the <em>null-coalescing assignment operator</em>. It says, “If the operand to the left is null, assign the right operand to the left operand.” Consider the following:</p>
<pre data-type="programlisting">myVariable ??= someDefault;</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">if (myVariable == null) myVariable = someDefault;</pre>
<p>The <code>??=</code> operator is particularly useful in implementing lazily calculated properties. We’ll cover this topic later, in <a data-type="xref" href="ch04.html#calculated_fields_and_lazy_evaluation">“Calculated Fields and Lazy Evaluation”</a>.</p>
</div></section>
<section data-pdf-bookmark="Null-Conditional Operator" data-type="sect2"><div class="sect2" id="null_conditional_operator">
<h2>Null-Conditional Operator</h2>
<p><a contenteditable="false" data-primary="?. (null-conditional operator)" data-type="indexterm" id="id1900"/><a contenteditable="false" data-primary="null-conditional operator (?.)" data-type="indexterm" id="id1901"/>The <code>?.</code> operator is the <em>null-conditional</em> or “Elvis” operator (after the Elvis emoticon). It allows you to call methods and access members just like the standard dot operator except that if the operand on the left is null, the expression evaluates to null instead of throwing a <code>NullReferenceException</code>:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb<strong>?.</strong>ToString();  // No error; s instead evaluates to null</pre>
<p>The last line is equivalent to the following:</p>
<pre data-type="programlisting">string s = (sb == null ? null : sb.ToString());</pre>
<p>Null-conditional expressions also work with indexers:</p>
<pre data-type="programlisting">string[] words = null;
string word = words?[1];   // word is null</pre>
<p>Upon encountering a null, the Elvis operator short-circuits the remainder of the expression. In the following example, <code>s</code> evaluates to null, even with a standard dot operator between <code>ToString()</code> and <code>ToUpper()</code>:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb<strong>?.</strong>ToString().ToUpper();   // s evaluates to null without error</pre>
<p class="pagebreak-before">Repeated use of Elvis is necessary only if the operand immediately to its left might be null. The following expression is robust to both <code>x</code> being null and <code>x.y</code> being null:</p>
<pre data-type="programlisting">x?.y?.z</pre>
<p>It is equivalent to the following (except that <code>x.y</code> is evaluated only once):</p>
<pre data-type="programlisting">x == null ? null 
          : (x.y == null ? null : x.y.z)</pre>
<p>The final expression must be capable of accepting a null. The following is illegal:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
<strong>int</strong> length = sb?.ToString().Length;   // Illegal : int cannot be null</pre>
<p>We can fix this with the use of nullable value types (see <a data-type="xref" href="ch04.html#nullable_value_types">“Nullable Value Types”</a>). If you’re already familiar with nullable value types, here’s a preview:</p>
<pre data-type="programlisting"><strong>int?</strong> length = sb?.ToString().Length;   // OK: int? can be null</pre>
<p>You can also use the null-conditional operator to call a void method:</p>
<pre data-type="programlisting">someObject<strong>?.</strong>SomeVoidMethod();</pre>
<p>If <code>someObject</code> is null, this becomes a “no-operation” rather than throwing a <code>NullReferenceException</code>.</p>
<p>You can use the null-conditional operator with the commonly used type members that we describe in <a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>, including <em>methods</em>, <em>fields</em>, <em>properties</em>, and <em>indexers</em>. It also combines well with the <em>null-coalescing operator</em>:<a contenteditable="false" data-primary="" data-startref="ch02.html1021" data-type="indexterm" id="id1902"/></p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb?.ToString() <strong>??</strong> "nothing";   // s evaluates to "nothing"</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Statements" data-type="sect1"><div class="sect1" id="statements">
<h1>Statements</h1>
<p><a contenteditable="false" data-primary="statements" data-type="indexterm" id="ch02.html1022"/>Functions comprise statements that execute sequentially in the textual order in which they appear. <a contenteditable="false" data-primary="{} (braces)" data-secondary="enclosing statement blocks" data-type="indexterm" id="id1903"/><a contenteditable="false" data-primary="braces ({})" data-secondary="enclosing statement blocks" data-type="indexterm" id="id1904"/><a contenteditable="false" data-primary="statement block" data-type="indexterm" id="id1905"/>A <em>statement block</em> is a series of statements appearing between braces (the <code>{}</code> tokens).</p>
<section data-pdf-bookmark="Declaration Statements" data-type="sect2"><div class="sect2" id="declaration_statements">
<h2>Declaration Statements</h2>
<p><a contenteditable="false" data-primary="declaration statements" data-type="indexterm" id="id1906"/><a contenteditable="false" data-primary="statements" data-secondary="declaration statements" data-type="indexterm" id="id1907"/>A variable declaration introduces a new variable, optionally initializing it with an expression. You may declare multiple variables of the same type in a comma-separated list:</p>
<pre data-type="programlisting">string someWord = "rosebud";
int someNumber = 42;
bool rich = true, famous = false;</pre>
<p>A constant declaration is like a variable declaration except that it cannot be changed after it has been declared, and the initialization must occur with the declaration (see <a data-type="xref" href="ch03.html#constants">“Constants”</a>):</p>
<pre data-type="programlisting">const double c = 2.99792458E08;
c += 10;                        // Compile-time Error</pre>
<section data-pdf-bookmark="Local variables" data-type="sect3"><div class="sect3" id="local_variables">
<h3>Local variables</h3>
<p><a contenteditable="false" data-primary="local variables" data-secondary="scope of" data-type="indexterm" id="id1908"/>The scope of a local variable or local constant extends throughout the current block. You cannot declare another local variable with the same name in the current block or in any nested blocks:</p>
<pre data-type="programlisting">int x;
{
  int y;
  int x;            // Error - x already defined
}
{
  int y;            // OK - y not in scope
}
Console.Write (y);  // Error - y is out of scope</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A variable’s scope extends in <em>both directions</em> throughout its code block. This means that if we moved the initial declaration of <code>x</code> in this example to the bottom of the method, we’d get the same error. This is in contrast to C++ and is somewhat peculiar, given that it’s not legal to refer to a variable or constant before it’s declared.</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Expression Statements" data-type="sect2"><div class="sect2" id="expression_statements">
<h2>Expression Statements</h2>
<p><a contenteditable="false" data-primary="expression statements" data-type="indexterm" id="id1909"/><a contenteditable="false" data-primary="statements" data-secondary="expression statements" data-type="indexterm" id="id1910"/>Expression statements are expressions that are also valid statements. An expression statement must either change state or call something that might change state. Changing state essentially means changing a variable. Following are the possible expression statements:</p>
<ul>
<li><p>Assignment expressions (including increment and decrement expressions)</p></li>
<li><p>Method call expressions (both void and nonvoid)</p></li>
<li><p>Object instantiation expressions</p></li>
</ul>
<p>Here are some examples:</p>
<pre data-type="programlisting">// Declare variables with declaration statements:
string s;
int x, y;
System.Text.StringBuilder sb;

// Expression statements
x = 1 + 2;                 // Assignment expression
x++;                       // Increment expression
y = Math.Max (x, 5);       // Assignment expression
Console.WriteLine (y);     // Method call expression
sb = new StringBuilder();  // Assignment expression
new StringBuilder();       // Object instantiation expression</pre>
<p>When you call a constructor or a method that returns a value, you’re not obliged to use the result. However, unless the constructor or method changes state, the statement is completely useless:</p>
<pre data-type="programlisting">new StringBuilder();     // Legal, but useless
new string ('c', 3);     // Legal, but useless
x.Equals (y);            // Legal, but useless</pre>
</div></section>
<section data-pdf-bookmark="Selection Statements" data-type="sect2"><div class="sect2" id="selection_statements">
<h2>Selection Statements</h2>
<p><a contenteditable="false" data-primary="selection statements" data-type="indexterm" id="id1911"/><a contenteditable="false" data-primary="statements" data-secondary="selection statements" data-type="indexterm" id="id1912"/>C# has the following mechanisms to conditionally control the flow of program execution:</p>
<ul>
<li><p>Selection statements (<code>if</code>, <code>switch</code>)</p></li>
<li><p>Conditional operator (<code>?:</code>)</p></li>
<li><p>Loop statements (<code>while</code>, <code>do</code>-<code>while</code>, <code>for</code>, <code>foreach</code>)</p></li>
</ul>
<p>This section covers the simplest two constructs: the <code>if</code> statement and the <code>switch</code> statement.</p>
<section data-pdf-bookmark="The if statement" data-type="sect3"><div class="sect3" id="the_if_statement">
<h3>The if statement</h3>
<p><a contenteditable="false" data-primary="if statement" data-type="indexterm" id="id1913"/><a contenteditable="false" data-primary="selection statements" data-secondary="if statement" data-type="indexterm" id="id1914"/>An <code>if</code> statement executes a statement if a <code>bool</code> expression is true:</p>
<pre data-type="programlisting">if (5 &lt; 2 * 3)
  Console.WriteLine ("true");       // true</pre>
<p>The statement can be a code block:</p>
<pre data-type="programlisting">if (5 &lt; 2 * 3)
{
  Console.WriteLine ("true");
  Console.WriteLine ("Let’s move on!");
}</pre>
</div></section>
<section data-pdf-bookmark="The else clause" data-type="sect3"><div class="sect3" id="the_else_clause">
<h3>The else clause</h3>
<p><a contenteditable="false" data-primary="else clause" data-type="indexterm" id="id1915"/><a contenteditable="false" data-primary="selection statements" data-secondary="else clause and" data-type="indexterm" id="id1916"/>An <code>if</code> statement can optionally feature an <code>else</code> clause:</p>
<pre data-type="programlisting">if (2 + 2 == 5)
  Console.WriteLine ("Does not compute");
else
  Console.WriteLine ("False");        // False</pre>
<p>Within an <code>else</code> clause, you can nest another <code>if</code> statement:</p>
<pre data-type="programlisting"><strong>if (2 + 2 == 5)</strong>
  <strong>Console.WriteLine ("Does not compute");</strong>
<strong>else</strong>
  <strong>if (2 + 2 == 4)</strong>
    <strong>Console.WriteLine ("Computes");    // Computes</strong></pre>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Changing the flow of execution with braces" data-type="sect3"><div class="sect3" id="changing_the_flow_of_execution_with_bra">
<h3 class="less_space">Changing the flow of execution with braces</h3>
<p><a contenteditable="false" data-primary="{} (braces)" data-secondary="in if statements" data-type="indexterm" id="id1917"/><a contenteditable="false" data-primary="braces ({})" data-secondary="in if statements" data-type="indexterm" id="id1918"/><a contenteditable="false" data-primary="selection statements" data-secondary="changing the flow of execution with braces" data-type="indexterm" id="id1919"/>An <code>else</code> clause always applies to the immediately preceding <code>if</code> statement in the statement block:</p>
<pre data-type="programlisting">if (true)
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine ("executes");</pre>
<p>This is semantically identical to the following:</p>
<pre data-type="programlisting">if (true)
{
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine ("executes");
}</pre>
<p>We can change the execution flow by moving the braces:</p>
<pre data-type="programlisting">if (true)
{
  if (false)
    Console.WriteLine();
}
else
  Console.WriteLine ("does not execute");</pre>
<p>With braces, you explicitly state your intention. This can improve the readability of nested <code>if</code> statements—even when not required by the compiler. A notable exception is with the following pattern:</p>
<pre data-type="programlisting">void TellMeWhatICanDo (int age)
{
  if (age &gt;= 35)
    Console.WriteLine ("You can be president!");
  <strong>else if</strong> (age &gt;= 21)
    Console.WriteLine ("You can drink!");
  <strong>else if</strong> (age &gt;= 18)
    Console.WriteLine ("You can vote!");
  else
    Console.WriteLine ("You can wait!");
}</pre>
<p>Here, we’ve arranged the <code>if</code> and <code>else</code> statements to mimic the “elseif” construct of other languages (and C#’s <code>#elif</code> preprocessor directive). Visual Studio’s auto-formatting recognizes this pattern and preserves the indentation. Semantically, though, each <code>if</code> statement following an <code>else</code> statement is functionally nested within the <code>else</code> clause.</p>
</div></section>
<section data-pdf-bookmark="The switch statement" data-type="sect3"><div class="sect3" id="the_switch_statement">
<h3>The switch statement</h3>
<p><a contenteditable="false" data-primary="selection statements" data-secondary="switch statements" data-type="indexterm" id="ch02.html1023"/><a contenteditable="false" data-primary="statements" data-secondary="switch statements" data-type="indexterm" id="ch02.html1024"/><a contenteditable="false" data-primary="switch statements" data-type="indexterm" id="ch02.html1025"/><code>switch</code> statements let you branch program execution based on a selection of possible values that a variable might have. <code>switch</code> statements can result in cleaner code than multiple <code>if</code> statements because <code>switch</code> statements require an expression to be evaluated only once:</p>
<pre data-type="programlisting">void ShowCard (int cardNumber)
{
  switch (cardNumber)
  {
    case 13:
      Console.WriteLine ("King");
      break;
    case 12:
      Console.WriteLine ("Queen");
      break;
    case 11:
      Console.WriteLine ("Jack");
      break;
    case -1:                         // Joker is -1
      goto case 12;                  // In this game joker counts as queen
    default:                         // Executes for any other cardNumber
      Console.WriteLine (cardNumber);
      break;
  }
}</pre>
<p>This example demonstrates the most common scenario, which is switching on <em>constants</em>. When you specify a constant, you’re restricted to the built-in numeric types and the <code>bool</code>, <code>char</code>, <code>string</code>, and <code>enum</code> types.</p>
<p>At the end of each <code>case</code> clause, you must specify explicitly where execution is to go next, with some kind of jump statement (unless your code ends in an infinite loop). Here are the options:</p>
<ul>
<li><p><code>break</code> (jumps to the end of the <code>switch</code> statement)</p></li>
<li><p><code>goto case <em>x</em></code> (jumps to another <code>case</code> clause)</p></li>
<li><p><code>goto default</code> (jumps to the <code>default</code> clause)</p></li>
<li><p>Any other jump statement—namely, <code>return</code>, <code>throw</code>, <code>continue</code>, or <code>goto <em>label</em></code></p></li>
</ul>
<p>When more than one value should execute the same code, you can list the common <code>case</code>s sequentially:</p>
<pre data-type="programlisting">switch (cardNumber)
{
  <strong>case 13:</strong>
  <strong>case 12:</strong>
  <strong>case 11:</strong>
    Console.WriteLine ("Face card");
    break;
  default:
    Console.WriteLine ("Plain card");
    break;
}</pre>
<p>This feature of a <code>switch</code> statement can be pivotal in terms of producing cleaner code than multiple <code>if</code>-<code>else</code> statements.<a contenteditable="false" data-primary="" data-startref="ch02.html1025" data-type="indexterm" id="id1920"/><a contenteditable="false" data-primary="" data-startref="ch02.html1024" data-type="indexterm" id="id1921"/><a contenteditable="false" data-primary="" data-startref="ch02.html1023" data-type="indexterm" id="id1922"/></p>
</div></section>
<section data-pdf-bookmark="Switching on types" data-type="sect3"><div class="sect3" id="switching_on_types">
<h3>Switching on types</h3>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="selection statements" data-secondary="switching on types" data-type="indexterm" id="id1923"/>Switching on a type is a special case of switching on a <em>pattern.</em> A number of other patterns have been introduced in recent versions of C#; see <a data-type="xref" href="ch04.html#patterns">“Patterns”</a> for a full discussion.</p>
</div>
<p>You can also switch on <em>types</em> (from C# 7):</p>
<pre data-type="programlisting">TellMeTheType (12);
TellMeTheType ("hello");
TellMeTheType (true);

void TellMeTheType (object x)   // object allows any type.
{
  switch (x)
  {
    case <strong>int i</strong>:
      Console.WriteLine ("It's an int!");
      Console.WriteLine ($"The square of {i} is {i * i}");
      break;
    case <strong>string s</strong>:
      Console.WriteLine ("It's a string");
      Console.WriteLine ($"The length of {s} is {s.Length}");
      break;
    case <strong>DateTime</strong>:
      Console.WriteLine ("It's a DateTime");
      break;
    default:
      Console.WriteLine ("I don't know what x is");
      break;
  }
}</pre>
<p>(The <code>object</code> type allows for a variable of any type; we discuss this fully in <a data-type="xref" href="ch03.html#inheritance">“Inheritance”</a> and <a data-type="xref" href="ch03.html#the_object_type">“The object Type”</a>.)</p>
<p>Each <em>case</em> clause specifies a type upon which to match, and a variable upon which to assign the typed value if the match succeeds (the “pattern” variable). Unlike with constants, there’s no restriction on what types you can use.</p>
<p>You can predicate a <code>case</code> with the <code>when</code> keyword:</p>
<pre data-type="programlisting">switch (x)
{
  case bool b <strong>when b == true:</strong>     // Fires only when b is true
    Console.WriteLine ("True!");
    break;
  case bool b:
    Console.WriteLine ("False!");
    break;
}</pre>
<p>The order of the case clauses can matter when switching on type (unlike when switching on constants). This example would give a different result if we reversed the two cases (in fact, it would not even compile, because the compiler would determine that the second case is unreachable). An exception to this rule is the <code>default</code> clause, which is always executed last, regardless of where it appears.</p>
<p>You can stack multiple case clauses. The <code>Console.WriteLine</code> in the following code will execute for any floating-point type greater than 1,000:</p>
<pre data-type="programlisting">switch (x)
{
  <strong>case float f when f &gt; 1000:</strong>
  <strong>case double d when d &gt; 1000:</strong>
  <strong>case decimal m when m &gt; 1000:</strong>
    Console.WriteLine ("We can refer to <strong>x</strong> here but not <strong>f</strong> or <strong>d</strong> or <strong>m</strong>");
    break;
}</pre>
<p>In this example, the compiler lets us consume the pattern variables <code>f</code>, <code>d</code>, and <code>m</code>, <em>only</em> in the <code>when</code> clauses. When we call <code>Console.WriteLine</code>, it’s unknown which one of those three variables will be assigned, so the compiler puts all of them out of scope.</p>
<p>You can mix and match constants and patterns in the same switch statement. And you can also switch on the null value:</p>
<pre data-type="programlisting">case <strong>null:</strong>
  Console.WriteLine ("Nothing here");
  break;</pre>
</div></section>
<section data-pdf-bookmark="Switch expressions" data-type="sect3"><div class="sect3" id="switch_expressions-id00093">
<h3>Switch expressions</h3>
<p><a contenteditable="false" data-primary="C# 8" data-primary-sortas="C# 08" data-secondary="switch expressions" data-type="indexterm" id="id1924"/><a contenteditable="false" data-primary="expressions" data-secondary="switch expressions" data-type="indexterm" id="id1925"/><a contenteditable="false" data-primary="selection statements" data-secondary="switch expressions" data-type="indexterm" id="id1926"/><a contenteditable="false" data-primary="switch expressions" data-type="indexterm" id="id1927"/>From C# 8, you can use <code>switch</code> in the context of an <em>expression</em>. Assuming that <code>cardNumber</code> is of type <code>int</code>, the following illustrates its use:</p>
<pre data-type="programlisting">string cardName = cardNumber <strong>switch</strong>
{
  13 <strong>=&gt;</strong> "King"<strong>,</strong>
  12 <strong>=&gt;</strong> "Queen"<strong>,</strong>
  11 <strong>=&gt;</strong> "Jack"<strong>,</strong>
  <strong>_ =&gt;</strong> "Pip card"   // equivalent to 'default'
};</pre>
<p>Notice that the <code>switch</code> keyword appears <em>after</em> the variable name, and that the case clauses are expressions (terminated by commas) rather than statements. Switch expressions are more compact than their switch statement counterparts, and you can use them in LINQ queries (<a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>).</p>
<p>If you omit the default expression (<code>_</code>) and the switch fails to match, an exception is thrown.</p>
<p>You can also switch on multiple values (the <em>tuple</em> pattern):</p>
<pre data-type="programlisting">int cardNumber = 12;
string suite = "spades";

string cardName = <strong>(cardNumber, suite)</strong> switch
{
  <strong>(13, "spades")</strong> =&gt; "King of spades",
  <strong>(13, "clubs")</strong> =&gt; "King of clubs",
  ...
};</pre>
<p>Many more options are possible through the use of <em>patterns</em> (see <a data-type="xref" href="ch04.html#patterns">“Patterns”</a>).</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Iteration Statements" data-type="sect2"><div class="sect2" id="iteration_statements">
<h2>Iteration Statements</h2>
<p><a contenteditable="false" data-primary="iteration statements" data-type="indexterm" id="ch02.html1026"/><a contenteditable="false" data-primary="statements" data-secondary="iteration statements" data-type="indexterm" id="ch02.html1027"/>C# enables a sequence of statements to execute repeatedly with the <code>while</code>, <code>do-while</code>, <code>for</code>, and <code>foreach</code> statements.</p>
<section data-pdf-bookmark="while and do-while loops" data-type="sect3"><div class="sect3" id="while_and_do_while_loops">
<h3>while and do-while loops</h3>
<p><a contenteditable="false" data-primary="iteration statements" data-secondary="while and do-while loops" data-type="indexterm" id="id1928"/><a contenteditable="false" data-primary="while loops" data-type="indexterm" id="id1929"/><code>while</code> loops repeatedly execute a body of code while a <code>bool</code> expression is true. The expression is tested <em>before</em> the body of the loop is executed. For example, the following writes <code>012</code>:</p>
<pre data-type="programlisting">int i = 0;
while (i &lt; 3)
{
  Console.Write (i);
  i++;
}</pre>
<p><a contenteditable="false" data-primary="do-while loops" data-type="indexterm" id="id1930"/><code>do-while</code> loops differ in functionality from <code>while</code> loops only in that they test the expression <em>after</em> the statement block has executed (ensuring that the block is always executed at least once). Here’s the preceding example rewritten with a <code>do-while</code> loop:</p>
<pre data-type="programlisting">int i = 0;
do
{
  Console.WriteLine (i);
  i++;
}
while (i &lt; 3);</pre>
</div></section>
<section data-pdf-bookmark="for loops" data-type="sect3"><div class="sect3" id="for_loops">
<h3>for loops</h3>
<p><a contenteditable="false" data-primary="for loops" data-type="indexterm" id="id1931"/><a contenteditable="false" data-primary="iteration statements" data-secondary="for loops" data-type="indexterm" id="id1932"/><code>for</code> loops are like <code>while</code> loops with special clauses for <em>initialization</em> and <em>iteration</em> of a loop variable. A <code>for</code> loop contains three clauses as follows:</p>
<pre data-type="programlisting">for (<em>initialization-clause</em>; <em>condition-clause</em>; <em>iteration-clause</em>)
  <em>statement-or-statement-block</em></pre>
<p>Here’s what each clause does:</p>
<dl>
<dt>Initialization clause</dt>
<dd>Executed before the loop begins; used to initialize one or more <em>iteration</em> variables</dd>
<dt>Condition clause</dt>
<dd>The <code>bool</code> expression that, while true, will execute the body</dd>
<dt>Iteration clause</dt>
<dd>Executed <em>after</em> each iteration of the statement block; used typically to update the iteration variable</dd>
</dl>
<p>For example, the following prints the numbers 0 through 2:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; 3; i++)
  Console.WriteLine (i);</pre>
<p>The following prints the first 10 Fibonacci numbers (in which each number is the sum of the previous two):</p>
<pre data-type="programlisting">for (int i = 0, prevFib = 1, curFib = 1; i &lt; 10; i++)
{
  Console.WriteLine (prevFib);
  int newFib = prevFib + curFib;
  prevFib = curFib; curFib = newFib;
}</pre>
<p>Any of the three parts of the <code>for</code> statement can be omitted. You can implement an infinite loop such as the following (though <code>while(true)</code> can be used, instead):</p>
<pre data-type="programlisting">for (;;)
  Console.WriteLine ("interrupt me");</pre>
</div></section>
<section data-pdf-bookmark="foreach loops" data-type="sect3"><div class="sect3" id="foreach_loops">
<h3>foreach loops</h3>
<p><a contenteditable="false" data-primary="foreach loops" data-type="indexterm" id="id1933"/><a contenteditable="false" data-primary="iteration statements" data-secondary="foreach loops" data-type="indexterm" id="id1934"/>The <code>foreach</code> statement iterates over each element in an enumerable object. Most of the .NET types that represent a set or list of elements are enumerable. For example, both an array and a string are enumerable. Here is an example of enumerating over the characters in a string, from the first character through to the last:</p>
<pre data-type="programlisting">foreach (char c in "beer")   // c is the <em>iteration variable</em>
  Console.WriteLine (c);</pre>
<p>Here’s the output:</p>
<pre data-type="programlisting">b
e
e
r</pre>
<p>We define enumerable objects in <a data-type="xref" href="ch04.html#enumeration_and_iterators">“Enumeration and Iterators”</a>.<a contenteditable="false" data-primary="" data-startref="ch02.html1027" data-type="indexterm" id="id1935"/><a contenteditable="false" data-primary="" data-startref="ch02.html1026" data-type="indexterm" id="id1936"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Jump Statements" data-type="sect2"><div class="sect2" id="jump_statements">
<h2>Jump Statements</h2>
<p><a contenteditable="false" data-primary="jump statements" data-type="indexterm" id="ch02.html1028"/><a contenteditable="false" data-primary="statements" data-secondary="jump statements" data-type="indexterm" id="ch02.html1029"/>The C# jump statements are <code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code>, and <code>throw</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Jump statements obey the reliability rules of <code>try</code> statements (see <a data-type="xref" href="ch04.html#try_statements_and_exceptions">“try Statements and Exceptions”</a>). This means that:</p>
<ul>
<li><p>A jump out of a <code>try</code> block always executes the <code>try</code>’s <code>finally</code> block before reaching the target of the jump.</p></li>
<li><p>A jump cannot be made from the inside to the outside of a <code>finally</code> block (except via <code>throw</code>).</p></li>
</ul>
</div>
<section data-pdf-bookmark="The break statement" data-type="sect3"><div class="sect3" id="the_break_statement">
<h3>The break statement</h3>
<p><a contenteditable="false" data-primary="break statement" data-type="indexterm" id="id1937"/><a contenteditable="false" data-primary="jump statements" data-secondary="break statement" data-type="indexterm" id="id1938"/>The <code>break</code> statement ends the execution of the body of an iteration or <code>switch</code> statement:</p>
<pre data-type="programlisting">int x = 0;
while (true)
{
  if (x++ &gt; 5)
    <strong>break</strong>;      // break from the loop
}
// execution continues here after break
...</pre>
</div></section>
<section data-pdf-bookmark="The continue statement" data-type="sect3"><div class="sect3" id="the_continue_statement">
<h3>The continue statement</h3>
<p><a contenteditable="false" data-primary="continue statement" data-type="indexterm" id="id1939"/><a contenteditable="false" data-primary="jump statements" data-secondary="continue statement" data-type="indexterm" id="id1940"/>The <code>continue</code> statement forgoes the remaining statements in a loop and makes an early start on the next iteration. The following loop skips even numbers:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; 10; i++)
{
  if ((i % 2) == 0)       // If i is even,
    continue;             // continue with next iteration

  Console.Write (i + " ");
}

OUTPUT: 1 3 5 7 9</pre>
</div></section>
<section data-pdf-bookmark="The goto statement" data-type="sect3"><div class="sect3" id="the_goto_statement">
<h3>The goto statement</h3>
<p><a contenteditable="false" data-primary="goto statement" data-type="indexterm" id="id1941"/><a contenteditable="false" data-primary="jump statements" data-secondary="goto statement" data-type="indexterm" id="id1942"/>The <code>goto</code> statement transfers execution to another label within a statement block. The form is as follows:</p>
<pre data-type="programlisting">goto <em>statement-label</em>;</pre>
<p>Or, when used within a <code>switch</code> statement:</p>
<pre data-type="programlisting">goto case <em>case-constant</em>;    // (Only works with constants, not patterns)</pre>
<p>A label is a placeholder in a code block that precedes a statement, denoted with a colon suffix. The following iterates the numbers 1 through 5, mimicking a <code>for</code> loop:</p>
<pre data-type="programlisting">int i = 1;
<strong>startLoop:</strong>
if (i &lt;= 5)
{
  Console.Write (i + " ");
  i++;
  <strong>goto startLoop;</strong>
}

OUTPUT: 1 2 3 4 5</pre>
<p>The <code>goto case <em>case-constant</em></code> transfers execution to another case in a <code>switch</code> block (see <a data-type="xref" href="#the_switch_statement">“The switch statement”</a>).</p>
</div></section>
<section data-pdf-bookmark="The return statement" data-type="sect3"><div class="sect3" id="the_return_statement">
<h3>The return statement</h3>
<p><a contenteditable="false" data-primary="jump statements" data-secondary="return statement" data-type="indexterm" id="id1943"/><a contenteditable="false" data-primary="return statement" data-type="indexterm" id="id1944"/>The <code>return</code> statement exits the method and must return an expression of the method’s return type if the method is nonvoid:</p>
<pre data-type="programlisting">decimal AsPercentage (decimal d)
{
  decimal p = d * 100m;
  return p;             // Return to the calling method with value
}</pre>
<p>A <code>return</code> statement can appear anywhere in a method (except in a <code>finally</code> block), and can be used more than once.</p>
</div></section>
<section data-pdf-bookmark="The throw statement" data-type="sect3"><div class="sect3" id="the_throw_statement">
<h3>The throw statement</h3>
<p><a contenteditable="false" data-primary="jump statements" data-secondary="throw statement" data-type="indexterm" id="id1945"/><a contenteditable="false" data-primary="throw statement" data-type="indexterm" id="id1946"/>The <code>throw</code> statement throws an exception to indicate an error has occurred (see <a data-type="xref" href="ch04.html#try_statements_and_exceptions">“try Statements and Exceptions”</a>):<a contenteditable="false" data-primary="" data-startref="ch02.html1029" data-type="indexterm" id="id1947"/><a contenteditable="false" data-primary="" data-startref="ch02.html1028" data-type="indexterm" id="id1948"/></p>
<pre data-type="programlisting">if (w == null)
  throw new ArgumentNullException (...);</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Miscellaneous Statements" data-type="sect2"><div class="sect2" id="miscellaneous_statements">
<h2>Miscellaneous Statements</h2>
<p><a contenteditable="false" data-primary="using statement" data-type="indexterm" id="id1949"/>The <code>using</code> statement provides an elegant syntax for calling <code>Dispose</code> on objects that implement <code>IDisposable</code>, within a <code>finally</code> block (see <a data-type="xref" href="ch04.html#try_statements_and_exceptions">“try Statements and Exceptions”</a> and <a data-type="xref" href="ch12.html#idisposablecomma_disposecomma_and_close">“IDisposable, Dispose, and Close”</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# overloads the <code>using</code> keyword to have independent meanings in different contexts. Specifically, the <code>using</code> <em>directive</em> is different from the <code>using</code> <em>statement</em>.</p>
</div>
<p><a contenteditable="false" data-primary="lock statement" data-type="indexterm" id="id1950"/>The <code>lock</code> statement is a shortcut for calling the <code>Enter</code> and <code>Exit</code> methods of the <code>Monitor</code> class (see Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch14.html#concurrency_and_asynchron">14</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch23.html#spanless_thantgreater_than_and-id00089">23</a>).<a contenteditable="false" data-primary="" data-startref="ch02.html1022" data-type="indexterm" id="id1951"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Namespaces" data-type="sect1"><div class="sect1" id="namespaces-id00029">
<h1>Namespaces</h1>
<p><a contenteditable="false" data-primary="namespaces" data-type="indexterm" id="ch02.html1030"/>A namespace is a domain for type names. Types are typically organized into hierarchical namespaces, making them easier to find and avoiding conflicts. For example, the <code>RSA</code> type that handles public key encryption is defined within the following namespace:</p>
<pre data-type="programlisting">System.Security.Cryptography</pre>
<p>A namespace forms an integral part of a type’s name. The following code calls <code>RSA</code>’s <code>Create</code> method:</p>
<pre data-type="programlisting">System.Security.Cryptography.RSA rsa =
  System.Security.Cryptography.RSA.Create();</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Namespaces are independent of assemblies, which are <em>.dll</em> files that serve as units of deployment (described in <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>).</p>
<p>Namespaces also have no impact on member visibility—<code>public</code>, <code>internal</code>, <code>private</code>, and so on.</p>
</div>
<p>The <code>namespace</code> keyword defines a namespace for types within that block; for <span class="keep-together">example:</span></p>
<pre data-type="programlisting">namespace Outer.Middle.Inner
{
  class Class1 {}
  class Class2 {}
}</pre>
<p>The dots in the namespace indicate a hierarchy of nested namespaces. The code that follows is semantically identical to the preceding example:</p>
<pre data-type="programlisting">namespace Outer
{
  namespace Middle
  {
    namespace Inner
    {
      class Class1 {}
      class Class2 {}
    }
  }
}</pre>
<p>You can refer to a type with its <em>fully qualified name</em>, which includes all namespaces from the outermost to the innermost. For example, we could refer to <code>Class1</code> in the preceding example as <code>Outer.Middle.Inner.Class1</code>.</p>
<p>Types not defined in any namespace are said to reside in the <em>global namespace</em>. The global namespace also includes top-level namespaces, such as <code>Outer</code> in our example.</p>
<section class="pagebreak-before" data-pdf-bookmark="File-Scoped Namespaces" data-type="sect2"><div class="sect2" id="file_scoped_namespaces-id00068">
<h2 class="less_space">File-Scoped Namespaces</h2>
<p><a contenteditable="false" data-primary="C# 10" data-secondary="file-scoped namespaces" data-type="indexterm" id="id1952"/><a contenteditable="false" data-primary="file-scoped namespaces" data-type="indexterm" id="id1953"/><a contenteditable="false" data-primary="namespaces" data-secondary="file-scoped" data-type="indexterm" id="id1954"/>Often, you will want all the types in a file to be defined in one namespace:</p>
<pre data-type="programlisting">namespace MyNamespace
{
  class Class1 {}
  class Class2 {}
}</pre>
<p>From C# 10, you can accomplish this with a <em>file-scoped namespace</em>:</p>
<pre data-type="programlisting"><strong>namespace MyNamespace;</strong>  // Applies to everything that follows in the file.

class Class1 {}         // inside MyNamespace
class Class2 {}         // inside MyNamespace</pre>
<p>File-scoped namespaces reduce clutter and eliminate an unnecessary level of indentation.</p>
</div></section>
<section data-pdf-bookmark="The using Directive" data-type="sect2"><div class="sect2" id="the_using_directive">
<h2>The using Directive</h2>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="using directive and" data-type="indexterm" id="id1955"/><a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id1956"/>The <code>using</code> directive <em>imports</em> a namespace, allowing you to refer to types without their fully qualified names. The following imports the previous example’s <code>Outer​.Mid⁠dle.Inner</code> namespace:</p>
<pre data-type="programlisting">using Outer.Middle.Inner;

<strong>Class1 c;    // Don’t need fully qualified name</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s legal (and often desirable) to define the same type name in different namespaces. However, you’d typically do so only if it was unlikely for a consumer to want to import both namespaces at once. A good example is the <code>TextBox</code> class, which is defined both in <code>System.Windows.Controls</code> (WPF) and <code>System.Windows.Forms</code> (Windows Forms).</p>
</div>
<p>A <code>using</code> directive can be nested within a namespace itself to limit the scope of the directive.</p>
</div></section>
<section data-pdf-bookmark="The global using Directive" data-type="sect2"><div class="sect2" id="the_global_using_directive-id00095">
<h2>The global using Directive</h2>
<p><a contenteditable="false" data-primary="C# 10" data-secondary="global using directive" data-type="indexterm" id="id1957"/><a contenteditable="false" data-primary="global using directive (C# 10)" data-type="indexterm" id="id1958"/>From C# 10, if you prefix a <code>using</code> directive with the <code>global</code> keyword, the directive will apply to all files in the project or compilation unit:</p>
<pre data-type="programlisting"><strong>global</strong> using System;
<strong>global</strong> using System.Collection.Generic;</pre>
<p>This lets you centralize common imports and avoid repeating the same directives in every file.</p>
<p><code>global using</code> directives must precede nonglobal directives and cannot appear inside namespace declarations. The global directive can be used with <code>using static</code>.</p>
<section data-pdf-bookmark="Implicit global usings" data-type="sect3"><div class="sect3" id="implicit_global_usings">
<h3>Implicit global usings</h3>
<p><a contenteditable="false" data-primary="implicit global using directives" data-type="indexterm" id="id1959"/>From .NET 6, project files allow for implicit <code>global using</code> directives. If the <code>Implici⁠t​Usings</code> element is set to true in the project file (the default for new projects), the following namespaces are automatically imported:</p>
<pre data-type="programlisting">System
System.Collections.Generic
System.IO
System.Linq
System.Net.Http
System.Threading
System.Threading.Tasks</pre>
<p>Additional namespaces are imported, based on the project SDK (Web, Windows Forms, WPF, and so on).</p>
</div></section>
</div></section>
<section data-pdf-bookmark="using static" data-type="sect2"><div class="sect2" id="using_static">
<h2>using static</h2>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="using static directive and" data-type="indexterm" id="id1960"/><a contenteditable="false" data-primary="using static directive" data-type="indexterm" id="id1961"/>The <code>using static</code> directive imports a <em>type</em> rather than a namespace. All static members of the imported type can then be used without qualification. In the following example, we call the <code>Console</code> class’s static <code>WriteLine</code> method without needing to refer to the type:</p>
<pre data-type="programlisting"><strong>using static System.Console;</strong>

<strong>WriteLine</strong> ("Hello");</pre>
<p>The <code>using static</code> directive imports all accessible static members of the type, including fields, properties, and nested types (<a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>). You can also apply this directive to enum types (<a data-type="xref" href="ch03.html#creating_types_in_chash">Chapter 3</a>), in which case their members are imported. So, if we import the following enum type:</p>
<pre data-type="programlisting">using static System.Windows.Visibility;</pre>
<p>we can specify <code>Hidden</code> instead of <code>Visibility.Hidden</code>:</p>
<pre data-type="programlisting">var textBox = new TextBox { Visibility = <strong>Hidden</strong> };   // XAML-style</pre>
<p>Should an ambiguity arise between multiple static imports, the C# compiler is not smart enough to infer the correct type from the context and will generate an error.</p>
</div></section>
<section data-pdf-bookmark="Rules Within a Namespace" data-type="sect2"><div class="sect2" id="rules_within_a_namespace">
<h2>Rules Within a Namespace</h2>
<section data-pdf-bookmark="Name scoping" data-type="sect3"><div class="sect3" id="name_scoping">
<h3>Name scoping</h3>
<p><a contenteditable="false" data-primary="name scoping" data-type="indexterm" id="id1962"/><a contenteditable="false" data-primary="namespaces" data-secondary="name scoping" data-type="indexterm" id="id1963"/><a contenteditable="false" data-primary="namespaces" data-secondary="rules within" data-type="indexterm" id="ch02.html1031"/>Names declared in outer namespaces can be used unqualified within inner namespaces. In this example, <code>Class1</code> does not need qualification within <code>Inner</code>:</p>
<pre data-type="programlisting">namespace Outer
{
  class Class1 {}

  namespace Inner
  {
    class Class2 : <strong>Class1</strong>  {}
  }
}</pre>
<p>If you want to refer to a type in a different branch of your namespace hierarchy, you can use a partially qualified name. In the following example, we base <code>SalesReport</code> on <code>Common.ReportBase</code>:</p>
<pre data-type="programlisting">namespace MyTradingCompany
{
  namespace Common
  {
    class ReportBase {}
  }
  namespace ManagementReporting
  {
    class SalesReport : <strong>Common.ReportBase</strong>  {}
  }
}</pre>
</div></section>
<section data-pdf-bookmark="Name hiding" data-type="sect3"><div class="sect3" id="name_hiding">
<h3>Name hiding</h3>
<p><a contenteditable="false" data-primary="name hiding" data-type="indexterm" id="id1964"/><a contenteditable="false" data-primary="namespaces" data-secondary="name hiding" data-type="indexterm" id="id1965"/>If the same type name appears in both an inner and an outer namespace, the inner name wins. To refer to the type in the outer namespace, you must qualify its name:</p>
<pre data-type="programlisting">namespace Outer
{
  class Foo { }

  namespace Inner
  {
    class Foo { }

    class Test
    {
      Foo f1;         // = Outer.Inner.Foo
      Outer.Foo f2;   // = Outer.Foo
    }
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All type names are converted to fully qualified names at compile time. Intermediate Language (IL) code contains no unqualified or partially qualified names.</p>
</div>
</div></section>
<section data-pdf-bookmark="Repeated namespaces" data-type="sect3"><div class="sect3" id="repeated_namespaces">
<h3>Repeated namespaces</h3>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="repeated" data-type="indexterm" id="id1966"/>You can repeat a namespace declaration, as long as the type names within the namespaces don’t conflict:</p>
<pre data-type="programlisting">namespace Outer.Middle.Inner
{
  class Class1 {}
}

namespace Outer.Middle.Inner
{
  class Class2 {}
}</pre>
<p>We can even break the example into two source files such that we could compile each class into a different assembly.</p>
<p>Source file 1:</p>
<pre data-type="programlisting">namespace Outer.Middle.Inner
{
  class Class1 {}
}</pre>
<p>Source file 2:</p>
<pre data-type="programlisting">namespace Outer.Middle.Inner
{
  class Class2 {}
}</pre>
</div></section>
<section data-pdf-bookmark="Nested using directives" data-type="sect3"><div class="sect3" id="nested_using_directives">
<h3>Nested using directives</h3>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="nested using directives withing" data-type="indexterm" id="id1967"/><a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id1968"/>You can nest a <code>using</code> directive within a namespace. This allows you to scope the <code>using</code> directive within a namespace declaration. In the following example, <code>Class1</code> is visible in one scope but not in another:<a contenteditable="false" data-primary="" data-startref="ch02.html1031" data-type="indexterm" id="id1969"/></p>
<pre data-type="programlisting">namespace N1
{
  class Class1 {}
}

namespace N2
{
  using N1;

  class Class2 : Class1 {}
}

namespace N2
{
  class Class3 : Class1 {}   // Compile-time error
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Aliasing Types and Namespaces" data-type="sect2"><div class="sect2" id="aliasing_types_and_namespaces">
<h2>Aliasing Types and Namespaces</h2>
<p><a contenteditable="false" data-primary="aliasing" data-secondary="types within namespaces" data-type="indexterm" id="id1970"/><a contenteditable="false" data-primary="namespaces" data-secondary="aliasing types and" data-type="indexterm" id="id1971"/><a contenteditable="false" data-primary="types" data-secondary="aliasing within namespaces" data-type="indexterm" id="id1972"/>Importing a namespace can result in type-name collision. Rather than importing the entire namespace, you can import just the specific types that you need, giving each type an alias:</p>
<pre data-type="programlisting">using PropertyInfo2 = System.Reflection.PropertyInfo;
class Program { PropertyInfo2 p; }</pre>
<p class="pagebreak-before">An entire namespace can be aliased, as follows:</p>
<pre data-type="programlisting">using R = System.Reflection;
class Program { R.PropertyInfo p; }</pre>
<section data-pdf-bookmark="Alias any type (C# 12)" data-type="sect3"><div class="sect3" id="alias_any_type_left_parenthesischash_on">
<h3>Alias any type (C# 12)</h3>
<p><a contenteditable="false" data-primary="aliasing" data-secondary="any type" data-type="indexterm" id="id1973"/><a contenteditable="false" data-primary="C# 12" data-secondary="aliasing any type" data-type="indexterm" id="id1974"/><a contenteditable="false" data-primary="types" data-secondary="aliasing any type (C# 12)" data-type="indexterm" id="id1975"/>From C# 12, the <code>using</code> directive can alias any kind of type, including, for instance, arrays:</p>
<pre data-type="programlisting">using NumberList = double[];
NumberList numbers = { 2.5, 3.5 };</pre>
<p>You can also alias tuples—we cover this in <a data-type="xref" href="ch04.html#aliasing_tuples_left_parenthesischash_o">“Aliasing Tuples (C# 12)”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Advanced Namespace Features" data-type="sect2"><div class="sect2" id="advanced_namespace_features">
<h2>Advanced Namespace Features</h2>
<section data-pdf-bookmark="Extern" data-type="sect3"><div class="sect3" id="extern">
<h3>Extern</h3>
<p><a contenteditable="false" data-primary="extern aliases" data-type="indexterm" id="id1976"/><a contenteditable="false" data-primary="namespaces" data-secondary="extern aliases" data-type="indexterm" id="id1977"/>Extern <a contenteditable="false" data-primary="namespaces" data-secondary="advanced features" data-type="indexterm" id="ch02.html1032"/>aliases allow your program to reference two types with the same fully qualified name (i.e., the namespace and type name are identical). This is an unusual scenario and can occur only when the two types come from different assemblies. Consider the following example.</p>
<p>Library 1, compiled to <em>Widgets1.dll</em>:</p>
<pre data-type="programlisting">namespace Widgets
{
  public class Widget {}
}</pre>
<p>Library 2, compiled to <em>Widgets2.dll</em>:</p>
<pre data-type="programlisting">namespace Widgets
{
  public class Widget {}
}</pre>
<p>Application, which references <em>Widgets1.dll</em> and <em>Widgets2.dll</em>:</p>
<pre data-type="programlisting">using Widgets;

Widget w = new Widget();</pre>
<p>The application cannot compile, because <code>Widget</code> is ambiguous. Extern aliases can resolve the ambiguity. The first step is to modify the application’s <em>.csproj</em> file, assigning a unique alias to each reference:</p>
<pre data-type="programlisting">&lt;ItemGroup&gt;
  &lt;Reference Include="Widgets1"&gt;
    <strong>&lt;Aliases&gt;W1&lt;/Aliases&gt;</strong>
  &lt;/Reference&gt;
  &lt;Reference Include="Widgets2"&gt;
    <strong>&lt;Aliases&gt;W2&lt;/Aliases&gt;</strong>
  &lt;/Reference&gt;
&lt;/ItemGroup&gt;</pre>
<p>The second step is to use the <code>extern alias</code> directive:</p>
<pre data-type="programlisting"><strong>extern alias W1;</strong>
<strong>extern alias W2;</strong>

W1.Widgets.Widget w1 = new W1.Widgets.Widget();
W2.Widgets.Widget w2 = new W2.Widgets.Widget();</pre>
</div></section>
<section data-pdf-bookmark="Namespace alias qualifiers" data-type="sect3"><div class="sect3" id="namespace_alias_qualifiers">
<h3>Namespace alias qualifiers</h3>
<p><a contenteditable="false" data-primary="aliasing" data-secondary="namespace alias qualifiers" data-type="indexterm" id="id1978"/><a contenteditable="false" data-primary="namespaces" data-secondary="alias qualifiers" data-type="indexterm" id="id1979"/>As we mentioned earlier, names in inner namespaces hide names in outer namespaces. However, sometimes even the use of a fully qualified type name does not resolve the conflict. Consider the following example:</p>
<pre data-type="programlisting">namespace N
{
  class A
  {
    static void Main() =&gt; new A.B();     // Instantiate class B
    public class B {}                    // Nested type
  }
}

namespace A
{
  class B {}
}</pre>
<p>The <code>Main</code> method could be instantiating either the nested class <code>B</code>, or the class <code>B</code> within the namespace <code>A</code>. The compiler always gives higher precedence to identifiers in the current namespace (in this case, the nested <code>B</code> class).</p>
<p>To resolve such conflicts, a namespace name can be qualified, relative to one of the following:</p>
<ul>
<li><p><a contenteditable="false" data-primary="global keyword" data-type="indexterm" id="id1980"/>The global namespace—the root of all namespaces (identified with the contextual keyword <code>global</code>)</p></li>
<li><p>The set of extern aliases</p></li>
</ul>
<p><a contenteditable="false" data-primary=":: (namespace alias qualification)" data-type="indexterm" id="id1981"/><a contenteditable="false" data-primary="namespace alias qualification (::)" data-type="indexterm" id="id1982"/>The <code>::</code> token performs namespace alias qualification. In this example, we qualify using the global namespace (this is most commonly seen in autogenerated code to avoid name conflicts):</p>
<pre data-type="programlisting">namespace N
{
  class A
  {
    static void Main()
    {
      System.Console.WriteLine (new A.B());
      System.Console.WriteLine (new global::A.B());
    }

    public class B {}
  }
}

namespace A
{
  class B {}
}</pre>
<p><a contenteditable="false" data-primary="" data-startref="ch02.html1032" data-type="indexterm" id="id1983"/> Here is an example of qualifying with an alias (adapted from the example in <a data-type="xref" href="#extern">“Extern”</a>):<a contenteditable="false" data-primary="" data-startref="ch02.html1030" data-type="indexterm" id="id1984"/><a contenteditable="false" data-primary="" data-startref="ch02.html100" data-type="indexterm" id="id1985"/></p>
<pre data-type="programlisting">extern alias W1;
extern alias W2;

W1::Widgets.Widget w1 = new W1::Widgets.Widget();
W2::Widgets.Widget w2 = new W2::Widgets.Widget();</pre>
</div></section>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn1"><sup><a href="ch02.html#ch01fn1-marker">1</a></sup> A minor caveat is that very large <code>long</code> values lose some precision when converted to <code>double</code>.</p><p data-type="footnote" id="ch01fn2"><sup><a href="ch02.html#ch01fn2-marker">2</a></sup> Technically, <code>decimal</code> is a floating-point type, too, although it’s not referred to as such in the C# language specification.</p><p data-type="footnote" id="ch01fn3"><sup><a href="ch02.html#ch01fn3-marker">3</a></sup> It’s possible to <em>overload</em> these operators (<a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a>) such that they return a non-<code>bool</code> type, but this is almost never done in practice.</p><p data-type="footnote" id="ch01fn4"><sup><a href="ch02.html#ch01fn4-marker">4</a></sup> An exception to this rule is when calling Component Object Model (COM) methods. We discuss this in <a data-type="xref" href="ch25.html#regular_expressions-id00102">Chapter 25</a>.</p></div></div></section></body></html>