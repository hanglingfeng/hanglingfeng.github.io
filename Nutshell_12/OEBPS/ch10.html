<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>LINQ to XML</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="LINQ to XML" data-pdf-bookmark="Chapter 10. LINQ to XML" data-type="chapter" epub:type="chapter"><div class="chapter" id="linq_to_xml">
<h1><span class="label">Chapter 10. </span>LINQ to XML</h1>

<p>.<a contenteditable="false" data-primary="LINQ to XML" data-type="indexterm" id="ch10.html0"/>NET provides a number of APIs for working with XML data. The primary choice for general-purpose XML document processing is <em>LINQ to XML</em>. LINQ to XML comprises a lightweight, LINQ-friendly XML document object model (DOM), plus a set of supplementary query operators.</p>

<p>In this chapter, we concentrate entirely on LINQ to XML. In <a data-type="xref" href="ch11.html#other_xml_and_json_technologies">Chapter 11</a>, we cover the forward-only XML reader/writer, and in the <a href="http://www.albahari.com/nutshell">online supplement</a>, we cover the types for working with schemas and stylesheets. .NET also includes the legacy <code>XmlDocument</code>-based DOM, which we don’t cover.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The LINQ to XML DOM is extremely well designed and highly performant. Even without LINQ, the LINQ to XML DOM is valuable as a lightweight façade over the low-level <code>XmlReader</code> and <code>XmlWriter</code> classes.</p>
</div>

<p>All LINQ to XML types are defined in the <code>System.Xml.Linq</code> namespace.</p>

<section data-pdf-bookmark="Architectural Overview" data-type="sect1"><div class="sect1" id="architectural_overview">
<h1>Architectural Overview</h1>

<p><a contenteditable="false" data-primary="DOM (document object model)" data-secondary="basics" data-type="indexterm" id="id3359"/><a contenteditable="false" data-primary="LINQ to XML" data-secondary="architectural overview" data-type="indexterm" id="id3360"/>This section starts with a very brief introduction to the concept of a DOM, and then explains the rationale behind LINQ to XML’s DOM.</p>

<section data-pdf-bookmark="What Is a DOM?" data-type="sect2"><div class="sect2" id="what_is_a_domquestion_mark">
<h2>What Is a DOM?</h2>

<p>Consider the following XML file:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;customer id="123" status="archived"&gt;
  &lt;firstname&gt;Joe&lt;/firstname&gt;
  &lt;lastname&gt;Bloggs&lt;/lastname&gt;
&lt;/customer&gt;</pre>

<p class="pagebreak-before">As with all XML files, we start with a <em>declaration</em> and then a root <em>element</em>, whose name is <code>customer</code>. The <code>customer</code> element has two <em>attributes</em>, each with a name (<code>id</code> and <code>status</code>) and value (<code>"123"</code> and <code>"archived"</code>). Within <code>customer</code>, there are two child elements, <code>firstname</code> and <code>lastname</code>, each having simple text content (<code>"Joe"</code> and <code>"Bloggs"</code>).</p>

<p>Each of these constructs—declaration, element, attribute, value, and text content—can be represented with a class. And if such classes have collection properties for storing child content, we can assemble a <em>tree</em> of objects to fully describe a document. This is called a <em>Document Object Model</em>, or DOM.</p>
</div></section>

<section data-pdf-bookmark="The LINQ to XML DOM" data-type="sect2"><div class="sect2" id="the_linq_to_xml_dom">
<h2>The LINQ to XML DOM</h2>

<p><a contenteditable="false" data-primary="LINQ to XML" data-secondary="LINQ to XML DOM" data-type="indexterm" id="id3361"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-type="indexterm" id="id3362"/>LINQ to XML comprises two things:</p>

<ul>
	<li>
	<p>An XML DOM, which we call the <em>X-DOM</em></p>
	</li>
	<li>
	<p>A set of about 10 supplementary query operators</p>
	</li>
</ul>

<p>As you might expect, the X-DOM consists of types such as <code>XDocument</code>, <code>XElement</code>, and <code>XAttribute</code>. Interestingly, the X-DOM types are not tied to LINQ—you can load, instantiate, update, and save an X-DOM without ever writing a LINQ query.</p>

<p>Conversely, you could use LINQ to query a DOM created of the older W3C-compliant types. However, this would be frustrating and limiting. The distinguishing feature of the X-DOM is that it’s <em>LINQ-friendly</em>, meaning:</p>

<ul>
	<li>
	<p>It has methods that emit useful <code>IEnumerable</code> sequences upon which you can query.</p>
	</li>
	<li>
	<p>Its constructors are designed such that you can build an X-DOM tree through a LINQ projection.</p>
	</li>
</ul>
</div></section>
</div></section>

<section data-pdf-bookmark="X-DOM Overview" data-type="sect1"><div class="sect1" id="x_dom_overview">
<h1>X-DOM Overview</h1>

<p><a contenteditable="false" data-primary="XElement" data-type="indexterm" id="ch10.html1"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="overview" data-type="indexterm" id="ch10.html2"/><a data-type="xref" href="#core_x_dom_types">Figure 10-1</a> shows the core X-DOM types. The most frequently used of these types is <code>XElement</code>. <a contenteditable="false" data-primary="XObject" data-type="indexterm" id="id3363"/><code>XObject</code> is the root of the <em>inheritance</em> hierarchy; <code>XElement</code> and <code>XDocument</code> are roots of the <em>containership</em> hierarchy.</p>

<figure><div class="figure" id="core_x_dom_types"><img alt="Core X-DOM types" src="assets/cn10_1001.png"/>
<h6><span class="label">Figure 10-1. </span>Core X-DOM types</h6>
</div></figure>

<p><a data-type="xref" href="#a_simple_x_dom_tree">Figure 10-2</a> shows the X-DOM tree created from the following code:</p>

<pre data-type="programlisting">
string xml = @"&lt;customer id='123' status='archived'&gt;
                 &lt;firstname&gt;Joe&lt;/firstname&gt;
                 &lt;lastname&gt;Bloggs&lt;!--nice name--&gt;&lt;/lastname&gt;
               &lt;/customer&gt;";

XElement customer = XElement.Parse (xml);</pre>

<figure><div class="figure" id="a_simple_x_dom_tree"><img alt="A simple X-DOM tree" src="assets/cn10_1002.png"/>
<h6><span class="label">Figure 10-2. </span>A simple X-DOM tree</h6>
</div></figure>

<p><code>XObject</code> is the abstract base class for all XML content. It defines a link to the <code>Parent</code> element in the containership tree as well as an optional <code>XDocument</code>.</p>

<p><a contenteditable="false" data-primary="XNode" data-type="indexterm" id="id3364"/><code>XNode</code> is the base class for most XML content excluding attributes. The distinguishing feature of <code>XNode</code> is that it can sit in an ordered collection of mixed-type <code>XNode</code>s. For instance, consider the following XML:</p>

<pre data-type="programlisting">
&lt;data&gt;
  <strong>Hello world</strong>
  <strong>&lt;subelement1/&gt;</strong>
  <strong>&lt;!--comment--&gt;</strong>
  <strong>&lt;subelement2/&gt;</strong>
&lt;/data&gt;</pre>

<p>Within the parent element <code>&lt;data&gt;</code>, there’s first an <code>XText</code> node (<code>Hello world</code>), then an <code>XElement</code> node, then an <code>XComment</code> node, and then a second <code>XElement</code> node. <a contenteditable="false" data-primary="XAttribute" data-type="indexterm" id="id3365"/>In contrast, an <code>XAttribute</code> will tolerate only other <code>XAttribute</code>s as peers.</p>

<p><a contenteditable="false" data-primary="XContainer" data-type="indexterm" id="id3366"/>Although an <code>XNode</code> can access its parent <code>XElement</code>, it has no concept of <em>child</em> nodes: this is the job of its subclass <code>XContainer</code>. <code>XContainer</code> defines members for dealing with children and is the abstract base class for <code>XElement</code> and <code>XDocument</code>.</p>

<p><code>XElement</code> introduces members for managing attributes—as well as a <code>Name</code> and <code>Value</code>. In the (fairly common) case of an element having a single <code>XText</code> child node, the <code>Value</code> property on <code>XElement</code> encapsulates this child’s content for both get and set operations, cutting unnecessary navigation. Thanks to <code>Value</code>, you can mostly avoid working directly with <code>XText</code> nodes.</p>

<p><a contenteditable="false" data-primary="XDocument" data-type="indexterm" id="id3367"/><code>XDocument</code> represents the root of an XML tree. More precisely, it <em>wraps</em> the root <code>XElement</code>, adding an <code>XDeclaration</code>, processing instructions, and other root-level “fluff.” Unlike with the W3C DOM, its use is optional: you can load, manipulate, and save an X-DOM without ever creating an <code>XDocument</code>! The nonreliance on <code>XDocument</code> also means that you can efficiently and easily move a node subtree to another X-DOM hierarchy.</p>

<section data-pdf-bookmark="Loading and Parsing" data-type="sect2"><div class="sect2" id="loading_and_parsing">
<h2>Loading and Parsing</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="loading and parsing" data-type="indexterm" id="id3368"/>Both <code>XElement</code> and <code>XDocument</code> provide static <code>Load</code> and <code>Parse</code> methods to build an X-DOM tree from an existing source:</p>

<ul>
	<li>
	<p><code>Load</code> builds an X-DOM from a file, URI, <code>Stream</code>, <code>TextReader</code>, or <code>XmlReader</code>.</p>
	</li>
	<li>
	<p><code>Parse</code> builds an X-DOM from a string.</p>
	</li>
</ul>

<p>For example:</p>

<pre data-type="programlisting">
XDocument fromWeb = XDocument.Load ("http://albahari.com/sample.xml");

XElement fromFile = XElement.Load (@"e:\media\somefile.xml");

XElement config = XElement.Parse (
@"&lt;configuration&gt;
    &lt;client enabled='true'&gt;
      &lt;timeout&gt;30&lt;/timeout&gt;
    &lt;/client&gt;
  &lt;/configuration&gt;");</pre>

<p>In later sections, we describe how to traverse and update an X-DOM. As a quick preview, here’s how to manipulate the <code>config</code> element we just populated:</p>

<pre data-type="programlisting">
foreach (XElement child in config.Elements())
  Console.WriteLine (child.Name);                     // client

XElement client = config.Element ("client");

bool enabled = (bool) client.Attribute ("enabled");   // Read attribute
Console.WriteLine (enabled);                          // True
client.Attribute ("enabled").SetValue (!enabled);     // Update attribute

int timeout = (int) client.Element ("timeout");       // Read element
Console.WriteLine (timeout);                          // 30
client.Element ("timeout").SetValue (timeout * 2);    // Update element

client.Add (new XElement ("retries", 3));             // Add new element

Console.WriteLine (config);         // Implicitly call config.ToString()</pre>

<p>Here’s the result of that last <code>Console.WriteLine</code>:</p>

<pre data-type="programlisting">
&lt;configuration&gt;
  &lt;client enabled="false"&gt;
    &lt;timeout&gt;60&lt;/timeout&gt;
    &lt;retries&gt;3&lt;/retries&gt;
  &lt;/client&gt;
&lt;/configuration&gt;</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>XNode</code> also provides a static <code>ReadFrom</code> method that instantiates and populates any type of node from an <code>XmlReader</code>. Unlike <code>Load</code>, it stops after reading one (complete) node, so you can continue to read manually from the <code>XmlReader</code> afterward.</p>

<p>You can also do the reverse and use an <code>XmlReader</code> or <code>XmlWriter</code> to read or write an <code>XNode</code>, via its <code>CreateReader</code> and <code>CreateWriter</code> methods.</p>

<p>We describe XML readers and writers and how to use them with the X-DOM in <a data-type="xref" href="ch11.html#other_xml_and_json_technologies">Chapter 11</a>.</p>
</div>
</div></section>

<section data-pdf-bookmark="Saving and Serializing" data-type="sect2"><div class="sect2" id="saving_and_serializing">
<h2>Saving and Serializing</h2>

<p><a contenteditable="false" data-primary="To..." data-secondary="ToString method" data-type="indexterm" id="id3369"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="saving and serializing" data-type="indexterm" id="id3370"/>Calling <code>ToString</code> on any node converts its content to an XML string—formatted with line breaks and indentation as we just saw. (You can disable the line breaks and indentation by specifying <code>SaveOptions.DisableFormatting</code> when calling <code>ToString</code>.)</p>

<p><code>XElement</code> and <code>XDocument</code> also provide a <code>Save</code> method that writes an X-DOM to a file, <code>Stream</code>, <code>TextWriter</code>, or <code>XmlWriter</code>. If you specify a file, an XML declaration is automatically written. There is also a <code>WriteTo</code> method defined in the <code>XNode</code> class, which accepts just an <code>XmlWriter</code>.</p>

<p>We describe in more detail the handling of XML declarations when saving in <a data-type="xref" href="#documents_and_declarations">“Documents and Declarations”</a>.<a contenteditable="false" data-primary="" data-startref="ch10.html2" data-type="indexterm" id="id3371"/><a contenteditable="false" data-primary="" data-startref="ch10.html1" data-type="indexterm" id="id3372"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Instantiating an X-DOM" data-type="sect1"><div class="sect1" id="instantiating_an_x_dom">
<h1>Instantiating an X-DOM</h1>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="instantiating" data-type="indexterm" id="ch10.html3"/>Rather than using the <code>Load</code> or <code>Parse</code> methods, you can build an X-DOM tree by manually instantiating objects and adding them to a parent via <code>XContainer</code>’s <code>Add</code> method.</p>

<p>To construct an <code>XElement</code> and <code>XAttribute</code>, simply provide a name and value:</p>

<pre data-type="programlisting">
XElement lastName = new XElement ("lastname", "Bloggs");
lastName.Add (new XComment ("nice name"));

XElement customer = new XElement ("customer");
customer.Add (new XAttribute ("id", 123));
customer.Add (new XElement ("firstname", "Joe"));
customer.Add (lastName);

Console.WriteLine (customer.ToString());</pre>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;customer id="123"&gt;
  &lt;firstname&gt;Joe&lt;/firstname&gt;
  &lt;lastname&gt;Bloggs&lt;!--nice name--&gt;&lt;/lastname&gt;
&lt;/customer&gt;</pre>

<p>A value is optional when constructing an <code>XElement</code>—you can provide just the element name and add content later. Notice that when we did provide a value, a simple string sufficed—we didn’t need to explicitly create and add an <code>XText</code> child node. The X-DOM does this work automatically, so you can deal simply with “values.”</p>

<section data-pdf-bookmark="Functional Construction" data-type="sect2"><div class="sect2" id="functional_construction">
<h2>Functional Construction</h2>

<p><a contenteditable="false" data-primary="functional construction" data-type="indexterm" id="id3373"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="functional construction" data-type="indexterm" id="id3374"/>In our preceding example, it’s difficult to glean the XML structure from the code. <span class="keep-together">X-DOM</span> supports another mode of instantiation, called <em>functional construction</em> (from functional programming). With functional construction, you build an entire tree in a single expression:</p>

<pre data-type="programlisting">
XElement customer =
  new XElement ("customer", new XAttribute ("id", 123),
    new XElement ("firstname", "joe"),
    new XElement ("lastname", "bloggs",
      new XComment ("nice name")
    )
  );</pre>

<p>This has two benefits. First, the code resembles the shape of the XML. Second, it can be incorporated into the <code>select</code> clause of a LINQ query. For example, the following query projects from an EF Core entity class into an X-DOM:</p>

<pre data-type="programlisting">
XElement query =
  new XElement ("customers",
    from c in dbContext.Customers.AsEnumerable()
    select
      new XElement ("customer", new XAttribute ("id", c.ID),
        new XElement ("firstname", c.FirstName),
        new XElement ("lastname", c.LastName,
          new XComment ("nice name")
        )
      )
  );</pre>

<p>We examine this further later in this chapter in <a data-type="xref" href="#projecting_into_an_x_dom">“Projecting into an X-DOM”</a>.</p>
</div></section>

<section data-pdf-bookmark="Specifying Content" data-type="sect2"><div class="sect2" id="specifying_content">
<h2>Specifying Content</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="content specification" data-type="indexterm" id="id3375"/>Functional construction is possible because the constructors for <code>XElement</code> (and <code>XDocument</code>) are overloaded to accept a <code>params</code> object array:</p>

<pre data-type="programlisting">
public XElement (XName name, params object[] content)</pre>

<p>The same holds true for the <code>Add</code> method in <code>XContainer</code>:</p>

<pre data-type="programlisting">
public void Add (params object[] content)</pre>

<p>Hence, you can specify any number of child objects of any type when building or appending an X-DOM. This works because <em>anything</em> counts as legal content. To see how, we need to examine how each content object is processed internally. Here are the decisions made by <code>XContainer</code>, in order:</p>

<ol>
	<li>
	<p>If the object is <code>null</code>, it’s ignored.</p>
	</li>
	<li>
	<p>If the object is based on <code>XNode</code> or <code>XStreamingElement</code>, it’s added as is to the <code>Nodes</code> collection.</p>
	</li>
	<li>
	<p>If the object is an <code>XAttribute</code>, it’s added to the <code>Attributes</code> collection.</p>
	</li>
	<li>
	<p>If the object is a <code>string</code>, it’s wrapped in an <code>XText</code> node and added to <code>Nodes</code>.<sup><a data-type="noteref" href="ch10.html#ch01fn11" id="ch01fn11-marker">1</a></sup></p>
	</li>
	<li>
	<p>If the object implements <code>IEnumerable</code>, it’s enumerated, and the same rules are applied to each element.</p>
	</li>
	<li>
	<p>Otherwise, the object is converted to a string, wrapped in an <code>XText</code> node, and then added to <code>Nodes</code>.<sup><a data-type="noteref" href="ch10.html#ch01fn12" id="ch01fn12-marker">2</a></sup></p>
	</li>
</ol>

<p>Everything ends up in one of two buckets: <code>Nodes</code> or <code>Attributes</code>. Furthermore, any object is valid content because it can always ultimately call <code>ToString</code> on it and treat it as an <code>XText</code> node.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Before calling <code>ToString</code> on an arbitrary type, <code>XContainer</code> first tests whether it is one of the following types:</p>

<pre data-type="programlisting">
float, double, decimal, bool,
DateTime, DateTimeOffset, TimeSpan</pre>

<p>If so, it calls an appropriate typed <code>ToString</code> method on the <code>XmlConvert</code> helper class instead of calling <code>ToString</code> on the object itself. This ensures that the data is round-trippable and compliant with standard XML formatting rules.</p>
</div>
</div></section>

<section data-pdf-bookmark="Automatic Deep Cloning" data-type="sect2"><div class="sect2" id="automatic_deep_cloning">
<h2>Automatic Deep Cloning</h2>

<p><a contenteditable="false" data-primary="cloning" data-type="indexterm" id="id3376"/><a contenteditable="false" data-primary="deep cloning" data-type="indexterm" id="id3377"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="automatic deep cloning" data-type="indexterm" id="id3378"/>When a node or attribute is added to an element (whether via functional construction or an <code>Add</code> method), the node or attribute’s <code>Parent</code> property is set to that element. A node can have only one parent element: if you add an already parented node to a second parent, the node is automatically <em>deep-cloned</em>. In the following example, each customer has a separate copy of <code>address</code>:</p>

<pre data-type="programlisting">
var address = new XElement ("address",
                  new XElement ("street", "Lawley St"),
                  new XElement ("town", "North Beach")
              );
var customer1 = new XElement ("customer1", address);
var customer2 = new XElement ("customer2", address);

customer1.Element ("address").Element ("street").Value = "Another St";
Console.WriteLine (
  customer2.Element ("address").Element ("street").Value);   // Lawley St</pre>

<p>This automatic duplication keeps X-DOM object instantiation free of side effects—another hallmark of functional programming.<a contenteditable="false" data-primary="" data-startref="ch10.html3" data-type="indexterm" id="id3379"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Navigating and Querying" data-type="sect1"><div class="sect1" id="navigating_and_querying">
<h1>Navigating and Querying</h1>

<p><a contenteditable="false" data-primary="query expressions" data-secondary="X-DOM" data-type="indexterm" id="ch10.html4"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="navigating and querying" data-type="indexterm" id="ch10.html5"/>As you might expect, the <code>XNode</code> and <code>XContainer</code> classes define methods and properties for traversing the X-DOM tree. Unlike a conventional DOM, however, these functions don’t return a collection that implements <code>IList&lt;T&gt;</code>. Instead, they return either a single value or a <em>sequence</em> that implements <code>IEnumerable&lt;T&gt;</code>—upon which you are then expected to execute a LINQ query (or enumerate with a <code>foreach</code>). This allows for advanced queries as well as simple navigation tasks—using familiar LINQ query syntax.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Element and attribute names are case sensitive in the X-DOM, just as they are in XML.</p>
</div>

<section data-pdf-bookmark="Child Node Navigation" data-type="sect2"><div class="sect2" id="child_node_navigation">
<h2>Child Node Navigation</h2>

<table class="border">
	<thead>
		<tr>
			<th>Return type</th>
			<th>Members</th>
			<th>Works on</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>XNode</code></td>
			<td><code>FirstNode { get; }</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>LastNode { get; }</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td><code>IEnumerable&lt;XNode&gt;</code></td>
			<td><code>Nodes()</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>DescendantNodes()</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>DescendantNodesAndSelf()</code></td>
			<td><code>XElement*</code></td>
		</tr>
		<tr>
			<td><code>XElement</code></td>
			<td><code>Element (XName)</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td><code>IEnumerable&lt;XElement&gt;</code></td>
			<td><code>Elements()</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>Elements (XName)</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>Descendants()</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>Descendants (XName)</code></td>
			<td><code>XContainer*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>DescendantsAndSelf()</code></td>
			<td><code>XElement*</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>DescendantsAndSelf (XName)</code></td>
			<td><code>XElement*</code></td>
		</tr>
		<tr>
			<td><code>bool</code></td>
			<td><code>HasElements { get; }</code></td>
			<td><code>XElement</code></td>
		</tr>
	</tbody>
</table>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="child node navigation" data-type="indexterm" id="id3380"/>Functions marked with an asterisk in the third column of this and other tables also operate on <em>sequences</em> of the same type. For instance, you can call <code>Nodes</code> on either an <code>XContainer</code> or a sequence of <code>XContainer</code> objects. This is possible because of extension methods defined in <code>System.Xml.Linq</code>—the supplementary query operators we talked about in the overview.</p>
</div>

<section data-pdf-bookmark="FirstNode, LastNode, and Nodes" data-type="sect3"><div class="sect3" id="firstnodecomma_lastnodecomma_and_nodes">
<h3>FirstNode, LastNode, and Nodes</h3>

<p><a contenteditable="false" data-primary="FirstNode function" data-type="indexterm" id="id3381"/><a contenteditable="false" data-primary="LastNode function" data-type="indexterm" id="id3382"/><a contenteditable="false" data-primary="Nodes function" data-type="indexterm" id="id3383"/><code>FirstNode</code> and <code>LastNode</code> give you direct access to the first or last child node; <span class="keep-together"><code>Nodes</code> returns</span> all children as a sequence. All three functions consider only direct <span class="keep-together">descendants</span>:</p>

<pre data-type="programlisting">
var bench = new XElement ("bench",
              new XElement ("toolbox",
                new XElement ("handtool", "Hammer"),
                new XElement ("handtool", "Rasp")
              ),
              new XElement ("toolbox",
                new XElement ("handtool", "Saw"),
                new XElement ("powertool", "Nailgun")
              ),
              new XComment ("Be careful with the nailgun")
            );
foreach (XNode node in bench<strong>.Nodes()</strong>)
  Console.WriteLine (node.ToString (SaveOptions.DisableFormatting) + ".");</pre>

<p>This is the output:</p>

<pre data-type="programlisting">
&lt;toolbox&gt;&lt;handtool&gt;Hammer&lt;/handtool&gt;&lt;handtool&gt;Rasp&lt;/handtool&gt;&lt;/toolbox&gt;.
&lt;toolbox&gt;&lt;handtool&gt;Saw&lt;/handtool&gt;&lt;powertool&gt;Nailgun&lt;/powertool&gt;&lt;/toolbox&gt;.
&lt;!--Be careful with the nailgun--&gt;.</pre>
</div></section>

<section data-pdf-bookmark="Retrieving elements" data-type="sect3"><div class="sect3" id="retrieving_elements">
<h3>Retrieving elements</h3>

<p><a contenteditable="false" data-primary="Element method" data-type="indexterm" id="id3384"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="retrieving elements" data-type="indexterm" id="id3385"/>The <code>Elements</code> method returns just the child nodes of type <code>XElement</code>:</p>

<pre data-type="programlisting">
foreach (XElement e in bench<strong>.Elements()</strong>)
  Console.WriteLine (e.Name + "=" + e.Value);    // toolbox=HammerRasp
                                                 // toolbox=SawNailgun</pre>

<p>The following LINQ query finds the toolbox with the nail gun:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from toolbox in bench.Elements()
  where toolbox.Elements().Any (tool =&gt; tool.Value == "Nailgun")
  select toolbox.Value;

RESULT: { "SawNailgun" }</pre>

<p>The next example uses a <code>SelectMany</code> query to retrieve the hand tools in all <span class="keep-together">toolboxes</span>:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from toolbox in bench.Elements()
  from tool in toolbox.Elements()
  where tool.Name == "handtool"
  select tool.Value;

RESULT: { "Hammer", "Rasp", "Saw" }</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Elements</code> itself is equivalent to a LINQ query on <code>Nodes</code>. Our preceding query could be started as follows:</p>

<pre data-type="programlisting">
from toolbox in bench.<strong>Nodes().OfType&lt;XElement&gt;()</strong>
where ...</pre>
</div>

<p><code>Elements</code> can also return just the elements of a given name:</p>

<pre data-type="programlisting">
int x = bench<strong>.Elements ("toolbox")</strong>.Count();    // 2</pre>

<p>This is equivalent to the following:</p>

<pre data-type="programlisting">
int x = bench.Elements().<strong>Where (e =&gt; e.Name == "toolbox")</strong>.Count();  // 2</pre>

<p><code>Elements</code> is also defined as an extension method accepting <code>IEnumerable​&lt;XCon⁠tainer&gt;</code> or, more precisely, it accepts an argument of this type:</p>

<pre data-type="programlisting">
IEnumerable&lt;T&gt; where T : XContainer</pre>

<p>This allows it to work with sequences of elements, too. Using this method, we can rewrite the query that finds the hand tools in all toolboxes as follows:</p>

<pre data-type="programlisting">
from tool in bench.Elements ("toolbox").<strong>Elements</strong> ("handtool")
select tool.Value;</pre>

<p>The first call to <code>Elements</code> binds to <code>XContainer</code>’s instance method; the second call to <code>Elements</code> binds to the extension method.</p>
</div></section>

<section data-pdf-bookmark="Retrieving a single element" data-type="sect3"><div class="sect3" id="retrieving_a_single_element">
<h3>Retrieving a single element</h3>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="retrieving a single element" data-type="indexterm" id="id3386"/>The method <code>Element</code> (singular) returns the first matching element of the given name. <code>Element</code> is useful for simple navigation, as follows:</p>

<pre data-type="programlisting">
XElement settings = XElement.Load ("databaseSettings.xml");
string cx = settings.Element ("database").Element ("connectString").Value;</pre>

<p><code>Element</code> is equivalent to calling <code>Elements()</code> and then applying LINQ’s <code>FirstOr​De⁠fault</code> query operator with a name-matching predicate. <code>Element</code> returns <code>null</code> if the requested element doesn’t exist.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Element("xyz").Value</code> will throw a <code>NullReferenceException</code> if element <code>xyz</code> does not exist. If you’d prefer a <code>null</code> to an exception, either use the null-conditional operator—<code>Element("xyz")?.Value</code>—or cast the <code>XElement</code> to a <code>string</code> instead of querying its <code>Value</code> property. In other words:</p>

<pre data-type="programlisting">
string xyz = (string) settings.Element ("xyz");</pre>

<p>This works because <code>XElement</code> defines an explicit <code>string</code> conversion—just for this purpose!</p>
</div>
</div></section>

<section data-pdf-bookmark="Retrieving descendants" data-type="sect3"><div class="sect3" id="retrieving_descendants">
<h3>Retrieving descendants</h3>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="retrieving descendants" data-type="indexterm" id="id3387"/><code>XContainer</code> also provides <code>Descendants</code> and <a contenteditable="false" data-primary="DescendantNodes method" data-type="indexterm" id="id3388"/><code>DescendantNodes</code> methods that return child elements or nodes plus all of their children, and so on (the entire tree). <a contenteditable="false" data-primary="Descendants method" data-type="indexterm" id="id3389"/><code>Descendants</code> accepts an optional element name. Returning to our earlier example, we can use <code>Descendants</code> to find all of the hand tools:</p>

<pre data-type="programlisting">
Console.WriteLine (bench<strong>.Descendants ("handtool")</strong>.Count());  // 3</pre>

<p>Both parent and leaf nodes are included, as the following example demonstrates:</p>

<pre data-type="programlisting">
foreach (XNode node in bench<strong>.DescendantNodes()</strong>)
  Console.WriteLine (node.ToString (SaveOptions.DisableFormatting));</pre>

<p>Here’s the output:</p>

<pre data-type="programlisting">
&lt;toolbox&gt;&lt;handtool&gt;Hammer&lt;/handtool&gt;&lt;handtool&gt;Rasp&lt;/handtool&gt;&lt;/toolbox&gt;
&lt;handtool&gt;Hammer&lt;/handtool&gt;
Hammer
&lt;handtool&gt;Rasp&lt;/handtool&gt;
Rasp
&lt;toolbox&gt;&lt;handtool&gt;Saw&lt;/handtool&gt;&lt;powertool&gt;Nailgun&lt;/powertool&gt;&lt;/toolbox&gt;
&lt;handtool&gt;Saw&lt;/handtool&gt;
Saw
&lt;powertool&gt;Nailgun&lt;/powertool&gt;
Nailgun
&lt;!--Be careful with the nailgun--&gt;</pre>

<p>The next query extracts all comments anywhere within the X-DOM that contain the word “careful”:</p>

<pre data-type="programlisting">
IEnumerable&lt;string&gt; query =
  from c in bench.DescendantNodes().OfType&lt;XComment&gt;()
  where c.Value.Contains ("careful")
  orderby c.Value
  select c.Value;</pre>
</div></section>
</div></section>

<section data-pdf-bookmark="Parent Navigation" data-type="sect2"><div class="sect2" id="parent_navigation">
<h2>Parent Navigation</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="parent navigation" data-type="indexterm" id="id3390"/>All <code>XNode</code>s have a <code>Parent</code> property and <code>Ancestor<em>XXX</em></code> methods for parent navigation. A parent is always an <code>XElement</code>:</p>

<table class="border">
	<thead>
		<tr>
			<th>Return type</th>
			<th>Members</th>
			<th>Works on</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>XElement</code></td>
			<td><code>Parent { get; }</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>Enumerable&lt;XElement&gt;</code></td>
			<td><code>Ancestors()</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>Ancestors (XName)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>AncestorsAndSelf()</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>AncestorsAndSelf (XName)</code></td>
			<td><code>XElement</code></td>
		</tr>
	</tbody>
</table>

<p>If <code>x</code> is an <code>XElement</code>, the following always prints <code>true</code>:</p>

<pre data-type="programlisting">
foreach (XNode child in x.Nodes())
  Console.WriteLine (child.Parent == x);</pre>

<p>However, the same is not the case if <code>x</code> is an <code>XDocument</code>. <code>XDocument</code> is peculiar: it can have children but can never be anyone’s parent! To access the <code>XDocument</code>, you instead use the <code>Document</code> property; this works on any object in the X-DOM tree.</p>

<p><code>Ancestors</code> returns a sequence whose first element is <code>Parent</code> and whose next element is <code>Parent.Parent</code>, and so on, until the root element.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can navigate to the root element with the LINQ query <code>AncestorsAndSelf().Last()</code>.</p>

<p>Another way to achieve the same thing is to call <code>Docu⁠ment​.Root</code>, although this works only if an <code>XDocument</code> is present.</p>
</div>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Peer Node Navigation" data-type="sect2"><div class="sect2" id="peer_node_navigation">
<h2 class="less_space">Peer Node Navigation</h2>

<table class="border">
	<thead>
		<tr>
			<th>Return type</th>
			<th>Members</th>
			<th>Defined in</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>bool</code></td>
			<td><code>IsBefore (XNode node)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>IsAfter (XNode node)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>XNode</code></td>
			<td><code>PreviousNode { get; }</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>NextNode { get; }</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>IEnumerable&lt;XNode&gt;</code></td>
			<td><code>NodesBeforeSelf()</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>NodesAfterSelf()</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>IEnumerable&lt;XElement&gt;</code></td>
			<td><code>ElementsBeforeSelf()</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>ElementsBeforeSelf (XName name)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>ElementsAfterSelf()</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>ElementsAfterSelf (XName name)</code></td>
			<td><code>XNode</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="peer node navigation" data-type="indexterm" id="id3391"/>With <code>PreviousNode</code> and <code>NextNode</code> (and <code>FirstNode</code>/<code>LastNode</code>), you can traverse nodes with the feel of a linked list. This is noncoincidental: internally, nodes are stored in a linked list.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>XNode</code> internally uses a <em>singly</em> linked list, so <code>PreviousNode</code> is not performant.</p>
</div>
</div></section>

<section data-pdf-bookmark="Attribute Navigation" data-type="sect2"><div class="sect2" id="attribute_navigation">
<h2>Attribute Navigation</h2>

<table class="border">
	<thead>
		<tr>
			<th>Return type</th>
			<th>Members</th>
			<th>Defined in</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>bool</code></td>
			<td><code>HasAttributes { get; }</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td><code>XAttribute</code></td>
			<td><code>Attribute (XName name)</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>FirstAttribute { get; }</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>LastAttribute { get; }</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td><code>IEnumerable&lt;XAttribute&gt;</code></td>
			<td><code>Attributes()</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>Attributes (XName name)</code></td>
			<td><code>XElement</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="attribute navigation" data-type="indexterm" id="id3392"/>In addition, <code>XAttribute</code> defines <code>PreviousAttribute</code> and <code>NextAttribute</code> properties as well as <code>Parent</code>.</p>

<p>The <code>Attributes</code> method that accepts a name returns a sequence with either zero or one element; an element cannot have duplicate attribute names in XML.<a contenteditable="false" data-primary="" data-startref="ch10.html5" data-type="indexterm" id="id3393"/><a contenteditable="false" data-primary="" data-startref="ch10.html4" data-type="indexterm" id="id3394"/></p>
</div></section>
</div></section>

<section class="pagebreak-before" data-pdf-bookmark="Updating an X-DOM" data-type="sect1"><div class="sect1" id="updating_an_x_dom">
<h1 class="less_space">Updating an X-DOM</h1>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="updating" data-type="indexterm" id="ch10.html6"/>You can update elements and attributes in the following ways:</p>

<ul>
	<li>
	<p>Call <code>SetValue</code> or reassign the <code>Value</code> property.</p>
	</li>
	<li>
	<p>Call <code>SetElementValue</code> or <code>SetAttributeValue</code>.</p>
	</li>
	<li>
	<p>Call one of the <code>Remove<em>XXX</em></code> methods.</p>
	</li>
	<li>
	<p>Call one of the <code>Add<em>XXX</em></code> or <code>Replace<em>XXX</em></code> methods, specifying fresh content.</p>
	</li>
</ul>

<p>You can also reassign the <code>Name</code> property on <code>XElement</code> objects.</p>

<section data-pdf-bookmark="Simple Value Updates" data-type="sect2"><div class="sect2" id="simple_value_updates">
<h2>Simple Value Updates</h2>

<table class="border">
	<thead>
		<tr>
			<th>Members</th>
			<th>Works on</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>SetValue (object value)</code></td>
			<td><code>XElement</code>, <code>XAttribute</code></td>
		</tr>
		<tr>
			<td><code>Value { get; set }</code></td>
			<td><code>XElement</code>, <code>XAttribute</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="simple value updates" data-type="indexterm" id="id3395"/>The <code>SetValue</code> method replaces an element or attribute’s content with a simple value. Setting the <code>Value</code> property does the same but accepts string data only. We describe both of these functions in detail later in <a data-type="xref" href="#working_with_values">“Working with Values”</a>. An effect of calling <code>SetValue</code> (or reassigning <code>Value</code>) is that it replaces all child nodes:</p>

<pre data-type="programlisting">
XElement settings = new XElement ("settings",
                      new XElement ("timeout", 30)
                    );
settings.SetValue ("blah");
Console.WriteLine (settings.ToString());  // &lt;settings&gt;blah&lt;/settings&gt;</pre>
</div></section>

<section data-pdf-bookmark="Updating Child Nodes and Attributes" data-type="sect2"><div class="sect2" id="updating_child_nodes_and_attributes">
<h2>Updating Child Nodes and Attributes</h2>

<table class="border">
	<thead>
		<tr>
			<th>Category</th>
			<th>Members</th>
			<th>Works on</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Add</td>
			<td><code>Add (params object[] content)</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>AddFirst (params object[] content)</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td>Remove</td>
			<td><code>RemoveNodes()</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>RemoveAttributes()</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>RemoveAll()</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td>Update</td>
			<td><code>ReplaceNodes (params object[] content)</code></td>
			<td><code>XContainer</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>ReplaceAttributes (params object[] content)</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>ReplaceAll (params object[] content</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>SetElementValue (XName name, object value)</code></td>
			<td><code>XElement</code></td>
		</tr>
		<tr>
			<td> </td>
			<td><code>SetAttributeValue (XName name, object value)</code></td>
			<td><code>XElement</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="updating child nodes and attributes" data-type="indexterm" id="id3396"/>The most convenient methods in this group are the last two: <code>SetElementValue</code> and <code>SetAttributeValue</code>. They serve as shortcuts for instantiating an <code>XElement</code> or <span class="keep-together"><code>XAttribute</code></span> and then <code>Add</code>ing it to a parent, replacing any existing element or attribute of that name:</p>

<pre data-type="programlisting">
XElement settings = new XElement ("settings");
settings.SetElementValue ("timeout", 30);     // Adds child node
settings.SetElementValue ("timeout", 60);     // Update it to 60</pre>

<p><code>Add</code> appends a child node to an element or document. <code>AddFirst</code> does the same thing but inserts at the beginning of the collection rather than the end.</p>

<p>You can remove all child nodes or attributes in one hit with <code>RemoveNodes</code> or <code>RemoveAttributes</code>. <code>RemoveAll</code> is equivalent to calling both methods.</p>

<p>The <code>Replace<em>XXX</em></code> methods are equivalent to <code>Remov</code>ing and then <code>Add</code>ing. They take a snapshot of the input, so <code>e.ReplaceNodes(e.Nodes())</code> works as expected.</p>
</div></section>

<section data-pdf-bookmark="Updating Through the Parent" data-type="sect2"><div class="sect2" id="updating_through_the_parent">
<h2>Updating Through the Parent</h2>

<table class="border">
	<thead>
		<tr>
			<th>Members</th>
			<th>Works on</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>AddBeforeSelf (params object[] content)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>AddAfterSelf (params object[] content)</code></td>
			<td><code>XNode</code></td>
		</tr>
		<tr>
			<td><code>Remove()</code></td>
			<td><code>XNode</code>, <code>XAttribute</code></td>
		</tr>
		<tr>
			<td><code>ReplaceWith (params object[] content)</code></td>
			<td><code>XNode</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="updating through the parent" data-type="indexterm" id="id3397"/>The methods <code>AddBeforeSelf</code>, <code>AddAfterSelf</code>, <code>Remove</code>, and <code>ReplaceWith</code> don’t operate on the node’s children. Instead, they operate on the collection in which the node itself is in. This requires that the node have a parent element—otherwise, an exception is thrown. <code>AddBeforeSelf</code> and <code>AddAfterSelf</code> are useful for inserting a node into an arbitrary position:</p>

<pre data-type="programlisting">
XElement items = new XElement ("items",
                   new XElement ("one"),
                   new XElement ("three")
                 );
items.FirstNode.AddAfterSelf (new XElement ("<strong>two</strong>"));</pre>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;items&gt;&lt;one /&gt;&lt;<strong>two</strong> /&gt;&lt;three /&gt;&lt;/items&gt;</pre>

<p>Inserting into an arbitrary position within a long sequence of elements is efficient because nodes are stored internally in a linked list.</p>

<p>The <code>Remove</code> method removes the current node from its parent. <code>ReplaceWith</code> does the same and then inserts some other content at the same position:</p>

<pre data-type="programlisting">
XElement items = XElement.Parse ("&lt;items&gt;&lt;one/&gt;&lt;two/&gt;&lt;three/&gt;&lt;/items&gt;");
items.FirstNode.ReplaceWith (new XComment ("One was here"));</pre>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;items&gt;<strong>&lt;!--one was here--&gt;</strong>&lt;two /&gt;&lt;three /&gt;&lt;/items&gt;</pre>

<section data-pdf-bookmark="Removing a sequence of nodes or attributes" data-type="sect3"><div class="sect3" id="removing_a_sequence_of_nodes_or_attribu">
<h3>Removing a sequence of nodes or attributes</h3>

<p><a contenteditable="false" data-primary="System..." data-secondary="System.Xml.Linq" data-type="indexterm" id="id3398"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="removing a sequence of nodes or attributes" data-type="indexterm" id="id3399"/>Thanks to extension methods in <code>System.Xml.Linq</code>, you can also call <code>Remove</code> on a <em>sequence</em> of nodes or attributes. Consider this X-DOM:</p>

<pre data-type="programlisting">
XElement contacts = XElement.Parse (
@"&lt;contacts&gt;
    &lt;customer name='Mary'/&gt;
    &lt;customer name='Chris' archived='true'/&gt;
    &lt;supplier name='Susan'&gt;
      &lt;phone archived='true'&gt;012345678&lt;!--confidential--&gt;&lt;/phone&gt;
    &lt;/supplier&gt;
  &lt;/contacts&gt;");</pre>

<p>The following removes all customers:</p>

<pre data-type="programlisting">
contacts.Elements ("customer").Remove();</pre>

<p>The following removes all archived contacts (so <em>Chris</em> disappears):</p>

<pre data-type="programlisting">
contacts.Elements().Where (e =&gt; (bool?) e.Attribute ("archived") == true)
                   .Remove();</pre>

<p>If we replaced <code>Elements()</code> with <code>Descendants()</code>, all archived elements throughout the DOM would disappear, yielding this result:</p>

<pre data-type="programlisting">
&lt;contacts&gt;
  &lt;customer name="Mary" /&gt;
  &lt;supplier name="Susan" /&gt;
&lt;/contacts&gt;</pre>

<p>The next example removes all contacts that feature the comment “confidential” anywhere in their tree:</p>

<pre data-type="programlisting">
contacts.Elements().Where (e =&gt; e.DescendantNodes()
                                 .OfType&lt;XComment&gt;()
                                 .Any (c =&gt; c.Value == "confidential")
                          ).Remove();</pre>

<p>This is the result:</p>

<pre data-type="programlisting">
&lt;contacts&gt;
  &lt;customer name="Mary" /&gt;
  &lt;customer name="Chris" archived="true" /&gt;
&lt;/contacts&gt;</pre>

<p>Contrast this with the following simpler query, which strips all comment nodes from the tree:</p>

<pre data-type="programlisting">
contacts.DescendantNodes().OfType&lt;XComment&gt;().Remove();</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Internally, the <code>Remove</code> method first reads all matching elements into a temporary list and then enumerates over the temporary list to perform the deletions. This prevents errors that could otherwise result from deleting and querying at the same time.<a contenteditable="false" data-primary="" data-startref="ch10.html6" data-type="indexterm" id="id3400"/></p>
</div>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Working with Values" data-type="sect1"><div class="sect1" id="working_with_values">
<h1>Working with Values</h1>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="working with values" data-type="indexterm" id="ch10.html7"/><code>XElement</code> and <code>XAttribute</code> both have a <code>Value</code> property of type <code>string</code>. If an element has a single <code>XText</code> child node, <code>XElement</code>’s <code>Value</code> property acts as a convenient shortcut to the content of that node. With <code>XAttribute</code>, the <code>Value</code> property is simply the attribute’s value.</p>

<p>Despite the storage differences, the X-DOM provides a consistent set of operations for working with element and attribute values.</p>

<section data-pdf-bookmark="Setting Values" data-type="sect2"><div class="sect2" id="setting_values">
<h2>Setting Values</h2>

<p><a contenteditable="false" data-primary="SetValue method" data-type="indexterm" id="id3401"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="setting values" data-type="indexterm" id="id3402"/>There are two ways to assign a value: call <code>SetValue</code> or assign the <code>Value</code> property. <code>SetValue</code> is more flexible because it accepts not just strings but other simple data types, too:</p>

<pre data-type="programlisting">
var e = new XElement ("date", DateTime.Now);
e.SetValue (DateTime.Now.AddDays(1));
Console.Write (e.Value);              // 2019-10-02T16:39:10.734375+09:00</pre>

<p>We could have instead just set the element’s <code>Value</code> property, but this would mean manually converting the <code>DateTime</code> to a string. This is more complicated than calling <code>ToString</code>—it requires the use of <code>XmlConvert</code> for an XML-compliant result.</p>

<p>When you pass a <em>value</em> into <code>XElement</code> or <code>XAttribute</code>’s constructor, the same automatic conversion takes place for nonstring types. This ensures that <code>DateTime</code>s are correctly formatted; <code>true</code> is written in lowercase, and <code>double.NegativeInfinity</code> is written as “-INF”.</p>
</div></section>

<section data-pdf-bookmark="Getting Values" data-type="sect2"><div class="sect2" id="getting_values">
<h2>Getting Values</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="getting values" data-type="indexterm" id="id3403"/>To go the other way around and parse a <code>Value</code> back to a base type, you simply cast the <code>XElement</code> or <code>XAttribute</code> to the desired type. It sounds like it shouldn’t work—but it does! For instance:</p>

<pre data-type="programlisting">
XElement e = new XElement ("now", DateTime.Now);
DateTime dt = (DateTime) e;

XAttribute a = new XAttribute ("resolution", 1.234);
double res = (double) a;</pre>

<p>An element or attribute doesn’t store <code>DateTime</code>s or numbers natively—they’re always stored as text and then parsed as needed. It also doesn’t “remember” the original type, so you must cast it correctly to prevent a runtime error. To make your code robust, you can put the cast in a <code>try</code>/<code>catch</code> block, catching a <code>Format​Excep⁠tion</code>.</p>

<p>Explicit casts on <code>XElement</code> and <code>XAttribute</code> can parse to the following types:</p>

<ul>
	<li>
	<p>All standard numeric types</p>
	</li>
	<li>
	<p><code>string</code>, <code>bool</code>, <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code>, and <code>Guid</code></p>
	</li>
	<li>
	<p><code>Nullable&lt;&gt;</code> versions of the aforementioned value types</p>
	</li>
</ul>

<p>Casting to a nullable type is useful in conjunction with the <code>Element</code> and <code>Attribute</code> methods, because if the requested name doesn’t exist, the cast still works. For instance, if <code>x</code> has no <code>timeout</code> element, the first line generates a runtime error and the second line does not:</p>

<pre data-type="programlisting">
int timeout = (int) x.Element ("timeout");      // Error
int? timeout = (int?) x.Element ("timeout");    // OK; timeout is null.</pre>

<p>You can factor away the nullable type in the final result with the <code>??</code> operator. The following evaluates to <code>1.0</code> if the <code>resolution</code> attribute doesn’t exist:</p>

<pre data-type="programlisting">
double resolution = (double?) x.Attribute ("resolution") ?? 1.0;</pre>

<p>Casting to a nullable type won’t get you out of trouble, though, if the element or attribute <em>exists</em> and has an empty (or improperly formatted) value. For this, you must catch a <code>FormatException</code>.</p>

<p>You can also use casts in LINQ queries. The following returns “John”:</p>

<pre data-type="programlisting">
var data = XElement.Parse (
  @"&lt;data&gt;
      &lt;customer id='1' name='Mary' credit='100' /&gt;
      &lt;customer id='2' name='John' credit='150' /&gt;
      &lt;customer id='3' name='Anne' /&gt;
    &lt;/data&gt;");

IEnumerable&lt;string&gt; query = from cust in data.Elements()
                            where <strong>(int?)</strong> cust.Attribute ("credit") &gt; 100
                            select cust.Attribute ("name").Value;</pre>

<p>Casting to a nullable <code>int</code> prevents a <code>NullReferenceException</code> in the case of Anne, who has no <code>credit</code> attribute. Another solution would be to add a predicate to the <code>where</code> clause:</p>

<pre data-type="programlisting">
where <strong>cust.Attributes ("credit").Any()</strong> &amp;&amp; (int) cust.Attribute...</pre>

<p>The same principles apply in querying element values.</p>
</div></section>

<section data-pdf-bookmark="Values and Mixed Content Nodes" data-type="sect2"><div class="sect2" id="values_and_mixed_content_nodes">
<h2>Values and Mixed Content Nodes</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="values and mixed content nodes" data-type="indexterm" id="id3404"/>Given the value of <code>Value</code>, you might wonder when you’d ever need to deal directly with <code>XText</code> nodes. The answer is when you have mixed content. For example:</p>

<pre data-type="programlisting">
&lt;summary&gt;An XAttribute is &lt;bold&gt;not&lt;/bold&gt; an XNode&lt;/summary&gt;</pre>

<p>A simple <code>Value</code> property is not enough to capture <code>summary</code>’s content. The <code>summary</code> element contains three children: an <code>XText</code> node, followed by an <code>XElement</code>, followed by another <code>XText</code> node. Here’s how to construct it:</p>

<pre data-type="programlisting">
XElement summary = new XElement ("summary",
                      new XText ("An XAttribute is "),
                      new XElement ("bold", "not"),
                      new XText (" an XNode")
                    );</pre>

<p>Interestingly, we can still query <code>summary</code>’s <code>Value</code>—without getting an exception. Instead, we get a concatenation of each child’s value:</p>

<pre data-type="programlisting">
An XAttribute is not an XNode</pre>

<p>It’s also legal to reassign <code>summary</code>’s <code>Value</code>, at the cost of replacing all previous children with a single new <code>XText</code> node.</p>
</div></section>

<section data-pdf-bookmark="Automatic XText Concatenation" data-type="sect2"><div class="sect2" id="automatic_xtext_concatenation">
<h2>Automatic XText Concatenation</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="automatic XText concatenation" data-type="indexterm" id="id3405"/><a contenteditable="false" data-primary="XText" data-type="indexterm" id="id3406"/>When you add simple content to an <code>XElement</code>, the X-DOM appends to the existing <code>XText</code> child rather than creating a new one. In the following examples, <code>e1</code> and <code>e2</code> end up with just one child <code>XText</code> element whose value is <code>HelloWorld</code>:</p>

<pre data-type="programlisting">
var e1 = new XElement ("test", "Hello"); e1.Add ("World");
var e2 = new XElement ("test", "Hello", "World");</pre>

<p>If you specifically create <code>XText</code> nodes, however, you end up with multiple children:</p>

<pre data-type="programlisting">
var e = new XElement ("test", new XText ("Hello"), new XText ("World"));
Console.WriteLine (e.Value);             // HelloWorld
Console.WriteLine (e.Nodes().Count());   // 2</pre>

<p><code>XElement</code> doesn’t concatenate the two <code>XText</code> nodes, so the nodes’ object identities are preserved.<a contenteditable="false" data-primary="" data-startref="ch10.html7" data-type="indexterm" id="id3407"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Documents and Declarations" data-type="sect1"><div class="sect1" id="documents_and_declarations">
<h1>Documents and Declarations</h1>

<section data-pdf-bookmark="XDocument" data-type="sect2"><div class="sect2" id="xdocument">
<h2>XDocument</h2>

<p><a contenteditable="false" data-primary="XDocument" data-type="indexterm" id="ch10.html8"/>As <a contenteditable="false" data-primary="LINQ to XML" data-secondary="documents and declarations" data-type="indexterm" id="ch10.html9"/>we said previously, an <code>XDocument</code> wraps a root <code>XElement</code> and allows you to add an <a contenteditable="false" data-primary="XDeclaration object" data-type="indexterm" id="id3408"/><code>XDeclaration</code>, processing instructions, a document type, and root-level comments. An <code>XDocument</code> is optional and can be ignored or omitted: unlike with the W3C DOM, it does not serve as glue to keep everything together.</p>

<p>An <code>XDocument</code> provides the same functional constructors as <code>XElement</code>. And because it’s based on <code>XContainer</code>, it also supports the <code>Add<em>XXX</em></code>, <code>Remove<em>XXX</em></code>, and <code>Replace<em>XXX</em></code> methods. Unlike <code>XElement</code>, however, an <code>XDocument</code> can accept only limited content:</p>

<ul>
	<li>
	<p>A single <code>XElement</code> object (the “root”)</p>
	</li>
	<li>
	<p>A single <code>XDeclaration</code> object</p>
	</li>
	<li>
	<p>A single <code>XDocumentType</code> object (to reference a document type definition [DTD])</p>
	</li>
	<li>
	<p>Any number of <code>XProcessingInstruction</code> objects</p>
	</li>
	<li>
	<p>Any number of <code>XComment</code> objects</p>
	</li>
</ul>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Of these, only the root <code>XElement</code> is mandatory in order to have a valid <code>XDocument</code>. The <code>XDeclaration</code> is optional—if omitted, default settings are applied during serialization.</p>
</div>

<p>The simplest valid <code>XDocument</code> has just a root element:</p>

<pre data-type="programlisting">
var doc = new XDocument (
            new XElement ("test", "data")
          );</pre>

<p>Notice that we didn’t include an <code>XDeclaration</code> object. The file generated by calling <code>doc.Save</code> would still contain an XML declaration, however, because one is generated by default.</p>

<p>The next example produces a simple but correct XHTML file, illustrating all the constructs that an <code>XDocument</code> can accept:</p>

<pre data-type="programlisting">
var styleInstruction = new XProcessingInstruction (
  "xml-stylesheet", "href='styles.css' type='text/css'");

var docType = new XDocumentType ("html",
  "-//W3C//DTD XHTML 1.0 Strict//EN",
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd", null);

XNamespace ns = "http://www.w3.org/1999/xhtml";
var root =
  new XElement (ns + "html",
    new XElement (ns + "head",
      new XElement (ns + "title", "An XHTML page")),
    new XElement (ns + "body",
      new XElement (ns + "p", "This is the content"))
  );

var doc =
  new XDocument (
    <strong>new XDeclaration ("1.0", "utf-8", "no"),</strong>
    <strong>new XComment ("Reference a stylesheet"),</strong>
    <strong>styleInstruction,</strong>
    <strong>docType,</strong>
    <strong>root);</strong>

doc.Save ("test.html");</pre>

<p>The resultant <em>test.html</em> reads as follows:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;
&lt;!--Reference a stylesheet--&gt;
&lt;?xml-stylesheet href='styles.css' type='text/css'?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;An XHTML page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;This is the content&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p><code>XDocument</code> has a <code>Root</code> property that serves as a shortcut for accessing a document’s single <code>XElement</code>. The reverse link is provided by <code>XObject</code>’s <code>Document</code> property, which works for all objects in the tree:</p>

<pre data-type="programlisting">
Console.WriteLine (doc.Root.Name.LocalName);          // html
XElement bodyNode = doc.Root.Element (ns + "body");
Console.WriteLine (bodyNode.Document == doc);         // True</pre>

<p>Recall that a document’s children have no <code>Parent</code>:</p>

<pre data-type="programlisting">
Console.WriteLine (doc.Root.Parent == null);          // True
foreach (XNode node in doc.Nodes())
  Console.Write (node.Parent == null);                // TrueTrueTrueTrue</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An <code>XDeclaration</code> is not an <code>XNode</code> and does not appear in the document’s <code>Nodes</code> collection—unlike comments, processing instructions, and the root element. Instead, it’s assigned to a dedicated property called <code>Declaration</code>. This is why “True” is repeated four and not five times in the last example.<a contenteditable="false" data-primary="" data-startref="ch10.html9" data-type="indexterm" id="id3409"/></p>
</div>
</div></section>

<section data-pdf-bookmark="XML Declarations" data-type="sect2"><div class="sect2" id="xml_declarations">
<h2>XML Declarations</h2>

<p><a contenteditable="false" data-primary="LINQ to XML" data-secondary="XML declarations" data-type="indexterm" id="id3410"/><a contenteditable="false" data-primary="XML declarations" data-type="indexterm" id="id3411"/>A standard XML file starts with a declaration such as the following:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;</pre>

<p>An XML declaration ensures that the file will be correctly parsed and understood by a reader. <code>XElement</code> and <code>XDocument</code> follow these rules in emitting XML declarations:</p>

<ul>
	<li>
	<p>Calling <code>Save</code> with a filename always writes a declaration.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="Unicode" data-secondary="XmlWriter and" data-type="indexterm" id="id3412"/>Calling <code>Save</code> with an <code>XmlWriter</code> writes a declaration unless the <code>XmlWriter</code> is instructed otherwise.</p>
	</li>
	<li>
	<p>The <code>ToString</code> method never emits an XML declaration.</p>
	</li>
</ul>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can instruct an <code>XmlWriter</code> not to produce a declaration by setting the <code>OmitXmlDeclaration</code> and <code>ConformanceLevel</code> properties of an <code>XmlWriterSettings</code> object when constructing the <code>XmlWriter</code>. We describe this in <a data-type="xref" href="ch11.html#other_xml_and_json_technologies">Chapter 11</a>.</p>
</div>

<p>The presence or absence of an <code>XDeclaration</code> object has no effect on whether an XML declaration is written. The purpose of an <code>XDeclaration</code> is instead to <em>hint the XML serialization</em>, in two ways:</p>

<ul>
	<li>
	<p>What text encoding to use</p>
	</li>
	<li>
	<p>What to put in the XML declaration’s <code>encoding</code> and <code>standalone</code> attributes (should a declaration be written)</p>
	</li>
</ul>

<p><code>XDeclaration</code>’s constructor accepts three arguments, which correspond to the attributes <code>version</code>, <code>encoding</code>, and <code>standalone</code>. In the following example, <em>test.xml</em> is encoded in UTF-16:</p>

<pre data-type="programlisting">
var doc = new XDocument (
            new XDeclaration ("1.0", "<strong>utf-16</strong>", "yes"),
            new XElement ("test", "data")
          );
doc.Save ("test.xml");</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Whatever you specify for the XML version is ignored by the XML writer: it always writes <code>"1.0"</code>.</p>
</div>

<p>The encoding must use an IETF code such as <code>"utf-16"</code>, just as it would appear in the XML declaration.</p>

<section data-pdf-bookmark="Writing a declaration to a string" data-type="sect3"><div class="sect3" id="writing_a_declaration_to_a_string">
<h3>Writing a declaration to a string</h3>

<p><a contenteditable="false" data-primary="string type" data-secondary="writing a declaration to" data-type="indexterm" id="id3413"/><a contenteditable="false" data-primary="XmlWriter" data-secondary="writing a declaration to a string" data-type="indexterm" id="id3414"/>Suppose that we want to serialize an <code>XDocument</code> to a <code>string</code>, including the XML declaration. Because <code>ToString</code> doesn’t write a declaration, we’d need to use an <code>XmlWriter</code> instead:</p>

<pre data-type="programlisting">
var doc = new XDocument (
            <strong>new XDeclaration ("1.0", "utf-8", "yes"),</strong>
            new XElement ("test", "data")
          );
var output = new StringBuilder();
var settings = new XmlWriterSettings { Indent = true };
using (XmlWriter xw = XmlWriter.Create (output, settings))
  doc.Save (xw);
Console.WriteLine (output.ToString());</pre>

<p>This is the result:</p>

<pre data-type="programlisting">
&lt;?xml version="1.0" encoding="utf-16" standalone="yes"?&gt;
&lt;test&gt;data&lt;/test&gt;</pre>

<p>Notice that we have UTF-16 in the output, even though we explicitly requested UTF-8 in an <code>XDeclaration</code>! This might look like a bug, but in fact, <code>XmlWriter</code> is being remarkably smart. Because we’re writing to a <code>string</code> and not a file or stream, it’s impossible to apply any encoding other than UTF-16—the format in which strings are internally stored. Hence, <code>XmlWriter</code> writes <code>"utf-16"</code> so as not to lie.</p>

<p>This also explains why the <code>ToString</code> method doesn’t emit an XML declaration. Imagine that instead of calling <code>Save</code>, you did the following to write an <code>XDocument</code> to a file:</p>

<pre data-type="programlisting">
File.WriteAllText ("data.xml", doc.ToString());</pre>

<p>As it stands, <em>data.xml</em> would lack an XML declaration, making it incomplete but still parsable (you can infer the text encoding). But if <code>ToString()</code> emitted an XML <span class="keep-together">declaration</span>, <em>data.xml</em> would actually contain an <em>incorrect</em> declaration (<code>encoding="utf-16"</code>), which might prevent it from being read at all because <code>WriteAllText</code> encodes using UTF-8.<a contenteditable="false" data-primary="" data-startref="ch10.html8" data-type="indexterm" id="id3415"/></p>
</div></section>
</div></section>
</div></section>

<section data-pdf-bookmark="Names and Namespaces" data-type="sect1"><div class="sect1" id="names_and_namespaces">
<h1>Names and Namespaces</h1>

<p><a contenteditable="false" data-primary="LINQ to XML" data-secondary="names and namespaces" data-type="indexterm" id="ch10.html10"/><a contenteditable="false" data-primary="namespaces" data-secondary="XML" data-type="indexterm" id="ch10.html11"/>Just as .NET types can have namespaces, so too can XML elements and attributes.</p>

<p>XML namespaces achieve two things. First, rather like namespaces in C#, they help prevent naming collisions. This can become an issue when you merge data from one XML file into another. Second, namespaces assign <em>absolute</em> meaning to a name. The name “nil,” for instance, could mean anything. Within the <em>http://www.w3.org/2001/xmlschema-instance</em> namespace, however, “nil” means something equivalent to <code>null</code> in C# and comes with specific rules on how it can be applied.</p>

<p>Because XML namespaces are a significant source of confusion, we first cover namespaces in general, and then move on to how they’re used in LINQ to XML.</p>

<section data-pdf-bookmark="Namespaces in XML" data-type="sect2"><div class="sect2" id="namespaces_in_xml">
<h2>Namespaces in XML</h2>

<p>Suppose that we want to define a <code>customer</code> element in the namespace <code>OReilly.Nutshell.CSharp</code>. There are two ways to proceed. The first is to use the <code>xmlns</code> attribute:</p>

<pre data-type="programlisting">
&lt;customer <strong>xmlns="OReilly.Nutshell.CSharp"</strong>/&gt;</pre>

<p><code>xmlns</code> is a special reserved attribute. When used in this manner, it performs two functions:</p>

<ul>
	<li>
	<p>It specifies a namespace for the element in question.</p>
	</li>
	<li>
	<p>It specifies a default namespace for all descendant elements.</p>
	</li>
</ul>

<p>This means that in the following example, <code>address</code> and <code>postcode</code> implicitly reside in the <code>OReilly.Nutshell.CSharp</code> namespace:</p>

<pre data-type="programlisting">
&lt;customer xmlns="OReilly.Nutshell.CSharp"&gt;
  &lt;address&gt;
    &lt;postcode&gt;02138&lt;/postcode&gt;
  &lt;/address&gt;
&lt;/customer&gt;</pre>

<p class="pagebreak-before">If we want <code>address</code> and <code>postcode</code> to have <em>no</em> namespace, we’d need to do this:</p>

<pre data-type="programlisting">
&lt;customer xmlns="OReilly.Nutshell.CSharp"&gt;
  &lt;address <strong>xmlns=""</strong>&gt;
    &lt;postcode&gt;02138&lt;/postcode&gt;     &lt;!-- postcode now inherits empty ns --&gt;
  &lt;/address&gt;
&lt;/customer&gt;</pre>

<section data-pdf-bookmark="Prefixes" data-type="sect3"><div class="sect3" id="prefixes-id00072">
<h3>Prefixes</h3>

<p><a contenteditable="false" data-primary="namespaces" data-secondary="prefixes" data-type="indexterm" id="id3416"/><a contenteditable="false" data-primary="prefixes" data-secondary="namespaces and" data-type="indexterm" id="id3417"/>The other way to specify a namespace is with a <em>prefix</em>. A prefix is an alias that you assign to a namespace to save typing. There are two steps in using a prefix—<em>defining</em> the prefix and <em>using</em> it. You can do both together:</p>

<pre data-type="programlisting">
&lt;<strong>nut:</strong>customer <strong>xmlns:nut</strong>="OReilly.Nutshell.CSharp"/&gt;</pre>

<p>Two distinct things are happening here. On the right, <code>xmlns:nut="..."</code> defines a prefix called <code>nut</code> and makes it available to this element and all its descendants. On the left, <code>nut:customer</code> assigns the newly allocated prefix to the <code>customer</code> element.</p>

<p>A prefixed element <em>does not</em> define a default namespace for descendants. In the following XML, <code>firstname</code> has an empty namespace:</p>

<pre data-type="programlisting">
&lt;nut:customer xmlns:nut="OReilly.Nutshell.CSharp"&gt;
  &lt;firstname&gt;Joe&lt;/firstname&gt;
&lt;/customer&gt;</pre>

<p>To give <code>firstname</code> the <code>OReilly.Nutshell.CSharp</code> prefix, you must do this:</p>

<pre data-type="programlisting">
&lt;nut:customer xmlns:nut="OReilly.Nutshell.CSharp"&gt;
  &lt;<strong>nut:</strong>firstname&gt;Joe&lt;/firstname&gt;
&lt;/customer&gt;</pre>

<p>You can also define a prefix—or prefixes—for the convenience of your descendants, without assigning any of them to the parent element itself. The following defines two prefixes, <code>i</code> and <code>z</code>, while leaving the <code>customer</code> element itself with an empty namespace:</p>

<pre data-type="programlisting">
&lt;customer xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:z="http://schemas.microsoft.com/2003/10/Serialization/"&gt;
  ...
&lt;/customer&gt;</pre>

<p>If this were the root node, the whole document would have <code>i</code> and <code>z</code> at its fingertips. Prefixes are convenient when elements need to draw from multiple namespaces.</p>

<p>Notice that both namespaces in this example are URIs. Using URIs (that you own) is standard practice: it ensures namespace uniqueness. So, in real life, our <code>customer</code> element would more likely be:</p>

<pre data-type="programlisting">
&lt;customer xmlns="http://oreilly.com/schemas/nutshell/csharp"/&gt;</pre>

<p>or:</p>

<pre data-type="programlisting">
&lt;nut:customer xmlns:nut="http://oreilly.com/schemas/nutshell/csharp"/&gt;</pre>
</div></section>

<section data-pdf-bookmark="Attributes" data-type="sect3"><div class="sect3" id="attribute">
<h3>Attributes</h3>

<p><a contenteditable="false" data-primary="attributes" data-secondary="namespaces and" data-type="indexterm" id="id3418"/><a contenteditable="false" data-primary="namespaces" data-secondary="attributes" data-type="indexterm" id="id3419"/>You can assign namespaces to attributes, too. The main difference is that an attribute always requires a prefix. For instance:</p>

<pre data-type="programlisting">
&lt;customer xmlns:nut="OReilly.Nutshell.CSharp" <strong>nut:id="123"</strong> /&gt;</pre>

<p>Another difference is that an unqualified attribute always has an empty namespace: it never inherits a default namespace from a parent element.</p>

<p>Attributes tend not to need namespaces because their meaning is usually local to the element. An exception is with general-purpose or metadata attributes such as the <code>nil</code> attribute defined by W3C:</p>

<pre data-type="programlisting">
&lt;customer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;firstname&gt;Joe&lt;/firstname&gt;
  &lt;lastname <strong>xsi:nil="true"</strong>/&gt;
&lt;/customer&gt;</pre>

<p>This indicates unambiguously that <code>lastname</code> is <code>nil</code> (<code>null</code> in C#) and not an empty string. Because we’ve used the standard namespace, a general-purpose parsing utility could know with certainty our intention.</p>
</div></section>
</div></section>

<section data-pdf-bookmark="Specifying Namespaces in the X-DOM" data-type="sect2"><div class="sect2" id="specifying_namespaces_in_the_x_dom">
<h2>Specifying Namespaces in the X-DOM</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="namespace specification" data-type="indexterm" id="id3420"/>So <a contenteditable="false" data-primary="namespaces" data-secondary="X-DOM" data-type="indexterm" id="ch10.html12"/>far in this chapter, we’ve used just simple strings for <code>XElement</code> and <code>XAttribute</code> names. A simple string corresponds to an XML name with an empty namespace—rather like a .NET type defined in the global namespace.</p>

<p>There are a couple of ways to specify an XML namespace. The first is to enclose it in braces, before the local name:</p>

<pre data-type="programlisting">
var e = new XElement ("<strong>{http://domain.com/xmlspace}customer</strong>", "Bloggs");
Console.WriteLine (e.ToString());</pre>

<p>This yields the resulting XML:</p>

<pre data-type="programlisting">
&lt;customer xmlns="http://domain.com/xmlspace"&gt;Bloggs&lt;/customer&gt;</pre>

<p>The second (and more performant) approach is to use the <code>XNamespace</code> and <code>XName</code> types. Here are their definitions:</p>

<pre data-type="programlisting">
public sealed class XNamespace
{
  public string NamespaceName { get; }
}

public sealed class XName     // A local name with optional namespace
{
  public string LocalName { get; }
  public XNamespace Namespace { get; }   // Optional
}</pre>

<p>Both types define implicit casts from <code>string</code>, so the following is legal:</p>

<pre data-type="programlisting">
XNamespace ns   = "http://domain.com/xmlspace";
XName localName = "customer";
XName fullName  = "{http://domain.com/xmlspace}customer";</pre>

<p><code>XNamespace</code> also overloads the <code>+</code> operator, allowing you to combine a namespace and name into an <code>XName</code> without using braces:</p>

<pre data-type="programlisting">
XNamespace ns = "http://domain.com/xmlspace";
<strong>XName fullName = ns + "customer";</strong>
Console.WriteLine (fullName);     // {http://domain.com/xmlspace}customer</pre>

<p>All constructors and methods in the X-DOM that accept an element or attribute name actually accept an <code>XName</code> object rather than a <code>string</code>. The reason you can substitute a string—as in all our examples to date—is because of the implicit cast.</p>

<p>Specifying a namespace is the same whether for an element or an attribute:</p>

<pre data-type="programlisting">
XNamespace ns = "http://domain.com/xmlspace";
var data = new XElement (<strong>ns + "data"</strong>,
              new XAttribute (<strong>ns + "id"</strong>, 123)
           );</pre>
</div></section>

<section data-pdf-bookmark="The X-DOM and Default Namespaces" data-type="sect2"><div class="sect2" id="the_x_dom_and_default_namespaces">
<h2>The X-DOM and Default Namespaces</h2>

<p><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="default namespaces" data-type="indexterm" id="id3421"/>The X-DOM ignores the concept of default namespaces until it comes time to actually output XML. This means that when you construct a child <code>XElement</code>, you must give it a namespace explicitly if needed; it <em>will not</em> inherit from the parent:</p>

<pre data-type="programlisting">
XNamespace ns = "http://domain.com/xmlspace";
var data = new XElement (<strong>ns + "data"</strong>,
             new XElement (<strong>ns + "customer"</strong>, "Bloggs"),
             new XElement (<strong>ns + "purchase"</strong>, "Bicycle")
           );</pre>

<p>The X-DOM does, however, apply default namespaces when reading and outputting XML:</p>

<pre data-type="programlisting">
Console.WriteLine (data.ToString());

OUTPUT:
  <strong>&lt;data xmlns="http://domain.com/xmlspace"&gt;</strong>
    <strong>&lt;customer&gt;Bloggs&lt;/customer&gt;</strong>
    <strong>&lt;purchase&gt;Bicycle&lt;/purchase&gt;</strong>
  <strong>&lt;/data&gt;</strong>

Console.WriteLine (data.Element (ns + "customer").ToString());

OUTPUT:
  <strong>&lt;customer xmlns="http://domain.com/xmlspace"&gt;Bloggs&lt;/customer&gt;</strong></pre>

<p>If you construct <code>XElement</code> children without specifying namespaces, in other words</p>

<pre data-type="programlisting">
XNamespace ns = "http://domain.com/xmlspace";
var data = new XElement (ns + "data",
             new XElement (<strong>"customer"</strong>, "Bloggs"),
             new XElement (<strong>"purchase"</strong>, "Bicycle")
           );
Console.WriteLine (data.ToString());</pre>

<p>you get this result instead:</p>

<pre data-type="programlisting">
&lt;data xmlns="http://domain.com/xmlspace"&gt;
  &lt;customer <strong>xmlns=""</strong>&gt;Bloggs&lt;/customer&gt;
  &lt;purchase <strong>xmlns=""</strong>&gt;Bicycle&lt;/purchase&gt;
&lt;/data&gt;</pre>

<p>Another trap is failing to include a namespace when navigating an X-DOM:</p>

<pre data-type="programlisting">
XNamespace ns = "http://domain.com/xmlspace";
var data = new XElement (<strong>ns + "data"</strong>,
             new XElement (<strong>ns + "customer"</strong>, "Bloggs"),
             new XElement (<strong>ns + "purchase"</strong>, "Bicycle")
           );
XElement x = data.Element (ns + "customer");    // ok
XElement y = data.Element ("customer");         // null</pre>

<p>If you build an X-DOM tree without specifying namespaces, you can subsequently assign every element to a single namespace, as follows:<a contenteditable="false" data-primary="" data-startref="ch10.html12" data-type="indexterm" id="id3422"/></p>

<pre data-type="programlisting">
foreach (XElement e in data.DescendantsAndSelf())
  if (e.Name.Namespace == "")
    e.Name = ns + e.Name.LocalName;</pre>
</div></section>

<section data-pdf-bookmark="Prefixes" data-type="sect2"><div class="sect2" id="prefixes-id00074">
<h2>Prefixes</h2>

<p><a contenteditable="false" data-primary="prefixes" data-secondary="X-DOM" data-type="indexterm" id="id3423"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="prefixes" data-type="indexterm" id="id3424"/>The X-DOM treats prefixes just as it treats namespaces: purely as a serialization function. This means that you can choose to completely ignore the issue of prefixes—and get by! The only reason you might want to do otherwise is for efficiency when outputting to an XML file. For example, consider this:</p>

<pre data-type="programlisting">
XNamespace ns1 = "http://domain.com/space1";
XNamespace ns2 = "http://domain.com/space2";

var mix = new XElement (ns1 + "data",
            new XElement (ns2 + "element", "value"),
            new XElement (ns2 + "element", "value"),
            new XElement (ns2 + "element", "value")
          );</pre>

<p>By default, <code>XElement</code> will serialize this as follows:</p>

<pre data-type="programlisting">
&lt;data xmlns="http://domain.com/space1"&gt;
  &lt;element xmlns="http://domain.com/space2"&gt;value&lt;/element&gt;
  &lt;element xmlns="http://domain.com/space2"&gt;value&lt;/element&gt;
  &lt;element xmlns="http://domain.com/space2"&gt;value&lt;/element&gt;
&lt;/data&gt;</pre>

<p>As you can see, there’s a bit of unnecessary duplication. The solution is <em>not</em> to change the way you construct the X-DOM, but instead to hint the serializer prior to writing the XML. Do this by adding attributes defining prefixes that you want to see applied. This is typically done on the root element:</p>

<pre data-type="programlisting">
mix.SetAttributeValue (XNamespace.Xmlns + "ns1", ns1);
mix.SetAttributeValue (XNamespace.Xmlns + "ns2", ns2);</pre>

<p>This assigns the prefix “ns1” to our <code>XNamespace</code> variable <code>ns1</code>, and “ns2” to <code>ns2</code>. The X-DOM automatically picks up these attributes when serializing and uses them to condense the resulting XML. Here’s the result now of calling <code>ToString</code> on <code>mix</code>:</p>

<pre data-type="programlisting">
&lt;ns1:data xmlns:ns1="http://domain.com/space1"
          xmlns:ns2="http://domain.com/space2"&gt;
  &lt;ns2:element&gt;value&lt;/ns2:element&gt;
  &lt;ns2:element&gt;value&lt;/ns2:element&gt;
  &lt;ns2:element&gt;value&lt;/ns2:element&gt;
&lt;/ns1:data&gt;</pre>

<p>Prefixes don’t change the way you construct, query, or update the X-DOM—for these activities, you ignore the presence of prefixes and continue to use full names. Prefixes come into play only when converting to and from XML files or streams.</p>

<p>Prefixes are also honored in serializing attributes. In the following example, we record a customer’s date of birth and credit as <code>"nil"</code> using the W3C-standard attribute. The highlighted line ensures that the prefix is serialized without unnecessary namespace repetition:</p>

<pre data-type="programlisting">
XNamespace xsi = "http://www.w3.org/2001/XMLSchema-instance";
var nil = new XAttribute (xsi + "nil", true);

var cust = new XElement ("customers",
             <strong>new XAttribute (XNamespace.Xmlns + "xsi", xsi),</strong>
             new XElement ("customer",
               new XElement ("lastname", "Bloggs"),
               new XElement ("dob", nil),
               new XElement ("credit", nil)
             )
           );</pre>

<p>This is its XML:</p>

<pre data-type="programlisting">
&lt;customers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;customer&gt;
    &lt;lastname&gt;Bloggs&lt;/lastname&gt;
    &lt;dob xsi:nil="true" /&gt;
    &lt;credit xsi:nil="true" /&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre>

<p>For brevity, we predeclared the nil <code>XAttribute</code> so that we could use it twice in building the DOM. You’re allowed to reference the same attribute twice because it’s automatically duplicated as required.<a contenteditable="false" data-primary="" data-startref="ch10.html11" data-type="indexterm" id="id3425"/><a contenteditable="false" data-primary="" data-startref="ch10.html10" data-type="indexterm" id="id3426"/></p>
</div></section>
</div></section>

<section data-pdf-bookmark="Annotations" data-type="sect1"><div class="sect1" id="annotations">
<h1>Annotations</h1>

<p><a contenteditable="false" data-primary="annotations, LINQ to XML" data-type="indexterm" id="id3427"/><a contenteditable="false" data-primary="LINQ to XML" data-secondary="annotations" data-type="indexterm" id="id3428"/><a contenteditable="false" data-primary="XObject" data-type="indexterm" id="id3429"/>You can attach custom data to any <code>XObject</code> with an annotation. Annotations are intended for your own private use and are treated as black boxes by X-DOM. If you’ve ever used the <code>Tag</code> property on a Windows Forms or Windows Presentation Foundation (WPF) control, you’ll be familiar with the concept—the difference is that you have multiple annotations, and your annotations can be <em>privately scoped</em>. You can create an annotation that other types cannot even see—let alone overwrite.</p>

<p>The following methods on <code>XObject</code> add and remove annotations:</p>

<pre data-type="programlisting">
public void AddAnnotation (object annotation)
public void RemoveAnnotations&lt;T&gt;()     where T : class</pre>

<p>The following methods retrieve annotations:</p>

<pre data-type="programlisting">
public T Annotation&lt;T&gt;()               where T : class
public IEnumerable&lt;T&gt; Annotations&lt;T&gt;() where T : class</pre>

<p>Each annotation is keyed by its <em>type</em>, which must be a reference type. The following adds and then retrieves a <code>string</code> annotation:</p>

<pre data-type="programlisting">
XElement e = new XElement ("test");
e.AddAnnotation ("Hello");
Console.WriteLine (e.Annotation&lt;string&gt;());   // Hello</pre>

<p>You can add multiple annotations of the same type and then use the <code>Annotations</code> method to retrieve a <em>sequence</em> of matches.</p>

<p>A public type such as <code>string</code> doesn’t make a great key, however, because code in other types can interfere with your annotations. A better approach is to use an internal or (nested) private class:</p>

<pre data-type="programlisting">
class X
{
  class CustomData { internal string Message; }   // Private nested type

  static void Test()
  {
    XElement e = new XElement ("test");
    e.AddAnnotation (new CustomData { Message = "Hello" } );
    Console.Write (e.Annotations&lt;CustomData&gt;().First().Message);  // Hello
  }
}</pre>

<p>To remove annotations, you must also have access to the key’s type:</p>

<pre data-type="programlisting">
e.RemoveAnnotations&lt;CustomData&gt;();</pre>
</div></section>

<section data-pdf-bookmark="Projecting into an X-DOM" data-type="sect1"><div class="sect1" id="projecting_into_an_x_dom">
<h1>Projecting into an X-DOM</h1>

<p><a contenteditable="false" data-primary="LINQ queries" data-secondary="projecting into an X-DOM" data-type="indexterm" id="ch10.html13"/><a contenteditable="false" data-primary="projecting" data-secondary="into an X-DOM" data-type="indexterm" id="ch10.html14"/><a contenteditable="false" data-primary="XML DOM (X-DOM)" data-secondary="projecting into" data-type="indexterm" id="ch10.html15"/>So far, we’ve shown how to use LINQ to get data <em>out</em> of an X-DOM. You can also use LINQ queries to project <em>into</em> an X-DOM. The source can be anything over which LINQ can query, such as the following:</p>

<ul>
	<li>
	<p>EF Core entity classes</p>
	</li>
	<li>
	<p>A local collection</p>
	</li>
	<li>
	<p>Another X-DOM</p>
	</li>
</ul>

<p>Regardless of the source, the strategy is the same in using LINQ to emit an X-DOM: first write a <em>functional construction</em> expression that produces the desired X-DOM shape and then build a LINQ query around the expression.</p>

<p>For instance, suppose that we want to retrieve customers from a database into the following XML:</p>

<pre data-type="programlisting">
&lt;customers&gt;
  &lt;customer id="1"&gt;
    &lt;name&gt;Sue&lt;/name&gt;
    &lt;buys&gt;3&lt;/buys&gt;
  &lt;/customer&gt;
  ...
&lt;/customers&gt;</pre>

<p>We start by writing a functional construction expression for the X-DOM using simple literals:</p>

<pre data-type="programlisting">
var customers =
  new XElement ("customers",
    new XElement ("customer", new XAttribute ("id", 1),
      new XElement ("name", "Sue"),
      new XElement ("buys", 3)
    )
  );</pre>

<p>We then turn this into a projection and build a LINQ query around it:</p>

<pre data-type="programlisting">
var customers =
  new XElement ("customers",
    // We must call AsEnumerable() due to a bug in EF Core.
    <strong>from c in dbContext.Customers.AsEnumerable()</strong>
    <strong>select</strong>
      new XElement ("customer", new XAttribute ("id", <strong>c.ID</strong>),
        new XElement ("name", <strong>c.Name</strong>),
        new XElement ("buys", <strong>c.Purchases.Count</strong>)
      )
    );</pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The call to <code>AsEnumerable</code> is required due to a bug in EF Core (a fix is scheduled for a later release). After the bug is fixed, removing the call to <code>AsEnumerable</code> will improve efficiency by preventing a round-trip with each call to <code>c.Purchases.Count</code>.</p>
</div>

<p>Here’s the result:</p>

<pre data-type="programlisting">
&lt;customers&gt;
  &lt;customer id="1"&gt;
    &lt;name&gt;Tom&lt;/name&gt;
    &lt;buys&gt;3&lt;/buys&gt;
  &lt;/customer&gt;
  &lt;customer id="2"&gt;
    &lt;name&gt;Harry&lt;/name&gt;
    &lt;buys&gt;2&lt;/buys&gt;
  &lt;/customer&gt;
    ...
&lt;/customers&gt;</pre>

<p>We can see how this works more clearly by constructing the same query in two steps. First:</p>

<pre data-type="programlisting">
IEnumerable&lt;XElement&gt; sqlQuery =
  from c in dbContext.Customers.AsEnumerable()
  select
    new XElement ("customer", new XAttribute ("id", c.ID),
      new XElement ("name", c.Name),
      new XElement ("buys", c.Purchases.Count)
    );</pre>

<p>This inner portion is a normal LINQ query that projects into <code>XElement</code>s. Here’s the second step:</p>

<pre data-type="programlisting">
var customers = new XElement ("customers", sqlQuery);</pre>

<p>This constructs the root <code>XElement</code>. The only thing unusual is that the content, <code>sqlQuery</code>, is not a single <code>XElement</code> but an <code>IQueryable&lt;XElement&gt;</code>, which implements <code>IEnumerable&lt;XElement&gt;</code>. Remember that in the processing of XML content, collections are automatically enumerated. So, each <code>XElement</code> is added as a child node.</p>

<section data-pdf-bookmark="Eliminating Empty Elements" data-type="sect2"><div class="sect2" id="eliminating_empty_elements">
<h2>Eliminating Empty Elements</h2>

<p>Suppose in the preceding example that we also wanted to include details of the customer’s most recent high-value purchase. We could do this as follows:</p>

<pre data-type="programlisting">
var customers =
  new XElement ("customers",
    // The AsEnumerable call can be removed when the EF Core bug is fixed.
    from c in dbContext.Customers.AsEnumerable()
    let lastBigBuy = (from p in c.Purchases
                      where p.Price &gt; 1000
                      orderby p.Date descending
                      select p).FirstOrDefault()
    select
      new XElement ("customer", new XAttribute ("id", c.ID),
        new XElement ("name", c.Name),
        new XElement ("buys", c.Purchases.Count),
        <strong>new XElement ("lastBigBuy",</strong>
          <strong>new XElement ("description", lastBigBuy?.Description),</strong>
          <strong>new XElement ("price", lastBigBuy?.Price ?? 0m)</strong>
        )
      )
  );</pre>

<p>This emits empty elements, though, for customers with no high-value purchases. (If it were a local query rather than a database query, it would throw a <code>NullReferenceException</code>.) In such cases, it would be better to omit the <code>lastBigBuy</code> node entirely. We can achieve this by wrapping the constructor for the <code>lastBigBuy</code> element in a conditional operator:</p>

<pre data-type="programlisting">
    select
      new XElement ("customer", new XAttribute ("id", c.ID),
        new XElement ("name", c.Name),
        new XElement ("buys", c.Purchases.Count),
        <strong>lastBigBuy == null ? null :</strong>
          <strong>new XElement ("lastBigBuy",</strong>
<strong>            new XElement ("description", lastBigBuy.Description),</strong>
<strong>            new XElement ("price", lastBigBuy.Price)</strong></pre>

<p>For customers with no <code>lastBigBuy</code>, a <code>null</code> is emitted instead of an empty <code>XElement</code>. This is what we want, because <code>null</code> content is simply ignored.</p>
</div></section>

<section data-pdf-bookmark="Streaming a Projection" data-type="sect2"><div class="sect2" id="streaming_a_projection">
<h2>Streaming a Projection</h2>

<p><a contenteditable="false" data-primary="XStreamingElement" data-type="indexterm" id="id3430"/>If you’re projecting into an X-DOM only to <code>Save</code> it (or call <code>ToString</code> on it), you can improve memory efficiency through an <code>XStreamingElement</code>. <a contenteditable="false" data-primary="deferred loading" data-type="indexterm" id="id3431"/>An <code>XStreaming​Ele⁠ment</code> is a cut-down version of <code>XElement</code> that applies <em>deferred loading</em> semantics to its child content. To use it, you simply replace the outer <code>XElement</code>s with <code>XStreamin⁠g​Element</code>s:</p>

<pre data-type="programlisting">
var customers =
  new <strong>XStreamingElement</strong> ("customers",
    from c in dbContext.Customers
    select
      new <strong>XStreamingElement</strong> ("customer", new XAttribute ("id", c.ID),
        new XElement ("name", c.Name),
        new XElement ("buys", c.Purchases.Count)
      )
    );
customers.Save ("data.xml");</pre>

<p>The queries passed into an <code>XStreamingElement</code>’s constructor are not enumerated until you call <code>Save</code>, <code>ToString</code>, or <code>WriteTo</code> on the element; this prevents loading the whole X-DOM into memory at once. The flipside is that the queries are reevaluated, should you re-<code>Save</code>. Also, you cannot traverse an <code>XStreamingElement</code>’s child content—it does not expose methods such as <code>Elements</code> or <code>Attributes</code>.</p>

<p><code>XStreamingElement</code> is not based on <code>XObject</code>—or any other class—because it has such a limited set of members. The only members it has, besides <code>Save</code>, <code>ToString</code>, and <code>WriteTo</code>, are the following:</p>

<ul>
	<li>
	<p>An <code>Add</code> method, which accepts content like the constructor</p>
	</li>
	<li>
	<p>A <code>Name</code> property</p>
	</li>
</ul>

<p><code>XStreamingElement</code> does not allow you to <em>read</em> content in a streamed fashion—for this, you must use an <code>XmlReader</code> in conjunction with the X-DOM. We describe how to do this in <a data-type="xref" href="ch11.html#patterns_for_using_xmlreadersolidusxmlw">“Patterns for Using XmlReader/XmlWriter”</a><a contenteditable="false" data-primary="" data-startref="ch10.html15" data-type="indexterm" id="id3432"/><a contenteditable="false" data-primary="" data-startref="ch10.html14" data-type="indexterm" id="id3433"/><a contenteditable="false" data-primary="" data-startref="ch10.html13" data-type="indexterm" id="id3434"/>.<a contenteditable="false" data-primary="" data-startref="ch10.html0" data-type="indexterm" id="id3435"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn11"><sup><a href="ch10.html#ch01fn11-marker">1</a></sup> The X-DOM actually optimizes this step internally by storing simple text content in a string. The <code>XTEXT</code> node is not actually created until you call <code>Nodes( )</code> on the <code>XContainer</code>.</p><p data-type="footnote" id="ch01fn12"><sup><a href="ch10.html#ch01fn12-marker">2</a></sup> See <a data-type="link" href="#ch01fn11">footnote 1</a>.</p></div></div></section></body></html>