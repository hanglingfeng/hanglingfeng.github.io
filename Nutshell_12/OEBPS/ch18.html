<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Reflection and Metadata</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3330d66d-9080-4595-aa6c-b8113bd76e5a" name="Adept.expected.resource"/></head><body data-type="book"><section data-nutshell-tab="Reflection and Metadata" data-pdf-bookmark="Chapter 18. Reflection and Metadata" data-type="chapter" epub:type="chapter"><div class="chapter" id="reflection_and_metadata">
<h1><span class="label">Chapter 18. </span>Reflection and Metadata</h1>
<p><a contenteditable="false" data-primary="reflection" data-type="indexterm" id="ch18.html100"/>As we saw in <a data-type="xref" href="ch17.html#assemblies">Chapter 17</a>, a C# program compiles into an assembly that includes metadata, compiled code, and resources. Inspecting the metadata and compiled code at runtime is called <em>reflection</em>.</p>
<p>The compiled code in an assembly contains almost all of the content of the original source code. Some information is lost, such as local variable names, comments, and preprocessor directives. However, reflection can access pretty much everything else, even making it possible to write a decompiler.</p>
<p>Many of the services available in .NET and exposed via C# (such as dynamic binding, serialization, and data binding) depend on the presence of metadata. Your own programs can also take advantage of this metadata and even extend it with new information using custom attributes. The <code>System.Reflection</code> namespace houses the reflection API. <a contenteditable="false" data-primary="System..." data-secondary="System.Reflection.Emit" data-type="indexterm" id="id4124"/>It is also possible at runtime to dynamically create new metadata and executable instructions in Intermediate Language (IL) via the classes in the <code>System.Reflection.Emit</code> namespace.</p>
<p>The examples in this chapter assume that you import the <code>System</code> and <code>Sys⁠tem.​Reflection</code> as well as <code>System.Reflection.Emit</code> namespaces.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When we use the term “dynamically” in this chapter, we mean using reflection to perform some task whose type safety is enforced only at runtime. This is similar in principle to <em>dynamic binding</em> via C#’s <code>dynamic</code> keyword, although the mechanism and functionality is different.</p>
<p>Dynamic binding is much easier to use and employs the Dynamic Language Runtime (DLR) for dynamic language interoperability. Reflection is relatively clumsy to use, but it is more flexible in terms of what you can do with the CLR. For instance, reflection lets you obtain lists of types and members, instantiate an object whose name comes from a string, and build assemblies on the fly.</p>
</div>
<section data-pdf-bookmark="Reflecting and Activating Types" data-type="sect1"><div class="sect1" id="reflecting_and_activating_types">
<h1>Reflecting and Activating Types</h1>
<p><a contenteditable="false" data-primary="reflection" data-secondary="reflecting and activating types" data-type="indexterm" id="ch18.html101"/><a contenteditable="false" data-primary="types" data-secondary="reflecting and activating" data-type="indexterm" id="ch18.html102"/>In this section, we examine how to obtain a <code>Type</code>, inspect its metadata, and use it to dynamically instantiate an object.</p>
<section data-pdf-bookmark="Obtaining a Type" data-type="sect2"><div class="sect2" id="obtaining_a_type">
<h2>Obtaining a Type</h2>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Type" data-type="indexterm" id="id4125"/><a contenteditable="false" data-primary="reflection" data-secondary="obtaining a type" data-type="indexterm" id="ch18.html103"/>An instance of <code>System.Type</code> represents the metadata for a type. Because <code>Type</code> is widely used, it lives in the <code>System</code> namespace rather than the <code>System.Reflection</code> namespace.</p>
<p>You can get an instance of a <code>System.Type</code> by calling <code>GetType</code> on any object or with C#’s <code>typeof</code> operator:</p>
<pre data-type="programlisting">Type t1 = DateTime.Now.GetType();     // Type obtained at runtime
Type t2 = typeof (DateTime);          // Type obtained at compile time</pre>
<p>You can use <code>typeof</code> to obtain array types and generic types, as follows:</p>
<pre data-type="programlisting">Type t3 = typeof (DateTime[]);          // 1-d Array type
Type t4 = typeof (DateTime[,]);         // 2-d Array type
Type t5 = typeof (Dictionary&lt;int,int&gt;); // Closed generic type
Type t6 = typeof (Dictionary&lt;,&gt;);       // Unbound generic type</pre>
<p><a contenteditable="false" data-primary="Assembly..." data-secondary="Assembly.GetType" data-type="indexterm" id="id4126"/>You can also retrieve a <code>Type</code> by name. If you have a reference to its <code>Assembly</code>, call <code>Assembly.GetType</code> (we describe this further in the section <a data-type="xref" href="#reflecting_assemblies">“Reflecting Assemblies”</a>):</p>
<pre data-type="programlisting">Type t = Assembly.GetExecutingAssembly().GetType ("Demos.TestProgram");</pre>
<p>If you don’t have an <code>Assembly</code> object, you can obtain a type through its <em>assembly qualified name</em> (the type’s full name followed by the assembly’s fully  or partially  qualified name). The assembly implicitly loads as if you called <code>Assembly.Load(string)</code>:</p>
<pre data-type="programlisting">Type t = Type.GetType ("System.Int32, System.Private.CoreLib");</pre>
<p>After you have a <code>System.Type</code> object, you can use its properties to access the type’s name, assembly, base type, visibility, and so on:</p>
<pre data-type="programlisting">Type stringType = typeof (string);
string name     = stringType.Name;          // String
Type baseType   = stringType.BaseType;      // typeof(Object)
Assembly assem  = stringType.Assembly;      // System.Private.CoreLib
bool isPublic   = stringType.IsPublic;      // true</pre>
<p>A <code>System.Type</code> instance is a window into the entire metadata for the type—and the assembly in which it’s defined.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>System.Type</code> is abstract, so the <code>typeof</code> operator must actually give you a subclass of <code>Type</code>. The subclass that the CLR uses is internal to .NET and is called <code>RuntimeType</code>.</p>
</div>
<section data-pdf-bookmark="TypeInfo" data-type="sect3"><div class="sect3" id="typeinfo">
<h3>TypeInfo</h3>
<p><a contenteditable="false" data-primary="Type..." data-secondary="TypeInfo class" data-type="indexterm" id="id4127"/>Should you target .NET Core 1.x (or an older Windows Store profile), you’ll find most of <code>Type</code>’s members are missing. These missing members are exposed instead on a class called <code>TypeInfo</code>, which you obtain by calling <code>GetTypeInfo</code>. So, to get our previous example to run, you would do this:</p>
<pre data-type="programlisting">Type stringType = typeof(string);
string name = stringType.Name;
Type baseType = stringType.<strong>GetTypeInfo()</strong>.BaseType;
Assembly assem = stringType.<strong>GetTypeInfo()</strong>.Assembly;
bool isPublic = stringType.<strong>GetTypeInfo()</strong>.IsPublic;</pre>
<p><code>TypeInfo</code> also exists in .NET Core 2 and 3 and .NET 5+ (and .NET Framework 4.5+ and all .NET Standard versions), so the preceding code works almost universally. <code>TypeInfo</code> also includes additional properties and methods for reflecting over members.</p>
</div></section>
<section data-pdf-bookmark="Obtaining array types" data-type="sect3"><div class="sect3" id="obtaining_array_types">
<h3>Obtaining array types</h3>
<p><a contenteditable="false" data-primary="array types, obtaining" data-type="indexterm" id="id4128"/>As we just saw, <code>typeof</code> and <code>GetType</code> work with array types. You can also obtain an array type by calling <code>MakeArrayType</code> on the <em>element</em> type:</p>
<pre data-type="programlisting">Type simpleArrayType = typeof (int).<strong>MakeArrayType()</strong>;
Console.WriteLine (simpleArrayType == typeof (int[]));     // True</pre>
<p>You can create multidimensional arrays by passing an integer argument to <code>MakeArrayType</code>:</p>
<pre data-type="programlisting">Type cubeType = typeof (int).<strong>MakeArrayType (3)</strong>;       // cube shaped
Console.WriteLine (cubeType == typeof (int[,,]));     // True</pre>
<p><code>GetElementType</code> does the reverse: it retrieves an array type’s element type:</p>
<pre data-type="programlisting">Type e = typeof (int[]).GetElementType();     // e == typeof (int)</pre>
<p><code>GetArrayRank</code> returns the number of dimensions of a rectangular array:</p>
<pre data-type="programlisting">int rank = typeof (int[,,]).GetArrayRank();   // 3</pre>
</div></section>
<section data-pdf-bookmark="Obtaining nested types" data-type="sect3"><div class="sect3" id="obtaining_nested_types">
<h3>Obtaining nested types</h3>
<p><a contenteditable="false" data-primary="" data-startref="ch18.html103" data-type="indexterm" id="id4129"/><a contenteditable="false" data-primary="nested types" data-secondary="obtaining" data-type="indexterm" id="id4130"/>To retrieve nested types, call <code>GetNestedTypes</code> on the containing type:</p>
<pre data-type="programlisting">foreach (Type t in typeof (System.Environment).GetNestedTypes())
  Console.WriteLine (t.FullName);

OUTPUT: System.Environment+SpecialFolder</pre>
<p>Or:</p>
<pre data-type="programlisting">foreach (TypeInfo t in typeof (System.Environment).GetTypeInfo()
                                                  .DeclaredNestedTypes)
  Debug.WriteLine (t.FullName);</pre>
<p>The one caveat with nested types is that the CLR treats a nested type as having special “nested” accessibility levels:</p>
<pre data-type="programlisting">Type t = typeof (System.Environment.SpecialFolder);
Console.WriteLine (t.IsPublic);                      // False
Console.WriteLine (t.IsNestedPublic);                // True</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Type Names" data-type="sect2"><div class="sect2" id="type_names">
<h2>Type Names</h2>
<p><a contenteditable="false" data-primary="reflection" data-secondary="type names" data-type="indexterm" id="id4131"/>A type has <code>Namespace</code>, <code>Name</code>, and <code>FullName</code> properties. In most cases, <code>FullName</code> is a composition of the former two:</p>
<pre data-type="programlisting">Type t = typeof (System.Text.StringBuilder);

Console.WriteLine (t.Namespace);      // System.Text
Console.WriteLine (t.Name);           // StringBuilder
Console.WriteLine (t.FullName);       // System.Text.StringBuilder</pre>
<p>There are two exceptions to this rule: nested types and closed generic types.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyQualifiedName" data-type="indexterm" id="id4132"/><code>Type</code> also has a property called <code>AssemblyQualifiedName</code>, which returns <code>FullName</code> followed by a comma and then the full name of its assembly. This is the same string that you can pass to <code>Type.GetType</code>, and it uniquely identifies a type within the default loading context.</p>
</div>
<section data-pdf-bookmark="Nested type names" data-type="sect3"><div class="sect3" id="nested_type_names">
<h3>Nested type names</h3>
<p><a contenteditable="false" data-primary="nested types" data-secondary="type names" data-type="indexterm" id="id4133"/>With nested types, the containing type appears only in <code>FullName</code>:</p>
<pre data-type="programlisting">Type t = typeof (System.Environment.SpecialFolder);

Console.WriteLine (t.Namespace);      // System
Console.WriteLine (t.Name);           // SpecialFolder
Console.WriteLine (t.FullName);       // <strong>System.Environment+SpecialFolder</strong></pre>
<p><a contenteditable="false" data-primary="+ (plus sign)" data-secondary="in nested type names" data-type="indexterm" id="id4134"/><a contenteditable="false" data-primary="plus sign (+)" data-secondary="in nested type names" data-type="indexterm" id="id4135"/>The <code>+</code> symbol differentiates the containing type from a nested namespace.</p>
</div></section>
<section data-pdf-bookmark="Generic type names" data-type="sect3"><div class="sect3" id="generic_type_names">
<h3>Generic type names</h3>
<p><a contenteditable="false" data-primary="' (quote, single)" data-secondary="following generic type names" data-type="indexterm" id="id4136"/><a contenteditable="false" data-primary="generic types" data-secondary="type names" data-type="indexterm" id="id4137"/><a contenteditable="false" data-primary="quote, single (')" data-secondary="following generic type names" data-type="indexterm" id="id4138"/>Generic type names are suffixed with the <code>'</code> symbol, followed by the number of type parameters. If the generic type is unbound, this rule applies to both <code>Name</code> and <code>FullName</code>:</p>
<pre data-type="programlisting">Type t = typeof (Dictionary&lt;,&gt;); // Unbound
Console.WriteLine (t.Name);      // Dictionary'2
Console.WriteLine (t.FullName);  // System.Collections.Generic.Dictionary'2</pre>
<p>If the generic type is closed, however, <code>FullName</code> (only) acquires a substantial extra appendage. Each type parameter’s full <em>assembly qualified name</em> is enumerated:</p>
<pre data-type="programlisting">Console.WriteLine (typeof (Dictionary&lt;int,string&gt;).FullName);

// OUTPUT:
System.Collections.Generic.Dictionary`2[[System.Int32, 
System.Private.CoreLib, Version=4.0.0.0, Culture=neutral,
PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib,
Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]</pre>
<p>This ensures that <code>AssemblyQualifiedName</code> (a combination of the type’s full name and assembly name) contains enough information to fully identify both the generic type and its type parameters.</p>
</div></section>
<section data-pdf-bookmark="Array and pointer type names" data-type="sect3"><div class="sect3" id="array_and_pointer_type_names">
<h3>Array and pointer type names</h3>
<p><a contenteditable="false" data-primary="arrays" data-secondary="type names" data-type="indexterm" id="id4139"/><a contenteditable="false" data-primary="pointers" data-secondary="type names" data-type="indexterm" id="id4140"/>Arrays present with the same suffix that you use in a <code>typeof</code> expression:</p>
<pre data-type="programlisting">Console.WriteLine (typeof ( int[]  ).Name);      // Int32[]
Console.WriteLine (typeof ( int[,] ).Name);      // Int32[,]
Console.WriteLine (typeof ( int[,] ).FullName);  // System.Int32[,]</pre>
<p>Pointer types are similar:</p>
<pre data-type="programlisting">Console.WriteLine (typeof (byte*).Name);     // Byte*</pre>
</div></section>
<section data-pdf-bookmark="ref and out parameter type names" data-type="sect3"><div class="sect3" id="ref_and_out_parameter_type_names">
<h3>ref and out parameter type names</h3>
<p><a contenteditable="false" data-primary="&amp; (ampersand)" data-secondary="in parameter type names" data-type="indexterm" id="id4141"/><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="in parameter type names" data-type="indexterm" id="id4142"/><a contenteditable="false" data-primary="out parameter" data-secondary="type names" data-type="indexterm" id="id4143"/><a contenteditable="false" data-primary="ref parameter" data-secondary="type names" data-type="indexterm" id="id4144"/>A <code>Type</code> describing a <code>ref</code> or <code>out</code> parameter has an <code>&amp;</code> suffix:</p>
<pre data-type="programlisting">public void RefMethod (ref int p)
{
  Type t = MethodInfo.GetCurrentMethod().GetParameters()[0].ParameterType;
  Console.WriteLine (t.Name);    // Int32&amp;
}</pre>
<p>More on this later, in the section <a data-type="xref" href="#reflecting_and_invoking_members">“Reflecting and Invoking Members”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Base Types and Interfaces" data-type="sect2"><div class="sect2" id="base_types_and_interfaces">
<h2>Base Types and Interfaces</h2>
<p><a contenteditable="false" data-primary="base types and interfaces" data-type="indexterm" id="id4145"/><a contenteditable="false" data-primary="BaseType property" data-type="indexterm" id="id4146"/><a contenteditable="false" data-primary="reflection" data-secondary="base types and interfaces" data-type="indexterm" id="id4147"/><a contenteditable="false" data-primary="types" data-secondary="base types and interfaces" data-type="indexterm" id="id4148"/><code>Type</code> exposes a <code>BaseType</code> property:</p>
<pre data-type="programlisting">Type base1 = typeof (System.String).BaseType;
Type base2 = typeof (System.IO.FileStream).BaseType;

Console.WriteLine (base1.Name);     // Object
Console.WriteLine (base2.Name);     // Stream</pre>
<p>The <code>GetInterfaces</code> method returns the interfaces that a type implements:</p>
<pre data-type="programlisting">foreach (Type iType in typeof (Guid).GetInterfaces())
  Console.WriteLine (iType.Name);

<em>IFormattable</em>
<em>IComparable</em>
<em>IComparable'1</em>
<em>IEquatable'1</em></pre>
<p>(The <code>GetInterfaceMap</code> method returns a struct that shows how each member of an interface is implemented in a class or struct—we illustrate a use for this advanced feature in <a data-type="xref" href="#calling_static_virtualsolidusabstract_i">“Calling Static Virtual/Abstract Interface Members”</a>.)</p>
<p>Reflection provides three dynamic equivalents to C#’s static <code>is</code> operator:</p>
<dl>
<dt><code>IsInstanceOfType</code></dt>
<dd>Accepts a type and instance</dd>
<dt><code>IsAssignableFrom</code> and (from .NET 5) <code>IsAssignableTo</code></dt>
<dd>Accepts two types</dd>
</dl>
<p>Here’s an example of the first:</p>
<pre data-type="programlisting">object obj  = Guid.NewGuid();
Type target = typeof (IFormattable);

bool isTrue   = obj is IFormattable;             // Static C# operator
bool alsoTrue = target.<strong>IsInstanceOfType</strong> (obj);   // Dynamic equivalent</pre>
<p><code>IsAssignableFrom</code> is more versatile:</p>
<pre data-type="programlisting">Type target = typeof (IComparable), source = typeof (string);
Console.WriteLine (target.<strong>IsAssignableFrom</strong> (source));         // True</pre>
<p>The <code>IsSubclassOf</code> method works on the same principle as <code>IsAssignableFrom</code> but excludes interfaces.</p>
</div></section>
<section data-pdf-bookmark="Instantiating Types" data-type="sect2"><div class="sect2" id="instantiating_types">
<h2>Instantiating Types</h2>
<p><a contenteditable="false" data-primary="instantiating a type" data-type="indexterm" id="ch18.html104"/><a contenteditable="false" data-primary="type system, C#" data-secondary="instantiating a type" data-type="indexterm" id="ch18.html105"/>There are two ways to dynamically instantiate an object from its type:</p>
<ul>
<li><p>Call the static <code>Activator.CreateInstance</code> method</p></li>
<li><p>Call <code>Invoke</code> on a <code>ConstructorInfo</code> object obtained from calling <code>GetConstructor</code> on a <code>Type</code> (advanced scenarios)</p></li>
</ul>
<p><code>Activator.CreateInstance</code> accepts a <code>Type</code> and optional arguments that it passes to the constructor:</p>
<pre data-type="programlisting">int i = (int) Activator.CreateInstance (typeof (int));

DateTime dt = (DateTime) Activator.CreateInstance (typeof (DateTime),
                                                   2000, 1, 1);</pre>
<p><code>CreateInstance</code> lets you specify many other options such as the assembly from which to load the type and whether to bind to a nonpublic constructor. A <code>MissingMethodException</code> is thrown if the runtime can’t find a suitable constructor.</p>
<p>Calling <code>Invoke</code> on a <code>ConstructorInfo</code> is necessary when your argument values can’t disambiguate between overloaded constructors. For example, suppose that class <code>X</code> has two constructors: one accepting a parameter of type <code>string</code> and another accepting a parameter of type <code>StringBuilder</code>. The target is ambiguous should you pass a <code>null</code> argument into <code>Activator.CreateInstance</code>. This is when you need to use a <code>ConstructorInfo</code>, instead:</p>
<pre data-type="programlisting">// Fetch the constructor that accepts a single parameter of type <strong>string</strong>:
ConstructorInfo ci = typeof (X).GetConstructor (new[] { typeof (string) });

// Construct the object using that overload, passing in <strong>null</strong>:
object foo = ci.Invoke (new object[] { null });</pre>
<p>Or, if you’re targeting .NET Core 1, an older Windows Store profile:</p>
<pre data-type="programlisting">ConstructorInfo ci = typeof (X).GetTypeInfo().DeclaredConstructors
  .FirstOrDefault (c =&gt;
     c.GetParameters().Length == 1 &amp;&amp; 
     c.GetParameters()[0].ParameterType == typeof (string));</pre>
<p>To obtain a nonpublic constructor, you need to specify <code>BindingFlags</code>—see <a data-type="xref" href="#accessing_nonpublic_members">“Accessing Nonpublic Members”</a> in the later section <a data-type="xref" href="#reflecting_and_invoking_members">“Reflecting and Invoking Members”</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Dynamic instantiation adds a few microseconds onto the time taken to construct the object. This is quite a lot in relative terms because the CLR is ordinarily very fast in instantiating objects (a simple <code>new</code> on a small class takes in the region of tens of nanoseconds).</p>
</div>
<p>To dynamically instantiate arrays based on just element type, first call <code>MakeArrayType</code>. You can also instantiate generic types: we describe this in the next section.</p>
<p><a contenteditable="false" data-primary="Delegate.CreateDelegate" data-type="indexterm" id="id4149"/><a contenteditable="false" data-primary="delegates" data-secondary="dynamically instantiating" data-type="indexterm" id="id4150"/>To dynamically instantiate a delegate, call <code>Delegate.CreateDelegate</code>. The following example demonstrates instantiating both an instance delegate and a static delegate:</p>
<pre data-type="programlisting">class Program
{
  delegate int IntFunc (int x);

  static int Square (int x) =&gt; x * x;        // Static method
  int        Cube   (int x) =&gt; x * x * x;    // Instance method

  static void Main()
  {
    Delegate staticD = Delegate.CreateDelegate
      (typeof (IntFunc), <strong>typeof (Program)</strong>, "Square");

    Delegate instanceD = Delegate.CreateDelegate
      (typeof (IntFunc), <strong>new Program()</strong>, "Cube");

    Console.WriteLine (staticD.DynamicInvoke (3));      // 9
    Console.WriteLine (instanceD.DynamicInvoke (3));    // 27
  }
}</pre>
<p>You can invoke the <code>Delegate</code> object that’s returned by calling <code>DynamicInvoke</code>, as we did in this example, or by casting to the typed delegate:</p>
<pre data-type="programlisting">IntFunc f = (IntFunc) staticD;
Console.WriteLine (f(3));         // 9 <em>(but much faster!)</em></pre>
<p>You can pass a <code>MethodInfo</code> into <code>CreateDelegate</code> instead of a method name. We describe <code>MethodInfo</code> shortly, in <a data-type="xref" href="#reflecting_and_invoking_members">“Reflecting and Invoking Members”</a>, along with the rationale for casting a dynamically created delegate back to the static delegate type.<a contenteditable="false" data-primary="" data-startref="ch18.html105" data-type="indexterm" id="id4151"/><a contenteditable="false" data-primary="" data-startref="ch18.html104" data-type="indexterm" id="id4152"/></p>
</div></section>
<section data-pdf-bookmark="Generic Types" data-type="sect2"><div class="sect2" id="generic_types-id00071">
<h2>Generic Types</h2>
<p><a contenteditable="false" data-primary="generic types" data-secondary="reflection" data-type="indexterm" id="id4153"/>A <code>Type</code> can represent a closed or unbound generic type. Just as at compile time, a closed generic type can be instantiated, whereas an unbound type cannot:</p>
<pre data-type="programlisting">Type closed = typeof (List&lt;int&gt;);
List&lt;int&gt; list = (List&lt;int&gt;) Activator.CreateInstance (closed);  // OK

Type unbound   = typeof (List&lt;&gt;);
object anError = Activator.CreateInstance (unbound);    // Runtime error</pre>
<p>The <code>MakeGenericType</code> method converts an unbound into a closed generic type. Simply pass in the desired type arguments:</p>
<pre data-type="programlisting">Type unbound = typeof (List&lt;&gt;);
Type closed = unbound.MakeGenericType (typeof (int));</pre>
<p>The <code>GetGenericTypeDefinition</code> method does the opposite:</p>
<pre data-type="programlisting">Type unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2</pre>
<p>The <code>IsGenericType</code> property returns <code>true</code> if a <code>Type</code> is generic, and the <code>IsGenericTypeDefinition</code> property returns <code>true</code> if the generic type is unbound. The following tests whether a type is a nullable value type:</p>
<pre data-type="programlisting">Type nullable = typeof (bool?);
Console.WriteLine (
  nullable.IsGenericType &amp;&amp;
  nullable.GetGenericTypeDefinition() == typeof (Nullable&lt;&gt;));   // True</pre>
<p><code>GetGenericArguments</code> returns the type arguments for closed generic types:</p>
<pre data-type="programlisting">Console.WriteLine (closed.GetGenericArguments()[0]);     // System.Int32
Console.WriteLine (nullable.GetGenericArguments()[0]);   // System.Boolean</pre>
<p>For unbound generic types, <code>GetGenericArguments</code> returns pseudotypes that represent the placeholder types specified in the generic type definition:</p>
<pre data-type="programlisting">Console.WriteLine (unbound.GetGenericArguments()[0]);      // T</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>At runtime, all generic types are either <em>unbound</em> or <em>closed</em>. They’re unbound in the (relatively unusual) case of an expression such as <code>typeof(Foo&lt;&gt;)</code>; otherwise, they’re closed. There’s no such thing as an <em>open</em> generic type at runtime: all open types are closed by the compiler. The method in the following class always prints <code>False</code>:<a contenteditable="false" data-primary="" data-startref="ch18.html102" data-type="indexterm" id="id4154"/><a contenteditable="false" data-primary="" data-startref="ch18.html101" data-type="indexterm" id="id4155"/></p>
<pre data-type="programlisting">class Foo&lt;T&gt;
{
  public void Test()
    =&gt; Console.Write (GetType().IsGenericTypeDefinition);  
}</pre>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Reflecting and Invoking Members" data-type="sect1"><div class="sect1" id="reflecting_and_invoking_members">
<h1>Reflecting and Invoking Members</h1>
<p><a contenteditable="false" data-primary="reflection" data-secondary="reflecting and invoking members of a type" data-type="indexterm" id="ch18.html106"/><a contenteditable="false" data-primary="types" data-secondary="reflecting and invoking members of" data-type="indexterm" id="ch18.html107"/><a contenteditable="false" data-primary="Get..." data-secondary="GetMembers method" data-type="indexterm" id="ch18.html0"/>The <code>GetMembers</code> method returns the members of a type. Consider the following class:</p>
<pre data-type="programlisting">class Walnut
{
  private bool cracked;
  public void Crack() { cracked = true; }
}</pre>
<p>We can reflect on its public members, as follows:</p>
<pre data-type="programlisting">MemberInfo[] members = <strong>typeof (Walnut).GetMembers()</strong>;
foreach (MemberInfo m in members)
  Console.WriteLine (m);</pre>
<p>This is the result:</p>
<pre data-type="programlisting">Void Crack()
System.Type GetType()
System.String ToString()
Boolean Equals(System.Object)
Int32 GetHashCode()
Void .ctor()</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="reflecting_members_with_typeinfo">
<h1>Reflecting Members with TypeInfo</h1>
<p><a contenteditable="false" data-primary="Type..." data-secondary="TypeInfo class" data-type="indexterm" id="id4156"/><code>TypeInfo</code> exposes a different (and somewhat simpler) protocol for reflecting over members. Using this API is optional (except in .NET Core 1 and older Windows Store apps given that there’s no exact equivalent to the <code>GetMembers</code> method).</p>
<p>Instead of exposing methods like <code>GetMembers</code> that return arrays, <code>TypeInfo</code> exposes <em>properties</em> that return <code>IEnumerable&lt;T&gt;</code>, upon which you typically run LINQ queries. The broadest is <code>DeclaredMembers</code>:</p>
<pre data-type="programlisting">IEnumerable&lt;MemberInfo&gt; members =
  typeof(Walnut).GetTypeInfo().DeclaredMembers;</pre>
<p>Unlike with <code>GetMembers()</code>, the result excludes inherited members:</p>
<pre data-type="programlisting">Void Crack()
Void .ctor()
Boolean cracked</pre>
<p>There are also properties for returning specific kinds of members (<code>DeclaredProperties</code>, <code>DeclaredMethods</code>, <code>DeclaredEvents</code>, and so on) and methods for returning a specific member by name (e.g., <code>GetDeclaredMethod</code>). The latter cannot be used on overloaded methods (because there’s no way to specify parameter types). Instead, you run a LINQ query over <code>DeclaredMethods</code>:</p>
<pre data-type="programlisting">MethodInfo method = typeof (int).GetTypeInfo().DeclaredMethods
  .FirstOrDefault (m =&gt; m.Name == "ToString" &amp;&amp;
                        m.GetParameters().Length == 0);</pre>
</div></aside>
<p>When called with no arguments, <code>GetMembers</code> returns all the public members for a type (and its base types). <code>GetMember</code> retrieves a specific member by name—although it still returns an array because members can be overloaded:</p>
<pre data-type="programlisting">MemberInfo[] m = typeof (Walnut).GetMember ("Crack");
Console.WriteLine (m[0]);                              // Void Crack()</pre>
<p><code>MemberInfo</code> also has a property called <code>MemberType</code> of type <code>MemberTypes</code>. This is a flags enum with these values:</p>
<pre data-type="programlisting">All           Custom        Field        NestedType     TypeInfo
Constructor   Event         Method       Property</pre>
<p>When calling <code>GetMembers</code>, you can pass in a <code>MemberTypes</code> instance to restrict the kinds of members that it returns. Alternatively, you can restrict the result set by calling <code>GetMethods</code>, <code>GetFields</code>, <code>GetProperties</code>, <code>GetEvents</code>, <code>GetConstructors</code>, or <code>GetNestedTypes</code>. There are also singular versions of each of these to home in on a specific member.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It pays to be as specific as possible when retrieving a type member so that your code doesn’t break if additional members are added later. If you’re retrieving a method by name, specifying all parameter types ensures that your code will still work if the method is later overloaded (we provide examples shortly, in <a data-type="xref" href="#method_parameters">“Method Parameters”</a>).</p>
</div>
<p>A <code>MemberInfo</code> object has a <code>Name</code> property and two <code>Type</code> properties:</p>
<dl>
<dt><code>DeclaringType</code></dt>
<dd>Returns the <code>Type</code> that defines the member</dd>
<dt><code>ReflectedType</code></dt>
<dd>Returns the <code>Type</code> upon which <code>GetMembers</code> was called</dd>
</dl>
<p>The two differ when called on a member that’s defined in a base type: <code>DeclaringType</code> returns the base type, whereas <code>ReflectedType</code> returns the subtype. The following example highlights this:</p>
<pre data-type="programlisting">// MethodInfo is a subclass of MemberInfo; see <a data-type="xref" href="#member_types-id00079">Figure 18-1</a>.

MethodInfo test = typeof (Program).GetMethod ("ToString");
MethodInfo obj  = typeof (object) .GetMethod ("ToString");

Console.WriteLine (test.DeclaringType);      // System.Object
Console.WriteLine (obj.DeclaringType);       // System.Object

Console.WriteLine (test.ReflectedType);      // <strong>Program</strong>
Console.WriteLine (obj.ReflectedType);       // System.Object

Console.WriteLine (test == obj);             // <strong>False</strong></pre>
<p class="pagebreak-before">Because they have different <code>ReflectedType</code>s, the <code>test</code> and <code>obj</code> objects are not equal. Their difference, however, is purely a fabrication of the reflection API; our <code>Program</code> type has no distinct <code>ToString</code> method in the underlying type system. We can verify that the two <code>MethodInfo</code> objects refer to the same method in either of two ways:</p>
<pre data-type="programlisting">Console.WriteLine (test.MethodHandle == obj.MethodHandle);    // True

Console.WriteLine (test.MetadataToken == obj.MetadataToken    // True
                   &amp;&amp; test.Module == obj.Module);</pre>
<p>A <code>MethodHandle</code> is unique to each (genuinely distinct) method within a process; a <code>MetadataToken</code> is unique across all types and members within an assembly module.</p>
<p><code>MemberInfo</code> also defines methods to return custom attributes (see <a data-type="xref" href="#retrieving_attributes_at_runtime">“Retrieving Attributes at Runtime”</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can obtain the <code>MethodBase</code> of the currently executing method by calling <code>MethodBase.GetCurrentMethod</code>.<a contenteditable="false" data-primary="" data-startref="ch18.html0" data-type="indexterm" id="id4157"/></p>
</div>
<section data-pdf-bookmark="Member Types" data-type="sect2"><div class="sect2" id="member_types-id00028">
<h2>Member Types</h2>
<p><a contenteditable="false" data-primary="member types" data-type="indexterm" id="id4158"/><a contenteditable="false" data-primary="MemberInfo subclass" data-type="indexterm" id="id4159"/><code>MemberInfo</code> itself is light on members because it’s an abstract base for the types shown in <a data-type="xref" href="#member_types-id00079">Figure 18-1</a>.</p>
<figure><div class="figure" id="member_types-id00079">
<img alt="Member types" src="assets/cn10_1801.png"/>
<h6><span class="label">Figure 18-1. </span>Member types</h6>
</div></figure>
<p>You can cast a <code>MemberInfo</code> to its subtype, based on its <code>MemberType</code> property. If you obtained a member via <code>GetMethod</code>, <code>GetField</code>, <code>GetProperty</code>, <code>GetEvent</code>, <code>GetConstructor</code>, or <code>GetNestedType</code> (or their plural versions), a cast isn’t necessary. <a data-type="xref" href="#retrieving_member_metadata">Table 18-1</a> summarizes what methods to use for each kind of C# construct.</p>
<table class="border pagebreak-before less_space" id="retrieving_member_metadata">
<caption><span class="label">Table 18-1. </span>Retrieving member metadata</caption>
<thead>
<tr>
<th>C# construct</th>
<th>Method to use</th>
<th>Name to use</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method</td>
<td><code>GetMethod</code></td>
<td>(method name)</td>
<td><code>MethodInfo</code></td>
</tr>
<tr>
<td>Property</td>
<td><code>GetProperty</code></td>
<td>(property name)</td>
<td><code>PropertyInfo</code></td>
</tr>
<tr>
<td>Indexer</td>
<td><code>GetDefaultMembers</code></td>
<td/>
<td><code>MemberInfo[]</code> (containing <span class="keep-together"><code>PropertyInfo</code></span> objects if compiled in C#)</td>
</tr>
<tr>
<td>Field</td>
<td><code>GetField</code></td>
<td>(field name)</td>
<td><code>FieldInfo</code></td>
</tr>
<tr>
<td>Enum member</td>
<td><code>GetField</code></td>
<td>(member name)</td>
<td><code>FieldInfo</code></td>
</tr>
<tr>
<td>Event</td>
<td><code>GetEvent</code></td>
<td>(event name)</td>
<td><code>EventInfo</code></td>
</tr>
<tr>
<td>Constructor</td>
<td><code>GetConstructor</code></td>
<td/>
<td><code>ConstructorInfo</code></td>
</tr>
<tr>
<td>Finalizer</td>
<td><code>GetMethod</code></td>
<td><code>"Finalize"</code></td>
<td><code>MethodInfo</code></td>
</tr>
<tr>
<td>Operator</td>
<td><code>GetMethod</code></td>
<td><code>"op_"</code> + operator name</td>
<td><code>MethodInfo</code></td>
</tr>
<tr>
<td>Nested type</td>
<td><code>GetNestedType</code></td>
<td>(type name)</td>
<td><code>Type</code></td>
</tr>
</tbody>
</table>
<p>Each <code>MemberInfo</code> subclass has a wealth of properties and methods, exposing all aspects of the member’s metadata. This includes such things as visibility, modifiers, generic type arguments, parameters, return type, and custom attributes.</p>
<p>Here is an example of using <code>GetMethod</code>:</p>
<pre data-type="programlisting">MethodInfo m = typeof (Walnut).GetMethod ("Crack");
Console.WriteLine (m);                             // Void Crack()
Console.WriteLine (m.ReturnType);                  // System.Void</pre>
<p>All <code>*Info</code> instances are cached by the reflection API on first use:</p>
<pre data-type="programlisting">MethodInfo method = typeof (Walnut).<strong>GetMethod</strong> ("Crack");
MemberInfo member = typeof (Walnut).<strong>GetMember</strong> ("Crack") [0];

Console.Write (method == member);       // True</pre>
<p>As well as preserving object identity, caching improves the performance of what is otherwise a fairly slow API.</p>
</div></section>
<section data-pdf-bookmark="C# Members Versus CLR Members" data-type="sect2"><div class="sect2" id="chash_members_versus_clr_members">
<h2>C# Members Versus CLR Members</h2>
<p><a contenteditable="false" data-primary="CLR (Common Language Runtime)" data-secondary="C# members versus CLR members" data-type="indexterm" id="id4160"/><a contenteditable="false" data-primary="type system, C#" data-secondary="C# members versus CLR members" data-type="indexterm" id="id4161"/>The preceding table illustrates that some of C#’s functional constructs don’t have a 1:1 mapping with CLR constructs. This makes sense because the CLR and reflection API were designed with all .NET languages in mind—you can use reflection even from Visual Basic.</p>
<p>Some C# constructs—namely indexers, enums, operators, and finalizers—are contrivances as far as the CLR is concerned. Specifically:</p>
<ul>
<li><p>A C# indexer translates to a property accepting one or more arguments, marked as the type’s <code>[DefaultMember]</code>.</p></li>
<li><p>A C# enum translates to a subtype of <code>System.Enum</code> with a static field for each member.</p></li>
<li><p>A C# operator translates to a specially named static method, starting in “op_”; for example, <code>"op_Addition"</code>.</p></li>
<li><p>A C# finalizer translates to a method that overrides <code>Finalize</code>.</p></li>
</ul>
<p>Another complication is that properties and events actually comprise two things:</p>
<ul>
<li><p>Metadata describing the property or event (encapsulated by <code>PropertyInfo</code> or <code>EventInfo</code>)</p></li>
<li><p>One or two backing methods</p></li>
</ul>
<p>In a C# program, the backing methods are encapsulated within the property or event definition. But when compiled to IL, the backing methods present as ordinary methods that you can call like any other. This means that <code>GetMethods</code> returns property and event backing methods alongside ordinary methods:</p>
<pre data-type="programlisting">class Test { public int X { get { return 0; } set {} } }

void Demo()
{
  foreach (MethodInfo mi in typeof (Test).GetMethods())
    Console.Write (mi.Name + "  ");
}

// OUTPUT:
<strong>get_X  set_X</strong>  GetType  ToString  Equals  GetHashCode</pre>
<p>You can identify these methods through the <code>IsSpecialName</code> property in <code>MethodInfo</code>. <code>IsSpecialName</code> returns <code>true</code> for property, indexer, and event accessors, as well as operators. It returns <code>false</code> only for conventional C# methods—and the <code>Finalize</code> method if a finalizer is defined.</p>
<p>Here are the backing methods that C# generates:</p>
<table class="border">
<thead>
<tr>
<th>C# construct</th>
<th>Member type</th>
<th>Methods in IL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Property</td>
<td><code>Property</code></td>
<td><code>get_<em>XXX</em></code> and <code>set_<em>XXX</em></code></td>
</tr>
<tr>
<td>Indexer</td>
<td><code>Property</code></td>
<td><code>get_Item</code> and <code>set_Item</code></td>
</tr>
<tr>
<td>Event</td>
<td><code>Event</code></td>
<td><code>add_<em>XXX</em></code> and <code>remove_<em>XXX</em></code></td>
</tr>
</tbody>
</table>
<p>Each backing method has its own associated <code>MethodInfo</code> object. You can access these as follows:</p>
<pre data-type="programlisting">PropertyInfo pi = typeof (Console).GetProperty ("Title");
MethodInfo getter = pi.<strong>GetGetMethod</strong>();                   // get_Title
MethodInfo setter = pi.<strong>GetSetMethod</strong>();                   // set_Title
MethodInfo[] both = pi.<strong>GetAccessors</strong>();                   // Length==2</pre>
<p><code>GetAddMethod</code> and <code>GetRemoveMethod</code> perform a similar job for <code>EventInfo</code>.</p>
<p>To go in the reverse direction—from a <code>MethodInfo</code> to its associated <code>PropertyInfo</code> or <code>EventInfo</code>—you need to perform a query. LINQ is ideal for this job:</p>
<pre data-type="programlisting">PropertyInfo p = mi.DeclaringType.GetProperties()
                   .First (x =&gt; x.GetAccessors (true).Contains (mi));</pre>
<section data-pdf-bookmark="Init-only properties" data-type="sect3"><div class="sect3" id="init_only_properties">
<h3>Init-only properties</h3>
<p><a contenteditable="false" data-primary="C# 9" data-primary-sortas="C# 09" data-secondary="init-only properties" data-type="indexterm" id="id4162"/><a contenteditable="false" data-primary="init-only properties (C# 9)" data-type="indexterm" id="id4163"/>Init-only properties, introduced in C# 9, can be set via an object initializer but are subsequently treated as read-only by the compiler. From the CLR’s perspective, an <code>init</code> accessor is just like an ordinary <code>set</code> accessor, but with a special flag applied to the <code>set</code> method’s return type (which means something to the compiler).</p>
<p>Curiously, this flag is not encoded as a convention attribute. Instead, it uses a relatively obscure mechanism called a <em>modreq</em>, which ensures that previous versions of the C# compiler (which don’t recognize the new modreq) ignore the accessor rather than treat the property as writable.</p>
<p>The modreq for init-only accessors is called <code>IsExternalInit</code>, and you can query for it as follows:</p>
<pre data-type="programlisting">bool IsInitOnly (PropertyInfo pi) =&gt; pi
  .GetSetMethod().ReturnParameter.GetRequiredCustomModifiers()
  .Any (t =&gt; t.Name == "IsExternalInit");</pre>
</div></section>
<section data-pdf-bookmark="NullabilityInfoContext" data-type="sect3"><div class="sect3" id="nullabilityinfocontext">
<h3>NullabilityInfoContext</h3>
<p>From .NET 6, you can use the <code>NullabilityInfoContext</code> class to obtain information about the nullability annotations for a field, property, event or parameter:</p>
<pre data-type="programlisting">void PrintPropertyNullability (PropertyInfo pi)
{
  var info = new NullabilityInfoContext().Create (pi);
  Console.WriteLine (pi.Name + " read " + info.ReadState);
  Console.WriteLine (pi.Name + " write " + info.WriteState);
  // Use info.Element to get nullability info for array elements
}</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Generic Type Members" data-type="sect2"><div class="sect2" id="generic_type_members">
<h2>Generic Type Members</h2>
<p><a contenteditable="false" data-primary="generic types" data-secondary="obtaining member metadata" data-type="indexterm" id="id4164"/>You can obtain member metadata for both unbound and closed generic types:</p>
<pre data-type="programlisting">PropertyInfo unbound = typeof (<strong>IEnumerator&lt;&gt;</strong>)  .GetProperty ("Current");
PropertyInfo closed = typeof (<strong>IEnumerator&lt;int&gt;</strong>).GetProperty ("Current");

Console.WriteLine (unbound);   // T Current
Console.WriteLine (closed);    // Int32 Current

Console.WriteLine (unbound.PropertyType.IsGenericParameter);  // True
Console.WriteLine (closed.PropertyType.IsGenericParameter);   // False</pre>
<p>The <code>MemberInfo</code> objects returned from unbound and closed generic types are always distinct, even for members whose signatures don’t feature generic type parameters:</p>
<pre data-type="programlisting">PropertyInfo unbound = typeof (<strong>List&lt;&gt;</strong>)  .GetProperty ("Count");
PropertyInfo closed = typeof (<strong>List&lt;int&gt;</strong>).GetProperty ("Count");

Console.WriteLine (unbound);   // Int32 Count
Console.WriteLine (closed);    // Int32 Count

Console.WriteLine (unbound == closed);   // False

Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True
Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False</pre>
<p>Members of unbound generic types cannot be <em>dynamically invoked</em>.</p>
</div></section>
<section data-pdf-bookmark="Dynamically Invoking a Member" data-type="sect2"><div class="sect2" id="dynamically_invoking_a_member">
<h2>Dynamically Invoking a Member</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="type system, C#" data-secondary="dynamically invoking a member" data-type="indexterm" id="id4165"/>Dynamically invoking a member can be accomplished more easily using the <a href="https://github.com/albahari/uncapsulator">Uncapsulator open-source library</a> (available on NuGet and GitHub). Uncapsulator was written by the author, and provides a fluent API for invoking public and non-public members via reflection, using a custom dynamic binder.</p>
</div>
<p><a contenteditable="false" data-primary="late binding" data-type="indexterm" id="id4166"/>After you have a <code>MethodInfo</code>, <code>PropertyInfo</code>, or <code>FieldInfo</code> object, you can dynamically call it or get/set its value. This is called <em>late binding</em> because you choose which member to invoke at runtime rather than compile time.</p>
<p>To illustrate, the following uses ordinary <em>static binding</em>:</p>
<pre data-type="programlisting">string s = "Hello";
int length = s.Length;</pre>
<p>Here’s the same thing performed dynamically with late binding:</p>
<pre data-type="programlisting">object s = "Hello";
PropertyInfo prop = s.GetType().GetProperty ("Length");
int length = (int) <strong>prop.GetValue (s, null);</strong>               // 5</pre>
<p><code>GetValue</code> and <code>SetValue</code> get and set the value of a <code>PropertyInfo</code> or <code>FieldInfo</code>. The first argument is the instance, which can be <code>null</code> for a static member. Accessing an indexer is just like accessing a property called “Item,” except that you provide indexer values as the second argument when calling <code>GetValue</code> or <code>SetValue</code>.</p>
<p>To dynamically call a method, call <code>Invoke</code> on a <code>MethodInfo</code>, providing an array of arguments to pass to that method. If you get any of the argument types wrong, an exception is thrown at runtime. With dynamic invocation, you lose compile-time type safety, but you still have runtime type safety (just as with the <code>dynamic</code> <span class="keep-together">keyword</span>).</p>
</div></section>
<section data-pdf-bookmark="Method Parameters" data-type="sect2"><div class="sect2" id="method_parameters">
<h2>Method Parameters</h2>
<p><a contenteditable="false" data-primary="method parameters" data-type="indexterm" id="ch18.html108"/>Suppose that we want to dynamically call <code>string</code>’s <code>Substring</code> method. Statically, we would do this, as follows:</p>
<pre data-type="programlisting">Console.WriteLine ("stamp".Substring(2));                  // "amp"</pre>
<p>Here’s the dynamic equivalent with reflection and late binding:</p>
<pre data-type="programlisting">Type type = typeof (string);
Type[] parameterTypes = { typeof (int) };
MethodInfo method = type.GetMethod ("Substring", parameterTypes);

object[] arguments = { 2 };
object returnValue = method.Invoke ("stamp", arguments);
Console.WriteLine (returnValue);                           // "amp"</pre>
<p>Because the <code>Substring</code> method is overloaded, we had to pass an array of parameter types to <code>GetMethod</code> to indicate which version we wanted. Without the parameter types, <code>GetMethod</code> would throw an <code>AmbiguousMatchException</code>.</p>
<p>The <code>GetParameters</code> method, defined on <code>MethodBase</code> (the base class for <code>MethodInfo</code> and <code>ConstructorInfo</code>), returns parameter metadata. We can continue our previous example, as follows:</p>
<pre data-type="programlisting">ParameterInfo[] paramList = method.GetParameters();
foreach (ParameterInfo x in paramList)
{
  Console.WriteLine (x.Name);                 // startIndex
  Console.WriteLine (x.ParameterType);        // System.Int32
}</pre>
<section data-pdf-bookmark="Dealing with ref and out parameters" data-type="sect3"><div class="sect3" id="dealing_with_ref_and_out_parameters">
<h3>Dealing with ref and out parameters</h3>
<p><a contenteditable="false" data-primary="out parameter" data-secondary="passing" data-type="indexterm" id="id4167"/><a contenteditable="false" data-primary="ref parameter" data-secondary="passing" data-type="indexterm" id="id4168"/>To pass <code>ref</code> or <code>out</code> parameters, call <code>MakeByRefType</code> on the type before obtaining the method. For instance, you can dynamically execute this code:</p>
<pre data-type="programlisting">int x;
bool successfulParse = int.TryParse ("23", out x);</pre>
<p>as follows:</p>
<pre data-type="programlisting">object[] args = { "23", 0 };
Type[] argTypes = { typeof (string), typeof (int)<strong>.MakeByRefType()</strong> };
MethodInfo tryParse = typeof (int).GetMethod ("TryParse", argTypes);
bool successfulParse = (bool) tryParse.Invoke (null, args);

Console.WriteLine (successfulParse + " " + args[1]);       // True 23</pre>
<p>This same approach works for both <code>ref</code> and <code>out</code> parameter types.</p>
</div></section>
<section data-pdf-bookmark="Retrieving and invoking generic methods" data-type="sect3"><div class="sect3" id="retrieving_and_invoking_generic_methods">
<h3>Retrieving and invoking generic methods</h3>
<p><a contenteditable="false" data-primary="generic methods" data-secondary="retrieving/invoking" data-type="indexterm" id="id4169"/>Explicitly specifying parameter types when calling <code>GetMethod</code> can be essential in disambiguating overloaded methods. However, it’s impossible to specify generic parameter types. <a contenteditable="false" data-primary="System..." data-secondary="System.Linq.Enumerable class" data-type="indexterm" id="id4170"/>For instance, consider the <code>System.Linq.Enumerable</code> class, which overloads the <code>Where</code> method, as follows:</p>
<pre data-type="programlisting">public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);

public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate);</pre>
<p>To retrieve a specific overload, we must retrieve all methods and then manually find the desired overload. The following query retrieves the former overload of <code>Where</code>:</p>
<pre data-type="programlisting">from m in typeof (Enumerable).GetMethods()
where m.Name == "Where" &amp;&amp; m.IsGenericMethod 
let parameters = m.GetParameters()
where parameters.Length == 2
let genArg = m.GetGenericArguments().First()
let enumerableOfT = typeof (IEnumerable&lt;&gt;).MakeGenericType (genArg)
let funcOfTBool = typeof (Func&lt;,&gt;).MakeGenericType (genArg, typeof (bool))
where parameters[0].ParameterType == enumerableOfT
   &amp;&amp; parameters[1].ParameterType == funcOfTBool
select m</pre>
<p>Calling <code>.Single()</code> on this query gives the correct <code>MethodInfo</code> object with unbound type parameters. The next step is to close the type parameters by calling <code>MakeGenericMethod</code>:</p>
<pre data-type="programlisting">var closedMethod = unboundMethod.MakeGenericMethod (typeof (int));</pre>
<p>In this case, we’ve closed <code>TSource</code> with <code>int</code>, allowing us to call <code>Enumerable.Where</code> with a source of type <code>IEnumerable&lt;int&gt;</code> and a predicate of type <code>Func&lt;int,bool&gt;</code>:</p>
<pre data-type="programlisting">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;   // Odd numbers only</pre>
<p>We can now invoke the closed generic method:</p>
<pre data-type="programlisting">var query = (IEnumerable&lt;int&gt;) closedMethod.Invoke 
  (null, new object[] { source, predicate });

foreach (int element in query) Console.Write (element + "|");  // 3|5|7|</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re using the <code>System.Linq.Expressions</code> API to dynamically build expressions (<a data-type="xref" href="ch08.html#linq_queries">Chapter 8</a>), you don’t need to go to this trouble to specify a generic method. The <code>Expression.Call</code> method is overloaded to let you specify the closed type arguments of the method that you want to call:<a contenteditable="false" data-primary="" data-startref="ch18.html108" data-type="indexterm" id="id4171"/></p>
<pre data-type="programlisting">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;

var sourceExpr = Expression.Constant (source);
var predicateExpr = Expression.Constant (predicate);

var callExpression = Expression.Call (
  typeof (Enumerable), "Where",
  new[] { typeof (int) },  // Closed generic arg type.
  sourceExpr, predicateExpr);</pre>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Using Delegates for Performance" data-type="sect2"><div class="sect2" id="using_delegates_for_performance">
<h2>Using Delegates for Performance</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="calling dynamically instantiated delegates" data-type="indexterm" id="id4172"/>Dynamic invocations are relatively inefficient, with an overhead typically in the few-microseconds region. If you’re calling a method repeatedly in a loop, you can shift the per-call overhead into the nanoseconds region by instead calling a dynamically instantiated delegate that targets your dynamic method. In the following example, we dynamically call <code>string</code>’s <code>Trim</code> method a million times without significant overhead:</p>
<pre data-type="programlisting">MethodInfo trimMethod = typeof (string).GetMethod ("Trim", new Type[0]);
<strong>var trim = (StringToString) Delegate.CreateDelegate</strong>
    <strong>                                (typeof (StringToString), trimMethod);</strong>
for (int i = 0; i &lt; 1000000; i++)
  trim ("test");

delegate string StringToString (string s);</pre>
<p>This is faster because the costly late binding (shown in bold) happens just once.</p>
</div></section>
<section data-pdf-bookmark="Accessing Nonpublic Members" data-type="sect2"><div class="sect2" id="accessing_nonpublic_members">
<h2>Accessing Nonpublic Members</h2>
<p><a contenteditable="false" data-primary="nonpublic members" data-type="indexterm" id="id4173"/>All of the methods on types used to probe metadata (e.g., <code>GetProperty</code>, <code>GetField</code>, etc.) have overloads that take a <code>BindingFlags</code> enum. This enum serves as a metadata filter and allows you to change the default selection criteria. The most common use for this is to retrieve nonpublic members (this works only in desktop apps).</p>
<p>For instance, consider the following class:</p>
<pre data-type="programlisting">class Walnut
{
  private bool cracked;
  public void Crack() { cracked = true; }

  public override string ToString() { return cracked.ToString(); }
}</pre>
<p>We can <em>uncrack</em> the walnut, as follows:</p>
<pre data-type="programlisting">Type t = typeof (Walnut);
Walnut w = new Walnut();
w.Crack();
FieldInfo f = t.GetField ("cracked", BindingFlags.NonPublic |
                                     BindingFlags.Instance);
f.SetValue (w, false);
Console.WriteLine (w);         // False</pre>
<p>Using reflection to access nonpublic members is powerful, but it is also dangerous because you can bypass encapsulation, creating an unmanageable dependency on the internal implementation of a type.</p>
<section data-pdf-bookmark="The BindingFlags enum" data-type="sect3"><div class="sect3" id="the_bindingflags_enum">
<h3>The BindingFlags enum</h3>
<p><a contenteditable="false" data-primary="BindingFlags enum" data-type="indexterm" id="id4174"/><code>BindingFlags</code> is intended to be bitwise-combined. To get any matches at all, you need to start with one of the following four combinations:</p>
<pre data-type="programlisting">BindingFlags.Public    | BindingFlags.Instance
BindingFlags.Public    | BindingFlags.Static
BindingFlags.NonPublic | BindingFlags.Instance
BindingFlags.NonPublic | BindingFlags.Static</pre>
<p><code>NonPublic</code> includes <code>internal</code>, <code>protected</code>, <code>protected internal</code>, and <code>private</code>.</p>
<p>The following example retrieves all the public static members of type <code>object</code>:</p>
<pre data-type="programlisting">BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;
MemberInfo[] members = typeof (object).GetMembers (publicStatic);</pre>
<p>The following example retrieves all the nonpublic members of type <code>object</code>, both static and instance:</p>
<pre data-type="programlisting">BindingFlags nonPublicBinding =
  BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;

MemberInfo[] members = typeof (object).GetMembers (nonPublicBinding);</pre>
<p>The <code>DeclaredOnly</code> flag excludes functions inherited from base types, unless they are overridden.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>DeclaredOnly</code> flag is somewhat confusing in that it <em>restricts</em> the result set (whereas all the other binding flags <em>expand</em> the result set).</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Generic Methods" data-type="sect2"><div class="sect2" id="generic_methods-id00070">
<h2>Generic Methods</h2>
<p><a contenteditable="false" data-primary="generic methods" data-type="indexterm" id="id4175"/>You cannot directly invoke generic methods; the following throws an exception:</p>
<pre data-type="programlisting">class Program
{
  public static T Echo&lt;T&gt; (T x) { return x; }

  static void Main()
  {
    MethodInfo echo = typeof (Program).GetMethod ("Echo");
    Console.WriteLine (echo.IsGenericMethodDefinition);    // <strong>True</strong>
    echo.Invoke (null, new object[] { 123 } );             // <em>Exception</em>
  }
}</pre>
<p>An extra step is required, which is to call <code>MakeGenericMethod</code> on the <code>MethodInfo</code>, specifying concrete generic type arguments. This returns another <code>MethodInfo</code>, which you can then invoke, as follows:</p>
<pre data-type="programlisting">MethodInfo echo = typeof (Program).GetMethod ("Echo");
<strong>MethodInfo intEcho = echo.MakeGenericMethod (typeof (int));</strong>
Console.WriteLine (intEcho.IsGenericMethodDefinition);            // <strong>False</strong>
Console.WriteLine (intEcho.Invoke (null, new object[] { 3 } ));   // 3</pre>
</div></section>
<section data-pdf-bookmark="Anonymously Calling Members of a Generic Interface" data-type="sect2"><div class="sect2" id="ch18-anonymously_calling_members_of_a_gener">
<h2>Anonymously Calling Members of a Generic Interface</h2>
<p><a contenteditable="false" data-primary="generic interface" data-type="indexterm" id="id4176"/><a contenteditable="false" data-primary="reflection" data-secondary="anonymously calling members of generic interface" data-type="indexterm" id="id4177"/>Reflection is useful when you need to invoke a member of a generic interface and you don’t know the type parameters until runtime. In theory, the need for this arises rarely if types are perfectly designed; of course, types are not always perfectly designed.</p>
<p>For instance, suppose that we want to write a more powerful version of <code>ToString</code> that could expand the result of LINQ queries. We could start out as follows:</p>
<pre data-type="programlisting">public static string ToStringEx &lt;T&gt; (IEnumerable&lt;T&gt; sequence)
{
  ...
}</pre>
<p>This is already quite limiting. What if <code>sequence</code> contained <em>nested</em> collections that we also want to enumerate? We’d need to overload the method to cope:</p>
<pre data-type="programlisting">public static string ToStringEx &lt;T&gt; (IEnumerable&lt;IEnumerable&lt;T&gt;&gt; sequence)</pre>
<p>And then what if <code>sequence</code> contained groupings, or <em>projections</em> of nested sequences? The static solution of method overloading becomes impractical—we need an approach that can scale to handle an arbitrary object graph, such as the following:</p>
<pre data-type="programlisting">public static string ToStringEx (object value)
{
  if (value == null) return "&lt;null&gt;";
  StringBuilder sb = new StringBuilder();

  if (value is <strong>List&lt;&gt;</strong>)                                            // Error
    sb.Append ("List of " + (<strong>(List&lt;&gt;</strong>) value).Count + " items");   // Error

  if (value is <strong>IGrouping&lt;,&gt;</strong>)                                      // Error
    sb.Append ("Group with key=" + (<strong>(IGrouping&lt;,&gt;</strong>) value).Key);   // Error

  // Enumerate collection elements if this is a collection,
  // recursively calling ToStringEx()
  // ...

  return sb.ToString();
}</pre>
<p>Unfortunately, this won’t compile: you cannot invoke members of an <em>unbound</em> generic type such as <code>List&lt;&gt;</code> or <code>IGrouping&lt;&gt;</code>. In the case of <code>List&lt;&gt;</code>, we can solve the problem by using the nongeneric <code>IList</code> interface, instead:</p>
<pre data-type="programlisting">  if (value is <strong>IList</strong>)
    sb.AppendLine ("A list with " + (<strong>(IList)</strong> value).Count + " items");</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We can do this because the designers of <code>List&lt;&gt;</code> had the foresight to implement <code>IList</code> classic (as well as <code>IList</code> <em>generic</em>). The same principle is worthy of consideration when writing your own generic types: having a nongeneric interface or base class upon which consumers can fall back can be extremely valuable.</p>
</div>
<p>The solution is not as simple for <code>IGrouping&lt;,&gt;</code>. Here’s how the interface is defined:</p>
<pre data-type="programlisting">public interface IGrouping &lt;TKey,TElement&gt; : IEnumerable &lt;TElement&gt;,
                                             IEnumerable
{
  TKey Key { get; }
}</pre>
<p>There’s no nongeneric type we can use to access the <code>Key</code> property, so here we must use reflection. The solution is not to invoke members of an unbound generic type (which is impossible) but to invoke members of a <em>closed</em> generic type, whose type arguments we establish at runtime.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the following chapter, we solve this more simply with C#’s <code>dynamic</code> keyword. A good indication for dynamic binding is when you would otherwise need to perform <em>type gymnastics</em>—as we are doing right now.</p>
</div>
<p>The first step is to determine whether <code>value</code> implements <code>IGrouping&lt;,&gt;</code>, and if so, obtain its closed generic interface. We can do this most easily by executing a LINQ query. Then, we retrieve and invoke the <code>Key</code> property:</p>
<pre data-type="programlisting"><strong>public static string ToStringEx (object value)</strong>
<strong>{</strong>
  if (value == null) return "&lt;null&gt;";
  if (value.GetType().IsPrimitive) return value.ToString();

  StringBuilder sb = new StringBuilder();

  if (value is IList)
    sb.Append ("List of " + ((IList)value).Count + " items: ");

  <strong>Type closedIGrouping = value.GetType().GetInterfaces()</strong>
    <strong>.Where (t =&gt; t.IsGenericType &amp;&amp;</strong>
    <strong>             t.GetGenericTypeDefinition() == typeof (IGrouping&lt;,&gt;))</strong>
    <strong>.FirstOrDefault();</strong>

  if (closedIGrouping != null)   // Call the Key property on IGrouping&lt;,&gt;
  {
    <strong>PropertyInfo pi = closedIGrouping.GetProperty ("Key");</strong>
    <strong>object key = pi.GetValue (value, null);</strong>
    sb.Append ("Group with key=" + key + ": ");
  }

  if (value is IEnumerable)
    foreach (object element in ((IEnumerable)value))
      sb.Append (ToStringEx (element) + " ");

  if (sb.Length == 0) sb.Append (value.ToString());

  return "\r\n" + sb.ToString();
}</pre>
<p>This approach is robust: it works whether <code>IGrouping&lt;,&gt;</code> is implemented implicitly or explicitly. The following demonstrates this method:</p>
<pre data-type="programlisting">Console.WriteLine (ToStringEx (new List&lt;int&gt; { 5, 6, 7 } ));
Console.WriteLine (ToStringEx ("xyyzzz".GroupBy (c =&gt; c) ));

<em>List of 3 items: 5 6 7</em>

<em>Group with key=x: x</em>
<em>Group with key=y: y y</em>
<em>Group with key=z: z z z</em></pre>
</div></section>
<section data-pdf-bookmark="Calling Static Virtual/Abstract Interface Members" data-type="sect2"><div class="sect2" id="calling_static_virtualsolidusabstract_i">
<h2>Calling Static Virtual/Abstract Interface Members</h2>
<p><a contenteditable="false" data-primary="static abstract members" data-type="indexterm" id="ch18.html1b"/><a contenteditable="false" data-primary="static virtual members" data-type="indexterm" id="ch18.html1a"/><a contenteditable="false" data-primary="static interface members" data-secondary="static virtual/abstract members" data-type="indexterm" id="ch18.html1"/>From .NET 7 and C# 11, interfaces can define static virtual and abstract members (see <a data-type="xref" href="ch03.html#static_virtualsolidusabstract-id00091">“Static virtual/abstract interface members”</a>). An example is the .NET <code>IParsable&lt;TSelf&gt;</code> interface:</p>
<pre data-type="programlisting">public interface IParsable&lt;TSelf&gt; where TSelf : IParsable&lt;TSelf&gt;
{
  <strong>static abstract</strong> TSelf Parse (string s, IFormatProvider provider);
  ...
}</pre>
<p>With a constrained type parameter, static abstract interface members can be called polymorphically:</p>
<pre data-type="programlisting">T ParseAny&lt;T&gt; (string s) where T : IParsable&lt;T&gt; =&gt; T.Parse (s, null);</pre>
<p>To call a static abstract interface member via reflection, you must obtain a <code>MethodInfo</code> from the concrete type that implements the interface—not from the interface itself. The obvious solution is to retrieve the concrete member by signature:</p>
<pre data-type="programlisting">MethodInfo GetParseMethod (Type concreteType) =&gt;
  concreteType.GetMethod ("Parse",
    new[] { typeof (string), typeof (IFormatProvider) });</pre>
<p>However, this will fail if the member has been implemented explicitly. To solve this in a general fashion, we will start by writing a function that retrieves the <code>MethodInfo</code> on a concrete type that implements a specified interface method:</p>
<pre data-type="programlisting">MethodInfo GetImplementedInterfaceMethod (Type concreteType,
  Type interfaceType, string methodName, Type[] paramTypes)
{
  var map = concreteType.<strong>GetInterfaceMap (interfaceType)</strong>;

  return map.InterfaceMethods
    .Zip (map.TargetMethods)
    .Single (m =&gt; m.First.Name == methodName &amp;&amp;
             m.First.GetParameters().Select (p =&gt; p.ParameterType)
                                    .SequenceEqual (paramTypes))
    .Second;
}</pre>
<p><a contenteditable="false" data-primary="Get..." data-secondary="GetInterfaceMap method" data-type="indexterm" id="id4178"/>The key to making this work is the call to <code>GetInterfaceMap</code>. This method returns the following struct:</p>
<pre data-type="programlisting">public struct InterfaceMapping
{   
   public MethodInfo[] InterfaceMethods;    // These arrays each
   public MethodInfo[] TargetMethods;       // have the same length.
   ...
}</pre>
<p>This struct tells us how the members of the implemented interface (<code>Interface​Me⁠thods</code>) map to the concrete type’s members (<code>TargetMethods</code>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>GetInterfaceMap</code> works with ordinary (instance) methods as well; it just happens to be particularly useful when working with static abstract interface members.</p>
</div>
<p>We then used LINQ’s <code>Zip</code> method to align the elements in the two arrays, allowing us to easily obtain the target method corresponding to the interface method with the desired signature.</p>
<p>We can now use this to write a reflection-based <code>ParseAny</code> method:</p>
<pre data-type="programlisting">object ParseAny (Type type, string value)
{
  MethodInfo parseMethod = GetImplementedInterfaceMethod (type,
    type.GetInterface ("IParsable`1"),
    "Parse",
    new[] { typeof (string), typeof (IFormatProvider) });

  return parseMethod.Invoke (null, new[] { value, null });
}

Console.WriteLine (ParseAny (typeof (float), ".2"));   // 0.2</pre>
<p>When calling <code>GetImplementedInterfaceMethod</code>, we needed to provide the (closed) interface type, which we obtained by calling <code>GetInterface("IParsable`1")</code> on the concrete type. Given that (in this scenario) we knew the desired interface at compile time, we could have used the following expression instead:<a contenteditable="false" data-primary="" data-startref="ch18.html1b" data-type="indexterm" id="id4179"/><a contenteditable="false" data-primary="" data-startref="ch18.html1a" data-type="indexterm" id="id4180"/><a contenteditable="false" data-primary="" data-startref="ch18.html1" data-type="indexterm" id="id4181"/><a contenteditable="false" data-primary="" data-startref="ch18.html107" data-type="indexterm" id="id4182"/><a contenteditable="false" data-primary="" data-startref="ch18.html106" data-type="indexterm" id="id4183"/></p>
<pre data-type="programlisting">typeof (IParsable&lt;&gt;).MakeGenericType (type)</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Reflecting Assemblies" data-type="sect1"><div class="sect1" id="reflecting_assemblies">
<h1>Reflecting Assemblies</h1>
<p><a contenteditable="false" data-primary="assemblies" data-secondary="reflecting" data-type="indexterm" id="id4184"/><a contenteditable="false" data-primary="reflection" data-secondary="reflecting assemblies" data-type="indexterm" id="id4185"/>You can dynamically reflect an assembly by calling <code>GetType</code> or <code>GetTypes</code> on an <code>Assembly</code> object. The following retrieves from the current assembly, the type called <code>TestProgram</code> in the <code>Demos</code> namespace:</p>
<pre data-type="programlisting">Type t = Assembly.GetExecutingAssembly().GetType ("Demos.TestProgram");</pre>
<p>You can also obtain an assembly from an existing type:</p>
<pre data-type="programlisting">typeof (Foo).Assembly.GetType ("Demos.TestProgram");</pre>
<p>The next example lists all the types in the assembly <em>mylib.dll</em> in <em>e:\demo</em>:</p>
<pre data-type="programlisting">Assembly a = Assembly.LoadFile (@"e:\demo\mylib.dll");

foreach (Type t in a.GetTypes())
  Console.WriteLine (t);</pre>
<p>Or:</p>
<pre data-type="programlisting">Assembly a = typeof (Foo).GetTypeInfo().Assembly;

foreach (Type t in a.ExportedTypes)
  Console.WriteLine (t);</pre>
<p><code>GetTypes</code> and <code>ExportedTypes</code> return only top-level and not nested types.</p>
<section data-pdf-bookmark="Modules" data-type="sect2"><div class="sect2" id="ch18-sect-modules">
<h2>Modules</h2>
<p><a contenteditable="false" data-primary="modules, assembly" data-type="indexterm" id="id4186"/>Calling <code>GetTypes</code> on a multimodule assembly returns all types in all modules. As a result, you can ignore the existence of modules and treat an assembly as a type’s container. There is one case, though, for which modules are relevant—and that’s when dealing with metadata tokens.</p>
<p>A metadata token is an integer that uniquely refers to a type, member, string, or resource within the scope of a module. IL uses metadata tokens, so if you’re parsing IL, you’ll need to be able to resolve them. The methods for doing this are defined in the <code>Module</code> type and are called <code>ResolveType</code>, <code>ResolveMember</code>, <code>ResolveString</code>, and <code>ResolveSignature</code>. We revisit this in the final section of this chapter, on writing a disassembler.</p>
<p>You can obtain a list of all the modules in an assembly by calling <code>GetModules</code>. You can also access an assembly’s main module directly via its <code>ManifestModule</code> property.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Working with Attributes" data-type="sect1"><div class="sect1" id="working_with_attributes">
<h1>Working with Attributes</h1>
<p><a contenteditable="false" data-primary="attributes" data-secondary="reflection" data-type="indexterm" id="ch18.html109"/><a contenteditable="false" data-primary="reflection" data-secondary="working with attributes" data-type="indexterm" id="ch18.html1010"/>The CLR allows additional metadata to be attached to types, members, and assemblies through attributes. This is the mechanism by which some important CLR functions (such as assembly identification or the marshaling of types for native interoperability) are directed, making attributes an indivisible part of an application.</p>
<p>A key characteristic of attributes is that you can write your own and then use them just as you would any other attribute to “decorate” a code element with additional information. This additional information is compiled into the underlying assembly and can be retrieved at runtime using reflection to build services that work declaratively, such as automated unit testing.</p>
<section class="pagebreak-before" data-pdf-bookmark="Attribute Basics" data-type="sect2"><div class="sect2" id="attribute_basics">
<h2 class="less_space">Attribute Basics</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="basics" data-type="indexterm" id="id4187"/>There are three kinds of attributes:</p>
<ul>
<li><p>Bit-mapped attributes</p></li>
<li><p>Custom attributes</p></li>
<li><p>Pseudocustom attributes</p></li>
</ul>
<p>Of these, only <em>custom attributes</em> are extensible.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The term “attribute” by itself can refer to any of the three, although in the C# world, it most often refers to custom attributes or pseudocustom attributes.</p>
</div>
<p><a contenteditable="false" data-primary="bit-mapped attributes" data-type="indexterm" id="id4188"/>Bit-mapped attributes (our terminology) map to dedicated bits in a type’s metadata. Most of C#’s modifier keywords, such as <code>public</code>, <code>abstract</code>, and <code>sealed</code>, compile to bit-mapped attributes. These attributes are very efficient because they consume minimal space in the metadata (usually just one bit), and the CLR can locate them with little or no indirection. The reflection API exposes them via dedicated properties on <code>Type</code> (and other <code>MemberInfo</code> subclasses), such as <code>IsPublic</code>, <code>IsAbstract</code>, and <code>IsSealed</code>. The <code>Attributes</code> property returns a flags enum that describes most of them in one hit:</p>
<pre data-type="programlisting">static void Main()
{
  TypeAttributes ta = typeof (Console).<strong>Attributes</strong>;
  MethodAttributes ma = MethodInfo.GetCurrentMethod().<strong>Attributes</strong>;
  Console.WriteLine (ta + "\r\n" + ma);
}</pre>
<p>Here’s the result:</p>
<pre data-type="programlisting">AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit
PrivateScope, Private, Static, HideBySig</pre>
<p><a contenteditable="false" data-primary="custom attributes" data-type="indexterm" id="id4189"/>In contrast, <em>custom attributes</em> compile to a blob that hangs off the type’s main metadata table. <a contenteditable="false" data-primary="System..." data-secondary="System.Attribute" data-type="indexterm" id="id4190"/>All custom attributes are represented by a subclass of <code>System.Attribute</code> and, unlike bit-mapped attributes, are extensible. The blob in the metadata identifies the attribute class, and also stores the values of any positional or named argument that was specified when the attribute was applied. Custom attributes that you define yourself are architecturally identical to those defined in the .NET libraries.</p>
<p><a data-type="xref" href="ch04.html#advanced_chash">Chapter 4</a> describes how to attach custom attributes to a type or member in C#. Here, we attach the predefined <code>Obsolete</code> attribute to the <code>Foo</code> class:</p>
<pre data-type="programlisting">[Obsolete] public class Foo {...}</pre>
<p>This instructs the compiler to incorporate an instance of <code>ObsoleteAttribute</code> into the metadata for <code>Foo</code>, which then can be reflected at runtime by calling <code>GetCustom​At⁠tributes</code> on a <code>Type</code> or <code>MemberInfo</code> object.</p>
<p><a contenteditable="false" data-primary="pseudocustom attributes" data-type="indexterm" id="id4191"/><em>Pseudocustom attributes</em> look and feel just like standard custom attributes. They are represented by a subclass of <code>System.Attribute</code> and are attached in the standard manner:</p>
<pre data-type="programlisting">[System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
class SystemTime { ... }</pre>
<p>The difference is that the compiler or CLR internally optimizes pseudocustom attributes by converting them to bit-mapped attributes. Examples include  <code>StructLayout</code>, <code>In</code>, and <code>Out</code> (<a data-type="xref" href="ch24.html#native_and_com_interoperabilit">Chapter 24</a>). Reflection exposes pseudocustom attributes through dedicated properties such as <code>IsLayoutSequential</code>, and in many cases they are also returned as <code>System.Attribute</code> objects when you call <code>GetCustomAttributes</code>. This means that you can (almost) ignore the difference between pseudo- and non-pseudocustom attributes (a notable exception is when using <code>Reflection.Emit</code> to generate types dynamically at runtime; see <a data-type="xref" href="#emitting_assemblies_and_types">“Emitting Assemblies and Types”</a>).</p>
</div></section>
<section data-pdf-bookmark="The AttributeUsage Attribute" data-type="sect2"><div class="sect2" id="the_attributeusage_attribute">
<h2>The AttributeUsage Attribute</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="AttributeUsage" data-type="indexterm" id="id4192"/><a contenteditable="false" data-primary="AttributeUsage attribute" data-type="indexterm" id="id4193"/><code>AttributeUsage</code> is an attribute applied to attribute classes. It instructs the compiler how the target attribute should be used:</p>
<pre data-type="programlisting">public sealed class AttributeUsageAttribute : Attribute
{
  public AttributeUsageAttribute (AttributeTargets validOn);

  public bool AllowMultiple        { get; set; }
  public bool Inherited            { get; set; }
  public AttributeTargets ValidOn  { get; }
}</pre>
<p><code>AllowMultiple</code> controls whether the attribute being defined can be applied more than once to the same target; <code>Inherited</code> controls whether an attribute applied to a base class also applies to derived classes (or in the case of methods, whether an attribute applied to a virtual method also applies to overriding methods). <code>ValidOn</code> determines the set of targets (classes, interfaces, properties, methods, parameters, etc.) to which the attribute can be attached. It accepts any combination of values from the <code>AttributeTargets</code> enum, which has the following members:</p>
<table class="border">
<tbody>
<tr>
<td><code>All</code></td>
<td><code>Delegate</code></td>
<td><code>GenericParameter</code></td>
<td><code>Parameter</code></td>
</tr>
<tr>
<td><code>Assembly</code></td>
<td><code>Enum</code></td>
<td><code>Interface</code></td>
<td><code>Property</code></td>
</tr>
<tr>
<td><code>Class</code></td>
<td><code>Event</code></td>
<td><code>Method</code></td>
<td><code>ReturnValue</code></td>
</tr>
<tr>
<td><code>Constructor</code></td>
<td><code>Field</code></td>
<td><code>Module</code></td>
<td><code>Struct</code></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before">To illustrate, here’s how the authors of .NET have applied <code>AttributeUsage</code> to the <code>Serializable</code> attribute:</p>
<pre data-type="programlisting">[AttributeUsage (AttributeTargets.Delegate |
                 AttributeTargets.Enum     |
                 AttributeTargets.Struct   |
                 AttributeTargets.Class,     Inherited = false)
]
public sealed class SerializableAttribute : Attribute { }</pre>
<p>This is, in fact, almost the complete definition of the <code>Serializable</code> attribute. Writing an attribute class that has no properties or special constructors is this simple.</p>
</div></section>
<section data-pdf-bookmark="Defining Your Own Attribute" data-type="sect2"><div class="sect2" id="defining_your_own_attribute">
<h2>Defining Your Own Attribute</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="defining your own" data-type="indexterm" id="id4194"/>Here’s how to write your own attribute:</p>
<ol>
<li><p><a contenteditable="false" data-primary="System..." data-secondary="System.Attribute" data-type="indexterm" id="id4195"/>Derive a class from <code>System.Attribute</code> or a descendent of <code>System.Attribute</code>. By convention, the class name should end with the word “Attribute,” although this isn’t required.</p></li>
<li><p>Apply the <code>AttributeUsage</code> attribute, described in the preceding section.</p>
<p>If the attribute requires no properties or arguments in its constructor, the job is done.</p></li>
<li><p>Write one or more public constructors. The parameters to the constructor define the positional parameters of the attribute and will become mandatory when using the attribute.</p></li>
<li><p>Declare a public field or property for each named parameter you wish to support. Named parameters are optional when using the attribute.</p></li>
</ol>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Attribute properties and constructor parameters must be of the following types:</p>
<ul>
<li><p>A sealed primitive type: in other words, <code>bool</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>, <code>short</code>, or <code>string</code></p></li>
<li><p>The <code>Type</code> type</p></li>
<li><p>An enum type</p></li>
<li><p>A one-dimensional array of any of these</p></li>
</ul>
<p>When an attribute is applied, it must also be possible for the compiler to statically evaluate each of the properties or constructor arguments.</p>
</div>
<p>The following class defines an attribute for assisting an automated unit-testing system. It indicates that a method should be tested, the number of test repetitions, and a message in case of failure:</p>
<pre data-type="programlisting">[AttributeUsage (AttributeTargets.Method)]
public sealed class TestAttribute : Attribute
{
  public int     Repetitions;
  public string  FailureMessage;

  public TestAttribute () : this (1)     { }
  public TestAttribute (int repetitions) { Repetitions = repetitions; }
}</pre>
<p>Here’s a <code>Foo</code> class with methods decorated in various ways with the <code>Test</code> attribute:</p>
<pre data-type="programlisting">class Foo
{
  [Test]
  public void Method1() { ... }

  [Test(20)]
  public void Method2() { ... }

  [Test(20, FailureMessage="Debugging Time!")]
  public void Method3() { ... }
}</pre>
</div></section>
<section data-pdf-bookmark="Retrieving Attributes at Runtime" data-type="sect2"><div class="sect2" id="retrieving_attributes_at_runtime">
<h2>Retrieving Attributes at Runtime</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="retrieving at runtime" data-type="indexterm" id="id4196"/>There are two standard ways to retrieve attributes at runtime:</p>
<ul>
<li><p>Call <code>GetCustomAttributes</code> on any <code>Type</code> or <code>MemberInfo</code> object</p></li>
<li><p>Call <code>Attribute.GetCustomAttribute</code> or <code>Attribute.GetCustomAttributes</code></p></li>
</ul>
<p>These latter two methods are overloaded to accept any reflection object that corresponds to a valid attribute target (<code>Type</code>, <code>Assembly</code>, <code>Module</code>, <code>MemberInfo</code>, or <code>ParameterInfo</code>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also call <code>GetCustomAttributes<strong>Data</strong>()</code> on a type or member to obtain attribute information. The difference between this and <code>GetCustomAttributes()</code> is that the former lets you know you <em>how</em> the attribute was instantiated: it reports the constructor overload that was used, and the value of each constructor argument and named parameter. This is useful when you want to emit code or IL to reconstruct the attribute to the same state (see <a data-type="xref" href="#emitting_type_members">“Emitting Type Members”</a>).</p>
</div>
<p>Here’s how we can enumerate each method in the preceding <code>Foo</code> class that has a <code>TestAttribute</code>:</p>
<pre data-type="programlisting">foreach (MethodInfo mi in typeof (Foo).GetMethods())
{
  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute
    (mi, typeof (TestAttribute));

  if (att != null)
    Console.WriteLine ("Method {0} will be tested; reps={1}; msg={2}",
                        mi.Name, att.Repetitions, att.FailureMessage);
}</pre>
<p>Or:</p>
<pre data-type="programlisting">foreach (MethodInfo mi in typeof (Foo)<strong>.GetTypeInfo().DeclaredMethods</strong>)
...</pre>
<p>Here’s the output:</p>
<pre data-type="programlisting">Method Method1 will be tested; reps=1; msg=
Method Method2 will be tested; reps=20; msg=
Method Method3 will be tested; reps=20; msg=Debugging Time!</pre>
<p>To complete the illustration on how we could use this to write a unit-testing system, here’s the same example expanded so that it actually calls the methods decorated with the <code>Test</code> attribute:</p>
<pre data-type="programlisting">foreach (MethodInfo mi in typeof (Foo).GetMethods())
{
  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute
    (mi, typeof (TestAttribute));

  if (att != null)
    for (int i = 0; i &lt; att.Repetitions; i++)
      try
      {
        mi.Invoke (new Foo(), null);    // Call method with no arguments
      }
      catch (Exception ex)       // Wrap exception in att.FailureMessage
      {
        throw new Exception ("Error: " + att.FailureMessage, ex);
      }
}</pre>
<p>Returning to attribute reflection, here’s an example that lists the attributes present on a specific type:</p>
<pre data-type="programlisting">object[] atts = Attribute.GetCustomAttributes (typeof (Test));
foreach (object att in atts) Console.WriteLine (att);

[Serializable, Obsolete]
class Test
{
}</pre>
<p>And, here’s the output:<a contenteditable="false" data-primary="" data-startref="ch18.html1010" data-type="indexterm" id="id4197"/><a contenteditable="false" data-primary="" data-startref="ch18.html109" data-type="indexterm" id="id4198"/></p>
<pre data-type="programlisting">System.ObsoleteAttribute
System.SerializableAttribute</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Dynamic Code Generation" data-type="sect1"><div class="sect1" id="dynamic_code_generation">
<h1>Dynamic Code Generation</h1>
<p><a contenteditable="false" data-primary="System..." data-secondary="System.Reflection.Emit" data-type="indexterm" id="id4199"/><a contenteditable="false" data-primary="dynamic code generation" data-type="indexterm" id="ch18.html1011"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="dynamic code generation" data-type="indexterm" id="ch18.html1012"/><a contenteditable="false" data-primary="reflection" data-secondary="dynamic code generation" data-type="indexterm" id="ch18.html1013"/>The <code>System.Reflection.Emit</code> namespace contains classes for creating metadata and IL at runtime. Generating code dynamically is useful for certain kinds of programming tasks. An example is the regular expressions API, which emits performant types tuned to specific regular expressions. Another example is Entity Framework Core, which uses <code>Reflection.Emit</code> to generate proxy classes to enable lazy loading.</p>
<section data-pdf-bookmark="Generating IL with DynamicMethod" data-type="sect2"><div class="sect2" id="generating_il_with_dynamicmethod">
<h2>Generating IL with DynamicMethod</h2>
<p><a contenteditable="false" data-primary="dynamic code generation" data-secondary="generating IL with DynamicMethod" data-type="indexterm" id="ch18.html1014"/><a contenteditable="false" data-primary="DynamicMethod" data-secondary="generating IL with" data-type="indexterm" id="ch18.html1015"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="generating with DynamicMethod" data-type="indexterm" id="ch18.html1016"/>The <code>DynamicMethod</code> class is a lightweight tool in the <code>System.Reflection.Emit</code> namespace for generating methods on the fly. Unlike <code>TypeBuilder</code>, it doesn’t require that you first set up a dynamic assembly, module, and type in which to contain the method. This makes it suitable for simple tasks—as well as serving as a good introduction to <code>Reflection.Emit</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <code>DynamicMethod</code> and the associated IL are garbage-collected when no longer referenced. This means you can repeatedly generate dynamic methods without filling up memory. (To do the same with dynamic <em>assemblies</em>, you must apply the <code>AssemblyBuilderAccess.RunAndCollect</code> flag when creating the assembly.)</p>
</div>
<p>Here is a simple use of <code>DynamicMethod</code> to create a method that writes <code>Hello world</code> to the console:</p>
<pre data-type="programlisting">public class Test
{
  static void Main()
  {
    var dynMeth = new DynamicMethod ("Foo", null, null, typeof (Test));
    ILGenerator gen = dynMeth.GetILGenerator();
    gen.EmitWriteLine ("Hello world");
    gen.Emit (OpCodes.Ret);
    dynMeth.Invoke (null, null);                    // Hello world
  }
}</pre>
<p><code>OpCodes</code> has a static read-only field for every IL opcode. Most of the functionality is exposed through various opcodes, although <code>ILGenerator</code> also has specialized methods for generating labels and local variables and for exception handling. A method always ends in <code>Opcodes.Ret</code>, which means “return,” or some kind of branching/throwing instruction. The <code>EmitWriteLine</code> method on <code>ILGenerator</code> is a shortcut for <code>Emit</code>ting a number of lower-level opcodes. We would get the same result if we replaced the call to <code>EmitWriteLine</code> with this:</p>
<pre data-type="programlisting">MethodInfo writeLineStr = typeof (Console).GetMethod ("WriteLine",
                           new Type[] { typeof (string) });
gen.Emit (OpCodes.<strong>Ldstr</strong>, "Hello world");     // Load a string
gen.Emit (OpCodes.<strong>Call</strong>, writeLineStr);       // Call a method</pre>
<p>Note that we passed <code>typeof(Test)</code> into <code>DynamicMethod</code>’s constructor. This gives the dynamic method access to the nonpublic methods of that type, allowing us to do this:</p>
<pre data-type="programlisting"><strong>public class Test</strong>
<strong>{</strong>
  static void Main()
  {
    var dynMeth = new DynamicMethod ("Foo", null, null, <strong>typeof (Test)</strong><strong>);</strong>
    ILGenerator gen = dynMeth.GetILGenerator();

    <strong>MethodInfo privateMethod = typeof(Test).GetMethod ("HelloWorld",</strong>
    <strong>  BindingFlags.Static | BindingFlags.NonPublic);</strong>

    gen.Emit (OpCodes.Call, privateMethod);     // Call HelloWorld
    gen.Emit (OpCodes.Ret);

    dynMeth.Invoke (null, null);                // Hello world
  }

  static void HelloWorld()       // private method, yet we can call it
  {
    Console.WriteLine ("Hello world");
  }
<strong>}</strong></pre>
<p>Understanding IL requires a considerable investment of time. Rather than understand all the opcodes, it’s much easier to compile a C# program and then examine, copy, and tweak the IL. LINQPad displays the IL for any method or code snippet that you type, and assembly viewing tools such ILSpy are useful for examining existing assemblies.<a contenteditable="false" data-primary="" data-startref="ch18.html1016" data-type="indexterm" id="id4200"/><a contenteditable="false" data-primary="" data-startref="ch18.html1015" data-type="indexterm" id="id4201"/><a contenteditable="false" data-primary="" data-startref="ch18.html1014" data-type="indexterm" id="id4202"/></p>
</div></section>
<section data-pdf-bookmark="The Evaluation Stack" data-type="sect2"><div class="sect2" id="the_evaluation_stack">
<h2>The Evaluation Stack</h2>
<p><a contenteditable="false" data-primary="evaluation stack" data-type="indexterm" id="id4203"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="evaluation stack" data-type="indexterm" id="id4204"/>Central to IL is the concept of the <em>evaluation stack</em>. To call a method with arguments, you first push (“load”) the arguments onto the evaluation stack and then call the method. The method then pops the arguments it needs from the evaluation stack. We demonstrated this previously, in calling <code>Console.WriteLine</code>. Here’s a similar example with an integer:</p>
<pre data-type="programlisting">var dynMeth = new DynamicMethod ("Foo", null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();
MethodInfo writeLineInt = typeof (Console).GetMethod ("WriteLine",
                                        new Type[] { typeof (int) });

// The Ldc* op-codes load numeric literals of various types and sizes.

gen.Emit (<strong>OpCodes.Ldc_I4</strong>, 123);        // Push a 4-byte integer onto stack
gen.Emit (OpCodes.Call, writeLineInt);

gen.Emit (OpCodes.Ret);
dynMeth.Invoke (null, null);           // 123</pre>
<p>To add two numbers together, you first load each number onto the evaluation stack, and then call <code>Add</code>. The <code>Add</code> opcode pops two values from the evaluation stack and pushes the result back on. The following adds 2 and 2, and then writes the result using the <code>writeLine</code> method obtained previously:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2
gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2
gen.Emit (OpCodes.Add);                 // Add the result together
gen.Emit (OpCodes.Call, writeLineInt);</pre>
<p>To calculate <code>10 / 2 + 1</code>, you can do either this:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Ldc_I4, 10);
gen.Emit (OpCodes.Ldc_I4, 2);
gen.Emit (OpCodes.Div);
gen.Emit (OpCodes.Ldc_I4, 1);
gen.Emit (OpCodes.Add);
gen.Emit (OpCodes.Call, writeLineInt);</pre>
<p>or this:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Ldc_I4, 1);
gen.Emit (OpCodes.Ldc_I4, 10);
gen.Emit (OpCodes.Ldc_I4, 2);
gen.Emit (OpCodes.Div);
gen.Emit (OpCodes.Add);
gen.Emit (OpCodes.Call, writeLineInt);</pre>
</div></section>
<section data-pdf-bookmark="Passing Arguments to a Dynamic Method" data-type="sect2"><div class="sect2" id="passing_arguments_to_a_dynamic_method">
<h2>Passing Arguments to a Dynamic Method</h2>
<p><a contenteditable="false" data-primary="arguments" data-secondary="passing to a Dynamic Method" data-type="indexterm" id="id4205"/><a contenteditable="false" data-primary="dynamic code generation" data-secondary="passing arguments to a Dynamic Method" data-type="indexterm" id="id4206"/><a contenteditable="false" data-primary="DynamicMethod" data-secondary="passing arguments to" data-type="indexterm" id="id4207"/>The <code>Ldarg</code> and <code>Ldarg_<em>XXX</em></code> opcodes load an argument passed into a method onto the stack. To return a value, leave exactly one value on the stack upon finishing. For this to work, you must specify the return type and argument types when calling <code>DynamicMethod</code>’s constructor. The following creates a dynamic method that returns the sum of two integers:</p>
<pre data-type="programlisting">DynamicMethod dynMeth = new DynamicMethod ("Foo",
  <strong>typeof (int),                              // Return type = int</strong>
  <strong>new[] { typeof (int), typeof (int) },      // Parameter types = int, int</strong>
  typeof (void));

ILGenerator gen = dynMeth.GetILGenerator();

gen.Emit (OpCodes.Ldarg_0);      // Push first arg onto eval stack
gen.Emit (OpCodes.Ldarg_1);      // Push second arg onto eval stack
gen.Emit (OpCodes.Add);          // Add them together (result on stack)
gen.Emit (OpCodes.Ret);          // Return with stack having 1 value

int result = (int) dynMeth.Invoke (null, new object[] { 3, 4 } );   // 7</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When you exit, the evaluation stack must have exactly 0 or 1 item (depending on whether your method returns a value). If you violate this, the CLR will refuse to execute your method. You can remove an item from the stack without processing it by emitting <code>OpCodes.Pop</code>.</p>
</div>
<p>Rather than calling <code>Invoke</code>, it can be more convenient to work with a dynamic method as a typed delegate. The <code>CreateDelegate</code> method achieves just this. In our case, the delegate that we need has two integer parameters and an integer return type. We can use the <code>Func&lt;int, int, int&gt;</code> delegate for this purpose. The last line of our preceding example then becomes the following:</p>
<pre data-type="programlisting">var func = (Func&lt;int,int,int&gt;) dynMeth.CreateDelegate
                                 (typeof (Func&lt;int,int,int&gt;));
int result = func (3, 4);  // 7</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A delegate also eliminates the overhead of dynamic method invocation—saving a few microseconds per call.</p>
</div>
<p>We demonstrate how to pass by reference in <a data-type="xref" href="#emitting_type_members">“Emitting Type Members”</a>.</p>
</div></section>
<section data-pdf-bookmark="Generating Local Variables" data-type="sect2"><div class="sect2" id="generating_local_variables">
<h2>Generating Local Variables</h2>
<p><a contenteditable="false" data-primary="dynamic code generation" data-secondary="generating local variables" data-type="indexterm" id="id4208"/><a contenteditable="false" data-primary="local variables" data-secondary="dynamic code generation" data-type="indexterm" id="id4209"/>You can declare a local variable by calling <code>DeclareLocal</code> on an <code>ILGenerator</code>. This returns a <code>LocalBuilder</code> object, which you can use in conjunction with opcodes such as <code>Ldloc</code> (load a local variable) or <code>Stloc</code> (store a local variable). <code>Ldloc</code> pushes the evaluation stack; <code>Stloc</code> pops it. For example, consider the following C# code:</p>
<pre data-type="programlisting">int x = 6;
int y = 7;
x *= y;
Console.WriteLine (x);</pre>
<p>The following generates the preceding code dynamically:</p>
<pre data-type="programlisting">var dynMeth = new DynamicMethod ("Test", null, null, typeof (void));
ILGenerator gen = dynMeth.GetILGenerator();

LocalBuilder localX = gen.DeclareLocal (typeof (int));    // Declare x
LocalBuilder localY = gen.DeclareLocal (typeof (int));    // Declare y

gen.Emit (OpCodes.Ldc_I4, 6);        // Push literal 6 onto eval stack
gen.Emit (OpCodes.Stloc, localX);    // Store in localX
gen.Emit (OpCodes.Ldc_I4, 7);        // Push literal 7 onto eval stack
gen.Emit (OpCodes.Stloc, localY);    // Store in localY

gen.Emit (OpCodes.Ldloc, localX);    // Push localX onto eval stack
gen.Emit (OpCodes.Ldloc, localY);    // Push localY onto eval stack
gen.Emit (OpCodes.Mul);              // Multiply values together
gen.Emit (OpCodes.Stloc, localX);    // Store the result to localX

gen.EmitWriteLine (localX);          // Write the value of localX
gen.Emit (OpCodes.Ret);

dynMeth.Invoke (null, null);         // 42</pre>
</div></section>
<section data-pdf-bookmark="Branching" data-type="sect2"><div class="sect2" id="branching">
<h2>Branching</h2>
<p><a contenteditable="false" data-primary="branching" data-type="indexterm" id="id4210"/><a contenteditable="false" data-primary="dynamic code generation" data-secondary="branching" data-type="indexterm" id="id4211"/>In IL, there are no <code>while</code>, <code>do</code>, and <code>for</code> loops; it’s all done with labels and the equivalent of <code>goto</code> and conditional <code>goto</code> statements. These are the branching opcodes, such as <code>Br</code> (branch unconditionally), <code>Brtrue</code> (branch if the value on the evaluation stack is <code>true</code>), and <code>Blt</code> (branch if the first value is less than the second value).</p>
<p>To set a branch target, first call <code>DefineLabel</code> (this returns a <code>Label</code> object), and then call <code>MarkLabel</code> at the place where you want to anchor the label. For example, consider the following C# code:</p>
<pre data-type="programlisting">int x = 5;
while (x &lt;= 10) Console.WriteLine (x++);</pre>
<p>We can emit this as follows:</p>
<pre data-type="programlisting">ILGenerator gen = <em>...</em>

Label startLoop = gen.DefineLabel();                  // Declare labels
Label endLoop = gen.DefineLabel();

LocalBuilder x = gen.DeclareLocal (typeof (int));     // int x
gen.Emit (OpCodes.Ldc_I4, 5);                         //
gen.Emit (OpCodes.Stloc, x);                          // x = 5
<strong>gen.MarkLabel (startLoop);</strong>
  gen.Emit (OpCodes.Ldc_I4, 10);              // Load 10 onto eval stack
  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack

  <strong>gen.Emit (OpCodes.Blt, endLoop);            // if (x &gt; 10) goto endLoop</strong>

  gen.EmitWriteLine (x);                      // Console.WriteLine (x)

  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack
  gen.Emit (OpCodes.Ldc_I4, 1);               // Load 1 onto the stack
  gen.Emit (OpCodes.Add);                     // Add them together
  gen.Emit (OpCodes.Stloc, x);                // Save result back to x

  <strong>gen.Emit (OpCodes.Br, startLoop);           // return to start of loop</strong>
<strong>gen.MarkLabel (endLoop);</strong>

<strong>gen.Emit (OpCodes.Ret);</strong></pre>
</div></section>
<section data-pdf-bookmark="Instantiating Objects and Calling Instance Methods" data-type="sect2"><div class="sect2" id="instantiating_objects_and_calling_insta">
<h2>Instantiating Objects and Calling Instance Methods</h2>
<p><a contenteditable="false" data-primary="dynamic code generation" data-secondary="instantiating objects and calling instance methods" data-type="indexterm" id="id4212"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="instantiating objects and calling instance methods" data-type="indexterm" id="id4213"/>The IL equivalent of <code>new</code> is the <code>Newobj</code> opcode. This takes a constructor and loads the constructed object onto the evaluation stack. For instance, the following constructs a <code>StringBuilder</code>:</p>
<pre data-type="programlisting">var dynMeth = new DynamicMethod ("Test", null, null, typeof (void));
ILGenerator gen = dynMeth.GetILGenerator();

ConstructorInfo ci = typeof (StringBuilder).GetConstructor (new Type[0]);
gen.Emit (OpCodes.Newobj, ci);</pre>
<p>After loading an object onto the evaluation stack, you can use the <code>Call</code> or <code>Callvirt</code> opcode to invoke the object’s instance methods. Extending this example, we’ll query the <code>StringBuilder</code>’s <code>MaxCapacity</code> property by calling the property’s get accessor and then write out the result:</p>
<pre data-type="programlisting">gen.Emit (<strong>OpCodes.Callvirt</strong>, typeof (StringBuilder)
                            .GetProperty ("MaxCapacity").GetGetMethod());

gen.Emit (OpCodes.Call, typeof (Console).GetMethod ("WriteLine",
                                         new[] { typeof (int) } ));
gen.Emit (OpCodes.Ret);
dynMeth.Invoke (null, null);              // 2147483647</pre>
<p>To emulate C# calling semantics:</p>
<ul>
<li><p>Use <code>Call</code> to invoke static methods and value type instance methods.</p></li>
<li><p>Use <code>Callvirt</code> to invoke reference type instance methods (whether or not they’re declared virtual).</p></li>
</ul>
<p>In our example, we used <code>Callvirt</code> on the <code>StringBuilder</code> instance—even though <code>MaxProperty</code> is not virtual. This doesn’t cause an error: it simply performs a nonvirtual call, instead. Always invoking reference type instance methods with <code>Callvirt</code> avoids risking the opposite condition: invoking a virtual method with <code>Call</code>. (The risk is real. The author of the target method may later <em>change</em> its declaration.) <code>Callvirt</code> also has the benefit of checking that the receiver is non-null.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Invoking a virtual method with <code>Call</code> bypasses virtual calling semantics and calls that method directly. This is rarely desirable and, in effect, violates type safety.</p>
</div>
<p>In the following example, we construct a <code>StringBuilder</code> passing in two arguments, append <code>", world!"</code> to the <code>StringBuilder</code>, and then call <code>ToString</code> on it:</p>
<pre data-type="programlisting">// We will call:   new StringBuilder ("Hello", 1000)

ConstructorInfo ci = typeof (StringBuilder).GetConstructor (
                     new[] { typeof (string), typeof (int) } );

gen.Emit (OpCodes.Ldstr, "Hello");   // Load a string onto the eval stack
gen.Emit (OpCodes.Ldc_I4, 1000);     // Load an int onto the eval stack
gen.Emit (OpCodes.Newobj, ci);       // Construct the StringBuilder

Type[] strT = { typeof (string) };
gen.Emit (OpCodes.Ldstr, ", world!");
gen.Emit (OpCodes.Call, typeof (StringBuilder).GetMethod ("Append", strT));
gen.Emit (OpCodes.Callvirt, typeof (object).GetMethod ("ToString"));
gen.Emit (OpCodes.Call, typeof (Console).GetMethod ("WriteLine", strT));
gen.Emit (OpCodes.Ret);
dynMeth.Invoke (null, null);        // Hello, world!</pre>
<p>For fun, we called <code>GetMethod</code> on <code>typeof(object)</code> and then used <code>Callvirt</code> to perform a virtual method call on <code>ToString</code>. We could have gotten the same result by calling <code>ToString</code> on the <code>StringBuilder</code> type itself:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Callvirt, typeof (StringBuilder).GetMethod ("ToString",
                                                          new Type[0] ));</pre>
<p>(The empty type array is required in calling <code>GetMethod</code> because <code>StringBuilder</code> overloads <code>ToString</code> with another signature.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Had we called <code>object</code>’s <code>ToString</code> method nonvirtually:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Call,
          typeof (object).GetMethod ("ToString"));</pre>
<p>the result would have been <code>System.Text.StringBuilder</code>. In other words, we would have circumvented <code>StringBuilder</code>’s <code>ToString</code> override and called <code>object</code>’s version directly.</p>
</div>
</div></section>
<section data-pdf-bookmark="Exception Handling" data-type="sect2"><div class="sect2" id="ch-18-sect-exception_handling">
<h2>Exception Handling</h2>
<p><a contenteditable="false" data-primary="dynamic code generation" data-secondary="exception handling" data-type="indexterm" id="id4214"/><a contenteditable="false" data-primary="exception handling" data-secondary="dynamic code generation" data-type="indexterm" id="id4215"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="exception handling" data-type="indexterm" id="id4216"/><code>ILGenerator</code> provides dedicated methods for exception handling. Thus, the translation for this C# code:</p>
<pre data-type="programlisting">try                               { throw new NotSupportedException(); }
catch (NotSupportedException ex)  { Console.WriteLine (ex.Message);    }
finally                           { Console.WriteLine ("Finally");     }</pre>
<p>is this:</p>
<pre data-type="programlisting">MethodInfo getMessageProp = typeof (NotSupportedException)
                            .GetProperty ("Message").GetGetMethod();

MethodInfo writeLineString = typeof (Console).GetMethod ("WriteLine",
                                             new[] { typeof (object) } );
<strong>gen.BeginExceptionBlock();</strong>
  ConstructorInfo ci = typeof (NotSupportedException).GetConstructor (
                                                        new Type[0] );
  gen.Emit (OpCodes.Newobj, ci);
  gen.Emit (OpCodes.Throw);
<strong>gen.BeginCatchBlock (typeof (NotSupportedException));</strong>
  gen.Emit (OpCodes.Callvirt, getMessageProp);
  gen.Emit (OpCodes.Call, writeLineString);
<strong>gen.BeginFinallyBlock();</strong>
  gen.EmitWriteLine ("Finally");
<strong>gen.EndExceptionBlock();</strong></pre>
<p>Just as in C#, you can include multiple <code>catch</code> blocks. To rethrow the same exception, emit the <code>Rethrow</code> opcode.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><code>ILGenerator</code> provides a helper method called <code>ThrowException</code>. This contains a bug, however, preventing it from being used with a <code>DynamicMethod</code>. It works only with a <code>MethodBuilder</code> (see the next section).<a contenteditable="false" data-primary="" data-startref="ch18.html1013" data-type="indexterm" id="id4217"/><a contenteditable="false" data-primary="" data-startref="ch18.html1012" data-type="indexterm" id="id4218"/><a contenteditable="false" data-primary="" data-startref="ch18.html1011" data-type="indexterm" id="id4219"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Emitting Assemblies and Types" data-type="sect1"><div class="sect1" id="emitting_assemblies_and_types">
<h1>Emitting Assemblies and Types</h1>
<p><a contenteditable="false" data-primary="assemblies" data-secondary="emitting assemblies and types" data-type="indexterm" id="ch18.html1017"/><a contenteditable="false" data-primary="reflection" data-secondary="emitting assemblies and types" data-type="indexterm" id="ch18.html1018"/><a contenteditable="false" data-primary="type system, C#" data-secondary="emitting assemblies and types" data-type="indexterm" id="ch18.html1019"/>Although <code>DynamicMethod</code> is convenient, it can generate only methods. If you need to emit any other construct—or a complete type—you need to use the full “heavyweight” API. This means dynamically building an assembly and module. The assembly need not have a disk presence (in fact, it cannot, because .NET 5+ and .NET Core do not let you save generated assemblies to disk).</p>
<p>Let’s assume that we want to dynamically build a type. Because a type must reside in a module within an assembly, we first must create the assembly and module before we can create the type. <a contenteditable="false" data-primary="Assembly..." data-secondary="AssemblyBuilder" data-type="indexterm" id="id4220"/> This is the job of the <code>AssemblyBuilder</code> and <code>ModuleBuilder</code> types:</p>
<pre data-type="programlisting">AssemblyName aname = new AssemblyName ("MyDynamicAssembly");

AssemblyBuilder assemBuilder =
  AssemblyBuilder.DefineDynamicAssembly (aname, AssemblyBuilderAccess.Run);

ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule ("DynModule");</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can’t add a type to an existing assembly, because an assembly is immutable after it’s created.</p>
<p>Dynamic assemblies are not garbage-collected and remain in memory until the process ends, unless you specify <code>AssemblyBuilderAccess</code>.<code>RunAndCollect</code> when defining the assembly. Various restrictions apply to collectible assemblies (see <a href="http://albahari.com/dynamiccollect"><em class="hyperlink">http://albahari.com/dynamiccollect</em></a>).</p>
</div>
<p><a contenteditable="false" data-primary="Type..." data-secondary="TypeBuilder" data-type="indexterm" id="ch18.html1020"/>After we have a module in which the type can reside, we can use <code>TypeBuilder</code> to create the type. The following defines a class called <code>Widget</code>:</p>
<pre data-type="programlisting">TypeBuilder tb = modBuilder.DefineType ("Widget", TypeAttributes.Public);</pre>
<p><a contenteditable="false" data-primary="Type..." data-secondary="TypeAttributes" data-type="indexterm" id="id4221"/>The <code>TypeAttributes</code> flags enum supports the CLR type modifiers you see when disassembling a type with <em>ildasm</em>. As well as member visibility flags, this includes type modifiers such as <code>Abstract</code> and <code>Sealed</code>—and <code>Interface</code> for defining a .NET interface. It also includes <code>Serializable</code>, which is equivalent to applying the <code>[Serializable]</code> attribute in C#, and <code>Explicit</code>, which is equivalent to applying <code>[StructLayout(LayoutKind.Explicit)]</code>. We describe how to apply other kinds of attributes later in this chapter, in <a data-type="xref" href="#attaching_attributes">“Attaching Attributes”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>DefineType</code> method also accepts an optional base type:</p>
<ul>
<li><p>To define a struct, specify a base type of <code>System.ValueType</code>.</p></li>
<li><p>To define a delegate, specify a base type of <code>System.MulticastDelegate</code>.</p></li>
<li><p>To implement an interface, use the constructor that accepts an array of interface types.</p></li>
<li><p>To define an interface, specify <code>TypeAttributes.Interface | TypeAttributes.Abstract</code>.</p></li>
</ul>
<p>Defining a delegate type requires a number of extra steps. In his weblog, Joel Pobar demonstrates how this is done in his article titled <a href="http://www.albahari.com/joelpob">“Creating delegate types via Reflection.Emit”</a>.</p>
</div>
<p>We can now create members within the type:</p>
<pre data-type="programlisting">MethodBuilder methBuilder = tb.DefineMethod ("SayHello",
                                             MethodAttributes.Public,
                                             null, null);
ILGenerator gen = methBuilder.GetILGenerator();
gen.EmitWriteLine ("Hello world");
gen.Emit (OpCodes.Ret);</pre>
<p>We’re now ready to create the type, which finalizes its definition:</p>
<pre data-type="programlisting">Type t = tb.CreateType();</pre>
<p>After the type is created, we can use ordinary reflection to inspect and perform late binding:</p>
<pre data-type="programlisting">object o = Activator.CreateInstance (t);
t.GetMethod ("SayHello").Invoke (o, null);        // Hello world</pre>
<section data-pdf-bookmark="The Reflection.Emit Object Model" data-type="sect2"><div class="sect2" id="the_reflectiondotemit_object_model">
<h2>The Reflection.Emit Object Model</h2>
<p><a contenteditable="false" data-primary="Reflection.Emit object model" data-type="indexterm" id="id4222"/><a contenteditable="false" data-primary="System..." data-secondary="System.Reflection.Emit" data-type="indexterm" id="id4223"/><a data-type="xref" href="#systemdotreflectiondotemit">Figure 18-2</a> illustrates the essential types in <code>System.Reflection.Emit</code>. Each type describes a CLR construct and is based on a counterpart in the <code>System.Reflection</code> namespace. This allows you to use emitted constructs in place of normal constructs when building a type. For example, we previously called <code>Console.WriteLine</code>, as follows:</p>
<pre data-type="programlisting">MethodInfo writeLine = typeof(Console).GetMethod ("WriteLine",
                                       new Type[] { typeof (string) });
gen.Emit (OpCodes.Call, writeLine);</pre>
<p>We could just as easily call a dynamically generated method by calling <code>gen.Emit</code> with a <code>MethodBuilder</code> instead of a <code>MethodInfo</code>. This is essential—otherwise, you couldn’t write one dynamic method that called another in the same type.</p>
<figure><div class="figure" id="systemdotreflectiondotemit">
<img alt="System.Reflection.Emit" src="assets/cn10_1802.png"/>
<h6><span class="label">Figure 18-2. </span><code>System.Reflection.Emit</code></h6>
</div></figure>
<p>Recall that you must call <code>CreateType</code> on a <code>TypeBuilder</code> when you’ve finished populating it. Calling <code>CreateType</code> seals the <code>TypeBuilder</code> and all its members—so nothing more can be added or changed—and gives you back a real <code>Type</code> that you can instantiate.</p>
<p>Before you call <code>CreateType</code>, the <code>TypeBuilder</code> and its members are in an “uncreated” state. There are significant restrictions on what you can do with uncreated constructs. In particular, you cannot call any of the members that return <code>MemberInfo</code> objects, such as <code>GetMembers</code>, <code>GetMethod</code>, or <code>GetProperty</code>—these all throw an exception. If you want to refer to members of an uncreated type, you must use the original emissions:</p>
<pre data-type="programlisting">TypeBuilder tb = ...

MethodBuilder method1 = tb.DefineMethod ("Method1", ...);
MethodBuilder method2 = tb.DefineMethod ("Method2", ...);

ILGenerator gen1 = method1.GetILGenerator();

// Suppose we want method1 to call method2:

gen1.Emit (OpCodes.Call, method2);                    // Right
gen1.Emit (OpCodes.Call, tb.GetMethod ("Method2"));   // Wrong</pre>
<p>After calling <code>CreateType</code>, you can reflect on and activate not only the <code>Type</code> returned but also the original <code>TypeBuilder</code> object. The <code>TypeBuilder</code>, in fact, morphs into a proxy for the real <code>Type</code>. You’ll see why this feature is important in <a data-type="xref" href="#awkward_emission_targets">“Awkward Emission Targets”</a>.<a contenteditable="false" data-primary="" data-startref="ch18.html1020" data-type="indexterm" id="id4224"/><a contenteditable="false" data-primary="" data-startref="ch18.html1019" data-type="indexterm" id="id4225"/><a contenteditable="false" data-primary="" data-startref="ch18.html1018" data-type="indexterm" id="id4226"/></p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Emitting Type Members" data-type="sect1"><div class="sect1" id="emitting_type_members">
<h1 class="less_space">Emitting Type Members</h1>
<p><a contenteditable="false" data-primary="reflection" data-secondary="emitting type members" data-type="indexterm" id="ch18.html1021"/><a contenteditable="false" data-primary="type members, emitting" data-type="indexterm" id="ch18.html1022"/>All the examples in this section assume a <code>TypeBuilder</code>, <code>tb</code>, has been instantiated, as follows:</p>
<pre data-type="programlisting">AssemblyName aname = new AssemblyName ("MyEmissions");

AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly (
  aname, AssemblyBuilderAccess.Run);

ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule ("MainModule");

TypeBuilder tb = modBuilder.DefineType ("Widget", TypeAttributes.Public);</pre>
<section data-pdf-bookmark="Emitting Methods" data-type="sect2"><div class="sect2" id="emitting_methods">
<h2>Emitting Methods</h2>
<p><a contenteditable="false" data-primary="methods" data-secondary="emitting" data-type="indexterm" id="ch18.html1023"/>You can specify a return type and parameter types when calling <code>DefineMethod</code>, in the same manner as when instantiating a <code>DynamicMethod</code>. For instance, the following method:</p>
<pre data-type="programlisting">public static double SquareRoot (double value) =&gt; Math.Sqrt (value);</pre>
<p>can be generated like this:</p>
<pre data-type="programlisting">MethodBuilder mb = tb.DefineMethod ("SquareRoot",
  MethodAttributes.Static | MethodAttributes.Public,
  CallingConventions.Standard,
  <strong>typeof (double),                     // Return type</strong>
  <strong>new[]  { typeof (double) } );        // Parameter types</strong>

mb.DefineParameter (1, ParameterAttributes.None, "value");  // Assign name

ILGenerator gen = mb.GetILGenerator();
gen.Emit (OpCodes.Ldarg_0);                                // Load 1st arg
gen.Emit (OpCodes.Call, typeof(Math).GetMethod ("Sqrt"));
gen.Emit (OpCodes.Ret);

Type realType = tb.CreateType();
double x = (double) tb.GetMethod ("SquareRoot").Invoke (null,
                                                new object[] { 10.0 });
Console.WriteLine (x);   // 3.16227766016838</pre>
<p>Calling <code>DefineParameter</code> is optional and is typically done to assign the parameter a name. The number 1 refers to the first parameter (0 refers to the return value). If you call <code>DefineParameter</code>, the parameter is implicitly named <code>__p1</code>, <code>__p2</code>, and so on. Assigning names makes sense if you will write the assembly to disk; it makes your methods friendly to consumers.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>DefineParameter</code> returns a <code>ParameterBuilder</code> object upon which you can call <code>SetCustomAttribute</code> to attach attributes (see <a data-type="xref" href="#attaching_attributes">“Attaching Attributes”</a>).</p>
</div>
<p>To emit pass-by-reference parameters, such as in the following C# method:</p>
<pre data-type="programlisting">public static void SquareRoot (<strong>ref</strong> double value)
  =&gt; value = Math.Sqrt (value);</pre>
<p>call <code>MakeByRefType</code> on the parameter type(s):</p>
<pre data-type="programlisting">MethodBuilder mb = tb.DefineMethod ("SquareRoot",
  MethodAttributes.Static | MethodAttributes.Public,
  CallingConventions.Standard,
  null,
  new Type[] { <strong>typeof (double).MakeByRefType()</strong> } );

mb.DefineParameter (1, ParameterAttributes.None, "value");

ILGenerator gen = mb.GetILGenerator();
gen.Emit (OpCodes.Ldarg_0);
gen.Emit (OpCodes.Ldarg_0);
gen.Emit (OpCodes.Ldind_R8);
gen.Emit (OpCodes.Call, typeof (Math).GetMethod ("Sqrt"));
gen.Emit (OpCodes.Stind_R8);
gen.Emit (OpCodes.Ret);

Type realType = tb.CreateType();
object[] args = { 10.0 };
tb.GetMethod ("SquareRoot").Invoke (null, args);
Console.WriteLine (args[0]);                     // 3.16227766016838</pre>
<p>The opcodes here were copied from a disassembled C# method. Notice the difference in semantics for accessing parameters passed by reference: <code>Ldind</code> and <code>Stind</code> mean “load indirectly” and “store indirectly,” respectively. The R8 suffix means an eight-byte floating-point number.</p>
<p>The process for emitting <code>out</code> parameters is identical, except that you call <code>DefineParameter</code>, as follows:</p>
<pre data-type="programlisting">mb.DefineParameter (1, <strong>ParameterAttributes.Out</strong>, "value");</pre>
<section data-pdf-bookmark="Generating instance methods" data-type="sect3"><div class="sect3" id="generating_instance_methods">
<h3>Generating instance methods</h3>
<p><a contenteditable="false" data-primary="instance methods" data-secondary="generating" data-type="indexterm" id="id4227"/>To generate an instance method, specify <code>MethodAttributes.Instance</code> when calling <code>DefineMethod</code>:</p>
<pre data-type="programlisting">MethodBuilder mb = tb.DefineMethod ("SquareRoot",
  MethodAttributes.<strong>Instance</strong> | MethodAttributes.Public
  ...</pre>
<p>With instance methods, argument zero is implicitly <code>this</code>; the remaining arguments start at 1. So, <code>Ldarg_0</code> loads <code>this</code> onto the evaluation stack; <code>Ldarg_1</code> loads the first real method argument.</p>
</div></section>
<section data-pdf-bookmark="Overriding methods" data-type="sect3"><div class="sect3" id="overriding_methods">
<h3>Overriding methods</h3>
<p><a contenteditable="false" data-primary="methods" data-secondary="overriding" data-type="indexterm" id="id4228"/>Overriding a virtual method in a base class is easy: simply define a method with an identical name, signature, and return type, specifying <code>MethodAttributes.Virtual</code> when calling <code>DefineMethod</code>. The same applies when implementing interface methods.</p>
<p><a contenteditable="false" data-primary="DefineMethodOverride" data-type="indexterm" id="id4229"/><a contenteditable="false" data-primary="Type..." data-secondary="TypeBuilder" data-type="indexterm" id="id4230"/><code>TypeBuilder</code> also exposes a method called <code>DefineMethodOverride</code> that overrides a method with a different name. This makes sense only with explicit interface implementation; in other scenarios, use <code>DefineMethod</code>.</p>
</div></section>
<section data-pdf-bookmark="HideBySig" data-type="sect3"><div class="sect3" id="hidebysig">
<h3>HideBySig</h3>
<p><a contenteditable="false" data-primary="HideBySig" data-type="indexterm" id="id4231"/><a contenteditable="false" data-primary="MethodAttributes.HideBySig" data-type="indexterm" id="id4232"/>If you’re subclassing another type, it’s nearly always worth specifying <code>Method​At⁠tributes.HideBySig</code> when defining methods. <code>HideBySig</code> ensures that C#-style method-hiding semantics are applied, which is that a base method is hidden only if a subtype defines a method with an identical <em>signature</em>. Without <code>HideBySig</code>, method hiding considers only the <em>name</em>, so <code>Foo(string)</code> in the subtype will hide <code>Foo()</code> in the base type, which is generally undesirable.<a contenteditable="false" data-primary="" data-startref="ch18.html1023" data-type="indexterm" id="id4233"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Emitting Fields and Properties" data-type="sect2"><div class="sect2" id="emitting_fields_and_properties">
<h2>Emitting Fields and Properties</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="emitting" data-type="indexterm" id="ch18.html1024"/><a contenteditable="false" data-primary="properties" data-secondary="emitting" data-type="indexterm" id="ch18.html1025"/><a contenteditable="false" data-primary="reflection" data-secondary="emitting fields and properties" data-type="indexterm" id="ch18.html1026"/>To create a field, you call <code>DefineField</code> on a <code>TypeBuilder</code>, specifying the desired field name, type, and visibility. The following creates a private integer field called “length”:</p>
<pre data-type="programlisting">FieldBuilder field = tb.DefineField ("length", typeof (int),
                                      FieldAttributes.Private);</pre>
<p>Creating a property or indexer requires a few more steps. First, call <code>DefineProperty</code> on a <code>TypeBuilder</code>, providing it with the name and type of the property:</p>
<pre data-type="programlisting">PropertyBuilder prop = tb.DefineProperty (
                         "Text",                      // Name of property
                         PropertyAttributes.None,
                         typeof (string),             // Property type
                         new Type[0]                  // Indexer types
                       );</pre>
<p>(If you’re writing an indexer, the final argument is an array of indexer types.) Note that we haven’t specified the property visibility: this is done individually on the accessor methods.</p>
<p>The next step is to write the <code>get</code> and <code>set</code> methods. By convention, their names are prefixed with “get_” or “set_”. You then attach them to the property by calling <code>SetGetMethod</code> and <code>SetSetMethod</code> on the <code>PropertyBuilder</code>.</p>
<p>To give a complete example, let’s take the following field and property declaration</p>
<pre data-type="programlisting">string _text;
public string Text
{
  get          =&gt; _text;
  internal set =&gt; _text = value;
}</pre>
<p class="pagebreak-before">and generate it dynamically:</p>
<pre data-type="programlisting">FieldBuilder field = tb.DefineField ("_text", typeof (string),
                                      FieldAttributes.Private);
PropertyBuilder prop = tb.DefineProperty (
                         "Text",                      // Name of property
                         PropertyAttributes.None,
                         typeof (string),             // Property type
                         new Type[0]);                // Indexer types

MethodBuilder getter = tb.DefineMethod (
  "get_Text",                                         // Method name
  MethodAttributes.Public | MethodAttributes.SpecialName,
  typeof (string),                                    // Return type
  new Type[0]);                                       // Parameter types

ILGenerator getGen = getter.GetILGenerator();
getGen.Emit (OpCodes.Ldarg_0);        // Load "this" onto eval stack
getGen.Emit (OpCodes.Ldfld, field);   // Load field value onto eval stack
getGen.Emit (OpCodes.Ret);            // Return

MethodBuilder setter = tb.DefineMethod (
  "set_Text",
  MethodAttributes.Assembly | MethodAttributes.SpecialName,
  null,                                                 // Return type
  new Type[] { typeof (string) } );                     // Parameter types

ILGenerator setGen = setter.GetILGenerator();
setGen.Emit (OpCodes.Ldarg_0);        // Load "this" onto eval stack
setGen.Emit (OpCodes.Ldarg_1);        // Load 2nd arg, i.e., value
setGen.Emit (OpCodes.Stfld, field);   // Store value into field
setGen.Emit (OpCodes.Ret);            // return

prop.SetGetMethod (getter);           // Link the get method and property
prop.SetSetMethod (setter);           // Link the set method and property</pre>
<p>We can test the property as follows:</p>
<pre data-type="programlisting">Type t = tb.CreateType();
object o = Activator.CreateInstance (t);
t.GetProperty ("Text").SetValue (o, "Good emissions!", new object[0]);
string text = (string) t.GetProperty ("Text").GetValue (o, null);

Console.WriteLine (text);             // Good emissions!</pre>
<p>Notice that in defining the accessor <code>MethodAttributes</code>, we included <code>SpecialName</code>. This instructs compilers to disallow direct binding to these methods when statically referencing the assembly. It also ensures that the accessors are handled appropriately by reflection tools and Visual Studio’s IntelliSense.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can emit events in a similar manner, by calling <code>Define​E⁠vent</code> on a <code>TypeBuilder</code>. You then write explicit event accessor methods and attach them to the <code>EventBuilder</code> by calling <code>SetAddOnMethod</code> and <code>SetRemoveOnMethod</code>.<a contenteditable="false" data-primary="" data-startref="ch18.html1026" data-type="indexterm" id="id4234"/><a contenteditable="false" data-primary="" data-startref="ch18.html1025" data-type="indexterm" id="id4235"/><a contenteditable="false" data-primary="" data-startref="ch18.html1024" data-type="indexterm" id="id4236"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Emitting Constructors" data-type="sect2"><div class="sect2" id="emitting_constructors">
<h2>Emitting Constructors</h2>
<p><a contenteditable="false" data-primary="constructors" data-secondary="emitting" data-type="indexterm" id="id4237"/><a contenteditable="false" data-primary="reflection" data-secondary="emitting constructors" data-type="indexterm" id="id4238"/>You can define your own constructors by calling <code>DefineConstructor</code> on a type builder. You’re not obliged to do so—a default parameterless constructor is automatically provided if you don’t. The default constructor calls the base class constructor if subtyping, just like in C#. Defining one or more constructors displaces this default constructor.</p>
<p>If you need to initialize fields, the constructor’s a good spot. In fact, it’s the only spot: C#’s field initializers don’t have special CLR support—they are simply a syntactic shortcut for assigning values to fields in the constructor.</p>
<p>So, to reproduce this:</p>
<pre data-type="programlisting">class Widget
{
  <strong>int _capacity = 4000;</strong>
}</pre>
<p>you would define a constructor, as follows:</p>
<pre data-type="programlisting">FieldBuilder field = tb.DefineField ("_capacity", typeof (int),
                                      FieldAttributes.Private);
ConstructorBuilder c = tb.DefineConstructor (
  MethodAttributes.Public,
  CallingConventions.Standard,
  new Type[0]);                  // Constructor parameters

ILGenerator gen = c.GetILGenerator();

gen.Emit (OpCodes.Ldarg_0);             // Load "this" onto eval stack
gen.Emit (OpCodes.Ldc_I4, 4000);        // Load 4000 onto eval stack
gen.Emit (OpCodes.Stfld, field);        // Store it to our field
gen.Emit (OpCodes.Ret);</pre>
<section data-pdf-bookmark="Calling base constructors" data-type="sect3"><div class="sect3" id="calling_base_constructors">
<h3>Calling base constructors</h3>
<p><a contenteditable="false" data-primary="base constructors" data-type="indexterm" id="id4239"/>If subclassing another type, the constructor we just wrote would <em>circumvent the base class constructor</em>. This is unlike C#, in which the base class constructor is always called, whether directly or indirectly. For instance, given the following code:</p>
<pre data-type="programlisting">class A     { public A() { Console.Write ("A"); } }
class B : A { public B() {} }</pre>
<p>the compiler, in effect, will translate the second line into this:</p>
<pre data-type="programlisting">class B : A { public B() <strong>: base()</strong> {} }</pre>
<p>This is not the case when generating IL: you must explicitly call the base constructor if you want it to execute (which nearly always, you do). Assuming the base class is called <code>A</code>, here’s how to do it:</p>
<pre data-type="programlisting">gen.Emit (OpCodes.Ldarg_0);
ConstructorInfo baseConstr = typeof (A).GetConstructor (new Type[0]);
gen.Emit (OpCodes.Call, baseConstr);</pre>
<p>Calling constructors with arguments is just the same as with methods.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Attaching Attributes" data-type="sect2"><div class="sect2" id="attaching_attributes">
<h2>Attaching Attributes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="attaching custom attributes to dynamic construct" data-type="indexterm" id="id4240"/><a contenteditable="false" data-primary="dynamic construct" data-type="indexterm" id="id4241"/>You can attach custom attributes to a dynamic construct by calling <code>SetCustomAttribute</code> with a <code>CustomAttributeBuilder</code>. For example, suppose that we want to attach the following attribute declaration to a field or property:</p>
<pre data-type="programlisting">[XmlElement ("FirstName", Namespace="http://test/", Order=3)]</pre>
<p>This relies on the <code>XmlElementAttribute</code> constructor that accepts a single string. To use <code>CustomAttributeBuilder</code>, we must retrieve this constructor as well as the two additional properties that we want to set (<code>Namespace</code> and <code>Order</code>):<a contenteditable="false" data-primary="" data-startref="ch18.html1022" data-type="indexterm" id="id4242"/><a contenteditable="false" data-primary="" data-startref="ch18.html1021" data-type="indexterm" id="id4243"/><a contenteditable="false" data-primary="" data-startref="ch18.html1017" data-type="indexterm" id="id4244"/></p>
<pre data-type="programlisting">Type attType = typeof (XmlElementAttribute);

ConstructorInfo attConstructor = attType.GetConstructor (
  new Type[] { typeof (string) } );

var att = new CustomAttributeBuilder (
  attConstructor,                        // Constructor
  new object[] { "FirstName" },          // Constructor arguments
  new PropertyInfo[] 
  {
    attType.GetProperty ("Namespace"),   // Properties
    attType.GetProperty ("Order")
  },
  new object[] { "http://test/", 3 }     // Property values
);

myFieldBuilder.SetCustomAttribute (att);
// or propBuilder.SetCustomAttribute (att);
// or typeBuilder.SetCustomAttribute (att);  etc</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Emitting Generic Methods and Types" data-type="sect1"><div class="sect1" id="emitting_generic_methods_and_types">
<h1>Emitting Generic Methods and Types</h1>
<p><a contenteditable="false" data-primary="generic methods" data-secondary="emitting" data-type="indexterm" id="ch18.html1027"/><a contenteditable="false" data-primary="generic types" data-secondary="emitting" data-type="indexterm" id="ch18.html1028"/><a contenteditable="false" data-primary="reflection" data-secondary="emitting generic methods and types" data-type="indexterm" id="ch18.html1029"/>All the examples in this section assume that <code>modBuilder</code> has been instantiated as follows:</p>
<pre data-type="programlisting">AssemblyName aname = new AssemblyName ("MyEmissions");

AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly (
  aname, AssemblyBuilderAccess.Run);

ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule ("MainModule");</pre>
<section data-pdf-bookmark="Defining Generic Methods" data-type="sect2"><div class="sect2" id="defining_generic_methods">
<h2>Defining Generic Methods</h2>
<p><a contenteditable="false" data-primary="generic methods" data-secondary="defining" data-type="indexterm" id="id4245"/>To emit a generic method:</p>
<ol>
<li><p>Call <code>DefineGenericParameters</code> on a <code>MethodBuilder</code> to obtain an array of <code>GenericTypeParameterBuilder</code> objects.</p></li>
<li><p>Call <code>SetSignature</code> on a <code>MethodBuilder</code> using these generic type parameters.</p></li>
<li><p>Optionally, name the parameters as you would otherwise.</p></li>
</ol>
<p>For example, the following generic method:</p>
<pre data-type="programlisting">public static T Echo&lt;T&gt; (T value)
{
  return value;
}</pre>
<p>can be emitted like this:</p>
<pre data-type="programlisting">TypeBuilder tb = modBuilder.DefineType ("Widget", TypeAttributes.Public);

MethodBuilder mb = tb.DefineMethod ("Echo", MethodAttributes.Public |
                                            MethodAttributes.Static);
<strong>GenericTypeParameterBuilder[] genericParams</strong>
  <strong>= mb.DefineGenericParameters ("T");</strong>

mb.SetSignature (<strong>genericParams[0],     // Return type</strong>
                 null, null,
    <strong>             genericParams,        // Parameter types</strong>
                 null, null);

mb.DefineParameter (1, ParameterAttributes.None, "value");   // Optional

ILGenerator gen = mb.GetILGenerator();
gen.Emit (OpCodes.Ldarg_0);
gen.Emit (OpCodes.Ret);</pre>
<p>The <code>DefineGenericParameters</code> method accepts any number of string arguments—these correspond to the desired generic type names. In this example, we needed just one generic type called <code>T</code>. <code>GenericTypeParameterBuilder</code> is based on <code>System.Type</code>, so you can use it in place of a <code>TypeBuilder</code> when emitting opcodes.</p>
<p><code>GenericTypeParameterBuilder</code> also lets you specify a base type constraint:</p>
<pre data-type="programlisting">genericParams[0].<strong>SetBaseTypeConstraint</strong> (typeof (Foo));</pre>
<p>and interface constraints:</p>
<pre data-type="programlisting">genericParams[0].<strong>SetInterfaceConstraints</strong> (typeof (IComparable));</pre>
<p>To replicate this:</p>
<pre data-type="programlisting">public static T Echo&lt;T&gt; (T value) <strong>where T : IComparable&lt;T&gt;</strong></pre>
<p>you would write:</p>
<pre data-type="programlisting">genericParams[0].SetInterfaceConstraints (
  typeof (IComparable&lt;&gt;).MakeGenericType (genericParams[0]) );</pre>
<p>For other kinds of constraints, call <code>SetGenericParameterAttributes</code>. This accepts a member of the <code>GenericParameterAttributes</code> enum, which includes the following values:</p>
<pre data-type="programlisting">DefaultConstructorConstraint
NotNullableValueTypeConstraint
ReferenceTypeConstraint
Covariant
Contravariant</pre>
<p>The last two are equivalent to applying the <code>out</code> and <code>in</code> modifiers to the type parameters.</p>
</div></section>
<section data-pdf-bookmark="Defining Generic Types" data-type="sect2"><div class="sect2" id="defining_generic_types">
<h2>Defining Generic Types</h2>
<p><a contenteditable="false" data-primary="generic types" data-secondary="defining" data-type="indexterm" id="id4246"/>You can define generic types in a similar fashion. The difference is that you call <code>DefineGenericParameters</code> on the <code>TypeBuilder</code> rather than the <code>MethodBuilder</code>. So, to reproduce this:</p>
<pre data-type="programlisting">public class Widget&lt;T&gt;
{
  public T Value;
}</pre>
<p>you would do the following:</p>
<pre data-type="programlisting">TypeBuilder tb = modBuilder.DefineType ("Widget", TypeAttributes.Public);

GenericTypeParameterBuilder[] genericParams
  = tb.<strong>DefineGenericParameters</strong> ("T");

tb.DefineField ("Value", genericParams[0], FieldAttributes.Public);</pre>
<p>Generic constraints can be added, just as with a method.<a contenteditable="false" data-primary="" data-startref="ch18.html1029" data-type="indexterm" id="id4247"/><a contenteditable="false" data-primary="" data-startref="ch18.html1028" data-type="indexterm" id="id4248"/><a contenteditable="false" data-primary="" data-startref="ch18.html1027" data-type="indexterm" id="id4249"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Awkward Emission Targets" data-type="sect1"><div class="sect1" id="awkward_emission_targets">
<h1>Awkward Emission Targets</h1>
<p><a contenteditable="false" data-primary="reflection" data-secondary="awkward emission targets" data-type="indexterm" id="ch18.html1030"/>All of the examples in this section assume that a <code>modBuilder</code> has been instantiated as in previous sections.</p>
<section data-pdf-bookmark="Uncreated Closed Generics" data-type="sect2"><div class="sect2" id="uncreated_closed_generics">
<h2>Uncreated Closed Generics</h2>
<p><a contenteditable="false" data-primary="closed generic types" data-type="indexterm" id="id4250"/>Suppose that you want to emit a method that uses a closed generic type:</p>
<pre data-type="programlisting">public class Widget
{
  public static void Test() { var list = new List&lt;int&gt;(); }
}</pre>
<p>The process is fairly straightforward:</p>
<pre data-type="programlisting">TypeBuilder tb = modBuilder.DefineType ("Widget", TypeAttributes.Public);

MethodBuilder mb = tb.DefineMethod ("Test", MethodAttributes.Public |
                                            MethodAttributes.Static);
ILGenerator gen = mb.GetILGenerator();

<strong>Type variableType = typeof (List&lt;int&gt;);</strong>

ConstructorInfo ci = variableType.GetConstructor (new Type[0]);

LocalBuilder listVar = gen.DeclareLocal (variableType);
gen.Emit (OpCodes.Newobj, ci);
gen.Emit (OpCodes.Stloc, listVar);
gen.Emit (OpCodes.Ret);</pre>
<p>Now suppose that instead of a list of integers, we want a list of widgets:</p>
<pre data-type="programlisting">public class Widget
{
  public static void Test() { var list = new List&lt;<strong>Widget</strong>&gt;(); }
}</pre>
<p>In theory, this is a simple modification; all we do is replace this line:</p>
<pre data-type="programlisting">Type variableType = typeof (List&lt;int&gt;);</pre>
<p>with this one:</p>
<pre data-type="programlisting">Type variableType = typeof (List&lt;&gt;)<strong>.MakeGenericType (tb)</strong>;</pre>
<p>Unfortunately, this causes a <code>NotSupportedException</code> to be thrown when we then call <code>GetConstructor</code>. The problem is that you cannot call <code>GetConstructor</code> on a generic type closed with an uncreated type builder. The same goes for <code>GetField</code> and <code>GetMethod</code>.</p>
<p>The solution is unintuitive. <code>TypeBuilder</code> provides three static methods:</p>
<pre data-type="programlisting">public static ConstructorInfo GetConstructor (Type, ConstructorInfo);
public static FieldInfo       GetField       (Type, FieldInfo);
public static MethodInfo      GetMethod      (Type, MethodInfo);</pre>
<p>Although it doesn’t appear so, these methods exist specifically to obtain members of generic types closed with uncreated type builders! The first parameter is the closed generic type; the second parameter is the member that you want on the <em>unbound</em> generic type. Here’s the corrected version of our example:</p>
<pre data-type="programlisting"><strong>MethodBuilder mb = tb.DefineMethod ("Test", MethodAttributes.Public |</strong>
                                            MethodAttributes.Static);
<strong>ILGenerator gen = mb.GetILGenerator();</strong>

<strong>Type variableType = typeof (List&lt;&gt;).MakeGenericType (tb);</strong>

<strong>ConstructorInfo unbound = typeof (List&lt;&gt;).GetConstructor (new Type[0]);</strong>
<strong>ConstructorInfo ci = TypeBuilder.GetConstructor (variableType, unbound);</strong>

<strong>LocalBuilder listVar = gen.DeclareLocal (variableType);</strong>
<strong>gen.Emit (OpCodes.Newobj, ci);</strong>
<strong>gen.Emit (OpCodes.Stloc, listVar);</strong>
<strong>gen.Emit (OpCodes.Ret);</strong></pre>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Circular Dependencies" data-type="sect2"><div class="sect2" id="circular_dependencies">
<h2 class="less_space">Circular Dependencies</h2>
<p><a contenteditable="false" data-primary="circular dependencies" data-type="indexterm" id="id4251"/>Suppose that you want to build two types that reference each other, such as these:</p>
<pre data-type="programlisting">class A { public B Bee; }
class B { public A Aye; }</pre>
<p>You can generate this dynamically, as follows:</p>
<pre data-type="programlisting">var publicAtt = FieldAttributes.Public;

TypeBuilder aBuilder = modBuilder.DefineType ("A");
TypeBuilder bBuilder = modBuilder.DefineType ("B");

FieldBuilder bee = aBuilder.DefineField ("Bee", bBuilder, publicAtt);
FieldBuilder aye = bBuilder.DefineField ("Aye", aBuilder, publicAtt);

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();</pre>
<p>Notice that we didn’t call <code>CreateType</code> on <code>aBuilder</code> or <code>bBuilder</code> until we populated both objects. The principle is this: first hook everything up, and then call <code>CreateType</code> on each type builder.</p>
<p>Interestingly, the <code>realA</code> type is valid but <em>dysfunctional</em> until you call <code>CreateType</code> on <code>bBuilder</code>. (If you started using <code>aBuilder</code> prior to this, an exception would be thrown when you tried to access field <code>Bee</code>.)</p>
<p>You might wonder how <code>bBuilder</code> knows to “fix up” <code>realA</code> after creating <code>realB</code>. The answer is that it doesn’t: <code>realA</code> can fix <em>itself</em> the next time it’s used. This is possible because after calling <code>CreateType</code>, a <code>TypeBuilder</code> morphs into a proxy for the real runtime type. So, <code>realA</code>, with its references to <code>bBuilder</code>, can easily obtain the metadata it needs for the upgrade.</p>
<p>This system works when the type builder demands simple information of the unconstructed type—information that can be <em>predetermined</em>—such as type, member, and object references. In creating <code>realA</code>, the type builder doesn’t need to know, for instance, how many bytes <code>realB</code> will eventually occupy in memory. This is just as well because <code>realB</code> has not yet been created! But now imagine that <code>realB</code> was a struct. The final size of <code>realB</code> is now critical information in creating <code>realA</code>.</p>
<p>If the relationship is noncyclical; for instance:</p>
<pre data-type="programlisting">struct A { public B Bee; }
struct B {               }</pre>
<p>you can solve this by first creating struct <code>B</code> and then struct <code>A</code>. But consider this:</p>
<pre data-type="programlisting">struct A { public B Bee; }
struct B { public A Aye; }</pre>
<p>We won’t try to emit this because it’s nonsensical to have two structs contain each other (C# generates a compile-time error if you try). But the following variation is both legal and useful:</p>
<pre data-type="programlisting">public struct S&lt;T&gt; { ... }    // S can be empty and this demo will work.

class A { S&lt;B&gt; Bee; }
class B { S&lt;A&gt; Aye; }</pre>
<p>In creating <code>A</code>, a <code>TypeBuilder</code> now needs to know the memory footprint of <code>B</code>, and vice versa. To illustrate, let’s assume that struct <code>S</code> is defined statically. Here’s the code to emit classes <code>A</code> and <code>B</code>:</p>
<pre data-type="programlisting">var pub = FieldAttributes.Public;

TypeBuilder aBuilder = modBuilder.DefineType ("A");
TypeBuilder bBuilder = modBuilder.DefineType ("B");

aBuilder.DefineField ("Bee", typeof(S&lt;&gt;).MakeGenericType (bBuilder), pub);
bBuilder.DefineField ("Aye", typeof(S&lt;&gt;).MakeGenericType (aBuilder), pub);

Type realA = aBuilder.CreateType();    // Error: cannot load type B
Type realB = bBuilder.CreateType();</pre>
<p><code>CreateType</code> now throws a <code>TypeLoadException</code> no matter in which order you go:</p>
<ul>
<li><p>Call <code>aBuilder.CreateType</code> first, and it says “cannot load type <code>B</code>”.</p></li>
<li><p>Call <code>bBuilder.CreateType</code> first, and it says “cannot load type <code>A</code>”!</p></li>
</ul>
<p>To solve this, you must allow the type builder to create <code>realB</code> partway through creating <code>realA</code>. You do this by handling the <code>TypeResolve</code> event on the <code>AppDomain</code> class just before calling <code>CreateType</code>. So, in our example, we replace the last two lines with this:</p>
<pre data-type="programlisting">TypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };

ResolveEventHandler handler = delegate (object o, ResolveEventArgs args)
{
  var type = uncreatedTypes.FirstOrDefault (t =&gt; t.FullName == args.Name);
  return type == null ? null : type.CreateType().Assembly;
};

AppDomain.CurrentDomain.TypeResolve += handler;

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();

AppDomain.CurrentDomain.TypeResolve -= handler;</pre>
<p>The <code>TypeResolve</code> event fires during the call to <code>aBuilder.CreateType</code>, at the point when it needs you to call <code>CreateType</code> on <code>bBuilder</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Handling the <code>TypeResolve</code> event as in this example is also necessary when defining a nested type, when the nested and parent types refer to each other.<a contenteditable="false" data-primary="" data-startref="ch18.html1030" data-type="indexterm" id="id4252"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Parsing IL" data-type="sect1"><div class="sect1" id="parsing_il">
<h1>Parsing IL</h1>
<p><a contenteditable="false" data-primary="disassembler" data-type="indexterm" id="ch18.html1031"/><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="parsing" data-type="indexterm" id="ch18.html1032"/><a contenteditable="false" data-primary="reflection" data-secondary="parsing IL" data-type="indexterm" id="ch18.html1033"/>You can obtain information about the content of an existing method by calling <code>GetMethodBody</code> on a <code>MethodBase</code> object. This returns a <code>MethodBody</code> object that has properties for inspecting a method’s local variables, exception handling clauses, and stack size, as well as the raw IL. Rather like the reverse of <code>Reflection.Emit</code>!</p>
<p>Inspecting a method’s raw IL can be useful in profiling code. A simple use would be to determine which methods in an assembly have changed when an assembly is updated.</p>
<p>To illustrate parsing IL, we’ll write an application that disassembles IL in the style of <em>ildasm</em>. This could be used as the starting point for a code analysis tool or a higher-level language disassembler.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Remember that in the reflection API, all of C#’s functional constructs are either represented by a <code>MethodBase</code> subtype or (in the case of properties, events, and indexers) have <code>MethodBase</code> objects attached to them.</p>
</div>
<section data-pdf-bookmark="Writing a Disassembler" data-type="sect2"><div class="sect2" id="writing_a_disassembler">
<h2>Writing a Disassembler</h2>
<p><a contenteditable="false" data-primary="IL (intermediate language)" data-secondary="writing a disassembler" data-type="indexterm" id="ch18.html1034"/>Here is a sample of the output that our disassembler will produce:</p>
<pre data-type="programlisting">IL_00EB:  ldfld        Disassembler._pos
IL_00F0:  ldloc.2
IL_00F1:  add
IL_00F2:  ldelema      System.Byte
IL_00F7:  ldstr        "Hello world"
IL_00FC:  call         System.Byte.ToString
IL_0101:  ldstr        " "
IL_0106:  call         System.String.Concat</pre>
<p>To obtain this output, we must parse the binary tokens that make up the IL. The first step is to call the <code>GetILAsByteArray</code> method on <code>MethodBody</code> to obtain the IL as a byte array. To make the rest of the job easier, we will write this into a class as follows:</p>
<pre data-type="programlisting">public class Disassembler
{
  public static string Disassemble (MethodBase method)
    =&gt; new Disassembler (method).Dis();

  StringBuilder _output;    // The result to which we'll keep appending
  Module _module;           // This will come in handy later
  byte[] _il;               // The raw byte code
  int _pos;                 // The position we're up to in the byte code

  Disassembler (MethodBase method)
  {
    _module = method.DeclaringType.Module;
    <strong>_il = method.GetMethodBody().GetILAsByteArray();</strong>
  }

  string Dis()
  {
    _output = new StringBuilder();
    while (_pos &lt; _il.Length) <strong>DisassembleNextInstruction</strong>();
    return _output.ToString();
  }
}</pre>
<p>The static <code>Disassemble</code> method will be the only public member of this class. All other members will be private to the disassembly process. The <code>Dis</code> method contains the “main” loop where we process each instruction.</p>
<p>With this skeleton in place, all that remains is to write <code>DisassembleNextInstruction</code>. But before doing so, it will help to load all the opcodes into a static dictionary so that we can access them by their 8- or 16-bit value. The easiest way to accomplish this is to use reflection to retrieve all the static fields whose type is <code>OpCode</code> in the <code>OpCodes</code> class:</p>
<pre data-type="programlisting">static Dictionary&lt;short,OpCode&gt; _opcodes = new Dictionary&lt;short,OpCode&gt;();

static Disassembler()
{
  Dictionary&lt;short, OpCode&gt; opcodes = new Dictionary&lt;short, OpCode&gt;();
    foreach (FieldInfo fi in typeof (OpCodes).GetFields
                             (BindingFlags.Public | BindingFlags.Static))
      if (typeof (OpCode).IsAssignableFrom (fi.FieldType))
      {
        OpCode code = (OpCode) fi.GetValue (null);   // Get field's value
        if (code.OpCodeType != OpCodeType.Nternal)
          _opcodes.Add (code.Value, code);
      }
}</pre>
<p>We’ve written it in a static constructor so that it executes just once.</p>
<p>Now we can write <code>DisassembleNextInstruction</code>. Each IL instruction consists of a one- or two-byte opcode, followed by an operand of zero, one, two, four, or eight bytes. (An exception is inline switch opcodes, which are followed by a variable number of operands.) So, we read the opcode, then the operand, and then write out the result:</p>
<pre data-type="programlisting">void DisassembleNextInstruction()
{
  int opStart = _pos;

  OpCode code = <strong>ReadOpCode</strong>();
  string operand = <strong>ReadOperand</strong> (code);

  _output.AppendFormat ("IL_{0:X4}:  {1,-12} {2}",
                        opStart, code.Name, operand);
  _output.AppendLine();
}</pre>
<p>To read an opcode, we advance one byte and see whether we have a valid instruction. If not, we advance another byte and look for a two-byte instruction:</p>
<pre data-type="programlisting">OpCode ReadOpCode()
{
  byte byteCode = _il [_pos++];
  if (_opcodes.ContainsKey (byteCode)) return _opcodes [byteCode];

  if (_pos == _il.Length)  throw new Exception ("Unexpected end of IL");

  short shortCode = (short) (byteCode * 256 + _il [_pos++]);

  if (!_opcodes.ContainsKey (shortCode))
    throw new Exception ("Cannot find opcode " + shortCode);

  return _opcodes [shortCode];
}</pre>
<p>To read an operand, we first must establish its length. We can do this based on the operand type. Because most are four bytes long, we can filter out the exceptions fairly easily in a conditional clause.</p>
<p>The next step is to call <code>FormatOperand</code>, which attempts to format the operand:</p>
<pre data-type="programlisting">string ReadOperand (OpCode c)
{
  int operandLength =
    c.OperandType == OperandType.InlineNone
      ? 0 :
    c.OperandType == OperandType.ShortInlineBrTarget ||
    c.OperandType == OperandType.ShortInlineI ||
    c.OperandType == OperandType.ShortInlineVar
      ? 1 :
    c.OperandType == OperandType.InlineVar
      ? 2 :
    c.OperandType == OperandType.InlineI8 ||
    c.OperandType == OperandType.InlineR
      ? 8 :
    c.OperandType == OperandType.InlineSwitch
      ? 4 * (BitConverter.ToInt32 (_il, _pos) + 1) :
      4;  // All others are 4 bytes

  if (_pos + operandLength &gt; _il.Length)
    throw new Exception ("Unexpected end of IL");

  string result = <strong>FormatOperand</strong> (c, operandLength);
  if (result == null)
  {                        // Write out operand bytes in hex
    result = "";
    for (int i = 0; i &lt; operandLength; i++)
      result += _il [_pos + i].ToString ("X2") + " ";
  }
  _pos += operandLength;
  return result;
}</pre>
<p>If the <code>result</code> of calling <code>FormatOperand</code> is <code>null</code>, it means the operand needs no special formatting, so we simply write it out in hexadecimal. We could test the disassembler at this point by writing a <code>FormatOperand</code> method that always returns <code>null</code>. Here’s what the output would look like:</p>
<pre data-type="programlisting">IL_00A8:  ldfld        98 00 00 04
IL_00AD:  ldloc.2
IL_00AE:  add
IL_00AF:  ldelema      64 00 00 01
IL_00B4:  ldstr        26 04 00 70
IL_00B9:  call         B6 00 00 0A
IL_00BE:  ldstr        11 01 00 70
IL_00C3:  call         91 00 00 0A
...</pre>
<p>Although the opcodes are correct, the operands are not much use. Instead of hexadecimal numbers, we want member names and strings. The <code>FormatOperand</code> method, when it’s written, will address this—identifying the special cases that benefit from such formatting. These comprise most four-byte operands and the short branch instructions:</p>
<pre data-type="programlisting">string FormatOperand (OpCode c, int operandLength)
{
  if (operandLength == 0) return "";

  if (operandLength == 4)
    return <strong>Get4ByteOperand</strong> (c);
  else if (c.OperandType == OperandType.ShortInlineBrTarget)
    return <strong>GetShortRelativeTarget</strong>();
  else if (c.OperandType == OperandType.InlineSwitch)
    return <strong>GetSwitchTarget</strong> (operandLength);
  else
    return null;
}</pre>
<p>There are three kinds of four-byte operands that we treat specially. The first is references to members or types—with these, we extract the member or type name by calling the defining module’s <code>ResolveMember</code> method. The second case is <span class="keep-together">strings—these</span> are stored in the assembly module’s metadata and can be retrieved by calling <code>ResolveString</code>. The final case is branch targets, where the operand refers to a byte offset in the IL. We format these by working out the absolute address <em>after</em> the current instruction (+ four bytes):</p>
<pre data-type="programlisting">string Get4ByteOperand (OpCode c)
{
  int intOp = BitConverter.ToInt32 (_il, _pos);

  switch (c.OperandType)
  {
    case OperandType.InlineTok:
    case OperandType.InlineMethod:
    case OperandType.InlineField:
    case OperandType.InlineType:
      MemberInfo mi;
      try   { mi = _module.ResolveMember (intOp); }
      catch { return null; }
      if (mi == null) return null;

      if (mi.ReflectedType != null)
        return mi.ReflectedType.FullName + "." + mi.Name;
      else if (mi is Type)
        return ((Type)mi).FullName;
      else
        return mi.Name;

    case OperandType.InlineString:
      string s = _module.ResolveString (intOp);
      if (s != null) s = "'" + s + "'";
      return s;

    case OperandType.InlineBrTarget:
      return "IL_" + (_pos + intOp + 4).ToString ("X4");

    default:
      return null;
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The point where we call <code>ResolveMember</code> is a good window for a code analysis tool that reports on method dependencies.</p>
</div>
<p>For any other four-byte opcode, we return <code>null</code> (this will cause <code>ReadOperand</code> to format the operand as hex digits).</p>
<p>The final kinds of operand that need special attention are short branch targets and inline switches. A short branch target describes the destination offset as a single signed byte, as at the end of the current instruction (i.e., + one byte). A switch target is followed by a variable number of four-byte branch destinations:<a contenteditable="false" data-primary="" data-startref="ch18.html1034" data-type="indexterm" id="id4253"/><a contenteditable="false" data-primary="" data-startref="ch18.html1033" data-type="indexterm" id="id4254"/><a contenteditable="false" data-primary="" data-startref="ch18.html1032" data-type="indexterm" id="id4255"/><a contenteditable="false" data-primary="" data-startref="ch18.html1031" data-type="indexterm" id="id4256"/><a contenteditable="false" data-primary="" data-startref="ch18.html100" data-type="indexterm" id="id4257"/></p>
<pre data-type="programlisting">string GetShortRelativeTarget()
{
  int absoluteTarget = _pos + (sbyte) _il [_pos] + 1;
  return "IL_" + absoluteTarget.ToString ("X4");
}

string GetSwitchTarget (int operandLength)
{
  int targetCount = BitConverter.ToInt32 (_il, _pos);
  string [] targets = new string [targetCount];
  for (int i = 0; i &lt; targetCount; i++)
  {
    int ilTarget = BitConverter.ToInt32 (_il, _pos + (i + 1) * 4);
    targets [i] = "IL_" + (_pos + ilTarget + operandLength).ToString ("X4");
  }
  return "(" + string.Join (", ", targets) + ")";
}</pre>
<p>This completes the disassembler. We can test it by disassembling one of its own methods:</p>
<pre data-type="programlisting">MethodInfo mi = typeof (Disassembler).GetMethod (
  "ReadOperand", BindingFlags.Instance | BindingFlags.NonPublic);

Console.WriteLine (Disassembler.Disassemble (mi));</pre>
</div></section>
</div></section>
</div></section></body></html>